diff --git a/src/test/java/io/reactivex/rxjava3/internal/observers/CompletableConsumersTest.java b/src/test/java/io/reactivex/rxjava3/internal/observers/CompletableConsumersTest.java
new file mode 100644
index 0000000..eb17ead
--- /dev/null
+++ b/src/test/java/io/reactivex/rxjava3/internal/observers/CompletableConsumersTest.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2016-present, RxJava Contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+/*
+ * Copyright 2016-2019 David Karnok
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.rxjava3.internal.observers;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.exceptions.CompositeException;
+import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.observers.LambdaConsumerIntrospection;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.subjects.CompletableSubject;
+import io.reactivex.rxjava3.testsupport.TestHelper;
+
+public class CompletableConsumersTest implements Consumer<Object>, Action {
+
+    final CompositeDisposable composite = new CompositeDisposable();
+
+    final CompletableSubject processor = CompletableSubject.create();
+
+    final List<Object> events = new ArrayList<>();
+
+    @Override
+    public void run() throws Exception {
+        events.add("OnComplete");
+    }
+
+    @Override
+    public void accept(Object t) throws Exception {
+        events.add(t);
+    }
+
+    @Test
+    public void onErrorNormal() {
+
+        processor.subscribe(this, this, composite);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onComplete();
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList("OnComplete"), events);
+
+    }
+
+    @Test
+    public void onErrorError() {
+
+        Disposable d = processor.subscribe(this, this, composite);
+
+        assertTrue(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onError(new IOException());
+
+        assertTrue(events.toString(), events.get(0) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteNormal() {
+
+        processor.subscribe(this, this, composite);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onComplete();
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList("OnComplete"), events);
+
+    }
+
+    @Test
+    public void onCompleteError() {
+
+        processor.subscribe(this, this, composite);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onError(new IOException());
+
+        assertTrue(events.toString(), events.get(0) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteDispose() {
+
+        Disposable d = processor.subscribe(this, this, composite);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        d.dispose();
+
+        assertTrue(d.isDisposed());
+
+        assertEquals(0, composite.size());
+
+        assertFalse(processor.hasObservers());
+    }
+
+    @Test
+    public void onErrorCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            processor.subscribe(this, t -> {
+                throw new IOException(t);
+            }, composite);
+
+            processor.onError(new IllegalArgumentException());
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+            List<Throwable> inners = TestHelper.compositeList(errors.get(0));
+            TestHelper.assertError(inners, 0, IllegalArgumentException.class);
+            TestHelper.assertError(inners, 1, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            processor.subscribe(new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IOException();
+                }
+            }, this, composite);
+
+            processor.onComplete();
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Completable() {
+                @Override
+                protected void subscribeActual(
+                        CompletableObserver observer) {
+                    observer.onSubscribe(Disposable.empty());
+                    observer.onComplete();
+
+                    observer.onSubscribe(Disposable.empty());
+                    observer.onComplete();
+                    observer.onError(new IOException());
+                }
+            }.subscribe(this, this, composite);
+
+            assertEquals(Arrays.<Object>asList("OnComplete"), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/rxjava3/internal/observers/MaybeConsumersTest.java b/src/test/java/io/reactivex/rxjava3/internal/observers/MaybeConsumersTest.java
new file mode 100644
index 0000000..92b32c0
--- /dev/null
+++ b/src/test/java/io/reactivex/rxjava3/internal/observers/MaybeConsumersTest.java
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) 2016-present, RxJava Contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+/*
+ * Copyright 2016-2019 David Karnok
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.rxjava3.internal.observers;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.exceptions.CompositeException;
+import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.internal.functions.Functions;
+import io.reactivex.rxjava3.observers.LambdaConsumerIntrospection;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.subjects.MaybeSubject;
+import io.reactivex.rxjava3.testsupport.TestHelper;
+
+public class MaybeConsumersTest implements Consumer<Object>, Action {
+
+    final CompositeDisposable composite = new CompositeDisposable();
+
+    final MaybeSubject<Integer> processor = MaybeSubject.create();
+
+    final List<Object> events = new ArrayList<>();
+
+    @Override
+    public void run() throws Exception {
+        events.add("OnComplete");
+    }
+
+    @Override
+    public void accept(Object t) throws Exception {
+        events.add(t);
+    }
+
+    static <T> Disposable subscribeAutoDispose(Maybe<T> source, CompositeDisposable composite,
+            Consumer<? super T> onSuccess, Consumer<? super Throwable> onError, Action onComplete) {
+        return source.subscribe(onSuccess, onError, onComplete, composite);
+    }
+
+    @Test
+    public void onSuccessNormal() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, Functions.ON_ERROR_MISSING, () -> { });
+
+        assertFalse(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onSuccess(1);
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+    }
+
+    @Test
+    public void onErrorNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onSuccess(1);
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+    }
+
+    @Test
+    public void onErrorError() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onError(new IOException());
+
+        assertTrue(events.toString(), events.get(0) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onComplete();
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList("OnComplete"), events);
+
+    }
+
+    @Test
+    public void onCompleteError() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onError(new IOException());
+
+        assertTrue(events.toString(), events.get(0) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteDispose() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        d.dispose();
+
+        assertTrue(d.isDisposed());
+
+        assertEquals(0, composite.size());
+
+        assertFalse(processor.hasObservers());
+    }
+
+    @Test
+    public void onSuccessCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, new Consumer<Object>() {
+                @Override
+                public void accept(Object t) throws Exception {
+                    throw new IOException();
+                }
+            }, this, this);
+
+            processor.onSuccess(1);
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) throws Exception {
+                    throw new IOException(t);
+                }
+            }, this);
+
+            processor.onError(new IllegalArgumentException());
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+            List<Throwable> inners = TestHelper.compositeList(errors.get(0));
+            TestHelper.assertError(inners, 0, IllegalArgumentException.class);
+            TestHelper.assertError(inners, 1, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, this, new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IOException();
+                }
+            });
+
+            processor.onComplete();
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(
+                    new Maybe<Integer>() {
+                        @Override
+                        protected void subscribeActual(
+                                MaybeObserver<? super Integer> observer) {
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onComplete();
+
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onSuccess(2);
+                            observer.onComplete();
+                            observer.onError(new IOException());
+                        }
+                    }, composite, this, this, this
+                );
+
+            assertEquals(Arrays.<Object>asList("OnComplete"), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/rxjava3/internal/observers/ObservableConsumersTest.java b/src/test/java/io/reactivex/rxjava3/internal/observers/ObservableConsumersTest.java
new file mode 100644
index 0000000..b5d2634
--- /dev/null
+++ b/src/test/java/io/reactivex/rxjava3/internal/observers/ObservableConsumersTest.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (c) 2016-present, RxJava Contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+/*
+ * Copyright 2016-2019 David Karnok
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.rxjava3.internal.observers;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.rxjava3.core.Observable;
+import io.reactivex.rxjava3.core.Observer;
+import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.exceptions.*;
+import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.internal.functions.Functions;
+import io.reactivex.rxjava3.observers.LambdaConsumerIntrospection;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.subjects.PublishSubject;
+import io.reactivex.rxjava3.testsupport.TestHelper;
+
+public class ObservableConsumersTest implements Consumer<Object>, Action {
+
+    final CompositeDisposable composite = new CompositeDisposable();
+
+    final PublishSubject<Integer> processor = PublishSubject.create();
+
+    final List<Object> events = new ArrayList<>();
+
+    @Override
+    public void run() throws Exception {
+        events.add("OnComplete");
+    }
+
+    @Override
+    public void accept(Object t) throws Exception {
+        events.add(t);
+    }
+
+    static <T> Disposable subscribeAutoDispose(Observable<T> source, CompositeDisposable composite,
+            Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {
+        return source.subscribe(onNext, onError, onComplete, composite);
+    }
+
+    @Test
+    public void onNextNormal() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, Functions.ON_ERROR_MISSING, () -> { });
+
+        assertFalse(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onErrorNormal() {
+
+        subscribeAutoDispose(processor, composite, this, Functions.ON_ERROR_MISSING, () -> { });
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onErrorError() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onError(new IOException());
+
+        assertEquals(events.toString(), 1, events.get(0));
+        assertTrue(events.toString(), events.get(1) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1, "OnComplete"), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteError() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onError(new IOException());
+
+        assertEquals(events.toString(), 1, events.get(0));
+        assertTrue(events.toString(), events.get(1) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteDispose() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        d.dispose();
+
+        assertTrue(d.isDisposed());
+
+        assertEquals(0, composite.size());
+
+        assertFalse(processor.hasObservers());
+    }
+
+    @Test
+    public void onNextCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, new Consumer<Object>() {
+                @Override
+                public void accept(Object t) throws Exception {
+                    throw new IOException();
+                }
+            }, this, this);
+
+            processor.onNext(1);
+
+            assertTrue(errors.toString(), errors.isEmpty());
+
+            assertTrue(events.toString(), events.get(0) instanceof IOException);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextCrashOnError() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) throws Exception {
+                    throw new IOException(t);
+                }
+            }, this);
+
+            processor.onError(new IllegalArgumentException());
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+            List<Throwable> inners = TestHelper.compositeList(errors.get(0));
+            TestHelper.assertError(inners, 0, IllegalArgumentException.class);
+            TestHelper.assertError(inners, 1, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextCrashNoError() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, t -> {
+                throw new IOException();
+            }, Functions.ON_ERROR_MISSING, () -> { });
+
+            processor.onNext(1);
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);
+            assertTrue(errors.get(0).getCause() instanceof IOException);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, this, new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IOException();
+                }
+            });
+
+            processor.onNext(1);
+            processor.onComplete();
+
+            assertEquals(Arrays.asList(1), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(
+                    new Observable<Integer>() {
+                        @Override
+                        protected void subscribeActual(
+                                Observer<? super Integer> observer) {
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onNext(1);
+                            observer.onComplete();
+
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onNext(2);
+                            observer.onComplete();
+                            observer.onError(new IOException());
+                        }
+                    }, composite, this, this, this
+                );
+
+            assertEquals(Arrays.<Object>asList(1, "OnComplete"), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/rxjava3/internal/observers/SingleConsumersTest.java b/src/test/java/io/reactivex/rxjava3/internal/observers/SingleConsumersTest.java
new file mode 100644
index 0000000..a840d8f
--- /dev/null
+++ b/src/test/java/io/reactivex/rxjava3/internal/observers/SingleConsumersTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) 2016-present, RxJava Contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+/*
+ * Copyright 2016-2019 David Karnok
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.rxjava3.internal.observers;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.exceptions.CompositeException;
+import io.reactivex.rxjava3.functions.Consumer;
+import io.reactivex.rxjava3.internal.functions.Functions;
+import io.reactivex.rxjava3.observers.LambdaConsumerIntrospection;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.subjects.SingleSubject;
+import io.reactivex.rxjava3.testsupport.TestHelper;
+
+public class SingleConsumersTest implements Consumer<Object> {
+
+    final CompositeDisposable composite = new CompositeDisposable();
+
+    final SingleSubject<Integer> processor = SingleSubject.create();
+
+    final List<Object> events = new ArrayList<>();
+
+    @Override
+    public void accept(Object t) throws Exception {
+        events.add(t);
+    }
+
+    static <T> Disposable subscribeAutoDispose(Single<T> source, CompositeDisposable composite,
+            Consumer<? super T> onSuccess, Consumer<? super Throwable> onError) {
+        return source.subscribe(onSuccess, onError, composite);
+    }
+
+    @Test
+    public void onSuccessNormal() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, Functions.ON_ERROR_MISSING);
+
+        assertFalse(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onSuccess(1);
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+    }
+
+    @Test
+    public void onErrorNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onSuccess(1);
+
+        assertEquals(0, composite.size());
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+    }
+
+    @Test
+    public void onErrorError() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this);
+
+        assertTrue(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onError(new IOException());
+
+        assertTrue(events.toString(), events.get(0) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onSuccessCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, new Consumer<Object>() {
+                @Override
+                public void accept(Object t) throws Exception {
+                    throw new IOException();
+                }
+            }, this);
+
+            processor.onSuccess(1);
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) throws Exception {
+                    throw new IOException(t);
+                }
+            });
+
+            processor.onError(new IllegalArgumentException());
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+            List<Throwable> inners = TestHelper.compositeList(errors.get(0));
+            TestHelper.assertError(inners, 0, IllegalArgumentException.class);
+            TestHelper.assertError(inners, 1, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(
+                    new Single<Integer>() {
+                        @Override
+                        protected void subscribeActual(
+                                SingleObserver<? super Integer> observer) {
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onSuccess(1);
+
+                            observer.onSubscribe(Disposable.empty());
+                            observer.onSuccess(2);
+                            observer.onError(new IOException());
+                        }
+                    }, composite, this, this
+                );
+
+            assertEquals(Arrays.<Object>asList(1), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/rxjava3/internal/subscribers/FlowableConsumersTest.java b/src/test/java/io/reactivex/rxjava3/internal/subscribers/FlowableConsumersTest.java
new file mode 100644
index 0000000..cc7083c
--- /dev/null
+++ b/src/test/java/io/reactivex/rxjava3/internal/subscribers/FlowableConsumersTest.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (c) 2016-present, RxJava Contributors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+/*
+ * Copyright 2016-2019 David Karnok
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.rxjava3.internal.subscribers;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.*;
+
+import org.junit.Test;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.*;
+import io.reactivex.rxjava3.exceptions.*;
+import io.reactivex.rxjava3.functions.*;
+import io.reactivex.rxjava3.internal.functions.Functions;
+import io.reactivex.rxjava3.internal.subscriptions.BooleanSubscription;
+import io.reactivex.rxjava3.observers.LambdaConsumerIntrospection;
+import io.reactivex.rxjava3.plugins.RxJavaPlugins;
+import io.reactivex.rxjava3.processors.PublishProcessor;
+import io.reactivex.rxjava3.testsupport.TestHelper;
+
+public class FlowableConsumersTest implements Consumer<Object>, Action {
+
+    final CompositeDisposable composite = new CompositeDisposable();
+
+    final PublishProcessor<Integer> processor = PublishProcessor.create();
+
+    final List<Object> events = new ArrayList<>();
+
+    @Override
+    public void run() throws Exception {
+        events.add("OnComplete");
+    }
+
+    @Override
+    public void accept(Object t) throws Exception {
+        events.add(t);
+    }
+
+    static <T> Disposable subscribeAutoDispose(Flowable<T> source, CompositeDisposable composite,
+            Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete) {
+        return source.subscribe(onNext, onError, onComplete, composite);
+    }
+
+    @Test
+    public void onNextNormal() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, Functions.ON_ERROR_MISSING, () -> { });
+
+        assertFalse(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onErrorNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this, () -> { });
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onErrorError() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(d.getClass().toString(), ((LambdaConsumerIntrospection)d).hasCustomOnError());
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onError(new IOException());
+
+        assertEquals(events.toString(), 1, events.get(0));
+        assertTrue(events.toString(), events.get(1) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteNormal() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onComplete();
+
+        assertEquals(Arrays.<Object>asList(1, "OnComplete"), events);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteError() {
+
+        subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        processor.onNext(1);
+
+        assertTrue(composite.size() > 0);
+
+        assertEquals(Arrays.<Object>asList(1), events);
+
+        processor.onError(new IOException());
+
+        assertEquals(events.toString(), 1, events.get(0));
+        assertTrue(events.toString(), events.get(1) instanceof IOException);
+
+        assertEquals(0, composite.size());
+    }
+
+    @Test
+    public void onCompleteDispose() {
+
+        Disposable d = subscribeAutoDispose(processor, composite, this, this, this);
+
+        assertTrue(composite.size() > 0);
+
+        assertTrue(events.toString(), events.isEmpty());
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        d.dispose();
+
+        assertTrue(d.isDisposed());
+
+        assertEquals(0, composite.size());
+
+        assertFalse(processor.hasSubscribers());
+    }
+
+    @Test
+    public void onNextCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, new Consumer<Object>() {
+                @Override
+                public void accept(Object t) throws Exception {
+                    throw new IOException();
+                }
+            }, this, this);
+
+            processor.onNext(1);
+
+            assertTrue(errors.toString(), errors.isEmpty());
+
+            assertTrue(events.toString(), events.get(0) instanceof IOException);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextCrashOnError() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) throws Exception {
+                    throw new IOException(t);
+                }
+            }, this);
+
+            processor.onError(new IllegalArgumentException());
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+            List<Throwable> inners = TestHelper.compositeList(errors.get(0));
+            TestHelper.assertError(inners, 0, IllegalArgumentException.class);
+            TestHelper.assertError(inners, 1, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextCrashNoError() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, new Consumer<Object>() {
+                @Override
+                public void accept(Object t) throws Exception {
+                    throw new IOException();
+                }
+            }, Functions.ON_ERROR_MISSING, () -> { });
+
+            processor.onNext(1);
+
+            assertTrue(events.toString(), events.isEmpty());
+
+            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);
+            assertTrue(errors.get(0).getCause() instanceof IOException);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrash() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(processor, composite, this, this, new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IOException();
+                }
+            });
+
+            processor.onNext(1);
+            processor.onComplete();
+
+            assertEquals(Arrays.asList(1), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            subscribeAutoDispose(
+                    new Flowable<Integer>() {
+                        @Override
+                        protected void subscribeActual(
+                                Subscriber<? super Integer> s) {
+                            s.onSubscribe(new BooleanSubscription());
+                            s.onNext(1);
+                            s.onComplete();
+
+                            s.onSubscribe(new BooleanSubscription());
+                            s.onNext(2);
+                            s.onComplete();
+                            s.onError(new IOException());
+                        }
+                    }, composite, this, this, this
+                );
+
+            assertEquals(Arrays.<Object>asList(1, "OnComplete"), events);
+
+            TestHelper.assertUndeliverable(errors, 0, IOException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/rxjava3/validators/BaseTypeAnnotations.java b/src/test/java/io/reactivex/rxjava3/validators/BaseTypeAnnotations.java
index d03c0dc..582df0f 100644
--- a/src/test/java/io/reactivex/rxjava3/validators/BaseTypeAnnotations.java
+++ b/src/test/java/io/reactivex/rxjava3/validators/BaseTypeAnnotations.java
@@ -22,6 +22,7 @@ import org.reactivestreams.Publisher;
 
 import io.reactivex.rxjava3.annotations.*;
 import io.reactivex.rxjava3.core.*;
+import io.reactivex.rxjava3.disposables.DisposableContainer;
 import io.reactivex.rxjava3.flowables.ConnectableFlowable;
 import io.reactivex.rxjava3.observables.ConnectableObservable;
 import io.reactivex.rxjava3.parallel.ParallelFlowable;
@@ -44,7 +45,8 @@ public class BaseTypeAnnotations {
 
         for (Method m : clazz.getMethods()) {
             if (m.getDeclaringClass() == clazz) {
-                boolean isSubscribeMethod = "subscribe".equals(m.getName()) && m.getParameterTypes().length == 0;
+                boolean isSubscribeMethod = "subscribe".equals(m.getName()) &&
+                        (m.getParameterTypes().length == 0 || m.getParameterTypes()[m.getParameterCount() - 1] == DisposableContainer.class);
                 boolean isConnectMethod = "connect".equals(m.getName()) && m.getParameterTypes().length == 0;
                 boolean isAnnotationPresent = m.isAnnotationPresent(CheckReturnValue.class);
 
diff --git a/src/test/java/io/reactivex/rxjava3/validators/JavadocForAnnotations.java b/src/test/java/io/reactivex/rxjava3/validators/JavadocForAnnotations.java
index c3c814f..1c68378 100644
--- a/src/test/java/io/reactivex/rxjava3/validators/JavadocForAnnotations.java
+++ b/src/test/java/io/reactivex/rxjava3/validators/JavadocForAnnotations.java
@@ -95,7 +95,7 @@ public class JavadocForAnnotations {
                     ;
                     int lc = lineNumber(sourceCode, idx);
 
-                    e.append(" at io.reactivex.").append(baseClassName)
+                    e.append(" at io.reactivex.rxjava3.core.").append(baseClassName)
                     .append(" (").append(baseClassName).append(".java:")
                     .append(lc).append(")").append("\r\n\r\n");
                 }
diff --git a/src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java b/src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java
index b093036..3ab4158 100644
--- a/src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java
+++ b/src/test/java/io/reactivex/rxjava3/validators/JavadocWording.java
@@ -309,6 +309,7 @@ public class JavadocWording {
                                 && !m.signature.contains("Maybe")
                                 && !m.signature.contains("MaybeSource")
                                 && !m.signature.contains("Disposable")
+                                && !m.signature.contains("void subscribe")
                         ) {
                             CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);
                             if (idx < 6 || !subSequence.equals("{@link Disposable")) {
diff --git a/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java b/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
index 84f9970..51c7626 100644
--- a/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
+++ b/src/test/java/io/reactivex/rxjava3/validators/ParamValidationCheckerTest.java
@@ -25,7 +25,7 @@ import org.reactivestreams.*;
 import io.reactivex.rxjava3.core.*;
 import io.reactivex.rxjava3.core.Observable;
 import io.reactivex.rxjava3.core.Observer;
-import io.reactivex.rxjava3.disposables.Disposable;
+import io.reactivex.rxjava3.disposables.*;
 import io.reactivex.rxjava3.exceptions.TestException;
 import io.reactivex.rxjava3.functions.*;
 import io.reactivex.rxjava3.internal.functions.Functions;
@@ -580,6 +580,8 @@ public class ParamValidationCheckerTest {
 
         defaultValues.put(ParallelFailureHandling.class, ParallelFailureHandling.ERROR);
 
+        defaultValues.put(DisposableContainer.class, new CompositeDisposable());
+
         // JDK 8 types
 
         defaultValues.put(Optional.class, Optional.of(1));

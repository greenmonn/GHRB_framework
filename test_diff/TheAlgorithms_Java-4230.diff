diff --git a/src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java b/src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
index 2a5fe0b..4c9f16d 100644
--- a/src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
+++ b/src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
@@ -2,33 +2,101 @@ package com.thealgorithms.searches;
 
 import static org.junit.jupiter.api.Assertions.*;
 
+import com.thealgorithms.datastructures.Node;
 import java.util.List;
 import java.util.Optional;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-class BreadthFirstSearchTest {
+public class BreadthFirstSearchTest {
+    private Node<String> root;
+    private BreadthFirstSearch<String> bfs;
 
-    private static final DepthFirstSearch.Node rootNode = new DepthFirstSearch.Node("A",
-        List.of(new DepthFirstSearch.Node("B", List.of(new DepthFirstSearch.Node("D"), new DepthFirstSearch.Node("F", List.of(new DepthFirstSearch.Node("H"), new DepthFirstSearch.Node("I"))))), new DepthFirstSearch.Node("C", List.of(new DepthFirstSearch.Node("G"))), new DepthFirstSearch.Node("E")));
+    // Tree structure:
+    //
+    //        A
+    //      / | \
+    //     B  C  D
+    //    / \
+    //   E   F
+
+    @BeforeEach
+    public void setUp() {
+        // nodes declaration
+        root = new Node<>("A");
+
+        var nodeB = new Node<>("B");
+        var nodeC = new Node<>("C");
+        var nodeD = new Node<>("D");
+
+        var nodeE = new Node<>("E");
+        var nodeF = new Node<>("F");
+
+        // tree initialization
+        root.addChild(nodeB);
+        root.addChild(nodeC);
+        root.addChild(nodeD);
+
+        nodeB.addChild(nodeE);
+        nodeB.addChild(nodeF);
+
+        // create an instance to monitor the visited nodes
+        bfs = new BreadthFirstSearch<>();
+    }
 
     @Test
-    void searchI() {
-        Optional<DepthFirstSearch.Node> Inode = BreadthFirstSearch.search(rootNode, "I");
-        assertTrue(Inode.isPresent());
-        assertEquals(Inode.get().getName(), "I");
+    public void testSearchRoot() {
+        String expectedValue = "A";
+        List<String> expectedPath = List.of("A");
+
+        // check value
+        Optional<Node<String>> value = bfs.search(root, expectedValue);
+        assertEquals(expectedValue, value.orElse(new Node<>("")).getValue());
+
+        // check path
+        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
     }
 
     @Test
-    void searchG() {
-        Optional<DepthFirstSearch.Node> Gnode = BreadthFirstSearch.search(rootNode, "G");
-        assertTrue(Gnode.isPresent());
-        assertEquals(Gnode.get().getName(), "G");
+    public void testSearchF() {
+        String expectedValue = "F";
+        List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
+
+        // check value
+        Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));
+        assertEquals(expectedValue, value.get().getValue());
+
+        // check path
+        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
     }
 
     @Test
-    void searchE() {
-        Optional<DepthFirstSearch.Node> Enode = BreadthFirstSearch.search(rootNode, "E");
-        assertTrue(Enode.isPresent());
-        assertEquals(Enode.get().getName(), "E");
+    void testSearchNull() {
+        List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
+        Optional<Node<String>> node = bfs.search(root, null);
+
+        // check value
+        assertTrue(node.isEmpty());
+
+        // check path
+        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
+    }
+
+    @Test
+    void testNullRoot() {
+        var value = bfs.search(null, "B");
+        assertTrue(value.isEmpty());
+    }
+
+    @Test
+    void testSearchValueThatNotExists() {
+        List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
+        var value = bfs.search(root, "Z");
+
+        // check that the value is empty because it's not exists in the tree
+        assertTrue(value.isEmpty());
+
+        // check path is the whole list
+        assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
     }
 }
\ No newline at end of file
diff --git a/src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java b/src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java
new file mode 100644
index 0000000..f85e940
--- /dev/null
+++ b/src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java
@@ -0,0 +1,91 @@
+package com.thealgorithms.searches;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+import com.thealgorithms.datastructures.Node;
+import java.util.List;
+import java.util.Optional;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class DepthFirstSearchTest {
+
+    private Node<Integer> root;
+    private DepthFirstSearch<Integer> dfs;
+
+    //
+    // Tree structure:
+    //          1
+    //        / | \
+    //       2  3  4
+    //      / \
+    //     5   6
+
+    @BeforeEach
+    public void setUp() {
+        // nodes declaration
+        root = new Node<>(1);
+
+        var nodeB = new Node<>(2);
+        var nodeC = new Node<>(3);
+        var nodeD = new Node<>(4);
+
+        var nodeE = new Node<>(5);
+        var nodeF = new Node<>(6);
+
+        // tree initialization
+        root.addChild(nodeB);
+        root.addChild(nodeC);
+        root.addChild(nodeD);
+
+        nodeB.addChild(nodeE);
+        nodeB.addChild(nodeF);
+
+        // create an instance to monitor the visited nodes
+        dfs = new DepthFirstSearch<>();
+    }
+
+    @Test
+    public void testSearchRoot() {
+        Integer expectedValue = 1;
+        List<Integer> expectedPath = List.of(1);
+
+        // check value
+        Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
+        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
+
+        // check path
+        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
+    }
+
+    @Test
+    public void testSearch4() {
+        Integer expectedValue = 4;
+        List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);
+
+        // check value
+        Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
+        assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
+
+        // check path
+        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
+    }
+
+    @Test
+    void testNullRoot() {
+        var value = dfs.recursiveSearch(null, 4);
+        assertTrue(value.isEmpty());
+    }
+
+    @Test
+    void testSearchValueThatNotExists() {
+        List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);
+        var value = dfs.recursiveSearch(root, 10);
+
+        // check that the value is empty because it's not exists in the tree
+        assertTrue(value.isEmpty());
+
+        // check path is the whole list
+        assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
+    }
+}

diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java
deleted file mode 100644
index a6bf09f..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileQueueTest.java
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.container;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import org.apache.commons.io.FileUtils;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.metadata.TieredMetadataStore;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-public class TieredFileQueueTest {
-    TieredMessageStoreConfig storeConfig;
-    MessageQueue queue;
-
-    @Before
-    public void setUp() {
-        storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.store.tiered.mock.MemoryFileSegment");
-        queue = new MessageQueue("TieredFileQueueTest", storeConfig.getBrokerName(), 0);
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
-        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
-    }
-
-    @Test
-    public void testGetFileSegment() throws ClassNotFoundException, NoSuchMethodException {
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            queue, storeConfig);
-        fileQueue.setBaseOffset(0);
-        TieredFileSegment segment1 = fileQueue.getFileToWrite();
-        segment1.initPosition(1000);
-        segment1.append(ByteBuffer.allocate(100), 0);
-        segment1.setFull();
-        segment1.commit();
-
-        TieredFileSegment segment2 = fileQueue.getFileToWrite();
-        Assert.assertNotSame(segment1, segment2);
-        Assert.assertEquals(1000 + 100 + TieredCommitLog.CODA_SIZE, segment1.getMaxOffset());
-        Assert.assertEquals(1000 + 100 + TieredCommitLog.CODA_SIZE, segment2.getBaseOffset());
-
-        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1000), 0);
-        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1050), 0);
-        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1100 + TieredCommitLog.CODA_SIZE), 1);
-        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1150), -1);
-    }
-
-    @Test
-    public void testAppendAndRead() throws ClassNotFoundException, NoSuchMethodException {
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, storeConfig);
-        fileQueue.setBaseOffset(0);
-        Assert.assertEquals(0, fileQueue.getMinOffset());
-        Assert.assertEquals(0, fileQueue.getCommitMsgQueueOffset());
-
-        TieredFileSegment segment1 = fileQueue.getFileToWrite();
-        segment1.initPosition(segment1.getSize());
-        Assert.assertEquals(0, segment1.getBaseOffset());
-        Assert.assertEquals(1000, fileQueue.getCommitOffset());
-        Assert.assertEquals(1000, fileQueue.getMaxOffset());
-
-        ByteBuffer buffer = ByteBuffer.allocate(100);
-        long currentTimeMillis = System.currentTimeMillis();
-        buffer.putLong(currentTimeMillis);
-        buffer.rewind();
-        fileQueue.append(buffer);
-        Assert.assertEquals(1100, segment1.getMaxOffset());
-
-        segment1.setFull();
-        fileQueue.commit(true);
-        Assert.assertEquals(1100, segment1.getCommitOffset());
-
-        ByteBuffer readBuffer = fileQueue.readAsync(1000, 8).join();
-        Assert.assertEquals(currentTimeMillis, readBuffer.getLong());
-
-        TieredFileSegment segment2 = fileQueue.getFileToWrite();
-        Assert.assertNotEquals(segment1, segment2);
-        segment2.initPosition(segment2.getSize());
-        buffer.rewind();
-        fileQueue.append(buffer);
-        fileQueue.commit(true);
-        readBuffer = fileQueue.readAsync(1000, 1200).join();
-        Assert.assertEquals(currentTimeMillis, readBuffer.getLong(1100));
-    }
-
-    @Test
-    public void testLoadFromMetadata() throws ClassNotFoundException, NoSuchMethodException {
-        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-
-        MemoryFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            queue, 100, storeConfig);
-        fileSegment1.initPosition(fileSegment1.getSize());
-        fileSegment1.setFull();
-        metadataStore.updateFileSegment(fileSegment1);
-        metadataStore.updateFileSegment(fileSegment1);
-
-        MemoryFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            queue, 1100, storeConfig);
-        metadataStore.updateFileSegment(fileSegment2);
-
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            queue, storeConfig);
-        Assert.assertEquals(2, fileQueue.needCommitFileSegmentList.size());
-        TieredFileSegment file1 = fileQueue.getFileByIndex(0);
-        Assert.assertNotNull(file1);
-        Assert.assertEquals(100, file1.getBaseOffset());
-        Assert.assertFalse(file1.isFull());
-
-        TieredFileSegment file2 = fileQueue.getFileByIndex(1);
-        Assert.assertNotNull(file2);
-        Assert.assertEquals(1100, file2.getBaseOffset());
-        Assert.assertFalse(file2.isFull());
-
-        TieredFileSegment file3 = fileQueue.getFileByIndex(2);
-        Assert.assertNull(file3);
-    }
-
-    @Test
-    public void testCheckFileSize() throws ClassNotFoundException, NoSuchMethodException {
-        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-
-        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, 100, storeConfig);
-        fileSegment1.initPosition(fileSegment1.getSize() - 100);
-        fileSegment1.setFull(false);
-        metadataStore.updateFileSegment(fileSegment1);
-        metadataStore.updateFileSegment(fileSegment1);
-
-        TieredFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, 1100, storeConfig);
-        fileSegment2.initPosition(fileSegment2.getSize() - 100);
-        metadataStore.updateFileSegment(fileSegment2);
-        metadataStore.updateFileSegment(fileSegment2);
-
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, storeConfig);
-        Assert.assertEquals(1, fileQueue.needCommitFileSegmentList.size());
-
-        fileSegment1 = fileQueue.getFileByIndex(0);
-        Assert.assertTrue(fileSegment1.isFull());
-        Assert.assertEquals(fileSegment1.getSize() + 100, fileSegment1.getCommitOffset());
-
-        fileSegment2 = fileQueue.getFileByIndex(1);
-        Assert.assertEquals(1000, fileSegment2.getCommitPosition());
-
-        fileSegment2.setFull();
-        fileQueue.commit(true);
-        Assert.assertEquals(0, fileQueue.needCommitFileSegmentList.size());
-
-        fileQueue.getFileToWrite();
-        Assert.assertEquals(1, fileQueue.needCommitFileSegmentList.size());
-    }
-
-    @Test
-    public void testCleanExpiredFile() throws ClassNotFoundException, NoSuchMethodException {
-        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-
-        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, 100, storeConfig);
-        fileSegment1.initPosition(fileSegment1.getSize() - 100);
-        fileSegment1.setFull(false);
-        fileSegment1.setEndTimestamp(System.currentTimeMillis() - 1);
-        metadataStore.updateFileSegment(fileSegment1);
-        metadataStore.updateFileSegment(fileSegment1);
-
-        long file1CreateTimeStamp = System.currentTimeMillis();
-
-        TieredFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, 1100, storeConfig);
-        fileSegment2.initPosition(fileSegment2.getSize());
-        fileSegment2.setEndTimestamp(System.currentTimeMillis() + 1);
-        metadataStore.updateFileSegment(fileSegment2);
-        metadataStore.updateFileSegment(fileSegment2);
-
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, storeConfig);
-        Assert.assertEquals(2, fileQueue.getFileSegmentCount());
-
-        fileQueue.cleanExpiredFile(file1CreateTimeStamp);
-        fileQueue.destroyExpiredFile();
-        Assert.assertEquals(1, fileQueue.getFileSegmentCount());
-        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
-        Assert.assertNotNull(metadataStore.getFileSegment(fileSegment2));
-
-        fileQueue.cleanExpiredFile(Long.MAX_VALUE);
-        fileQueue.destroyExpiredFile();
-        Assert.assertEquals(0, fileQueue.getFileSegmentCount());
-        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
-        Assert.assertNull(metadataStore.getFileSegment(fileSegment2));
-    }
-
-    @Test
-    public void testRollingNewFile() throws ClassNotFoundException, NoSuchMethodException {
-        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-
-        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, 100, storeConfig);
-        fileSegment1.initPosition(fileSegment1.getSize() - 100);
-        metadataStore.updateFileSegment(fileSegment1);
-
-        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
-            queue, storeConfig);
-        Assert.assertEquals(1, fileQueue.getFileSegmentCount());
-
-        fileQueue.rollingNewFile();
-        Assert.assertEquals(2, fileQueue.getFileSegmentCount());
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java
deleted file mode 100644
index d189aad..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredFileSegmentTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.container;
-
-import java.nio.ByteBuffer;
-import java.util.concurrent.CompletableFuture;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.MessageBufferUtil;
-import org.apache.rocketmq.store.tiered.util.MessageBufferUtilTest;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class TieredFileSegmentTest {
-    public int baseOffset = 1000;
-
-    public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
-        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", "broker", 0),
-            baseOffset, new TieredMessageStoreConfig());
-    }
-
-    @Test
-    public void testCommitLog() {
-        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
-        segment.initPosition(segment.getSize());
-        long lastSize = segment.getSize();
-        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
-        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
-        Assert.assertTrue(segment.needCommit());
-
-        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
-        long msg3StoreTime = System.currentTimeMillis();
-        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, msg3StoreTime);
-        long queueOffset = baseOffset * 1000L;
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, queueOffset);
-        segment.append(buffer, msg3StoreTime);
-
-        Assert.assertEquals(baseOffset, segment.getBaseOffset());
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
-        Assert.assertEquals(0, segment.getBeginTimestamp());
-        Assert.assertEquals(msg3StoreTime, segment.getEndTimestamp());
-
-        segment.setFull();
-        segment.commit();
-        Assert.assertFalse(segment.needCommit());
-        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
-        Assert.assertEquals(queueOffset, segment.getCommitMsgQueueOffset());
-
-        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
-
-        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
-
-        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
-
-        ByteBuffer coda = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 3, TieredCommitLog.CODA_SIZE);
-        Assert.assertEquals(msg3StoreTime, coda.getLong(4 + 4));
-    }
-
-    private ByteBuffer buildConsumeQueue(long commitLogOffset) {
-        ByteBuffer cqItem = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqItem.putLong(commitLogOffset);
-        cqItem.putInt(2);
-        cqItem.putLong(3);
-        cqItem.flip();
-        return cqItem;
-    }
-
-    @Test
-    public void testConsumeQueue() {
-        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE);
-        segment.initPosition(segment.getSize());
-        long lastSize = segment.getSize();
-        segment.append(buildConsumeQueue(baseOffset), 0);
-        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN), 0);
-        long cqItem3Timestamp = System.currentTimeMillis();
-        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN * 2), cqItem3Timestamp);
-
-        Assert.assertEquals(baseOffset + lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3, segment.getMaxOffset());
-        Assert.assertEquals(0, segment.getBeginTimestamp());
-        Assert.assertEquals(cqItem3Timestamp, segment.getEndTimestamp());
-
-        segment.commit();
-        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
-
-        ByteBuffer cqItem1 = segment.read(lastSize, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset, cqItem1.getLong());
-
-        ByteBuffer cqItem2 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN, cqItem2.getLong());
-
-        ByteBuffer cqItem3 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN * 2, cqItem3.getLong());
-    }
-
-    @Test
-    public void testCommitFailed() {
-        long startTime = System.currentTimeMillis();
-        MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
-        long lastSize = segment.getSize();
-        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
-        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
-
-        segment.blocker = new CompletableFuture<>();
-        new Thread(() -> {
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                Assert.fail(e.getMessage());
-            }
-            ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
-            buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);
-            segment.append(buffer, 0);
-            segment.blocker.complete(false);
-        }).start();
-
-        segment.commit();
-        segment.blocker.join();
-
-        segment.blocker = new CompletableFuture<>();
-        segment.blocker.complete(true);
-        segment.commit();
-
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());
-
-        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
-
-        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
-
-        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java
deleted file mode 100644
index f4f517f..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/container/TieredIndexFileTest.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.container;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import org.apache.commons.io.FileUtils;
-import org.apache.commons.lang3.SystemUtils;
-import org.apache.commons.lang3.tuple.Pair;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.metadata.TieredMetadataStore;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
-import org.awaitility.Awaitility;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Assume;
-import org.junit.Before;
-import org.junit.Test;
-
-public class TieredIndexFileTest {
-    MessageQueue mq;
-    TieredMessageStoreConfig storeConfig;
-    TieredMetadataStore metadataStore;
-
-    @Before
-    public void setUp() {
-        MemoryFileSegment.checkSize = false;
-        mq = new MessageQueue("TieredIndexFileTest", "broker", 1);
-        storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.store.tiered.mock.MemoryFileSegment");
-        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
-        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
-        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        MemoryFileSegment.checkSize = true;
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
-//        metadataStore.reLoadStore();
-    }
-
-    @Test
-    public void testAppendAndQuery() throws IOException, ClassNotFoundException, NoSuchMethodException {
-        // skip this test on windows
-        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
-
-        TieredIndexFile indexFile = new TieredIndexFile(storeConfig);
-        indexFile.append(mq, 0, "key3", 3, 300, 1000);
-        indexFile.append(mq, 0, "key2", 2, 200, 1100);
-        indexFile.append(mq, 0, "key1", 1, 100, 1200);
-
-        Awaitility.waitAtMost(5, TimeUnit.SECONDS)
-            .until(() -> {
-                List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key1", 1000, 1200).join();
-                if (indexList.size() != 1) {
-                    return false;
-                }
-
-                ByteBuffer indexBuffer = indexList.get(0).getValue();
-                Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 2, indexBuffer.remaining());
-
-                Assert.assertEquals(1, indexBuffer.getLong(4 + 4 + 4));
-                Assert.assertEquals(100, indexBuffer.getInt(4 + 4 + 4 + 8));
-                Assert.assertEquals(200, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
-
-                Assert.assertEquals(3, indexBuffer.getLong(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4));
-                Assert.assertEquals(300, indexBuffer.getInt(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4 + 8));
-                Assert.assertEquals(0, indexBuffer.getInt(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4 + 8 + 4));
-                return true;
-            });
-
-        indexFile.append(mq, 0, "key4", 4, 400, 1300);
-        indexFile.append(mq, 0, "key4", 4, 400, 1300);
-        indexFile.append(mq, 0, "key4", 4, 400, 1300);
-
-        Awaitility.waitAtMost(5, TimeUnit.SECONDS)
-            .until(() -> {
-                List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key4", 1300, 1300).join();
-                if (indexList.size() != 1) {
-                    return false;
-                }
-
-                ByteBuffer indexBuffer = indexList.get(0).getValue();
-                Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 3, indexBuffer.remaining());
-                Assert.assertEquals(4, indexBuffer.getLong(4 + 4 + 4));
-                Assert.assertEquals(400, indexBuffer.getInt(4 + 4 + 4 + 8));
-                Assert.assertEquals(0, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
-                return true;
-            });
-
-        List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key1", 1300, 1300).join();
-        Assert.assertEquals(0, indexList.size());
-
-        indexList = indexFile.queryAsync(mq.getTopic(), "key4", 1200, 1300).join();
-        Assert.assertEquals(2, indexList.size());
-
-        ByteBuffer indexBuffer = indexList.get(0).getValue();
-        Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 3, indexBuffer.remaining());
-        Assert.assertEquals(4, indexBuffer.getLong(4 + 4 + 4));
-        Assert.assertEquals(400, indexBuffer.getInt(4 + 4 + 4 + 8));
-        Assert.assertEquals(0, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
-
-        indexBuffer = indexList.get(1).getValue();
-        Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE, indexBuffer.remaining());
-        Assert.assertEquals(2, indexBuffer.getLong(4 + 4 + 4));
-        Assert.assertEquals(200, indexBuffer.getInt(4 + 4 + 4 + 8));
-        Assert.assertEquals(100, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java
deleted file mode 100644
index a1c5b86..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/metadata/MetadataStoreTest.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.metadata;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.apache.commons.io.FileUtils;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.container.TieredCommitLog;
-import org.apache.rocketmq.store.tiered.container.TieredFileSegment;
-import org.apache.rocketmq.store.tiered.mock.MemoryFileSegment;
-import org.apache.rocketmq.store.tiered.util.TieredStoreUtil;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-public class MetadataStoreTest {
-    MessageQueue mq;
-    TieredMessageStoreConfig storeConfig;
-    TieredMetadataStore metadataStore;
-
-    @Before
-    public void setUp() {
-        storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "rmqut");
-        mq = new MessageQueue("MetadataStoreTest", storeConfig.getBrokerName(), 1);
-        metadataStore = new TieredMetadataManager(storeConfig);
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        FileUtils.deleteDirectory(new File("/tmp/rmqut"));
-        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
-    }
-
-    @Test
-    public void testQueue() {
-        QueueMetadata queueMetadata = metadataStore.getQueue(mq);
-        Assert.assertNull(queueMetadata);
-
-        queueMetadata = metadataStore.addQueue(mq, -1);
-        Assert.assertEquals(queueMetadata.getMinOffset(), -1);
-        Assert.assertEquals(queueMetadata.getMaxOffset(), -1);
-
-        long currentTimeMillis = System.currentTimeMillis();
-        queueMetadata.setMinOffset(0);
-        queueMetadata.setMaxOffset(0);
-        metadataStore.updateQueue(queueMetadata);
-        queueMetadata = metadataStore.getQueue(mq);
-        Assert.assertTrue(queueMetadata.getUpdateTimestamp() >= currentTimeMillis);
-        Assert.assertEquals(queueMetadata.getMinOffset(), 0);
-        Assert.assertEquals(queueMetadata.getMaxOffset(), 0);
-
-        MessageQueue mq2 = new MessageQueue("MetadataStoreTest", "broker", 2);
-        metadataStore.addQueue(mq2, 1);
-        AtomicInteger i = new AtomicInteger(0);
-        metadataStore.iterateQueue(mq.getTopic(), metadata -> {
-            Assert.assertEquals(i.get(), metadata.getMinOffset());
-            i.getAndIncrement();
-        });
-        Assert.assertEquals(i.get(), 2);
-
-        metadataStore.deleteQueue(mq);
-        queueMetadata = metadataStore.getQueue(mq);
-        Assert.assertNull(queueMetadata);
-    }
-
-    @Test
-    public void testTopic() {
-        TopicMetadata topicMetadata = metadataStore.getTopic(mq.getTopic());
-        Assert.assertNull(topicMetadata);
-
-        metadataStore.addTopic(mq.getTopic(), 2);
-        topicMetadata = metadataStore.getTopic(mq.getTopic());
-        Assert.assertEquals(mq.getTopic(), topicMetadata.getTopic());
-        Assert.assertEquals(topicMetadata.getStatus(), 0);
-        Assert.assertEquals(topicMetadata.getReserveTime(), 2);
-        Assert.assertEquals(topicMetadata.getTopicId(), 0);
-
-        metadataStore.updateTopicStatus(mq.getTopic(), 1);
-        metadataStore.updateTopicReserveTime(mq.getTopic(), 0);
-        topicMetadata = metadataStore.getTopic(mq.getTopic());
-        Assert.assertNotNull(topicMetadata);
-        Assert.assertEquals(topicMetadata.getStatus(), 1);
-        Assert.assertEquals(topicMetadata.getReserveTime(), 0);
-
-        metadataStore.addTopic(mq.getTopic() + "1", 1);
-        metadataStore.updateTopicStatus(mq.getTopic() + "1", 2);
-
-        metadataStore.addTopic(mq.getTopic() + "2", 2);
-        metadataStore.updateTopicStatus(mq.getTopic() + "2", 3);
-
-        AtomicInteger n = new AtomicInteger();
-        metadataStore.iterateTopic(metadata -> {
-            long i = metadata.getReserveTime();
-            Assert.assertEquals(metadata.getTopicId(), i);
-            Assert.assertEquals(metadata.getStatus(), i + 1);
-            if (i == 2) {
-                metadataStore.deleteTopic(metadata.getTopic());
-            }
-            n.getAndIncrement();
-        });
-        Assert.assertEquals(3, n.get());
-
-        Assert.assertNull(metadataStore.getTopic(mq.getTopic() + "2"));
-
-        Assert.assertNotNull(metadataStore.getTopic(mq.getTopic()));
-        Assert.assertNotNull(metadataStore.getTopic(mq.getTopic() + "1"));
-    }
-
-    @Test
-    public void testFileSegment() {
-        MemoryFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            mq,
-            100,
-            storeConfig);
-        fileSegment1.initPosition(fileSegment1.getSize());
-        FileSegmentMetadata metadata1 = metadataStore.updateFileSegment(fileSegment1);
-        Assert.assertEquals(mq, metadata1.getQueue());
-        Assert.assertEquals(TieredFileSegment.FileSegmentType.COMMIT_LOG, TieredFileSegment.FileSegmentType.valueOf(metadata1.getType()));
-        Assert.assertEquals(100, metadata1.getBaseOffset());
-        Assert.assertEquals(0, metadata1.getSealTimestamp());
-
-        fileSegment1.setFull();
-        metadata1 = metadataStore.updateFileSegment(fileSegment1);
-        Assert.assertEquals(1000, metadata1.getSize());
-        Assert.assertEquals(0, metadata1.getSealTimestamp());
-
-        fileSegment1.commit();
-        metadata1 = metadataStore.updateFileSegment(fileSegment1);
-        Assert.assertEquals(1000 + TieredCommitLog.CODA_SIZE, metadata1.getSize());
-        Assert.assertTrue(metadata1.getSealTimestamp() > 0);
-
-        MemoryFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
-            mq,
-            1100,
-            storeConfig);
-        metadataStore.updateFileSegment(fileSegment2);
-        List<FileSegmentMetadata> list = new ArrayList<>();
-        metadataStore.iterateFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, "MetadataStoreTest", 1, list::add);
-        Assert.assertEquals(2, list.size());
-        Assert.assertEquals(100, list.get(0).getBaseOffset());
-        Assert.assertEquals(1100, list.get(1).getBaseOffset());
-
-        Assert.assertNotNull(metadataStore.getFileSegment(fileSegment1));
-        metadataStore.deleteFileSegment(fileSegment1);
-        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
-    }
-
-    @Test
-    public void testReload() {
-        TieredMetadataManager metadataManager = (TieredMetadataManager) metadataStore;
-        metadataManager.addTopic(mq.getTopic(), 1);
-        metadataManager.addQueue(mq, 2);
-        metadataManager.persist();
-        Assert.assertTrue(new File(metadataManager.configFilePath()).exists());
-
-        metadataManager = new TieredMetadataManager(storeConfig);
-        metadataManager.load();
-
-        TopicMetadata topicMetadata = metadataManager.getTopic(mq.getTopic());
-        Assert.assertNotNull(topicMetadata);
-        Assert.assertEquals(topicMetadata.getReserveTime(), 1);
-
-        QueueMetadata queueMetadata = metadataManager.getQueue(mq);
-        Assert.assertNotNull(queueMetadata);
-        Assert.assertEquals(queueMetadata.getMinOffset(), 2);
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java
deleted file mode 100644
index 0071963..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/mock/MemoryFileSegment.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.mock;
-
-import java.io.File;
-import java.nio.ByteBuffer;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.tiered.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.store.tiered.container.TieredFileSegment;
-import org.junit.Assert;
-
-public class MemoryFileSegment extends TieredFileSegment {
-    private final ByteBuffer memStore;
-
-    public CompletableFuture<Boolean> blocker;
-
-    public static boolean checkSize = true;
-
-    public MemoryFileSegment(TieredFileSegment.FileSegmentType fileType, MessageQueue messageQueue, long baseOffset,
-        TieredMessageStoreConfig storeConfig) {
-        super(fileType, messageQueue, baseOffset, storeConfig);
-        switch (fileType) {
-            case COMMIT_LOG:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            case CONSUME_QUEUE:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            case INDEX:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            default:
-                memStore = null;
-                break;
-        }
-        memStore.position((int) getSize());
-    }
-
-    @Override public String getPath() {
-        return "/tiered/" + fileType + File.separator + baseOffset;
-    }
-
-    @Override public long getSize() {
-        if (checkSize) {
-            return 1000;
-        }
-        return 0;
-    }
-
-    @Override protected void createFile() {
-
-    }
-
-    @Override protected CompletableFuture<ByteBuffer> read0(long position, int length) {
-        ByteBuffer buffer = memStore.duplicate();
-        buffer.position((int) position);
-        ByteBuffer slice = buffer.slice();
-        slice.limit(length);
-        return CompletableFuture.completedFuture(slice);
-    }
-
-    @Override
-    protected CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
-        boolean append) {
-        try {
-            if (blocker != null && !blocker.get()) {
-                throw new IllegalStateException();
-            }
-        } catch (InterruptedException | ExecutionException e) {
-            Assert.fail(e.getMessage());
-        }
-
-        Assert.assertTrue(!checkSize || position >= getSize());
-
-        byte[] buffer = new byte[1024];
-
-        int startPos = memStore.position();
-        try {
-            int len;
-            while ((len = inputStream.read(buffer)) > 0) {
-                memStore.put(buffer, 0, len);
-            }
-            Assert.assertEquals(length, memStore.position() - startPos);
-        } catch (Exception e) {
-            Assert.fail(e.getMessage());
-            return CompletableFuture.completedFuture(false);
-        }
-        return CompletableFuture.completedFuture(true);
-    }
-
-    @Override protected boolean exists() {
-        return false;
-    }
-
-    @Override protected void destroyFile() {
-
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java
deleted file mode 100644
index d0e4932..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/CQItemBufferUtilTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.util;
-
-import java.nio.ByteBuffer;
-import org.apache.rocketmq.store.ConsumeQueue;
-import org.junit.Assert;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-public class CQItemBufferUtilTest {
-    private static ByteBuffer cqItem;
-
-    @BeforeClass
-    public static void setUp() {
-        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
-        cqItem.putLong(1);
-        cqItem.putInt(2);
-        cqItem.putLong(3);
-        cqItem.flip();
-    }
-
-    @Test
-    public void testGetCommitLogOffset() {
-        Assert.assertEquals(1, CQItemBufferUtil.getCommitLogOffset(cqItem));
-    }
-
-    @Test
-    public void testGetSize() {
-        Assert.assertEquals(2, CQItemBufferUtil.getSize(cqItem));
-    }
-
-    @Test
-    public void testGetTagCode() {
-        Assert.assertEquals(3, CQItemBufferUtil.getTagCode(cqItem));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java
deleted file mode 100644
index 739629a..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/MessageBufferUtilTest.java
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.util;
-
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import org.apache.commons.lang3.tuple.Pair;
-import org.apache.rocketmq.common.message.MessageConst;
-import org.apache.rocketmq.common.message.MessageDecoder;
-import org.apache.rocketmq.store.tiered.container.TieredCommitLog;
-import org.apache.rocketmq.store.tiered.container.TieredConsumeQueue;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class MessageBufferUtilTest {
-    public static final int MSG_LEN = 4 //TOTALSIZE
-        + 4 //MAGICCODE
-        + 4 //BODYCRC
-        + 4 //QUEUEID
-        + 4 //FLAG
-        + 8 //QUEUEOFFSET
-        + 8 //PHYSICALOFFSET
-        + 4 //SYSFLAG
-        + 8 //BORNTIMESTAMP
-        + 8 //BORNHOST
-        + 8 //STORETIMESTAMP
-        + 8 //STOREHOSTADDRESS
-        + 4 //RECONSUMETIMES
-        + 8 //Prepared Transaction Offset
-        + 4 + 0 //BODY
-        + 2 + 0 //TOPIC
-        + 2 + 30 //properties
-        + 0;
-
-    public static ByteBuffer buildMessageBuffer() {
-        // Initialization of storage space
-        ByteBuffer buffer = ByteBuffer.allocate(MSG_LEN);
-        // 1 TOTALSIZE
-        buffer.putInt(MSG_LEN);
-        // 2 MAGICCODE
-        buffer.putInt(MessageDecoder.MESSAGE_MAGIC_CODE_V2);
-        // 3 BODYCRC
-        buffer.putInt(3);
-        // 4 QUEUEID
-        buffer.putInt(4);
-        // 5 FLAG
-        buffer.putInt(5);
-        // 6 QUEUEOFFSET
-        buffer.putLong(6);
-        // 7 PHYSICALOFFSET
-        buffer.putLong(7);
-        // 8 SYSFLAG
-        buffer.putInt(8);
-        // 9 BORNTIMESTAMP
-        buffer.putLong(9);
-        // 10 BORNHOST
-        buffer.putLong(10);
-        // 11 STORETIMESTAMP
-        buffer.putLong(11);
-        // 12 STOREHOSTADDRESS
-        buffer.putLong(10);
-        // 13 RECONSUMETIMES
-        buffer.putInt(13);
-        // 14 Prepared Transaction Offset
-        buffer.putLong(14);
-        // 15 BODY
-        buffer.putInt(0);
-        // 16 TOPIC
-        buffer.putShort((short) 0);
-        // 17 PROPERTIES
-        Map<String, String> map = new HashMap<>();
-        map.put(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, "uk");
-        map.put("userkey", "uservalue0");
-        String properties = MessageDecoder.messageProperties2String(map);
-        byte[] propertiesBytes = properties.getBytes(StandardCharsets.UTF_8);
-        buffer.putShort((short) propertiesBytes.length);
-        buffer.put(propertiesBytes);
-        buffer.flip();
-
-        Assert.assertEquals(MSG_LEN, buffer.remaining());
-        return buffer;
-    }
-
-    @Test
-    public void testGetTotalSize() {
-        ByteBuffer buffer = buildMessageBuffer();
-        int totalSize = MessageBufferUtil.getTotalSize(buffer);
-        Assert.assertEquals(MSG_LEN, totalSize);
-    }
-
-    @Test
-    public void testGetMagicCode() {
-        ByteBuffer buffer = buildMessageBuffer();
-        int magicCode = MessageBufferUtil.getMagicCode(buffer);
-        Assert.assertEquals(MessageDecoder.MESSAGE_MAGIC_CODE_V2, magicCode);
-    }
-
-    @Test
-    public void testSplitMessages() {
-        ByteBuffer msgBuffer1 = buildMessageBuffer();
-        msgBuffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 10);
-        ByteBuffer msgBuffer2 = ByteBuffer.allocate(TieredCommitLog.CODA_SIZE);
-
-        msgBuffer2.putInt(TieredCommitLog.CODA_SIZE);
-        msgBuffer2.putInt(TieredCommitLog.BLANK_MAGIC_CODE);
-        msgBuffer2.putLong(System.currentTimeMillis());
-        msgBuffer2.flip();
-
-        ByteBuffer msgBuffer3 = buildMessageBuffer();
-        msgBuffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 11);
-
-        ByteBuffer msgBuffer = ByteBuffer.allocate(msgBuffer1.remaining() + msgBuffer2.remaining() + msgBuffer3.remaining());
-        msgBuffer.put(msgBuffer1);
-        msgBuffer.put(msgBuffer2);
-        msgBuffer.put(msgBuffer3);
-        msgBuffer.flip();
-
-        ByteBuffer cqBuffer1 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer1.putLong(1000);
-        cqBuffer1.putInt(MSG_LEN);
-        cqBuffer1.putLong(0);
-        cqBuffer1.flip();
-
-        ByteBuffer cqBuffer2 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer2.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
-        cqBuffer2.putInt(MSG_LEN);
-        cqBuffer2.putLong(0);
-        cqBuffer2.flip();
-
-        ByteBuffer cqBuffer3 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer3.putLong(1000 + MSG_LEN);
-        cqBuffer3.putInt(MSG_LEN);
-        cqBuffer3.putLong(0);
-        cqBuffer3.flip();
-
-        ByteBuffer cqBuffer4 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer4.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
-        cqBuffer4.putInt(MSG_LEN - 10);
-        cqBuffer4.putLong(0);
-        cqBuffer4.flip();
-
-        ByteBuffer cqBuffer5 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer5.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
-        cqBuffer5.putInt(MSG_LEN * 10);
-        cqBuffer5.putLong(0);
-        cqBuffer5.flip();
-
-        ByteBuffer cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2);
-        cqBuffer.put(cqBuffer1);
-        cqBuffer.put(cqBuffer2);
-        cqBuffer.flip();
-        cqBuffer1.rewind();
-        cqBuffer2.rewind();
-        List<Pair<Integer, Integer>> msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
-        Assert.assertEquals(2, msgList.size());
-        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
-        Assert.assertEquals(Pair.of(MSG_LEN + TieredCommitLog.CODA_SIZE, MSG_LEN), msgList.get(1));
-
-        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2);
-        cqBuffer.put(cqBuffer1);
-        cqBuffer.put(cqBuffer4);
-        cqBuffer.flip();
-        cqBuffer1.rewind();
-        cqBuffer4.rewind();
-        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
-        Assert.assertEquals(1, msgList.size());
-        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
-
-        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3);
-        cqBuffer.put(cqBuffer1);
-        cqBuffer.put(cqBuffer3);
-        cqBuffer.flip();
-        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
-        Assert.assertEquals(2, msgList.size());
-        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
-        Assert.assertEquals(Pair.of(MSG_LEN + TieredCommitLog.CODA_SIZE, MSG_LEN), msgList.get(1));
-
-        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqBuffer.put(cqBuffer5);
-        cqBuffer.flip();
-        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
-        Assert.assertEquals(0, msgList.size());
-    }
-
-    @Test
-    public void testGetQueueOffset() {
-        ByteBuffer buffer = buildMessageBuffer();
-        long queueOffset = MessageBufferUtil.getQueueOffset(buffer);
-        Assert.assertEquals(6, queueOffset);
-    }
-
-    @Test
-    public void testGetStoreTimeStamp() {
-        ByteBuffer buffer = buildMessageBuffer();
-        long storeTimeStamp = MessageBufferUtil.getStoreTimeStamp(buffer);
-        Assert.assertEquals(11, storeTimeStamp);
-    }
-
-    @Test
-    public void testGetOffsetId() {
-        ByteBuffer buffer = buildMessageBuffer();
-        InetSocketAddress inetSocketAddress = new InetSocketAddress("255.255.255.255", 65535);
-        ByteBuffer addr = ByteBuffer.allocate(Long.BYTES);
-        addr.put(inetSocketAddress.getAddress().getAddress(), 0, 4);
-        addr.putInt(inetSocketAddress.getPort());
-        addr.flip();
-        for (int i = 0; i < addr.remaining(); i++) {
-            buffer.put(MessageBufferUtil.STORE_HOST_POSITION + i, addr.get(i));
-        }
-        String excepted = MessageDecoder.createMessageId(ByteBuffer.allocate(TieredStoreUtil.MSG_ID_LENGTH), addr, 7);
-        String offsetId = MessageBufferUtil.getOffsetId(buffer);
-        Assert.assertEquals(excepted, offsetId);
-    }
-
-    @Test
-    public void testGetProperties() {
-        ByteBuffer buffer = buildMessageBuffer();
-        Map<String, String> properties = MessageBufferUtil.getProperties(buffer);
-        Assert.assertEquals(2, properties.size());
-        Assert.assertTrue(properties.containsKey(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
-        Assert.assertEquals("uk", properties.get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
-        Assert.assertTrue(properties.containsKey("userkey"));
-        Assert.assertEquals("uservalue0", properties.get("userkey"));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java
deleted file mode 100644
index 1bb462d..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/store/tiered/util/TieredStoreUtilTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.store.tiered.util;
-
-import java.util.HashMap;
-import java.util.Map;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class TieredStoreUtilTest {
-
-    private static final Map<Long, String> DATA_MAP = new HashMap<Long, String>() {
-        {
-            put(0L, "0Bytes");
-            put(1023L, "1023Bytes");
-            put(1024L, "1KB");
-            put(12_345L, "12.06KB");
-            put(10_123_456L, "9.65MB");
-            put(10_123_456_798L, "9.43GB");
-            put(1_777_777_777_777_777_777L, "1.54EB");
-        }
-    };
-
-    @Test
-    public void getHash() {
-        Assert.assertEquals("161c08ff", TieredStoreUtil.getHash("TieredStorageDailyTest"));
-    }
-
-    @Test
-    public void testOffset2FileName() {
-        Assert.assertEquals("cfcd208400000000000000000000", TieredStoreUtil.offset2FileName(0));
-        Assert.assertEquals("b10da56800000000004294937144", TieredStoreUtil.offset2FileName(4294937144L));
-    }
-
-    @Test
-    public void testFileName2Offset() {
-        Assert.assertEquals(0, TieredStoreUtil.fileName2Offset("cfcd208400000000000000000000"));
-        Assert.assertEquals(4294937144L, TieredStoreUtil.fileName2Offset("b10da56800000000004294937144"));
-    }
-
-    @Test
-    public void testToHumanReadable() {
-        DATA_MAP.forEach((in, expected) -> Assert.assertEquals(expected, TieredStoreUtil.toHumanReadable(in)));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
new file mode 100644
index 0000000..33e9088
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.ConsumeQueue;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+public class TieredDispatcherTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        MemoryFileSegment.checkSize = false;
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    @Test
+    public void testDispatch() {
+        metadataStore.addQueue(mq, 6);
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 6 * TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, storeConfig);
+        metadataStore.updateFileSegment(segment);
+
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultMessageStore = Mockito.mock(DefaultMessageStore.class);
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultMessageStore, storeConfig);
+
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultMessageStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 6, 7, MessageBufferUtilTest.MSG_LEN, 1);
+        dispatcher.dispatch(request);
+        Assert.assertNotNull(containerManager.getMQContainer(mq));
+        Assert.assertEquals(7, containerManager.getMQContainer(mq).getDispatchOffset());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.commit(true);
+        Assert.assertEquals(6, container.getBuildCQMaxOffset());
+
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+
+        ByteBuffer buffer1 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        container.appendCommitLog(buffer1);
+        ByteBuffer buffer2 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 8);
+        container.appendCommitLog(buffer2);
+        ByteBuffer buffer3 = MessageBufferUtilTest.buildMessageBuffer();
+        buffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 9);
+        container.appendCommitLog(buffer3);
+        container.commitCommitLog();
+        Assert.assertEquals(10, container.getDispatchOffset());
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer2);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+        Assert.assertEquals(7, container.getDispatchOffset());
+
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 7, 7, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer2);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer3);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(10, container.getConsumeQueueMaxOffset());
+    }
+
+    @Test
+    public void testDispatchByMQContainer() {
+        metadataStore.addQueue(mq, 6);
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);
+        Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);
+
+        Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);
+        Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);
+
+        ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(7);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);
+
+        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(8);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);
+
+        mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        ByteBuffer msg = MessageBufferUtilTest.buildMessageBuffer();
+        msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        dispatcher.dispatchByMQContainer(containerManager.getOrCreateMQContainer(mq));
+        Assert.assertEquals(8, containerManager.getMQContainer(mq).getDispatchOffset());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
new file mode 100644
index 0000000..1134729
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.tuple.Triple;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.QueryMessageResult;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.common.SelectMappedBufferResultWrapper;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredMessageFetcherTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        MemoryFileSegment.checkSize = false;
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setReadAheadCacheExpireDuration(Long.MAX_VALUE);
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
+        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+        mq = new MessageQueue("TieredMessageFetcherTest", storeConfig.getBrokerName(), 0);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    public Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> buildFetcher() {
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE, getMessageResult.getStatus());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MESSAGE_IN_QUEUE, getMessageResult.getStatus());
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        return Triple.of(fetcher, msg1, msg2);
+    }
+
+    @Test
+    public void testGetMessageFromTieredStoreAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+
+        AppendResult result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 2, storeConfig.getReadAheadMessageSizeThreshold(), MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        container.commit(true);
+        getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+    }
+
+    @Test
+    public void testGetMessageFromCacheAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, new ArrayList<>());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+        fetcher.putMessageToCache(container, 0, new SelectMappedBufferResult(0, msg1, msg1.remaining(), null), 0, 0, 1);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromCacheAsync(container, "group", 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(1, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+
+        Awaitility.waitAtMost(3, TimeUnit.SECONDS)
+            .until(() -> fetcher.readAheadCache.estimatedSize() == 2);
+        ArrayList<SelectMappedBufferResultWrapper> wrapperList = new ArrayList<>();
+        wrapperList.add(fetcher.getMessageFromCache(container, 0));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+        wrapperList.clear();
+        wrapperList.add(fetcher.getMessageFromCache(container, 1));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        SelectMappedBufferResult messageFromCache = fetcher.getMessageFromCache(container, 1).getDuplicateResult();
+        fetcher.recordCacheAccess(container, "group", 0, wrapperList);
+        Assert.assertNotNull(messageFromCache);
+        Assert.assertEquals(msg2, messageFromCache.getByteBuffer());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+    }
+
+    @Test
+    public void testGetMessageAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), -1, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_TOO_SMALL, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 2, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_ONE, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 3, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_BADLY, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+    }
+
+    @Test
+    public void testGetMessageStoreTimeStampAsync() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        long currentTimeMillis1 = System.currentTimeMillis();
+        msg1.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis1);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        long currentTimeMillis2 = System.currentTimeMillis();
+        msg2.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis2);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+
+        long result1 = fetcher.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join();
+        long result2 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join();
+        Assert.assertEquals(result1, result2);
+        Assert.assertEquals(currentTimeMillis1, result1);
+
+        long result3 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 1).join();
+        Assert.assertEquals(currentTimeMillis2, result3);
+    }
+
+    @Test
+    public void testGetOffsetInQueueByTime() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 50, 0, MessageBufferUtilTest.MSG_LEN, 0), true);
+        container.commit(true);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+
+        long timestamp = System.currentTimeMillis();
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp);
+        container.initOffset(50);
+        container.appendCommitLog(buffer, true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp, 50, "", "", 0, 0, null), true);
+        container.commit(true);
+        Assert.assertEquals(50, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+    }
+
+    @Test
+    public void testQueryMessageAsync() {
+        // skip this test on windows
+        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
+
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        container.initOffset(0);
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 2);
+        container.appendCommitLog(buffer);
+
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "another-key", 0, 0, null);
+        container.appendIndexFile(request);
+        container.commit(true);
+        Assert.assertEquals(1, fetcher.queryMessageAsync(mq.getTopic(), "key", 1, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        QueryMessageResult result = fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join();
+        Assert.assertEquals(2, result.getMessageMapedList().size());
+        Assert.assertEquals(1, result.getMessageMapedList().get(0).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+        Assert.assertEquals(0, result.getMessageMapedList().get(1).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
new file mode 100644
index 0000000..800b109
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.HashSet;
+import java.util.Properties;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.BrokerConfig;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.logging.org.slf4j.LoggerFactory;
+import org.apache.rocketmq.remoting.Configuration;
+import org.apache.rocketmq.store.CommitLog;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.MessageStore;
+import org.apache.rocketmq.store.QueryMessageResult;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.store.config.MessageStoreConfig;
+import org.apache.rocketmq.store.plugin.MessageStorePluginContext;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class TieredMessageStoreTest {
+    private MessageStoreConfig storeConfig;
+    private MessageQueue mq;
+    private MessageStore nextStore;
+    private TieredMessageStore store;
+    private TieredMessageFetcher fetcher;
+    private Configuration configuration;
+    private TieredContainerManager containerManager;
+
+    @Before
+    public void setUp() {
+        storeConfig = new MessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        mq = new MessageQueue("TieredMessageStoreTest", "broker", 0);
+
+        nextStore = Mockito.mock(DefaultMessageStore.class);
+        CommitLog commitLog = mock(CommitLog.class);
+        when(commitLog.getMinOffset()).thenReturn(100L);
+        when(nextStore.getCommitLog()).thenReturn(commitLog);
+
+        BrokerConfig brokerConfig = new BrokerConfig();
+        brokerConfig.setBrokerName("broker");
+        configuration = new Configuration(LoggerFactory.getLogger(TieredStoreUtil.TIERED_STORE_LOGGER_NAME), "/tmp/rmqut/config", storeConfig, brokerConfig);
+        Properties properties = new Properties();
+        properties.setProperty("tieredBackendServiceProvider", "org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        configuration.registerConfig(properties);
+        MessageStorePluginContext context = new MessageStorePluginContext(new MessageStoreConfig(), null, null, brokerConfig, configuration);
+
+        store = new TieredMessageStore(context, nextStore);
+
+        fetcher = Mockito.mock(TieredMessageFetcher.class);
+        try {
+            Field field = store.getClass().getDeclaredField("fetcher");
+            field.setAccessible(true);
+            field.set(store, fetcher);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+
+        TieredContainerManager.getInstance(store.getStoreConfig()).getOrCreateMQContainer(mq);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(store.getStoreConfig()).destroy();
+        TieredContainerManager.getInstance(store.getStoreConfig()).cleanup();
+    }
+
+    private void mockContainer() {
+        containerManager = Mockito.mock(TieredContainerManager.class);
+        TieredMessageQueueContainer container = Mockito.mock(TieredMessageQueueContainer.class);
+        when(container.getConsumeQueueCommitOffset()).thenReturn(Long.MAX_VALUE);
+        when(containerManager.getMQContainer(mq)).thenReturn(container);
+        try {
+            Field field = store.getClass().getDeclaredField("containerManager");
+            field.setAccessible(true);
+            field.set(store, containerManager);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+    }
+
+    @Test
+    public void testViaTieredStorage() {
+        mockContainer();
+        Properties properties = new Properties();
+        // TieredStorageLevel.DISABLE
+        properties.setProperty("tieredStorageLevel", "0");
+        configuration.update(properties);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.NOT_IN_DISK
+        properties.setProperty("tieredStorageLevel", "1");
+        configuration.update(properties);
+        when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(false);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.NOT_IN_MEM
+        properties.setProperty("tieredStorageLevel", "2");
+        configuration.update(properties);
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(false);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(true);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(false);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        Mockito.when(nextStore.checkInStoreByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Mockito.when(nextStore.checkInMemByConsumeOffset(anyString(), anyInt(), anyLong(), anyInt())).thenReturn(true);
+        Assert.assertFalse(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+
+        // TieredStorageLevel.FORCE
+        properties.setProperty("tieredStorageLevel", "3");
+        configuration.update(properties);
+        Assert.assertTrue(store.viaTieredStorage(mq.getTopic(), mq.getQueueId(), 0));
+    }
+
+    @Test
+    public void testGetMessageAsync() {
+        mockContainer();
+        GetMessageResult result1 = new GetMessageResult();
+        result1.setStatus(GetMessageStatus.FOUND);
+        GetMessageResult result2 = new GetMessageResult();
+        result2.setStatus(GetMessageStatus.MESSAGE_WAS_REMOVING);
+
+        when(fetcher.getMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(CompletableFuture.completedFuture(result1));
+        when(nextStore.getMessage(anyString(), anyString(), anyInt(), anyLong(), anyInt(), any())).thenReturn(result2);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        result1.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY);
+        Assert.assertSame(result1, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+
+        // TieredStorageLevel.FORCE
+        Properties properties = new Properties();
+        properties.setProperty("tieredStorageLevel", "3");
+        configuration.update(properties);
+        when(nextStore.checkInDiskByConsumeOffset(anyString(), anyInt(), anyLong())).thenReturn(true);
+        Assert.assertSame(result2, store.getMessage("group", mq.getTopic(), mq.getQueueId(), 0, 0, null));
+    }
+
+    @Test
+    public void testGetEarliestMessageTimeAsync() {
+        when(fetcher.getEarliestMessageTimeAsync(anyString(), anyInt())).thenReturn(CompletableFuture.completedFuture(1L));
+        Assert.assertEquals(1, (long) store.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join());
+
+        when(fetcher.getEarliestMessageTimeAsync(anyString(), anyInt())).thenReturn(CompletableFuture.completedFuture(-1L));
+        when(nextStore.getEarliestMessageTime(anyString(), anyInt())).thenReturn(2L);
+        Assert.assertEquals(2, (long) store.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join());
+    }
+
+    @Test
+    public void testGetMessageStoreTimeStampAsync() {
+        mockContainer();
+        // TieredStorageLevel.DISABLE
+        Properties properties = new Properties();
+        properties.setProperty("tieredStorageLevel", "DISABLE");
+        configuration.update(properties);
+        when(fetcher.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(1L));
+        when(nextStore.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(2L));
+        when(nextStore.getMessageStoreTimeStamp(anyString(), anyInt(), anyLong())).thenReturn(3L);
+        Assert.assertEquals(2, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+
+        // TieredStorageLevel.FORCE
+        properties.setProperty("tieredStorageLevel", "FORCE");
+        configuration.update(properties);
+        Assert.assertEquals(1, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+
+        Mockito.when(fetcher.getMessageStoreTimeStampAsync(anyString(), anyInt(), anyLong())).thenReturn(CompletableFuture.completedFuture(-1L));
+        Assert.assertEquals(3, (long) store.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join());
+    }
+
+    @Test
+    public void testGetOffsetInQueueByTime() {
+        Mockito.when(fetcher.getOffsetInQueueByTime(anyString(), anyInt(), anyLong(), eq(BoundaryType.LOWER))).thenReturn(1L);
+        Mockito.when(nextStore.getOffsetInQueueByTime(anyString(), anyInt(), anyLong())).thenReturn(2L);
+        Mockito.when(nextStore.getEarliestMessageTime()).thenReturn(100L);
+        Assert.assertEquals(1, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+        Assert.assertEquals(2, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 1000, BoundaryType.LOWER));
+
+        Mockito.when(fetcher.getOffsetInQueueByTime(anyString(), anyInt(), anyLong(), eq(BoundaryType.LOWER))).thenReturn(-1L);
+        Assert.assertEquals(2, store.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+    }
+
+    @Test
+    public void testQueryMessage() {
+        QueryMessageResult result1 = new QueryMessageResult();
+        result1.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        result1.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        when(fetcher.queryMessageAsync(anyString(), anyString(), anyInt(), anyLong(), anyLong())).thenReturn(CompletableFuture.completedFuture(result1));
+        QueryMessageResult result2 = new QueryMessageResult();
+        result2.addMessage(new SelectMappedBufferResult(0, null, 0, null));
+        when(nextStore.queryMessage(anyString(), anyString(), anyInt(), anyLong(), anyLong())).thenReturn(result2);
+        when(nextStore.getEarliestMessageTime()).thenReturn(100L);
+        Assert.assertEquals(2, store.queryMessage(mq.getTopic(), "key", 32, 0, 99).getMessageMapedList().size());
+        Assert.assertEquals(1, store.queryMessage(mq.getTopic(), "key", 32, 100, 200).getMessageMapedList().size());
+        Assert.assertEquals(3, store.queryMessage(mq.getTopic(), "key", 32, 0, 200).getMessageMapedList().size());
+    }
+
+    @Test
+    public void testGetMinOffsetInQueue() {
+        mockContainer();
+        TieredMessageQueueContainer container = containerManager.getMQContainer(mq);
+        when(nextStore.getMinOffsetInQueue(anyString(), anyInt())).thenReturn(100L);
+        when(containerManager.getMQContainer(mq)).thenReturn(null);
+        Assert.assertEquals(100L, store.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId()));
+
+        when(containerManager.getMQContainer(mq)).thenReturn(container);
+        when(container.getConsumeQueueMinOffset()).thenReturn(10L);
+        Assert.assertEquals(10L, store.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId()));
+    }
+
+    @Test
+    public void testCleanUnusedTopics() {
+        Set<String> topicSet = new HashSet<>();
+        store.cleanUnusedTopic(topicSet);
+        Assert.assertNull(TieredContainerManager.getInstance(store.getStoreConfig()).getMQContainer(mq));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getTopic(mq.getTopic()));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getQueue(mq));
+    }
+
+    @Test
+    public void testDeleteTopics() {
+        Set<String> topicSet = new HashSet<>();
+        topicSet.add(mq.getTopic());
+        store.deleteTopics(topicSet);
+        Assert.assertNull(TieredContainerManager.getInstance(store.getStoreConfig()).getMQContainer(mq));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getTopic(mq.getTopic()));
+        Assert.assertNull(TieredStoreUtil.getMetadataStore(store.getStoreConfig()).getQueue(mq));
+    }
+
+    @Test
+    public void testMetrics() {
+        store.getMetricsView();
+        store.initMetrics(OpenTelemetrySdk.builder().build().getMeter(""),
+            Attributes::builder);
+    }
+
+    @Test
+    public void testShutdownAndDestroy() {
+        store.destroy();
+//        store.shutdown();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java
new file mode 100644
index 0000000..5210a0f
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/common/CommonTest.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.common;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class CommonTest {
+    @Test
+    public void testInflightRequestFuture() {
+        List<Pair<Integer, CompletableFuture<Long>>> futureList = new ArrayList<>();
+        futureList.add(Pair.of(32, CompletableFuture.completedFuture(1031L)));
+        futureList.add(Pair.of(256, CompletableFuture.completedFuture(1287L)));
+        InflightRequestFuture future = new InflightRequestFuture(1000, futureList);
+
+        Assert.assertEquals(1000, future.getStartOffset());
+        Assert.assertTrue(future.isFirstDone());
+        Assert.assertTrue(future.isAllDone());
+        Assert.assertEquals(1031, future.getFirstFuture().join().longValue());
+        Assert.assertEquals(-1L, future.getFuture(0).join().longValue());
+        Assert.assertEquals(1031L, future.getFuture(1024).join().longValue());
+        Assert.assertEquals(1287L, future.getFuture(1200).join().longValue());
+        Assert.assertEquals(-1L, future.getFuture(2000).join().longValue());
+        Assert.assertEquals(1287L, future.getLastFuture().join().longValue());
+        Assert.assertArrayEquals(futureList.stream().map(Pair::getRight).toArray(), future.getAllFuture().toArray());
+    }
+
+    @Test
+    public void testInflightRequestKey() {
+        InflightRequestKey requestKey1 = new InflightRequestKey("group", 0, 0);
+        InflightRequestKey requestKey2 = new InflightRequestKey("group", 1, 1);
+        Assert.assertEquals(requestKey1, requestKey2);
+        Assert.assertEquals(requestKey1.hashCode(), requestKey2.hashCode());
+        Assert.assertEquals(requestKey1.getGroup(), requestKey2.getGroup());
+        Assert.assertNotEquals(requestKey1.getOffset(), requestKey2.getOffset());
+        Assert.assertNotEquals(requestKey1.getBatchSize(), requestKey2.getBatchSize());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
new file mode 100644
index 0000000..1c8254d
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredContainerManagerTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        mq = new MessageQueue("TieredContainerManagerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+
+    @Test
+    public void testLoadAndDestroy() {
+        metadataStore.addTopic(mq.getTopic(), 0);
+        metadataStore.addQueue(mq, 100);
+        MessageQueue mq1 = new MessageQueue(mq.getTopic(), mq.getBrokerName(), 1);
+        metadataStore.addQueue(mq1, 200);
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        boolean load = containerManager.load();
+        Assert.assertTrue(load);
+
+        Awaitility.await().atMost(3, TimeUnit.SECONDS).until(() -> containerManager.getAllMQContainer().size() == 2);
+
+        TieredMessageQueueContainer container = containerManager.getMQContainer(mq);
+        Assert.assertNotNull(container);
+        Assert.assertEquals(100, container.getDispatchOffset());
+
+        TieredMessageQueueContainer container1 = containerManager.getMQContainer(mq1);
+        Assert.assertNotNull(container1);
+        Assert.assertEquals(200, container1.getDispatchOffset());
+
+        containerManager.destroyContainer(mq);
+        Assert.assertTrue(container.isClosed());
+        Assert.assertNull(containerManager.getMQContainer(mq));
+        Assert.assertNull(metadataStore.getQueue(mq));
+
+        containerManager.destroy();
+        Assert.assertTrue(container1.isClosed());
+        Assert.assertNull(containerManager.getMQContainer(mq1));
+        Assert.assertNull(metadataStore.getQueue(mq1));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
new file mode 100644
index 0000000..6385fa2
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
@@ -0,0 +1,235 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredFileQueueTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue queue;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        queue = new MessageQueue("TieredFileQueueTest", storeConfig.getBrokerName(), 0);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+    }
+
+    @Test
+    public void testGetFileSegment() throws ClassNotFoundException, NoSuchMethodException {
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            queue, storeConfig);
+        fileQueue.setBaseOffset(0);
+        TieredFileSegment segment1 = fileQueue.getFileToWrite();
+        segment1.initPosition(1000);
+        segment1.append(ByteBuffer.allocate(100), 0);
+        segment1.setFull();
+        segment1.commit();
+
+        TieredFileSegment segment2 = fileQueue.getFileToWrite();
+        Assert.assertNotSame(segment1, segment2);
+        Assert.assertEquals(1000 + 100 + TieredCommitLog.CODA_SIZE, segment1.getMaxOffset());
+        Assert.assertEquals(1000 + 100 + TieredCommitLog.CODA_SIZE, segment2.getBaseOffset());
+
+        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1000), 0);
+        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1050), 0);
+        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1100 + TieredCommitLog.CODA_SIZE), 1);
+        Assert.assertSame(fileQueue.getSegmentIndexByOffset(1150), -1);
+    }
+
+    @Test
+    public void testAppendAndRead() throws ClassNotFoundException, NoSuchMethodException {
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, storeConfig);
+        fileQueue.setBaseOffset(0);
+        Assert.assertEquals(0, fileQueue.getMinOffset());
+        Assert.assertEquals(0, fileQueue.getCommitMsgQueueOffset());
+
+        TieredFileSegment segment1 = fileQueue.getFileToWrite();
+        segment1.initPosition(segment1.getSize());
+        Assert.assertEquals(0, segment1.getBaseOffset());
+        Assert.assertEquals(1000, fileQueue.getCommitOffset());
+        Assert.assertEquals(1000, fileQueue.getMaxOffset());
+
+        ByteBuffer buffer = ByteBuffer.allocate(100);
+        long currentTimeMillis = System.currentTimeMillis();
+        buffer.putLong(currentTimeMillis);
+        buffer.rewind();
+        fileQueue.append(buffer);
+        Assert.assertEquals(1100, segment1.getMaxOffset());
+
+        segment1.setFull();
+        fileQueue.commit(true);
+        Assert.assertEquals(1100, segment1.getCommitOffset());
+
+        ByteBuffer readBuffer = fileQueue.readAsync(1000, 8).join();
+        Assert.assertEquals(currentTimeMillis, readBuffer.getLong());
+
+        TieredFileSegment segment2 = fileQueue.getFileToWrite();
+        Assert.assertNotEquals(segment1, segment2);
+        segment2.initPosition(segment2.getSize());
+        buffer.rewind();
+        fileQueue.append(buffer);
+        fileQueue.commit(true);
+        readBuffer = fileQueue.readAsync(1000, 1200).join();
+        Assert.assertEquals(currentTimeMillis, readBuffer.getLong(1100));
+    }
+
+    @Test
+    public void testLoadFromMetadata() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+
+        MemoryFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            queue, 100, storeConfig);
+        fileSegment1.initPosition(fileSegment1.getSize());
+        fileSegment1.setFull();
+        metadataStore.updateFileSegment(fileSegment1);
+        metadataStore.updateFileSegment(fileSegment1);
+
+        MemoryFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            queue, 1100, storeConfig);
+        metadataStore.updateFileSegment(fileSegment2);
+
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            queue, storeConfig);
+        Assert.assertEquals(2, fileQueue.needCommitFileSegmentList.size());
+        TieredFileSegment file1 = fileQueue.getFileByIndex(0);
+        Assert.assertNotNull(file1);
+        Assert.assertEquals(100, file1.getBaseOffset());
+        Assert.assertFalse(file1.isFull());
+
+        TieredFileSegment file2 = fileQueue.getFileByIndex(1);
+        Assert.assertNotNull(file2);
+        Assert.assertEquals(1100, file2.getBaseOffset());
+        Assert.assertFalse(file2.isFull());
+
+        TieredFileSegment file3 = fileQueue.getFileByIndex(2);
+        Assert.assertNull(file3);
+    }
+
+    @Test
+    public void testCheckFileSize() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+
+        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, 100, storeConfig);
+        fileSegment1.initPosition(fileSegment1.getSize() - 100);
+        fileSegment1.setFull(false);
+        metadataStore.updateFileSegment(fileSegment1);
+        metadataStore.updateFileSegment(fileSegment1);
+
+        TieredFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, 1100, storeConfig);
+        fileSegment2.initPosition(fileSegment2.getSize() - 100);
+        metadataStore.updateFileSegment(fileSegment2);
+        metadataStore.updateFileSegment(fileSegment2);
+
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, storeConfig);
+        Assert.assertEquals(1, fileQueue.needCommitFileSegmentList.size());
+
+        fileSegment1 = fileQueue.getFileByIndex(0);
+        Assert.assertTrue(fileSegment1.isFull());
+        Assert.assertEquals(fileSegment1.getSize() + 100, fileSegment1.getCommitOffset());
+
+        fileSegment2 = fileQueue.getFileByIndex(1);
+        Assert.assertEquals(1000, fileSegment2.getCommitPosition());
+
+        fileSegment2.setFull();
+        fileQueue.commit(true);
+        Assert.assertEquals(0, fileQueue.needCommitFileSegmentList.size());
+
+        fileQueue.getFileToWrite();
+        Assert.assertEquals(1, fileQueue.needCommitFileSegmentList.size());
+    }
+
+    @Test
+    public void testCleanExpiredFile() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+
+        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, 100, storeConfig);
+        fileSegment1.initPosition(fileSegment1.getSize() - 100);
+        fileSegment1.setFull(false);
+        fileSegment1.setEndTimestamp(System.currentTimeMillis() - 1);
+        metadataStore.updateFileSegment(fileSegment1);
+        metadataStore.updateFileSegment(fileSegment1);
+
+        long file1CreateTimeStamp = System.currentTimeMillis();
+
+        TieredFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, 1100, storeConfig);
+        fileSegment2.initPosition(fileSegment2.getSize());
+        fileSegment2.setEndTimestamp(System.currentTimeMillis() + 1);
+        metadataStore.updateFileSegment(fileSegment2);
+        metadataStore.updateFileSegment(fileSegment2);
+
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, storeConfig);
+        Assert.assertEquals(2, fileQueue.getFileSegmentCount());
+
+        fileQueue.cleanExpiredFile(file1CreateTimeStamp);
+        fileQueue.destroyExpiredFile();
+        Assert.assertEquals(1, fileQueue.getFileSegmentCount());
+        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
+        Assert.assertNotNull(metadataStore.getFileSegment(fileSegment2));
+
+        fileQueue.cleanExpiredFile(Long.MAX_VALUE);
+        fileQueue.destroyExpiredFile();
+        Assert.assertEquals(0, fileQueue.getFileSegmentCount());
+        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
+        Assert.assertNull(metadataStore.getFileSegment(fileSegment2));
+    }
+
+    @Test
+    public void testRollingNewFile() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMetadataStore metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+
+        TieredFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, 100, storeConfig);
+        fileSegment1.initPosition(fileSegment1.getSize() - 100);
+        metadataStore.updateFileSegment(fileSegment1);
+
+        TieredFileQueue fileQueue = new TieredFileQueue(TieredFileSegment.FileSegmentType.CONSUME_QUEUE,
+            queue, storeConfig);
+        Assert.assertEquals(1, fileQueue.getFileSegmentCount());
+
+        fileQueue.rollingNewFile();
+        Assert.assertEquals(2, fileQueue.getFileSegmentCount());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
new file mode 100644
index 0000000..c30ee2a
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredIndexFileTest {
+    MessageQueue mq;
+    TieredMessageStoreConfig storeConfig;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        MemoryFileSegment.checkSize = false;
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
+        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
+        mq = new MessageQueue("TieredIndexFileTest", storeConfig.getBrokerName(), 1);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+//        metadataStore.reLoadStore();
+    }
+
+    @Test
+    public void testAppendAndQuery() throws IOException, ClassNotFoundException, NoSuchMethodException {
+        // skip this test on windows
+        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
+
+        TieredIndexFile indexFile = new TieredIndexFile(storeConfig);
+        indexFile.append(mq, 0, "key3", 3, 300, 1000);
+        indexFile.append(mq, 0, "key2", 2, 200, 1100);
+        indexFile.append(mq, 0, "key1", 1, 100, 1200);
+
+        Awaitility.waitAtMost(5, TimeUnit.SECONDS)
+            .until(() -> {
+                List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key1", 1000, 1200).join();
+                if (indexList.size() != 1) {
+                    return false;
+                }
+
+                ByteBuffer indexBuffer = indexList.get(0).getValue();
+                Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 2, indexBuffer.remaining());
+
+                Assert.assertEquals(1, indexBuffer.getLong(4 + 4 + 4));
+                Assert.assertEquals(100, indexBuffer.getInt(4 + 4 + 4 + 8));
+                Assert.assertEquals(200, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
+
+                Assert.assertEquals(3, indexBuffer.getLong(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4));
+                Assert.assertEquals(300, indexBuffer.getInt(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4 + 8));
+                Assert.assertEquals(0, indexBuffer.getInt(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE + 4 + 4 + 4 + 8 + 4));
+                return true;
+            });
+
+        indexFile.append(mq, 0, "key4", 4, 400, 1300);
+        indexFile.append(mq, 0, "key4", 4, 400, 1300);
+        indexFile.append(mq, 0, "key4", 4, 400, 1300);
+
+        Awaitility.waitAtMost(5, TimeUnit.SECONDS)
+            .until(() -> {
+                List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key4", 1300, 1300).join();
+                if (indexList.size() != 1) {
+                    return false;
+                }
+
+                ByteBuffer indexBuffer = indexList.get(0).getValue();
+                Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 3, indexBuffer.remaining());
+                Assert.assertEquals(4, indexBuffer.getLong(4 + 4 + 4));
+                Assert.assertEquals(400, indexBuffer.getInt(4 + 4 + 4 + 8));
+                Assert.assertEquals(0, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
+                return true;
+            });
+
+        List<Pair<Long, ByteBuffer>> indexList = indexFile.queryAsync(mq.getTopic(), "key1", 1300, 1300).join();
+        Assert.assertEquals(0, indexList.size());
+
+        indexList = indexFile.queryAsync(mq.getTopic(), "key4", 1200, 1300).join();
+        Assert.assertEquals(2, indexList.size());
+
+        ByteBuffer indexBuffer = indexList.get(0).getValue();
+        Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE * 3, indexBuffer.remaining());
+        Assert.assertEquals(4, indexBuffer.getLong(4 + 4 + 4));
+        Assert.assertEquals(400, indexBuffer.getInt(4 + 4 + 4 + 8));
+        Assert.assertEquals(0, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
+
+        indexBuffer = indexList.get(1).getValue();
+        Assert.assertEquals(TieredIndexFile.INDEX_FILE_HASH_COMPACT_INDEX_SIZE, indexBuffer.remaining());
+        Assert.assertEquals(2, indexBuffer.getLong(4 + 4 + 4));
+        Assert.assertEquals(200, indexBuffer.getInt(4 + 4 + 4 + 8));
+        Assert.assertEquals(100, indexBuffer.getInt(4 + 4 + 4 + 8 + 4));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
new file mode 100644
index 0000000..a9eb444
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
@@ -0,0 +1,195 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.container;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.metadata.QueueMetadata;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TieredMessageQueueContainerTest {
+    TieredMessageStoreConfig storeConfig;
+    MessageQueue mq;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setCommitLogRollingInterval(0);
+        storeConfig.setCommitLogRollingMinimumSize(999);
+        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        MemoryFileSegment.checkSize = true;
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+        TieredContainerManager.getInstance(storeConfig).cleanup();
+    }
+
+    @Test
+    public void testAppendCommitLog() throws ClassNotFoundException, NoSuchMethodException, IOException {
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        ByteBuffer message = MessageBufferUtilTest.buildMessageBuffer();
+        AppendResult result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);
+
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        container = new TieredMessageQueueContainer(mq, storeConfig);
+        container.initOffset(6);
+        result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        message.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        result = container.appendCommitLog(message);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        Assert.assertEquals(7, container.getBuildCQMaxOffset());
+
+        container.cleanExpiredFile(0);
+        container.destroyExpiredFile();
+        try {
+            Field field = container.getClass().getDeclaredField("commitLog");
+            field.setAccessible(true);
+            TieredCommitLog commitLog = (TieredCommitLog) field.get(container);
+            Field field2 = commitLog.getClass().getDeclaredField("fileQueue");
+            field2.setAccessible(true);
+            TieredFileQueue fileQueue = (TieredFileQueue) field2.get(commitLog);
+            Assert.assertEquals(2, fileQueue.getFileSegmentCount());
+
+            TieredFileSegment file1 = fileQueue.getFileByIndex(0);
+            TieredFileSegment file2 = fileQueue.getFileByIndex(1);
+
+            container.destroy();
+            Assert.assertEquals(0, fileQueue.getFileSegmentCount());
+            Assert.assertTrue(file1.isClosed());
+            Assert.assertTrue(file2.isClosed());
+        } catch (Exception e) {
+            Assert.fail(e.getClass().getCanonicalName() + ": " + e.getMessage());
+        }
+    }
+
+    @Test
+    public void testAppendConsumeQueue() throws ClassNotFoundException, NoSuchMethodException {
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 51, 2, 3, 4);
+        AppendResult result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.OFFSET_INCORRECT, result);
+
+        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 20, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        container = new TieredMessageQueueContainer(mq, storeConfig);
+        result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 52, 2, 3, 4);
+        result = container.appendConsumeQueue(request);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        container.flushMetadata();
+        QueueMetadata queueMetadata = metadataStore.getQueue(mq);
+        Assert.assertEquals(53, queueMetadata.getMaxOffset());
+    }
+
+    @Test
+    public void testBinarySearchInQueueByTime() throws ClassNotFoundException, NoSuchMethodException {
+        MemoryFileSegment.checkSize = false;
+
+        TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
+        container.initOffset(50);
+        long timestamp1 = System.currentTimeMillis();
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp1);
+        container.appendCommitLog(buffer, true);
+
+        long timestamp2 = timestamp1 + 100;
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 51);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 52);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 53);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp2);
+        container.appendCommitLog(buffer, true);
+
+        long timestamp3 = timestamp2 + 100;
+        buffer = MessageBufferUtilTest.buildMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 54);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp3);
+        container.appendCommitLog(buffer, true);
+
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp1, 50, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 51, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 52, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 3, MessageBufferUtilTest.MSG_LEN, 0, timestamp2, 53, "", "", 0, 0, null), true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 4, MessageBufferUtilTest.MSG_LEN, 0, timestamp3, 54, "", "", 0, 0, null), true);
+        container.commit(true);
+
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3 + 1, BoundaryType.UPPER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3, BoundaryType.UPPER));
+
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1 - 1, BoundaryType.LOWER));
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1, BoundaryType.LOWER));
+
+        Assert.assertEquals(51, container.binarySearchInQueueByTime(timestamp1 + 1, BoundaryType.LOWER));
+        Assert.assertEquals(51, container.binarySearchInQueueByTime(timestamp2, BoundaryType.LOWER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp2 + 1, BoundaryType.LOWER));
+        Assert.assertEquals(54, container.binarySearchInQueueByTime(timestamp3, BoundaryType.LOWER));
+
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1, BoundaryType.UPPER));
+        Assert.assertEquals(50, container.binarySearchInQueueByTime(timestamp1 + 1, BoundaryType.UPPER));
+        Assert.assertEquals(53, container.binarySearchInQueueByTime(timestamp2, BoundaryType.UPPER));
+        Assert.assertEquals(53, container.binarySearchInQueueByTime(timestamp2 + 1, BoundaryType.UPPER));
+
+        Assert.assertEquals(0, container.binarySearchInQueueByTime(timestamp1 - 1, BoundaryType.UPPER));
+        Assert.assertEquals(55, container.binarySearchInQueueByTime(timestamp3 + 1, BoundaryType.LOWER));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
new file mode 100644
index 0000000..45a3a6b
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
@@ -0,0 +1,188 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.metadata;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class MetadataStoreTest {
+    MessageQueue mq;
+    TieredMessageStoreConfig storeConfig;
+    TieredMetadataStore metadataStore;
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID());
+        mq = new MessageQueue("MetadataStoreTest", storeConfig.getBrokerName(), 1);
+        metadataStore = new TieredMetadataManager(storeConfig);
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        FileUtils.deleteDirectory(new File(FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID()));
+        TieredStoreUtil.getMetadataStore(storeConfig).destroy();
+    }
+
+    @Test
+    public void testQueue() {
+        QueueMetadata queueMetadata = metadataStore.getQueue(mq);
+        Assert.assertNull(queueMetadata);
+
+        queueMetadata = metadataStore.addQueue(mq, -1);
+        Assert.assertEquals(queueMetadata.getMinOffset(), -1);
+        Assert.assertEquals(queueMetadata.getMaxOffset(), -1);
+
+        long currentTimeMillis = System.currentTimeMillis();
+        queueMetadata.setMinOffset(0);
+        queueMetadata.setMaxOffset(0);
+        metadataStore.updateQueue(queueMetadata);
+        queueMetadata = metadataStore.getQueue(mq);
+        Assert.assertTrue(queueMetadata.getUpdateTimestamp() >= currentTimeMillis);
+        Assert.assertEquals(queueMetadata.getMinOffset(), 0);
+        Assert.assertEquals(queueMetadata.getMaxOffset(), 0);
+
+        MessageQueue mq2 = new MessageQueue("MetadataStoreTest", storeConfig.getBrokerName(), 2);
+        metadataStore.addQueue(mq2, 1);
+        AtomicInteger i = new AtomicInteger(0);
+        metadataStore.iterateQueue(mq.getTopic(), metadata -> {
+            Assert.assertEquals(i.get(), metadata.getMinOffset());
+            i.getAndIncrement();
+        });
+        Assert.assertEquals(i.get(), 2);
+
+        metadataStore.deleteQueue(mq);
+        queueMetadata = metadataStore.getQueue(mq);
+        Assert.assertNull(queueMetadata);
+    }
+
+    @Test
+    public void testTopic() {
+        TopicMetadata topicMetadata = metadataStore.getTopic(mq.getTopic());
+        Assert.assertNull(topicMetadata);
+
+        metadataStore.addTopic(mq.getTopic(), 2);
+        topicMetadata = metadataStore.getTopic(mq.getTopic());
+        Assert.assertEquals(mq.getTopic(), topicMetadata.getTopic());
+        Assert.assertEquals(topicMetadata.getStatus(), 0);
+        Assert.assertEquals(topicMetadata.getReserveTime(), 2);
+        Assert.assertEquals(topicMetadata.getTopicId(), 0);
+
+        metadataStore.updateTopicStatus(mq.getTopic(), 1);
+        metadataStore.updateTopicReserveTime(mq.getTopic(), 0);
+        topicMetadata = metadataStore.getTopic(mq.getTopic());
+        Assert.assertNotNull(topicMetadata);
+        Assert.assertEquals(topicMetadata.getStatus(), 1);
+        Assert.assertEquals(topicMetadata.getReserveTime(), 0);
+
+        metadataStore.addTopic(mq.getTopic() + "1", 1);
+        metadataStore.updateTopicStatus(mq.getTopic() + "1", 2);
+
+        metadataStore.addTopic(mq.getTopic() + "2", 2);
+        metadataStore.updateTopicStatus(mq.getTopic() + "2", 3);
+
+        AtomicInteger n = new AtomicInteger();
+        metadataStore.iterateTopic(metadata -> {
+            long i = metadata.getReserveTime();
+            Assert.assertEquals(metadata.getTopicId(), i);
+            Assert.assertEquals(metadata.getStatus(), i + 1);
+            if (i == 2) {
+                metadataStore.deleteTopic(metadata.getTopic());
+            }
+            n.getAndIncrement();
+        });
+        Assert.assertEquals(3, n.get());
+
+        Assert.assertNull(metadataStore.getTopic(mq.getTopic() + "2"));
+
+        Assert.assertNotNull(metadataStore.getTopic(mq.getTopic()));
+        Assert.assertNotNull(metadataStore.getTopic(mq.getTopic() + "1"));
+    }
+
+    @Test
+    public void testFileSegment() {
+        MemoryFileSegment fileSegment1 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            mq,
+            100,
+            storeConfig);
+        fileSegment1.initPosition(fileSegment1.getSize());
+        FileSegmentMetadata metadata1 = metadataStore.updateFileSegment(fileSegment1);
+        Assert.assertEquals(mq, metadata1.getQueue());
+        Assert.assertEquals(TieredFileSegment.FileSegmentType.COMMIT_LOG, TieredFileSegment.FileSegmentType.valueOf(metadata1.getType()));
+        Assert.assertEquals(100, metadata1.getBaseOffset());
+        Assert.assertEquals(0, metadata1.getSealTimestamp());
+
+        fileSegment1.setFull();
+        metadata1 = metadataStore.updateFileSegment(fileSegment1);
+        Assert.assertEquals(1000, metadata1.getSize());
+        Assert.assertEquals(0, metadata1.getSealTimestamp());
+
+        fileSegment1.commit();
+        metadata1 = metadataStore.updateFileSegment(fileSegment1);
+        Assert.assertEquals(1000 + TieredCommitLog.CODA_SIZE, metadata1.getSize());
+        Assert.assertTrue(metadata1.getSealTimestamp() > 0);
+
+        MemoryFileSegment fileSegment2 = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG,
+            mq,
+            1100,
+            storeConfig);
+        metadataStore.updateFileSegment(fileSegment2);
+        List<FileSegmentMetadata> list = new ArrayList<>();
+        metadataStore.iterateFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, "MetadataStoreTest", 1, list::add);
+        Assert.assertEquals(2, list.size());
+        Assert.assertEquals(100, list.get(0).getBaseOffset());
+        Assert.assertEquals(1100, list.get(1).getBaseOffset());
+
+        Assert.assertNotNull(metadataStore.getFileSegment(fileSegment1));
+        metadataStore.deleteFileSegment(fileSegment1);
+        Assert.assertNull(metadataStore.getFileSegment(fileSegment1));
+    }
+
+    @Test
+    public void testReload() {
+        TieredMetadataManager metadataManager = (TieredMetadataManager) metadataStore;
+        metadataManager.addTopic(mq.getTopic(), 1);
+        metadataManager.addQueue(mq, 2);
+        Assert.assertTrue(new File(metadataManager.configFilePath()).exists());
+
+        metadataManager = new TieredMetadataManager(storeConfig);
+        metadataManager.load();
+
+        TopicMetadata topicMetadata = metadataManager.getTopic(mq.getTopic());
+        Assert.assertNotNull(topicMetadata);
+        Assert.assertEquals(topicMetadata.getReserveTime(), 1);
+
+        QueueMetadata queueMetadata = metadataManager.getQueue(mq);
+        Assert.assertNotNull(queueMetadata);
+        Assert.assertEquals(queueMetadata.getMinOffset(), 2);
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
new file mode 100644
index 0000000..dea8f50
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.metrics;
+
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import org.apache.rocketmq.tieredstore.TieredMessageFetcher;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.junit.Test;
+
+public class TieredStoreMetricsManagerTest {
+
+    @Test
+    public void getMetricsView() {
+        TieredStoreMetricsManager.getMetricsView();
+    }
+
+    @Test
+    public void init() {
+        TieredMessageStoreConfig storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        TieredStoreMetricsManager.init(OpenTelemetrySdk.builder().build().getMeter(""),
+            null, storeConfig, new TieredMessageFetcher(storeConfig), null);
+    }
+
+    @Test
+    public void newAttributesBuilder() {
+        TieredStoreMetricsManager.newAttributesBuilder();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
new file mode 100644
index 0000000..25f4a6b
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.mock;
+
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.junit.Assert;
+
+public class MemoryFileSegment extends TieredFileSegment {
+    private final ByteBuffer memStore;
+
+    public CompletableFuture<Boolean> blocker;
+
+    public static boolean checkSize = true;
+
+    public MemoryFileSegment(TieredFileSegment.FileSegmentType fileType, MessageQueue messageQueue, long baseOffset,
+        TieredMessageStoreConfig storeConfig) {
+        super(fileType, messageQueue, baseOffset, storeConfig);
+        switch (fileType) {
+            case COMMIT_LOG:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            case CONSUME_QUEUE:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            case INDEX:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            default:
+                memStore = null;
+                break;
+        }
+        memStore.position((int) getSize());
+    }
+
+    @Override
+    public String getPath() {
+        return "/tiered/" + fileType + File.separator + baseOffset;
+    }
+
+    @Override
+    public long getSize() {
+        if (checkSize) {
+            return 1000;
+        }
+        return 0;
+    }
+
+    @Override
+    public void createFile() {
+
+    }
+
+    @Override
+    public CompletableFuture<ByteBuffer> read0(long position, int length) {
+        ByteBuffer buffer = memStore.duplicate();
+        buffer.position((int) position);
+        ByteBuffer slice = buffer.slice();
+        slice.limit(length);
+        return CompletableFuture.completedFuture(slice);
+    }
+
+    @Override
+    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
+        boolean append) {
+        try {
+            if (blocker != null && !blocker.get()) {
+                throw new IllegalStateException();
+            }
+        } catch (InterruptedException | ExecutionException e) {
+            Assert.fail(e.getMessage());
+        }
+
+        Assert.assertTrue(!checkSize || position >= getSize());
+
+        byte[] buffer = new byte[1024];
+
+        int startPos = memStore.position();
+        try {
+            int len;
+            while ((len = inputStream.read(buffer)) > 0) {
+                memStore.put(buffer, 0, len);
+            }
+            Assert.assertEquals(length, memStore.position() - startPos);
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+            return CompletableFuture.completedFuture(false);
+        }
+        return CompletableFuture.completedFuture(true);
+    }
+
+    @Override
+    public boolean exists() {
+        return false;
+    }
+
+    @Override
+    public void destroyFile() {
+
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
new file mode 100644
index 0000000..f55f748
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.provider;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.CompletableFuture;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TieredFileSegmentTest {
+    public int baseOffset = 1000;
+
+    public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
+        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", new TieredMessageStoreConfig().getBrokerName(), 0),
+            baseOffset, new TieredMessageStoreConfig());
+    }
+
+    @Test
+    public void testCommitLog() {
+        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
+        segment.initPosition(segment.getSize());
+        long lastSize = segment.getSize();
+        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
+        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
+        Assert.assertTrue(segment.needCommit());
+
+        ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+        long msg3StoreTime = System.currentTimeMillis();
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, msg3StoreTime);
+        long queueOffset = baseOffset * 1000L;
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, queueOffset);
+        segment.append(buffer, msg3StoreTime);
+
+        Assert.assertEquals(baseOffset, segment.getBaseOffset());
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
+        Assert.assertEquals(0, segment.getBeginTimestamp());
+        Assert.assertEquals(msg3StoreTime, segment.getEndTimestamp());
+
+        segment.setFull();
+        segment.commit();
+        Assert.assertFalse(segment.needCommit());
+        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
+        Assert.assertEquals(queueOffset, segment.getCommitMsgQueueOffset());
+
+        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
+
+        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
+
+        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
+
+        ByteBuffer coda = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 3, TieredCommitLog.CODA_SIZE);
+        Assert.assertEquals(msg3StoreTime, coda.getLong(4 + 4));
+    }
+
+    private ByteBuffer buildConsumeQueue(long commitLogOffset) {
+        ByteBuffer cqItem = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqItem.putLong(commitLogOffset);
+        cqItem.putInt(2);
+        cqItem.putLong(3);
+        cqItem.flip();
+        return cqItem;
+    }
+
+    @Test
+    public void testConsumeQueue() {
+        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE);
+        segment.initPosition(segment.getSize());
+        long lastSize = segment.getSize();
+        segment.append(buildConsumeQueue(baseOffset), 0);
+        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN), 0);
+        long cqItem3Timestamp = System.currentTimeMillis();
+        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN * 2), cqItem3Timestamp);
+
+        Assert.assertEquals(baseOffset + lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3, segment.getMaxOffset());
+        Assert.assertEquals(0, segment.getBeginTimestamp());
+        Assert.assertEquals(cqItem3Timestamp, segment.getEndTimestamp());
+
+        segment.commit();
+        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
+
+        ByteBuffer cqItem1 = segment.read(lastSize, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset, cqItem1.getLong());
+
+        ByteBuffer cqItem2 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN, cqItem2.getLong());
+
+        ByteBuffer cqItem3 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN * 2, cqItem3.getLong());
+    }
+
+    @Test
+    public void testCommitFailed() {
+        long startTime = System.currentTimeMillis();
+        MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
+        long lastSize = segment.getSize();
+        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
+        segment.append(MessageBufferUtilTest.buildMessageBuffer(), 0);
+
+        segment.blocker = new CompletableFuture<>();
+        new Thread(() -> {
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                Assert.fail(e.getMessage());
+            }
+            ByteBuffer buffer = MessageBufferUtilTest.buildMessageBuffer();
+            buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);
+            segment.append(buffer, 0);
+            segment.blocker.complete(false);
+        }).start();
+
+        segment.commit();
+        segment.blocker.join();
+
+        segment.blocker = new CompletableFuture<>();
+        segment.blocker.complete(true);
+        segment.commit();
+
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());
+
+        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
+
+        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
+
+        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java
new file mode 100644
index 0000000..7f8caea
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/CQItemBufferUtilTest.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.util;
+
+import java.nio.ByteBuffer;
+import org.apache.rocketmq.store.ConsumeQueue;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class CQItemBufferUtilTest {
+    private static ByteBuffer cqItem;
+
+    @BeforeClass
+    public static void setUp() {
+        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(1);
+        cqItem.putInt(2);
+        cqItem.putLong(3);
+        cqItem.flip();
+    }
+
+    @Test
+    public void testGetCommitLogOffset() {
+        Assert.assertEquals(1, CQItemBufferUtil.getCommitLogOffset(cqItem));
+    }
+
+    @Test
+    public void testGetSize() {
+        Assert.assertEquals(2, CQItemBufferUtil.getSize(cqItem));
+    }
+
+    @Test
+    public void testGetTagCode() {
+        Assert.assertEquals(3, CQItemBufferUtil.getTagCode(cqItem));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
new file mode 100644
index 0000000..268ea2d
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
@@ -0,0 +1,243 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.util;
+
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageDecoder;
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class MessageBufferUtilTest {
+    public static final int MSG_LEN = 4 //TOTALSIZE
+        + 4 //MAGICCODE
+        + 4 //BODYCRC
+        + 4 //QUEUEID
+        + 4 //FLAG
+        + 8 //QUEUEOFFSET
+        + 8 //PHYSICALOFFSET
+        + 4 //SYSFLAG
+        + 8 //BORNTIMESTAMP
+        + 8 //BORNHOST
+        + 8 //STORETIMESTAMP
+        + 8 //STOREHOSTADDRESS
+        + 4 //RECONSUMETIMES
+        + 8 //Prepared Transaction Offset
+        + 4 + 0 //BODY
+        + 2 + 0 //TOPIC
+        + 2 + 30 //properties
+        + 0;
+
+    public static ByteBuffer buildMessageBuffer() {
+        // Initialization of storage space
+        ByteBuffer buffer = ByteBuffer.allocate(MSG_LEN);
+        // 1 TOTALSIZE
+        buffer.putInt(MSG_LEN);
+        // 2 MAGICCODE
+        buffer.putInt(MessageDecoder.MESSAGE_MAGIC_CODE_V2);
+        // 3 BODYCRC
+        buffer.putInt(3);
+        // 4 QUEUEID
+        buffer.putInt(4);
+        // 5 FLAG
+        buffer.putInt(5);
+        // 6 QUEUEOFFSET
+        buffer.putLong(6);
+        // 7 PHYSICALOFFSET
+        buffer.putLong(7);
+        // 8 SYSFLAG
+        buffer.putInt(8);
+        // 9 BORNTIMESTAMP
+        buffer.putLong(9);
+        // 10 BORNHOST
+        buffer.putLong(10);
+        // 11 STORETIMESTAMP
+        buffer.putLong(11);
+        // 12 STOREHOSTADDRESS
+        buffer.putLong(10);
+        // 13 RECONSUMETIMES
+        buffer.putInt(13);
+        // 14 Prepared Transaction Offset
+        buffer.putLong(14);
+        // 15 BODY
+        buffer.putInt(0);
+        // 16 TOPIC
+        buffer.putShort((short) 0);
+        // 17 PROPERTIES
+        Map<String, String> map = new HashMap<>();
+        map.put(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, "uk");
+        map.put("userkey", "uservalue0");
+        String properties = MessageDecoder.messageProperties2String(map);
+        byte[] propertiesBytes = properties.getBytes(StandardCharsets.UTF_8);
+        buffer.putShort((short) propertiesBytes.length);
+        buffer.put(propertiesBytes);
+        buffer.flip();
+
+        Assert.assertEquals(MSG_LEN, buffer.remaining());
+        return buffer;
+    }
+
+    @Test
+    public void testGetTotalSize() {
+        ByteBuffer buffer = buildMessageBuffer();
+        int totalSize = MessageBufferUtil.getTotalSize(buffer);
+        Assert.assertEquals(MSG_LEN, totalSize);
+    }
+
+    @Test
+    public void testGetMagicCode() {
+        ByteBuffer buffer = buildMessageBuffer();
+        int magicCode = MessageBufferUtil.getMagicCode(buffer);
+        Assert.assertEquals(MessageDecoder.MESSAGE_MAGIC_CODE_V2, magicCode);
+    }
+
+    @Test
+    public void testSplitMessages() {
+        ByteBuffer msgBuffer1 = buildMessageBuffer();
+        msgBuffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 10);
+        ByteBuffer msgBuffer2 = ByteBuffer.allocate(TieredCommitLog.CODA_SIZE);
+
+        msgBuffer2.putInt(TieredCommitLog.CODA_SIZE);
+        msgBuffer2.putInt(TieredCommitLog.BLANK_MAGIC_CODE);
+        msgBuffer2.putLong(System.currentTimeMillis());
+        msgBuffer2.flip();
+
+        ByteBuffer msgBuffer3 = buildMessageBuffer();
+        msgBuffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 11);
+
+        ByteBuffer msgBuffer = ByteBuffer.allocate(msgBuffer1.remaining() + msgBuffer2.remaining() + msgBuffer3.remaining());
+        msgBuffer.put(msgBuffer1);
+        msgBuffer.put(msgBuffer2);
+        msgBuffer.put(msgBuffer3);
+        msgBuffer.flip();
+
+        ByteBuffer cqBuffer1 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer1.putLong(1000);
+        cqBuffer1.putInt(MSG_LEN);
+        cqBuffer1.putLong(0);
+        cqBuffer1.flip();
+
+        ByteBuffer cqBuffer2 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer2.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
+        cqBuffer2.putInt(MSG_LEN);
+        cqBuffer2.putLong(0);
+        cqBuffer2.flip();
+
+        ByteBuffer cqBuffer3 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer3.putLong(1000 + MSG_LEN);
+        cqBuffer3.putInt(MSG_LEN);
+        cqBuffer3.putLong(0);
+        cqBuffer3.flip();
+
+        ByteBuffer cqBuffer4 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer4.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
+        cqBuffer4.putInt(MSG_LEN - 10);
+        cqBuffer4.putLong(0);
+        cqBuffer4.flip();
+
+        ByteBuffer cqBuffer5 = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer5.putLong(1000 + TieredCommitLog.CODA_SIZE + MSG_LEN);
+        cqBuffer5.putInt(MSG_LEN * 10);
+        cqBuffer5.putLong(0);
+        cqBuffer5.flip();
+
+        ByteBuffer cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2);
+        cqBuffer.put(cqBuffer1);
+        cqBuffer.put(cqBuffer2);
+        cqBuffer.flip();
+        cqBuffer1.rewind();
+        cqBuffer2.rewind();
+        List<Pair<Integer, Integer>> msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
+        Assert.assertEquals(2, msgList.size());
+        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
+        Assert.assertEquals(Pair.of(MSG_LEN + TieredCommitLog.CODA_SIZE, MSG_LEN), msgList.get(1));
+
+        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2);
+        cqBuffer.put(cqBuffer1);
+        cqBuffer.put(cqBuffer4);
+        cqBuffer.flip();
+        cqBuffer1.rewind();
+        cqBuffer4.rewind();
+        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
+        Assert.assertEquals(1, msgList.size());
+        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
+
+        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3);
+        cqBuffer.put(cqBuffer1);
+        cqBuffer.put(cqBuffer3);
+        cqBuffer.flip();
+        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
+        Assert.assertEquals(2, msgList.size());
+        Assert.assertEquals(Pair.of(0, MSG_LEN), msgList.get(0));
+        Assert.assertEquals(Pair.of(MSG_LEN + TieredCommitLog.CODA_SIZE, MSG_LEN), msgList.get(1));
+
+        cqBuffer = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqBuffer.put(cqBuffer5);
+        cqBuffer.flip();
+        msgList = MessageBufferUtil.splitMessageBuffer(cqBuffer, msgBuffer);
+        Assert.assertEquals(0, msgList.size());
+    }
+
+    @Test
+    public void testGetQueueOffset() {
+        ByteBuffer buffer = buildMessageBuffer();
+        long queueOffset = MessageBufferUtil.getQueueOffset(buffer);
+        Assert.assertEquals(6, queueOffset);
+    }
+
+    @Test
+    public void testGetStoreTimeStamp() {
+        ByteBuffer buffer = buildMessageBuffer();
+        long storeTimeStamp = MessageBufferUtil.getStoreTimeStamp(buffer);
+        Assert.assertEquals(11, storeTimeStamp);
+    }
+
+    @Test
+    public void testGetOffsetId() {
+        ByteBuffer buffer = buildMessageBuffer();
+        InetSocketAddress inetSocketAddress = new InetSocketAddress("255.255.255.255", 65535);
+        ByteBuffer addr = ByteBuffer.allocate(Long.BYTES);
+        addr.put(inetSocketAddress.getAddress().getAddress(), 0, 4);
+        addr.putInt(inetSocketAddress.getPort());
+        addr.flip();
+        for (int i = 0; i < addr.remaining(); i++) {
+            buffer.put(MessageBufferUtil.STORE_HOST_POSITION + i, addr.get(i));
+        }
+        String excepted = MessageDecoder.createMessageId(ByteBuffer.allocate(TieredStoreUtil.MSG_ID_LENGTH), addr, 7);
+        String offsetId = MessageBufferUtil.getOffsetId(buffer);
+        Assert.assertEquals(excepted, offsetId);
+    }
+
+    @Test
+    public void testGetProperties() {
+        ByteBuffer buffer = buildMessageBuffer();
+        Map<String, String> properties = MessageBufferUtil.getProperties(buffer);
+        Assert.assertEquals(2, properties.size());
+        Assert.assertTrue(properties.containsKey(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
+        Assert.assertEquals("uk", properties.get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
+        Assert.assertTrue(properties.containsKey("userkey"));
+        Assert.assertEquals("uservalue0", properties.get("userkey"));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java
new file mode 100644
index 0000000..82e1125
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/TieredStoreUtilTest.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.util;
+
+import java.util.HashMap;
+import java.util.Map;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TieredStoreUtilTest {
+
+    private static final Map<Long, String> DATA_MAP = new HashMap<Long, String>() {
+        {
+            put(0L, "0Bytes");
+            put(1023L, "1023Bytes");
+            put(1024L, "1KB");
+            put(12_345L, "12.06KB");
+            put(10_123_456L, "9.65MB");
+            put(10_123_456_798L, "9.43GB");
+            put(1_777_777_777_777_777_777L, "1.54EB");
+        }
+    };
+
+    @Test
+    public void getHash() {
+        Assert.assertEquals("161c08ff", TieredStoreUtil.getHash("TieredStorageDailyTest"));
+    }
+
+    @Test
+    public void testOffset2FileName() {
+        Assert.assertEquals("cfcd208400000000000000000000", TieredStoreUtil.offset2FileName(0));
+        Assert.assertEquals("b10da56800000000004294937144", TieredStoreUtil.offset2FileName(4294937144L));
+    }
+
+    @Test
+    public void testFileName2Offset() {
+        Assert.assertEquals(0, TieredStoreUtil.fileName2Offset("cfcd208400000000000000000000"));
+        Assert.assertEquals(4294937144L, TieredStoreUtil.fileName2Offset("b10da56800000000004294937144"));
+    }
+
+    @Test
+    public void testToHumanReadable() {
+        DATA_MAP.forEach((in, expected) -> Assert.assertEquals(expected, TieredStoreUtil.toHumanReadable(in)));
+    }
+}

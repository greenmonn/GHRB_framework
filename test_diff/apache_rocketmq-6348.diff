diff --git a/controller/src/test/java/org/apache/rocketmq/controller/ControllerManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/ControllerManagerTest.java
new file mode 100644
index 0000000..8ad67d4
--- /dev/null
+++ b/controller/src/test/java/org/apache/rocketmq/controller/ControllerManagerTest.java
@@ -0,0 +1,254 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.controller;
+
+import java.io.File;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import org.apache.rocketmq.common.ControllerConfig;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.controller.impl.DLedgerController;
+import org.apache.rocketmq.remoting.RemotingClient;
+import org.apache.rocketmq.remoting.netty.NettyClientConfig;
+import org.apache.rocketmq.remoting.netty.NettyRemotingClient;
+import org.apache.rocketmq.remoting.netty.NettyServerConfig;
+import org.apache.rocketmq.remoting.protocol.RemotingCommand;
+import org.apache.rocketmq.remoting.protocol.RequestCode;
+import org.apache.rocketmq.remoting.protocol.ResponseCode;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.awaitility.Awaitility.await;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ControllerManagerTest {
+
+    public static final String STORE_BASE_PATH = System.getProperty("java.io.tmpdir") + File.separator + "ControllerManagerTest";
+
+    public static final String STORE_PATH = STORE_BASE_PATH + File.separator + UUID.randomUUID();
+
+    private List<ControllerManager> controllers;
+    private NettyRemotingClient remotingClient;
+    private NettyRemotingClient remotingClient1;
+
+    public ControllerManager launchManager(final String group, final String peers, final String selfId) {
+        final String path = STORE_PATH + File.separator + group + File.separator + selfId;
+        final ControllerConfig config = new ControllerConfig();
+        config.setControllerDLegerGroup(group);
+        config.setControllerDLegerPeers(peers);
+        config.setControllerDLegerSelfId(selfId);
+        config.setControllerStorePath(path);
+        config.setMappedFileSize(10 * 1024 * 1024);
+        config.setEnableElectUncleanMaster(true);
+        config.setScanNotActiveBrokerInterval(1000L);
+        config.setNotifyBrokerRoleChanged(false);
+
+        final NettyServerConfig serverConfig = new NettyServerConfig();
+
+        final ControllerManager manager = new ControllerManager(config, serverConfig, new NettyClientConfig());
+        manager.initialize();
+        manager.start();
+        this.controllers.add(manager);
+        return manager;
+    }
+
+    @Before
+    public void startup() {
+        UtilAll.deleteFile(new File(STORE_BASE_PATH));
+        this.controllers = new ArrayList<>();
+        this.remotingClient = new NettyRemotingClient(new NettyClientConfig());
+        this.remotingClient.start();
+        this.remotingClient1 = new NettyRemotingClient(new NettyClientConfig());
+        this.remotingClient1.start();
+    }
+
+    public ControllerManager waitLeader(final List<ControllerManager> controllers) throws Exception {
+        if (controllers.isEmpty()) {
+            return null;
+        }
+        DLedgerController c1 = (DLedgerController) controllers.get(0).getController();
+
+        ControllerManager manager = await().atMost(Duration.ofSeconds(10)).until(() -> {
+            String leaderId = c1.getMemberState().getLeaderId();
+            if (null == leaderId) {
+                return null;
+            }
+            for (ControllerManager controllerManager : controllers) {
+                final DLedgerController controller = (DLedgerController) controllerManager.getController();
+                if (controller.getMemberState().getSelfId().equals(leaderId) && controller.isLeaderState()) {
+                    return controllerManager;
+                }
+            }
+            return null;
+        }, item -> item != null);
+        return manager;
+    }
+
+    public void mockData() {
+        String group = UUID.randomUUID().toString();
+        String peers = String.format("n0-localhost:%d;n1-localhost:%d;n2-localhost:%d", 30000, 30001, 30002);
+        launchManager(group, peers, "n0");
+        launchManager(group, peers, "n1");
+        launchManager(group, peers, "n2");
+    }
+
+    /**
+     * Register broker to controller
+     */
+    public void registerBroker(
+        final String controllerAddress, final String clusterName,
+        final String brokerName, final Long brokerId,  final String brokerAddress, final Long expectMasterBrokerId, final RemotingClient client) throws Exception {
+        // Get next brokerId;
+        final GetNextBrokerIdRequestHeader getNextBrokerIdRequestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
+        final RemotingCommand getNextBrokerIdRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_NEXT_BROKER_ID, getNextBrokerIdRequestHeader);
+        final RemotingCommand getNextBrokerIdResponse = client.invokeSync(controllerAddress, getNextBrokerIdRequest, 3000);
+        final GetNextBrokerIdResponseHeader getNextBrokerIdResponseHeader = (GetNextBrokerIdResponseHeader) getNextBrokerIdResponse.decodeCommandCustomHeader(GetNextBrokerIdResponseHeader.class);
+        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
+        assertEquals(ResponseCode.SUCCESS, getNextBrokerIdResponse.getCode());
+        assertEquals(brokerId, getNextBrokerIdResponseHeader.getNextBrokerId());
+
+        // Apply brokerId
+        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, brokerId, registerCheckCode);
+        final RemotingCommand applyBrokerIdRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_APPLY_BROKER_ID, applyBrokerIdRequestHeader);
+        final RemotingCommand applyBrokerIdResponse = client.invokeSync(controllerAddress, applyBrokerIdRequest, 3000);
+        final ApplyBrokerIdResponseHeader applyBrokerIdResponseHeader = (ApplyBrokerIdResponseHeader) applyBrokerIdResponse.decodeCommandCustomHeader(ApplyBrokerIdResponseHeader.class);
+        assertEquals(ResponseCode.SUCCESS, applyBrokerIdResponse.getCode());
+
+        // Register success
+        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, brokerId, brokerAddress);
+        final RemotingCommand registerSuccessRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_REGISTER_BROKER, registerBrokerToControllerRequestHeader);
+        final RemotingCommand registerSuccessResponse = client.invokeSync(controllerAddress, registerSuccessRequest, 3000);
+        final RegisterBrokerToControllerResponseHeader registerBrokerToControllerResponseHeader = (RegisterBrokerToControllerResponseHeader) registerSuccessResponse.decodeCommandCustomHeader(RegisterBrokerToControllerResponseHeader.class);
+        assertEquals(ResponseCode.SUCCESS, registerSuccessResponse.getCode());
+        assertEquals(expectMasterBrokerId, registerBrokerToControllerResponseHeader.getMasterBrokerId());
+    }
+
+    public RemotingCommand brokerTryElect(final String controllerAddress, final String clusterName,
+        final String brokerName, final Long brokerId, final RemotingClient client) throws Exception {
+        final ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
+        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ELECT_MASTER, requestHeader);
+        RemotingCommand response = client.invokeSync(controllerAddress, request, 10000);
+        assertNotNull(response);
+        return response;
+    }
+
+    public void sendHeartbeat(final String controllerAddress, final String clusterName, final String brokerName, final Long brokerId,
+                              final String brokerAddress, final Long timeout, final RemotingClient client) throws Exception {
+        final BrokerHeartbeatRequestHeader heartbeatRequestHeader0 = new BrokerHeartbeatRequestHeader();
+        heartbeatRequestHeader0.setBrokerId(brokerId);
+        heartbeatRequestHeader0.setClusterName(clusterName);
+        heartbeatRequestHeader0.setBrokerName(brokerName);
+        heartbeatRequestHeader0.setBrokerAddr(brokerAddress);
+        heartbeatRequestHeader0.setHeartbeatTimeoutMills(timeout);
+        final RemotingCommand heartbeatRequest = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, heartbeatRequestHeader0);
+        RemotingCommand remotingCommand = client.invokeSync(controllerAddress, heartbeatRequest, 3000);
+        assertEquals(ResponseCode.SUCCESS, remotingCommand.getCode());
+    }
+
+    @Test
+    public void testSomeApi() throws Exception {
+        mockData();
+        final ControllerManager leader = waitLeader(this.controllers);
+        String leaderAddr = "localhost" + ":" + leader.getController().getRemotingServer().localListenPort();
+
+        // Register two broker
+        registerBroker(leaderAddr, "cluster1", "broker1", 1L, "127.0.0.1:8000", null, this.remotingClient);
+
+        registerBroker(leaderAddr, "cluster1", "broker1", 2L, "127.0.0.1:8001", null, this.remotingClient1);
+
+        // Send heartbeat
+        sendHeartbeat(leaderAddr, "cluster1", "broker1", 1L, "127.0.0.1:8000", 3000L, remotingClient);
+        sendHeartbeat(leaderAddr, "cluster1", "broker1", 2L, "127.0.0.1:8001", 3000L, remotingClient1);
+
+        // Two all try elect itself as master, but only the first can be the master
+        RemotingCommand tryElectCommand1 = brokerTryElect(leaderAddr, "cluster1", "broker1", 1L, this.remotingClient);
+        ElectMasterResponseHeader brokerTryElectResponseHeader1 = (ElectMasterResponseHeader) tryElectCommand1.decodeCommandCustomHeader(ElectMasterResponseHeader.class);
+        RemotingCommand tryElectCommand2 = brokerTryElect(leaderAddr, "cluster1", "broker1", 2L, this.remotingClient1);
+        ElectMasterResponseHeader brokerTryElectResponseHeader2 = (ElectMasterResponseHeader) tryElectCommand2.decodeCommandCustomHeader(ElectMasterResponseHeader.class);
+
+        assertEquals(ResponseCode.SUCCESS, tryElectCommand1.getCode());
+        assertEquals(1L, brokerTryElectResponseHeader1.getMasterBrokerId().longValue());
+        assertEquals("127.0.0.1:8000", brokerTryElectResponseHeader1.getMasterAddress());
+        assertEquals(1, brokerTryElectResponseHeader1.getMasterEpoch().intValue());
+        assertEquals(1, brokerTryElectResponseHeader1.getSyncStateSetEpoch().intValue());
+
+        assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, tryElectCommand2.getCode());
+        assertEquals(1L, brokerTryElectResponseHeader2.getMasterBrokerId().longValue());
+        assertEquals("127.0.0.1:8000", brokerTryElectResponseHeader2.getMasterAddress());
+        assertEquals(1, brokerTryElectResponseHeader2.getMasterEpoch().intValue());
+        assertEquals(1, brokerTryElectResponseHeader2.getSyncStateSetEpoch().intValue());
+
+        // Send heartbeat for broker2 every one second
+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
+        executor.scheduleAtFixedRate(() -> {
+            final BrokerHeartbeatRequestHeader heartbeatRequestHeader = new BrokerHeartbeatRequestHeader();
+            heartbeatRequestHeader.setClusterName("cluster1");
+            heartbeatRequestHeader.setBrokerName("broker1");
+            heartbeatRequestHeader.setBrokerAddr("127.0.0.1:8001");
+            heartbeatRequestHeader.setBrokerId(2L);
+            heartbeatRequestHeader.setHeartbeatTimeoutMills(3000L);
+            final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, heartbeatRequestHeader);
+            try {
+                final RemotingCommand remotingCommand = this.remotingClient1.invokeSync(leaderAddr, request, 3000);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }, 0, 1000L, TimeUnit.MILLISECONDS);
+        Boolean flag = await().atMost(Duration.ofSeconds(10)).until(() -> {
+            final GetReplicaInfoRequestHeader requestHeader = new GetReplicaInfoRequestHeader("broker1");
+            final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_REPLICA_INFO, requestHeader);
+            final RemotingCommand response = this.remotingClient1.invokeSync(leaderAddr, request, 3000);
+            final GetReplicaInfoResponseHeader responseHeader = (GetReplicaInfoResponseHeader) response.decodeCommandCustomHeader(GetReplicaInfoResponseHeader.class);
+            return responseHeader.getMasterBrokerId().equals(2L);
+        }, item -> item);
+
+        // The new master should be broker2.
+        assertTrue(flag);
+
+        executor.shutdown();
+    }
+
+    @After
+    public void tearDown() {
+        for (ControllerManager controller : this.controllers) {
+            controller.shutdown();
+        }
+        UtilAll.deleteFile(new File(STORE_BASE_PATH));
+        this.remotingClient.shutdown();
+        this.remotingClient1.shutdown();
+    }
+}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/ControllerTestBase.java b/controller/src/test/java/org/apache/rocketmq/controller/ControllerTestBase.java
new file mode 100644
index 0000000..f77f49d
--- /dev/null
+++ b/controller/src/test/java/org/apache/rocketmq/controller/ControllerTestBase.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.controller;
+
+public class ControllerTestBase {
+
+    public final static String DEFAULT_CLUSTER_NAME = "cluster-a";
+
+    public final static String DEFAULT_BROKER_NAME = "broker-set-a";
+
+    public final static String[] DEFAULT_IP = {"127.0.0.1:9000", "127.0.0.1:9001", "127.0.0.1:9002"};
+}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/DLedgerControllerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/DLedgerControllerTest.java
new file mode 100644
index 0000000..eaf78b6
--- /dev/null
+++ b/controller/src/test/java/org/apache/rocketmq/controller/impl/DLedgerControllerTest.java
@@ -0,0 +1,335 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.controller.impl;
+
+import io.openmessaging.storage.dledger.DLedgerConfig;
+import java.io.File;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.common.ControllerConfig;
+import org.apache.rocketmq.controller.Controller;
+import org.apache.rocketmq.controller.elect.impl.DefaultElectPolicy;
+import org.apache.rocketmq.remoting.protocol.RemotingCommand;
+import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
+import org.apache.rocketmq.remoting.protocol.ResponseCode;
+import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
+import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_BROKER_NAME;
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_CLUSTER_NAME;
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_IP;
+import static org.awaitility.Awaitility.await;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class DLedgerControllerTest {
+    private List<String> baseDirs;
+    private List<DLedgerController> controllers;
+
+    public DLedgerController launchController(final String group, final String peers, final String selfId,
+        String storeType, final boolean isEnableElectUncleanMaster) {
+        String tmpdir = System.getProperty("java.io.tmpdir");
+        final String path = (StringUtils.endsWith(tmpdir, File.separator) ? tmpdir : tmpdir + File.separator) + group + File.separator + selfId;
+        baseDirs.add(path);
+
+        final ControllerConfig config = new ControllerConfig();
+        config.setControllerDLegerGroup(group);
+        config.setControllerDLegerPeers(peers);
+        config.setControllerDLegerSelfId(selfId);
+        config.setControllerStorePath(path);
+        config.setMappedFileSize(10 * 1024 * 1024);
+        config.setEnableElectUncleanMaster(isEnableElectUncleanMaster);
+
+        final DLedgerController controller = new DLedgerController(config, (str1, str2, str3) -> true);
+
+        controller.startup();
+        return controller;
+    }
+
+    @Before
+    public void startup() {
+        this.baseDirs = new ArrayList<>();
+        this.controllers = new ArrayList<>();
+    }
+
+    @After
+    public void tearDown() {
+        for (Controller controller : this.controllers) {
+            controller.shutdown();
+        }
+        for (String dir : this.baseDirs) {
+            new File(dir).delete();
+        }
+    }
+
+    public void registerNewBroker(Controller leader, String clusterName, String brokerName, String brokerAddress,
+        Long expectBrokerId) throws Exception {
+        // Get next brokerId
+        final GetNextBrokerIdRequestHeader getNextBrokerIdRequest = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
+        RemotingCommand remotingCommand = leader.getNextBrokerId(getNextBrokerIdRequest).get(2, TimeUnit.SECONDS);
+        GetNextBrokerIdResponseHeader getNextBrokerIdResp = (GetNextBrokerIdResponseHeader) remotingCommand.readCustomHeader();
+        Long nextBrokerId = getNextBrokerIdResp.getNextBrokerId();
+        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
+
+        // Check response
+        assertEquals(expectBrokerId, nextBrokerId);
+
+        // Apply brokerId
+        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, nextBrokerId, registerCheckCode);
+        RemotingCommand remotingCommand1 = leader.applyBrokerId(applyBrokerIdRequestHeader).get(2, TimeUnit.SECONDS);
+
+        // Check response
+        assertEquals(ResponseCode.SUCCESS, remotingCommand1.getCode());
+
+        // Register success
+        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, nextBrokerId, brokerAddress);
+        RemotingCommand remotingCommand2 = leader.registerBroker(registerBrokerToControllerRequestHeader).get(2, TimeUnit.SECONDS);
+
+
+        assertEquals(ResponseCode.SUCCESS, remotingCommand2.getCode());
+    }
+
+    public void brokerTryElectMaster(Controller leader, String clusterName, String brokerName, String brokerAddress, Long brokerId,
+        boolean exceptSuccess) throws Exception {
+        final ElectMasterRequestHeader electMasterRequestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
+        RemotingCommand command = leader.electMaster(electMasterRequestHeader).get(2, TimeUnit.SECONDS);
+        ElectMasterResponseHeader header = (ElectMasterResponseHeader) command.readCustomHeader();
+        assertEquals(exceptSuccess, ResponseCode.SUCCESS == command.getCode());
+    }
+
+    private boolean alterNewInSyncSet(Controller leader, String brokerName, Long masterBrokerId, Integer masterEpoch,
+        Set<Long> newSyncStateSet, Integer syncStateSetEpoch) throws Exception {
+        final AlterSyncStateSetRequestHeader alterRequest =
+            new AlterSyncStateSetRequestHeader(brokerName, masterBrokerId, masterEpoch);
+        final RemotingCommand response = leader.alterSyncStateSet(alterRequest, new SyncStateSet(newSyncStateSet, syncStateSetEpoch)).get(10, TimeUnit.SECONDS);
+        if (null == response || response.getCode() != ResponseCode.SUCCESS) {
+            return false;
+        }
+        final RemotingCommand getInfoResponse = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).get(10, TimeUnit.SECONDS);
+        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) getInfoResponse.readCustomHeader();
+        final SyncStateSet syncStateSet = RemotingSerializable.decode(getInfoResponse.getBody(), SyncStateSet.class);
+        assertArrayEquals(syncStateSet.getSyncStateSet().toArray(), newSyncStateSet.toArray());
+        assertEquals(syncStateSet.getSyncStateSetEpoch(), syncStateSetEpoch + 1);
+        return true;
+    }
+
+    public DLedgerController waitLeader(final List<DLedgerController> controllers) throws Exception {
+        if (controllers.isEmpty()) {
+            return null;
+        }
+        DLedgerController c1 = controllers.get(0);
+        DLedgerController dLedgerController = await().atMost(Duration.ofSeconds(10)).until(() -> {
+            String leaderId = c1.getMemberState().getLeaderId();
+            if (null == leaderId) {
+                return null;
+            }
+            for (DLedgerController controller : controllers) {
+                if (controller.getMemberState().getSelfId().equals(leaderId) && controller.isLeaderState()) {
+                    return controller;
+                }
+            }
+            return null;
+        }, item -> item != null);
+        return dLedgerController;
+    }
+
+    public DLedgerController mockMetaData(boolean enableElectUncleanMaster) throws Exception {
+        String group = UUID.randomUUID().toString();
+        String peers = String.format("n0-localhost:%d;n1-localhost:%d;n2-localhost:%d", 30000, 30001, 30002);
+        DLedgerController c0 = launchController(group, peers, "n0", DLedgerConfig.MEMORY, enableElectUncleanMaster);
+        DLedgerController c1 = launchController(group, peers, "n1", DLedgerConfig.MEMORY, enableElectUncleanMaster);
+        DLedgerController c2 = launchController(group, peers, "n2", DLedgerConfig.MEMORY, enableElectUncleanMaster);
+        controllers.add(c0);
+        controllers.add(c1);
+        controllers.add(c2);
+
+        DLedgerController leader = waitLeader(controllers);
+
+        // register
+        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L);
+        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L);
+        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L);
+        // try elect
+        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L,true);
+        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L,  false);
+        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L,false);
+        final RemotingCommand getInfoResponse = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
+        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) getInfoResponse.readCustomHeader();
+        assertEquals(1, replicaInfo.getMasterEpoch().intValue());
+        assertEquals(DEFAULT_IP[0], replicaInfo.getMasterAddress());
+        // Try alter SyncStateSet
+        final HashSet<Long> newSyncStateSet = new HashSet<>();
+        newSyncStateSet.add(1L);
+        newSyncStateSet.add(2L);
+        newSyncStateSet.add(3L);
+        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 1));
+        return leader;
+    }
+
+    public void setBrokerAlivePredicate(DLedgerController controller, Long... deathBroker) {
+        controller.setBrokerAlivePredicate((clusterName, brokerName, brokerId) -> {
+            for (Long broker : deathBroker) {
+                if (broker.equals(brokerId)) {
+                    return false;
+                }
+            }
+            return true;
+        });
+    }
+
+    public void setBrokerElectPolicy(DLedgerController controller, Long... deathBroker) {
+        controller.setElectPolicy(new DefaultElectPolicy((clusterName, brokerName, brokerId) -> {
+            for (Long broker : deathBroker) {
+                if (broker.equals(brokerId)) {
+                    return false;
+                }
+            }
+            return true;
+        }, null));
+    }
+
+    @Test
+    public void testElectMaster() throws Exception {
+        final DLedgerController leader = mockMetaData(false);
+        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        setBrokerElectPolicy(leader, 1L);
+        final RemotingCommand resp = leader.electMaster(request).get(10, TimeUnit.SECONDS);
+        final ElectMasterResponseHeader response = (ElectMasterResponseHeader) resp.readCustomHeader();
+        assertEquals(2, response.getMasterEpoch().intValue());
+        assertNotEquals(1L, response.getMasterBrokerId().longValue());
+        assertNotEquals(DEFAULT_IP[0], response.getMasterAddress());
+    }
+
+    @Test
+    public void testAllReplicasShutdownAndRestartWithUnEnableElectUnCleanMaster() throws Exception {
+        final DLedgerController leader = mockMetaData(false);
+        final HashSet<Long> newSyncStateSet = new HashSet<>();
+        newSyncStateSet.add(1L);
+
+        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
+
+        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
+        // However, the syncStateSet in statemachine is {1}, not more replicas can be elected as master, it will be failed.
+        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        setBrokerElectPolicy(leader, 1L);
+        leader.electMaster(electRequest).get(10, TimeUnit.SECONDS);
+
+        final RemotingCommand resp = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).
+            get(10, TimeUnit.SECONDS);
+        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) resp.readCustomHeader();
+        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
+        assertEquals(syncStateSet.getSyncStateSet(), newSyncStateSet);
+        assertEquals(null, replicaInfo.getMasterAddress());
+        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
+
+        // Now, we start broker - id[2]address[127.0.0.1:9001] to try elect, but it was not in syncStateSet, so it will not be elected as master.
+        final ElectMasterRequestHeader request1 =
+            ElectMasterRequestHeader.ofBrokerTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 2L);
+        final ElectMasterResponseHeader r1 = (ElectMasterResponseHeader) leader.electMaster(request1).get(10, TimeUnit.SECONDS).readCustomHeader();
+        assertEquals(null, r1.getMasterBrokerId());
+        assertEquals(null, r1.getMasterAddress());
+
+        // Now, we start broker - id[1]address[127.0.0.1:9000] to try elect, it will be elected as master
+        setBrokerElectPolicy(leader);
+        final ElectMasterRequestHeader request2 =
+            ElectMasterRequestHeader.ofBrokerTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
+        final ElectMasterResponseHeader r2 = (ElectMasterResponseHeader) leader.electMaster(request2).get(10, TimeUnit.SECONDS).readCustomHeader();
+        assertEquals(1L, r2.getMasterBrokerId().longValue());
+        assertEquals(DEFAULT_IP[0], r2.getMasterAddress());
+        assertEquals(3, r2.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testEnableElectUnCleanMaster() throws Exception {
+        final DLedgerController leader = mockMetaData(true);
+        final HashSet<Long> newSyncStateSet = new HashSet<>();
+        newSyncStateSet.add(1L);
+
+        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
+
+        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
+        // However, event if the syncStateSet in statemachine is {DEFAULT_IP[0]}
+        // the option {enableElectUncleanMaster = true}, so the controller sill can elect a new master
+        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        setBrokerElectPolicy(leader, 1L);
+        final CompletableFuture<RemotingCommand> future = leader.electMaster(electRequest);
+        future.get(10, TimeUnit.SECONDS);
+
+        final RemotingCommand resp = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
+        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) resp.readCustomHeader();
+        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
+
+        final HashSet<Long> newSyncStateSet2 = new HashSet<>();
+        newSyncStateSet2.add(replicaInfo.getMasterBrokerId());
+        assertEquals(syncStateSet.getSyncStateSet(), newSyncStateSet2);
+        assertNotEquals(1L, replicaInfo.getMasterBrokerId().longValue());
+        assertNotEquals(DEFAULT_IP[0], replicaInfo.getMasterAddress());
+        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testChangeControllerLeader() throws Exception {
+        final DLedgerController leader = mockMetaData(false);
+        leader.shutdown();
+        this.controllers.remove(leader);
+        // Wait leader again
+        final DLedgerController newLeader = waitLeader(this.controllers);
+        assertNotNull(newLeader);
+
+        RemotingCommand response = await().atMost(Duration.ofSeconds(10)).until(() -> {
+            final RemotingCommand resp = newLeader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
+            if (resp.getCode() == ResponseCode.SUCCESS) {
+
+                return resp;
+            }
+            return null;
+
+        }, item -> item != null);
+        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) response.readCustomHeader();
+        final SyncStateSet syncStateSetResult = RemotingSerializable.decode(response.getBody(), SyncStateSet.class);
+        assertEquals(replicaInfo.getMasterAddress(), DEFAULT_IP[0]);
+        assertEquals(1, replicaInfo.getMasterEpoch().intValue());
+
+        final HashSet<Long> syncStateSet = new HashSet<>();
+        syncStateSet.add(1L);
+        syncStateSet.add(2L);
+        syncStateSet.add(3L);
+        assertEquals(syncStateSetResult.getSyncStateSet(), syncStateSet);
+    }
+}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/DefaultBrokerHeartbeatManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/DefaultBrokerHeartbeatManagerTest.java
new file mode 100644
index 0000000..b97ea32
--- /dev/null
+++ b/controller/src/test/java/org/apache/rocketmq/controller/impl/DefaultBrokerHeartbeatManagerTest.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.controller.impl;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.apache.rocketmq.common.ControllerConfig;
+import org.apache.rocketmq.controller.BrokerHeartbeatManager;
+import org.apache.rocketmq.controller.impl.heartbeat.DefaultBrokerHeartbeatManager;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+public class DefaultBrokerHeartbeatManagerTest {
+    private BrokerHeartbeatManager heartbeatManager;
+
+    @Before
+    public void init() {
+        final ControllerConfig config = new ControllerConfig();
+        config.setScanNotActiveBrokerInterval(2000);
+        this.heartbeatManager = new DefaultBrokerHeartbeatManager(config);
+        this.heartbeatManager.initialize();
+        this.heartbeatManager.start();
+    }
+
+    @Test
+    public void testDetectBrokerAlive() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        this.heartbeatManager.addBrokerLifecycleListener((clusterName, brokerName, brokerId) -> {
+            latch.countDown();
+        });
+        this.heartbeatManager.onBrokerHeartbeat("cluster1", "broker1", "127.0.0.1:7000", 1L,3000L, null,
+            1, 1L,-1L, 0);
+        assertTrue(latch.await(5000, TimeUnit.MILLISECONDS));
+        this.heartbeatManager.shutdown();
+    }
+
+}
\ No newline at end of file
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerManagerTest.java
deleted file mode 100644
index b7a4c32..0000000
--- a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerManagerTest.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.controller.impl.controller;
-
-import java.io.File;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import org.apache.rocketmq.common.ControllerConfig;
-import org.apache.rocketmq.common.UtilAll;
-import org.apache.rocketmq.controller.ControllerManager;
-import org.apache.rocketmq.controller.impl.DLedgerController;
-import org.apache.rocketmq.remoting.RemotingClient;
-import org.apache.rocketmq.remoting.netty.NettyClientConfig;
-import org.apache.rocketmq.remoting.netty.NettyRemotingClient;
-import org.apache.rocketmq.remoting.netty.NettyServerConfig;
-import org.apache.rocketmq.remoting.protocol.RemotingCommand;
-import org.apache.rocketmq.remoting.protocol.RequestCode;
-import org.apache.rocketmq.remoting.protocol.ResponseCode;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.namesrv.BrokerHeartbeatRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.awaitility.Awaitility.await;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public class ControllerManagerTest {
-
-    public static final String STORE_BASE_PATH = System.getProperty("java.io.tmpdir") + File.separator + "ControllerManagerTest";
-
-    public static final String STORE_PATH = STORE_BASE_PATH + File.separator + UUID.randomUUID();
-
-    private List<ControllerManager> controllers;
-    private NettyRemotingClient remotingClient;
-    private NettyRemotingClient remotingClient1;
-
-    public ControllerManager launchManager(final String group, final String peers, final String selfId) {
-        final String path = STORE_PATH + File.separator + group + File.separator + selfId;
-        final ControllerConfig config = new ControllerConfig();
-        config.setControllerDLegerGroup(group);
-        config.setControllerDLegerPeers(peers);
-        config.setControllerDLegerSelfId(selfId);
-        config.setControllerStorePath(path);
-        config.setMappedFileSize(10 * 1024 * 1024);
-        config.setEnableElectUncleanMaster(true);
-        config.setScanNotActiveBrokerInterval(1000L);
-        config.setNotifyBrokerRoleChanged(false);
-
-        final NettyServerConfig serverConfig = new NettyServerConfig();
-
-        final ControllerManager manager = new ControllerManager(config, serverConfig, new NettyClientConfig());
-        manager.initialize();
-        manager.start();
-        this.controllers.add(manager);
-        return manager;
-    }
-
-    @Before
-    public void startup() {
-        UtilAll.deleteFile(new File(STORE_BASE_PATH));
-        this.controllers = new ArrayList<>();
-        this.remotingClient = new NettyRemotingClient(new NettyClientConfig());
-        this.remotingClient.start();
-        this.remotingClient1 = new NettyRemotingClient(new NettyClientConfig());
-        this.remotingClient1.start();
-    }
-
-    public ControllerManager waitLeader(final List<ControllerManager> controllers) throws Exception {
-        if (controllers.isEmpty()) {
-            return null;
-        }
-        DLedgerController c1 = (DLedgerController) controllers.get(0).getController();
-
-        ControllerManager manager = await().atMost(Duration.ofSeconds(10)).until(() -> {
-            String leaderId = c1.getMemberState().getLeaderId();
-            if (null == leaderId) {
-                return null;
-            }
-            for (ControllerManager controllerManager : controllers) {
-                final DLedgerController controller = (DLedgerController) controllerManager.getController();
-                if (controller.getMemberState().getSelfId().equals(leaderId) && controller.isLeaderState()) {
-                    return controllerManager;
-                }
-            }
-            return null;
-        }, item -> item != null);
-        return manager;
-    }
-
-    public void mockData() {
-        String group = UUID.randomUUID().toString();
-        String peers = String.format("n0-localhost:%d;n1-localhost:%d;n2-localhost:%d", 30000, 30001, 30002);
-        launchManager(group, peers, "n0");
-        launchManager(group, peers, "n1");
-        launchManager(group, peers, "n2");
-    }
-
-    /**
-     * Register broker to controller
-     */
-    public void registerBroker(
-        final String controllerAddress, final String clusterName,
-        final String brokerName, final Long brokerId,  final String brokerAddress, final Long expectMasterBrokerId, final RemotingClient client) throws Exception {
-        // Get next brokerId;
-        final GetNextBrokerIdRequestHeader getNextBrokerIdRequestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
-        final RemotingCommand getNextBrokerIdRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_NEXT_BROKER_ID, getNextBrokerIdRequestHeader);
-        final RemotingCommand getNextBrokerIdResponse = client.invokeSync(controllerAddress, getNextBrokerIdRequest, 3000);
-        final GetNextBrokerIdResponseHeader getNextBrokerIdResponseHeader = (GetNextBrokerIdResponseHeader) getNextBrokerIdResponse.decodeCommandCustomHeader(GetNextBrokerIdResponseHeader.class);
-        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
-        assertEquals(ResponseCode.SUCCESS, getNextBrokerIdResponse.getCode());
-        assertEquals(brokerId, getNextBrokerIdResponseHeader.getNextBrokerId());
-
-        // Apply brokerId
-        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, brokerId, registerCheckCode);
-        final RemotingCommand applyBrokerIdRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_APPLY_BROKER_ID, applyBrokerIdRequestHeader);
-        final RemotingCommand applyBrokerIdResponse = client.invokeSync(controllerAddress, applyBrokerIdRequest, 3000);
-        final ApplyBrokerIdResponseHeader applyBrokerIdResponseHeader = (ApplyBrokerIdResponseHeader) applyBrokerIdResponse.decodeCommandCustomHeader(ApplyBrokerIdResponseHeader.class);
-        assertEquals(ResponseCode.SUCCESS, applyBrokerIdResponse.getCode());
-
-        // Register success
-        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, brokerId, brokerAddress);
-        final RemotingCommand registerSuccessRequest = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_REGISTER_BROKER, registerBrokerToControllerRequestHeader);
-        final RemotingCommand registerSuccessResponse = client.invokeSync(controllerAddress, registerSuccessRequest, 3000);
-        final RegisterBrokerToControllerResponseHeader registerBrokerToControllerResponseHeader = (RegisterBrokerToControllerResponseHeader) registerSuccessResponse.decodeCommandCustomHeader(RegisterBrokerToControllerResponseHeader.class);
-        assertEquals(ResponseCode.SUCCESS, registerSuccessResponse.getCode());
-        assertEquals(expectMasterBrokerId, registerBrokerToControllerResponseHeader.getMasterBrokerId());
-    }
-
-    public RemotingCommand brokerTryElect(final String controllerAddress, final String clusterName,
-        final String brokerName, final Long brokerId, final RemotingClient client) throws Exception {
-        final ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
-        final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_ELECT_MASTER, requestHeader);
-        RemotingCommand response = client.invokeSync(controllerAddress, request, 10000);
-        assertNotNull(response);
-        return response;
-    }
-
-    public void sendHeartbeat(final String controllerAddress, final String clusterName, final String brokerName, final Long brokerId,
-                              final String brokerAddress, final Long timeout, final RemotingClient client) throws Exception {
-        final BrokerHeartbeatRequestHeader heartbeatRequestHeader0 = new BrokerHeartbeatRequestHeader();
-        heartbeatRequestHeader0.setBrokerId(brokerId);
-        heartbeatRequestHeader0.setClusterName(clusterName);
-        heartbeatRequestHeader0.setBrokerName(brokerName);
-        heartbeatRequestHeader0.setBrokerAddr(brokerAddress);
-        heartbeatRequestHeader0.setHeartbeatTimeoutMills(timeout);
-        final RemotingCommand heartbeatRequest = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, heartbeatRequestHeader0);
-        RemotingCommand remotingCommand = client.invokeSync(controllerAddress, heartbeatRequest, 3000);
-        assertEquals(ResponseCode.SUCCESS, remotingCommand.getCode());
-    }
-
-    @Test
-    public void testSomeApi() throws Exception {
-        mockData();
-        final ControllerManager leader = waitLeader(this.controllers);
-        String leaderAddr = "localhost" + ":" + leader.getController().getRemotingServer().localListenPort();
-
-        // Register two broker
-        registerBroker(leaderAddr, "cluster1", "broker1", 1L, "127.0.0.1:8000", null, this.remotingClient);
-
-        registerBroker(leaderAddr, "cluster1", "broker1", 2L, "127.0.0.1:8001", null, this.remotingClient1);
-
-        // Send heartbeat
-        sendHeartbeat(leaderAddr, "cluster1", "broker1", 1L, "127.0.0.1:8000", 3000L, remotingClient);
-        sendHeartbeat(leaderAddr, "cluster1", "broker1", 2L, "127.0.0.1:8001", 3000L, remotingClient1);
-
-        // Two all try elect itself as master, but only the first can be the master
-        RemotingCommand tryElectCommand1 = brokerTryElect(leaderAddr, "cluster1", "broker1", 1L, this.remotingClient);
-        ElectMasterResponseHeader brokerTryElectResponseHeader1 = (ElectMasterResponseHeader) tryElectCommand1.decodeCommandCustomHeader(ElectMasterResponseHeader.class);
-        RemotingCommand tryElectCommand2 = brokerTryElect(leaderAddr, "cluster1", "broker1", 2L, this.remotingClient1);
-        ElectMasterResponseHeader brokerTryElectResponseHeader2 = (ElectMasterResponseHeader) tryElectCommand2.decodeCommandCustomHeader(ElectMasterResponseHeader.class);
-
-        assertEquals(ResponseCode.SUCCESS, tryElectCommand1.getCode());
-        assertEquals(1L, brokerTryElectResponseHeader1.getMasterBrokerId().longValue());
-        assertEquals("127.0.0.1:8000", brokerTryElectResponseHeader1.getMasterAddress());
-        assertEquals(1, brokerTryElectResponseHeader1.getMasterEpoch().intValue());
-        assertEquals(1, brokerTryElectResponseHeader1.getSyncStateSetEpoch().intValue());
-
-        assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, tryElectCommand2.getCode());
-        assertEquals(1L, brokerTryElectResponseHeader2.getMasterBrokerId().longValue());
-        assertEquals("127.0.0.1:8000", brokerTryElectResponseHeader2.getMasterAddress());
-        assertEquals(1, brokerTryElectResponseHeader2.getMasterEpoch().intValue());
-        assertEquals(1, brokerTryElectResponseHeader2.getSyncStateSetEpoch().intValue());
-
-        // Send heartbeat for broker2 every one second
-        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
-        executor.scheduleAtFixedRate(() -> {
-            final BrokerHeartbeatRequestHeader heartbeatRequestHeader = new BrokerHeartbeatRequestHeader();
-            heartbeatRequestHeader.setClusterName("cluster1");
-            heartbeatRequestHeader.setBrokerName("broker1");
-            heartbeatRequestHeader.setBrokerAddr("127.0.0.1:8001");
-            heartbeatRequestHeader.setBrokerId(2L);
-            heartbeatRequestHeader.setHeartbeatTimeoutMills(3000L);
-            final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.BROKER_HEARTBEAT, heartbeatRequestHeader);
-            try {
-                final RemotingCommand remotingCommand = this.remotingClient1.invokeSync(leaderAddr, request, 3000);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }, 0, 1000L, TimeUnit.MILLISECONDS);
-        Boolean flag = await().atMost(Duration.ofSeconds(10)).until(() -> {
-            final GetReplicaInfoRequestHeader requestHeader = new GetReplicaInfoRequestHeader("broker1");
-            final RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONTROLLER_GET_REPLICA_INFO, requestHeader);
-            final RemotingCommand response = this.remotingClient1.invokeSync(leaderAddr, request, 3000);
-            final GetReplicaInfoResponseHeader responseHeader = (GetReplicaInfoResponseHeader) response.decodeCommandCustomHeader(GetReplicaInfoResponseHeader.class);
-            return responseHeader.getMasterBrokerId().equals(2L);
-        }, item -> item);
-
-        // The new master should be broker2.
-        assertTrue(flag);
-
-        executor.shutdown();
-    }
-
-    @After
-    public void tearDown() {
-        for (ControllerManager controller : this.controllers) {
-            controller.shutdown();
-        }
-        UtilAll.deleteFile(new File(STORE_BASE_PATH));
-        this.remotingClient.shutdown();
-        this.remotingClient1.shutdown();
-    }
-}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerTestBase.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerTestBase.java
deleted file mode 100644
index 9b8fa75..0000000
--- a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/ControllerTestBase.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.rocketmq.controller.impl.controller;
-
-public class ControllerTestBase {
-
-    public final static String DEFAULT_CLUSTER_NAME = "cluster-a";
-
-    public final static String DEFAULT_BROKER_NAME = "broker-set-a";
-
-    public final static String[] DEFAULT_IP = {"127.0.0.1:9000", "127.0.0.1:9001", "127.0.0.1:9002"};
-}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DLedgerControllerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DLedgerControllerTest.java
deleted file mode 100644
index 3bffad6..0000000
--- a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DLedgerControllerTest.java
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.controller.impl.controller.impl;
-
-import io.openmessaging.storage.dledger.DLedgerConfig;
-import java.io.File;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
-
-import org.apache.commons.lang3.StringUtils;
-import org.apache.rocketmq.common.ControllerConfig;
-import org.apache.rocketmq.controller.Controller;
-import org.apache.rocketmq.controller.elect.impl.DefaultElectPolicy;
-import org.apache.rocketmq.controller.impl.DLedgerController;
-import org.apache.rocketmq.remoting.protocol.RemotingCommand;
-import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
-import org.apache.rocketmq.remoting.protocol.ResponseCode;
-import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
-import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_BROKER_NAME;
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_CLUSTER_NAME;
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_IP;
-import static org.awaitility.Awaitility.await;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public class DLedgerControllerTest {
-    private List<String> baseDirs;
-    private List<DLedgerController> controllers;
-
-    public DLedgerController launchController(final String group, final String peers, final String selfId,
-        String storeType, final boolean isEnableElectUncleanMaster) {
-        String tmpdir = System.getProperty("java.io.tmpdir");
-        final String path = (StringUtils.endsWith(tmpdir, File.separator) ? tmpdir : tmpdir + File.separator) + group + File.separator + selfId;
-        baseDirs.add(path);
-
-        final ControllerConfig config = new ControllerConfig();
-        config.setControllerDLegerGroup(group);
-        config.setControllerDLegerPeers(peers);
-        config.setControllerDLegerSelfId(selfId);
-        config.setControllerStorePath(path);
-        config.setMappedFileSize(10 * 1024 * 1024);
-        config.setEnableElectUncleanMaster(isEnableElectUncleanMaster);
-
-        final DLedgerController controller = new DLedgerController(config, (str1, str2, str3) -> true);
-
-        controller.startup();
-        return controller;
-    }
-
-    @Before
-    public void startup() {
-        this.baseDirs = new ArrayList<>();
-        this.controllers = new ArrayList<>();
-    }
-
-    @After
-    public void tearDown() {
-        for (Controller controller : this.controllers) {
-            controller.shutdown();
-        }
-        for (String dir : this.baseDirs) {
-            new File(dir).delete();
-        }
-    }
-
-    public void registerNewBroker(Controller leader, String clusterName, String brokerName, String brokerAddress,
-        Long expectBrokerId) throws Exception {
-        // Get next brokerId
-        final GetNextBrokerIdRequestHeader getNextBrokerIdRequest = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
-        RemotingCommand remotingCommand = leader.getNextBrokerId(getNextBrokerIdRequest).get(2, TimeUnit.SECONDS);
-        GetNextBrokerIdResponseHeader getNextBrokerIdResp = (GetNextBrokerIdResponseHeader) remotingCommand.readCustomHeader();
-        Long nextBrokerId = getNextBrokerIdResp.getNextBrokerId();
-        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
-
-        // Check response
-        assertEquals(expectBrokerId, nextBrokerId);
-
-        // Apply brokerId
-        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, nextBrokerId, registerCheckCode);
-        RemotingCommand remotingCommand1 = leader.applyBrokerId(applyBrokerIdRequestHeader).get(2, TimeUnit.SECONDS);
-
-        // Check response
-        assertEquals(ResponseCode.SUCCESS, remotingCommand1.getCode());
-
-        // Register success
-        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, nextBrokerId, brokerAddress);
-        RemotingCommand remotingCommand2 = leader.registerBroker(registerBrokerToControllerRequestHeader).get(2, TimeUnit.SECONDS);
-
-
-        assertEquals(ResponseCode.SUCCESS, remotingCommand2.getCode());
-    }
-
-    public void brokerTryElectMaster(Controller leader, String clusterName, String brokerName, String brokerAddress, Long brokerId,
-        boolean exceptSuccess) throws Exception {
-        final ElectMasterRequestHeader electMasterRequestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
-        RemotingCommand command = leader.electMaster(electMasterRequestHeader).get(2, TimeUnit.SECONDS);
-        ElectMasterResponseHeader header = (ElectMasterResponseHeader) command.readCustomHeader();
-        assertEquals(exceptSuccess, ResponseCode.SUCCESS == command.getCode());
-    }
-
-    private boolean alterNewInSyncSet(Controller leader, String brokerName, Long masterBrokerId, Integer masterEpoch,
-        Set<Long> newSyncStateSet, Integer syncStateSetEpoch) throws Exception {
-        final AlterSyncStateSetRequestHeader alterRequest =
-            new AlterSyncStateSetRequestHeader(brokerName, masterBrokerId, masterEpoch);
-        final RemotingCommand response = leader.alterSyncStateSet(alterRequest, new SyncStateSet(newSyncStateSet, syncStateSetEpoch)).get(10, TimeUnit.SECONDS);
-        if (null == response || response.getCode() != ResponseCode.SUCCESS) {
-            return false;
-        }
-        final RemotingCommand getInfoResponse = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).get(10, TimeUnit.SECONDS);
-        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) getInfoResponse.readCustomHeader();
-        final SyncStateSet syncStateSet = RemotingSerializable.decode(getInfoResponse.getBody(), SyncStateSet.class);
-        assertArrayEquals(syncStateSet.getSyncStateSet().toArray(), newSyncStateSet.toArray());
-        assertEquals(syncStateSet.getSyncStateSetEpoch(), syncStateSetEpoch + 1);
-        return true;
-    }
-
-    public DLedgerController waitLeader(final List<DLedgerController> controllers) throws Exception {
-        if (controllers.isEmpty()) {
-            return null;
-        }
-        DLedgerController c1 = controllers.get(0);
-        DLedgerController dLedgerController = await().atMost(Duration.ofSeconds(10)).until(() -> {
-            String leaderId = c1.getMemberState().getLeaderId();
-            if (null == leaderId) {
-                return null;
-            }
-            for (DLedgerController controller : controllers) {
-                if (controller.getMemberState().getSelfId().equals(leaderId) && controller.isLeaderState()) {
-                    return controller;
-                }
-            }
-            return null;
-        }, item -> item != null);
-        return dLedgerController;
-    }
-
-    public DLedgerController mockMetaData(boolean enableElectUncleanMaster) throws Exception {
-        String group = UUID.randomUUID().toString();
-        String peers = String.format("n0-localhost:%d;n1-localhost:%d;n2-localhost:%d", 30000, 30001, 30002);
-        DLedgerController c0 = launchController(group, peers, "n0", DLedgerConfig.MEMORY, enableElectUncleanMaster);
-        DLedgerController c1 = launchController(group, peers, "n1", DLedgerConfig.MEMORY, enableElectUncleanMaster);
-        DLedgerController c2 = launchController(group, peers, "n2", DLedgerConfig.MEMORY, enableElectUncleanMaster);
-        controllers.add(c0);
-        controllers.add(c1);
-        controllers.add(c2);
-
-        DLedgerController leader = waitLeader(controllers);
-
-        // register
-        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L);
-        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L);
-        registerNewBroker(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L);
-        // try elect
-        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L,true);
-        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L,  false);
-        brokerTryElectMaster(leader, DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L,false);
-        final RemotingCommand getInfoResponse = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
-        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) getInfoResponse.readCustomHeader();
-        assertEquals(1, replicaInfo.getMasterEpoch().intValue());
-        assertEquals(DEFAULT_IP[0], replicaInfo.getMasterAddress());
-        // Try alter SyncStateSet
-        final HashSet<Long> newSyncStateSet = new HashSet<>();
-        newSyncStateSet.add(1L);
-        newSyncStateSet.add(2L);
-        newSyncStateSet.add(3L);
-        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 1));
-        return leader;
-    }
-
-    public void setBrokerAlivePredicate(DLedgerController controller, Long... deathBroker) {
-        controller.setBrokerAlivePredicate((clusterName, brokerName, brokerId) -> {
-            for (Long broker : deathBroker) {
-                if (broker.equals(brokerId)) {
-                    return false;
-                }
-            }
-            return true;
-        });
-    }
-
-    public void setBrokerElectPolicy(DLedgerController controller, Long... deathBroker) {
-        controller.setElectPolicy(new DefaultElectPolicy((clusterName, brokerName, brokerId) -> {
-            for (Long broker : deathBroker) {
-                if (broker.equals(brokerId)) {
-                    return false;
-                }
-            }
-            return true;
-        }, null));
-    }
-
-    @Test
-    public void testElectMaster() throws Exception {
-        final DLedgerController leader = mockMetaData(false);
-        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        setBrokerElectPolicy(leader, 1L);
-        final RemotingCommand resp = leader.electMaster(request).get(10, TimeUnit.SECONDS);
-        final ElectMasterResponseHeader response = (ElectMasterResponseHeader) resp.readCustomHeader();
-        assertEquals(2, response.getMasterEpoch().intValue());
-        assertNotEquals(1L, response.getMasterBrokerId().longValue());
-        assertNotEquals(DEFAULT_IP[0], response.getMasterAddress());
-    }
-
-    @Test
-    public void testAllReplicasShutdownAndRestartWithUnEnableElectUnCleanMaster() throws Exception {
-        final DLedgerController leader = mockMetaData(false);
-        final HashSet<Long> newSyncStateSet = new HashSet<>();
-        newSyncStateSet.add(1L);
-
-        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
-
-        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
-        // However, the syncStateSet in statemachine is {1}, not more replicas can be elected as master, it will be failed.
-        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        setBrokerElectPolicy(leader, 1L);
-        leader.electMaster(electRequest).get(10, TimeUnit.SECONDS);
-
-        final RemotingCommand resp = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).
-            get(10, TimeUnit.SECONDS);
-        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) resp.readCustomHeader();
-        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
-        assertEquals(syncStateSet.getSyncStateSet(), newSyncStateSet);
-        assertEquals(null, replicaInfo.getMasterAddress());
-        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
-
-        // Now, we start broker - id[2]address[127.0.0.1:9001] to try elect, but it was not in syncStateSet, so it will not be elected as master.
-        final ElectMasterRequestHeader request1 =
-            ElectMasterRequestHeader.ofBrokerTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 2L);
-        final ElectMasterResponseHeader r1 = (ElectMasterResponseHeader) leader.electMaster(request1).get(10, TimeUnit.SECONDS).readCustomHeader();
-        assertEquals(null, r1.getMasterBrokerId());
-        assertEquals(null, r1.getMasterAddress());
-
-        // Now, we start broker - id[1]address[127.0.0.1:9000] to try elect, it will be elected as master
-        setBrokerElectPolicy(leader);
-        final ElectMasterRequestHeader request2 =
-            ElectMasterRequestHeader.ofBrokerTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
-        final ElectMasterResponseHeader r2 = (ElectMasterResponseHeader) leader.electMaster(request2).get(10, TimeUnit.SECONDS).readCustomHeader();
-        assertEquals(1L, r2.getMasterBrokerId().longValue());
-        assertEquals(DEFAULT_IP[0], r2.getMasterAddress());
-        assertEquals(3, r2.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testEnableElectUnCleanMaster() throws Exception {
-        final DLedgerController leader = mockMetaData(true);
-        final HashSet<Long> newSyncStateSet = new HashSet<>();
-        newSyncStateSet.add(1L);
-
-        assertTrue(alterNewInSyncSet(leader, DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
-
-        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
-        // However, event if the syncStateSet in statemachine is {DEFAULT_IP[0]}
-        // the option {enableElectUncleanMaster = true}, so the controller sill can elect a new master
-        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        setBrokerElectPolicy(leader, 1L);
-        final CompletableFuture<RemotingCommand> future = leader.electMaster(electRequest);
-        future.get(10, TimeUnit.SECONDS);
-
-        final RemotingCommand resp = leader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
-        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) resp.readCustomHeader();
-        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
-
-        final HashSet<Long> newSyncStateSet2 = new HashSet<>();
-        newSyncStateSet2.add(replicaInfo.getMasterBrokerId());
-        assertEquals(syncStateSet.getSyncStateSet(), newSyncStateSet2);
-        assertNotEquals(1L, replicaInfo.getMasterBrokerId().longValue());
-        assertNotEquals(DEFAULT_IP[0], replicaInfo.getMasterAddress());
-        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testChangeControllerLeader() throws Exception {
-        final DLedgerController leader = mockMetaData(false);
-        leader.shutdown();
-        this.controllers.remove(leader);
-        // Wait leader again
-        final DLedgerController newLeader = waitLeader(this.controllers);
-        assertNotNull(newLeader);
-
-        RemotingCommand response = await().atMost(Duration.ofSeconds(10)).until(() -> {
-            final RemotingCommand resp = newLeader.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).get(10, TimeUnit.SECONDS);
-            if (resp.getCode() == ResponseCode.SUCCESS) {
-
-                return resp;
-            }
-            return null;
-
-        }, item -> item != null);
-        final GetReplicaInfoResponseHeader replicaInfo = (GetReplicaInfoResponseHeader) response.readCustomHeader();
-        final SyncStateSet syncStateSetResult = RemotingSerializable.decode(response.getBody(), SyncStateSet.class);
-        assertEquals(replicaInfo.getMasterAddress(), DEFAULT_IP[0]);
-        assertEquals(1, replicaInfo.getMasterEpoch().intValue());
-
-        final HashSet<Long> syncStateSet = new HashSet<>();
-        syncStateSet.add(1L);
-        syncStateSet.add(2L);
-        syncStateSet.add(3L);
-        assertEquals(syncStateSetResult.getSyncStateSet(), syncStateSet);
-    }
-}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DefaultBrokerHeartbeatManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DefaultBrokerHeartbeatManagerTest.java
deleted file mode 100644
index 74de637..0000000
--- a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/DefaultBrokerHeartbeatManagerTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.controller.impl.controller.impl;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import org.apache.rocketmq.common.ControllerConfig;
-import org.apache.rocketmq.controller.BrokerHeartbeatManager;
-import org.apache.rocketmq.controller.impl.heartbeat.DefaultBrokerHeartbeatManager;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-
-public class DefaultBrokerHeartbeatManagerTest {
-    private BrokerHeartbeatManager heartbeatManager;
-
-    @Before
-    public void init() {
-        final ControllerConfig config = new ControllerConfig();
-        config.setScanNotActiveBrokerInterval(2000);
-        this.heartbeatManager = new DefaultBrokerHeartbeatManager(config);
-        this.heartbeatManager.initialize();
-        this.heartbeatManager.start();
-    }
-
-    @Test
-    public void testDetectBrokerAlive() throws InterruptedException {
-        final CountDownLatch latch = new CountDownLatch(1);
-        this.heartbeatManager.addBrokerLifecycleListener((clusterName, brokerName, brokerId) -> {
-            latch.countDown();
-        });
-        this.heartbeatManager.onBrokerHeartbeat("cluster1", "broker1", "127.0.0.1:7000", 1L,3000L, null,
-            1, 1L,-1L, 0);
-        assertTrue(latch.await(5000, TimeUnit.MILLISECONDS));
-        this.heartbeatManager.shutdown();
-    }
-
-}
\ No newline at end of file
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/manager/ReplicasInfoManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/manager/ReplicasInfoManagerTest.java
deleted file mode 100644
index f677daf..0000000
--- a/controller/src/test/java/org/apache/rocketmq/controller/impl/controller/impl/manager/ReplicasInfoManagerTest.java
+++ /dev/null
@@ -1,467 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.controller.impl.controller.impl.manager;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.rocketmq.common.ControllerConfig;
-import org.apache.rocketmq.controller.elect.ElectPolicy;
-import org.apache.rocketmq.controller.elect.impl.DefaultElectPolicy;
-import org.apache.rocketmq.controller.helper.BrokerValidPredicate;
-import org.apache.rocketmq.controller.impl.heartbeat.DefaultBrokerHeartbeatManager;
-import org.apache.rocketmq.controller.impl.event.ControllerResult;
-import org.apache.rocketmq.controller.impl.event.ElectMasterEvent;
-import org.apache.rocketmq.controller.impl.event.EventMessage;
-import org.apache.rocketmq.controller.impl.manager.ReplicasInfoManager;
-import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
-import org.apache.rocketmq.remoting.protocol.ResponseCode;
-import org.apache.rocketmq.remoting.protocol.body.BrokerReplicasInfo;
-import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
-import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.admin.CleanControllerBrokerDataRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
-import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_BROKER_NAME;
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_CLUSTER_NAME;
-import static org.apache.rocketmq.controller.impl.controller.ControllerTestBase.DEFAULT_IP;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public class ReplicasInfoManagerTest {
-    private ReplicasInfoManager replicasInfoManager;
-
-    private DefaultBrokerHeartbeatManager heartbeatManager;
-
-    private ControllerConfig config;
-
-
-    @Before
-    public void init() {
-        this.config = new ControllerConfig();
-        this.config.setEnableElectUncleanMaster(false);
-        this.config.setScanNotActiveBrokerInterval(300000000);
-        this.replicasInfoManager = new ReplicasInfoManager(config);
-        this.heartbeatManager = new DefaultBrokerHeartbeatManager(config);
-        this.heartbeatManager.initialize();
-        this.heartbeatManager.start();
-    }
-
-    @After
-    public void destroy() {
-        this.replicasInfoManager = null;
-        this.heartbeatManager.shutdown();
-        this.heartbeatManager = null;
-    }
-
-    private BrokerReplicasInfo.ReplicasInfo getReplicasInfo(String brokerName) {
-        ControllerResult<Void> syncStateData = this.replicasInfoManager.getSyncStateData(Arrays.asList(brokerName));
-        BrokerReplicasInfo replicasInfo = RemotingSerializable.decode(syncStateData.getBody(), BrokerReplicasInfo.class);
-        return replicasInfo.getReplicasInfoTable().get(brokerName);
-    }
-
-    public void registerNewBroker(String clusterName, String brokerName, String brokerAddress,
-                                  Long exceptBrokerId, Long exceptMasterBrokerId) {
-
-        // Get next brokerId
-        final GetNextBrokerIdRequestHeader getNextBrokerIdRequestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
-        final ControllerResult<GetNextBrokerIdResponseHeader> nextBrokerIdResult = this.replicasInfoManager.getNextBrokerId(getNextBrokerIdRequestHeader);
-        Long nextBrokerId = nextBrokerIdResult.getResponse().getNextBrokerId();
-        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
-
-        // check response
-        assertEquals(ResponseCode.SUCCESS, nextBrokerIdResult.getResponseCode());
-        assertEquals(exceptBrokerId, nextBrokerId);
-
-        // Apply brokerId
-        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, nextBrokerId, registerCheckCode);
-        final ControllerResult<ApplyBrokerIdResponseHeader> applyBrokerIdResult = this.replicasInfoManager.applyBrokerId(applyBrokerIdRequestHeader);
-        apply(applyBrokerIdResult.getEvents());
-
-        // check response
-        assertEquals(ResponseCode.SUCCESS, applyBrokerIdResult.getResponseCode());
-
-        // check it in state machine
-        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(brokerName);
-        BrokerReplicasInfo.ReplicaIdentity replicaIdentity = replicasInfo.getNotInSyncReplicas().stream().filter(x -> x.getBrokerId().equals(nextBrokerId)).findFirst().get();
-        assertNotNull(replicaIdentity);
-        assertEquals(brokerName, replicaIdentity.getBrokerName());
-        assertEquals(exceptBrokerId, replicaIdentity.getBrokerId());
-        assertEquals(brokerAddress, replicaIdentity.getBrokerAddress());
-
-        // register success
-        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, exceptBrokerId, brokerAddress);
-        ControllerResult<RegisterBrokerToControllerResponseHeader> registerSuccessResult = this.replicasInfoManager.registerBroker(registerBrokerToControllerRequestHeader, (a, b, c) -> true);
-        apply(registerSuccessResult.getEvents());
-
-        // check response
-        assertEquals(ResponseCode.SUCCESS, registerSuccessResult.getResponseCode());
-        assertEquals(exceptMasterBrokerId, registerSuccessResult.getResponse().getMasterBrokerId());
-
-    }
-    public void brokerElectMaster(String clusterName, Long brokerId, String brokerName, String brokerAddress, boolean isFirstTryElect, boolean expectToBeElected) {
-        this.brokerElectMaster(clusterName, brokerId, brokerName, brokerAddress, isFirstTryElect,expectToBeElected, (a, b, c) -> true);
-    }
-    
-    public void brokerElectMaster(String clusterName, Long brokerId, String brokerName, String brokerAddress, boolean isFirstTryElect, boolean expectToBeElected, BrokerValidPredicate validPredicate) {
-
-        final GetReplicaInfoResponseHeader replicaInfoBefore = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).getResponse();
-        BrokerReplicasInfo.ReplicasInfo syncStateSetInfo = getReplicasInfo(brokerName);
-        // Try elect itself as a master
-        ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
-        final ControllerResult<ElectMasterResponseHeader> result = this.replicasInfoManager.electMaster(requestHeader, new DefaultElectPolicy(validPredicate, null));
-        apply(result.getEvents());
-
-        final GetReplicaInfoResponseHeader replicaInfoAfter = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).getResponse();
-        final ElectMasterResponseHeader response = result.getResponse();
-
-        if (isFirstTryElect) {
-            // it should be elected
-            // check response
-            assertEquals(ResponseCode.SUCCESS, result.getResponseCode());
-            assertEquals(1, response.getMasterEpoch().intValue());
-            assertEquals(1, response.getSyncStateSetEpoch().intValue());
-            assertEquals(brokerAddress, response.getMasterAddress());
-            assertEquals(brokerId, response.getMasterBrokerId());
-            // check it in state machine
-            assertEquals(brokerAddress, replicaInfoAfter.getMasterAddress());
-            assertEquals(1, replicaInfoAfter.getMasterEpoch().intValue());
-            assertEquals(brokerId, replicaInfoAfter.getMasterBrokerId());
-        } else {
-
-            // failed because now master still exist
-            if (replicaInfoBefore.getMasterBrokerId() != null && validPredicate.check(clusterName, brokerName, replicaInfoBefore.getMasterBrokerId())) {
-                assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, result.getResponseCode());
-                assertEquals(replicaInfoBefore.getMasterAddress(), response.getMasterAddress());
-                assertEquals(replicaInfoBefore.getMasterEpoch(), response.getMasterEpoch());
-                assertEquals(replicaInfoBefore.getMasterBrokerId(), response.getMasterBrokerId());
-                assertEquals(replicaInfoBefore.getMasterBrokerId(), replicaInfoAfter.getMasterBrokerId());
-                return;
-            }
-            if (syncStateSetInfo.isExistInSync(brokerName, brokerId, brokerAddress) || this.config.isEnableElectUncleanMaster()) {
-                // a new master can be elected successfully
-                assertEquals(ResponseCode.SUCCESS, result.getResponseCode());
-                assertEquals(replicaInfoBefore.getMasterEpoch() + 1, replicaInfoAfter.getMasterEpoch().intValue());
-                
-                if (expectToBeElected) {
-                    assertEquals(brokerAddress, response.getMasterAddress());
-                    assertEquals(brokerId, response.getMasterBrokerId());
-                    assertEquals(brokerAddress, replicaInfoAfter.getMasterAddress());
-                    assertEquals(brokerId, replicaInfoAfter.getMasterBrokerId());
-                }
-
-            } else {
-                // failed because elect nothing
-                assertEquals(ResponseCode.CONTROLLER_ELECT_MASTER_FAILED, result.getResponseCode());
-            }
-        }
-    }
-
-    private boolean alterNewInSyncSet(String brokerName, Long brokerId, Integer masterEpoch,
-        Set<Long> newSyncStateSet, Integer syncStateSetEpoch) {
-        final AlterSyncStateSetRequestHeader alterRequest =
-            new AlterSyncStateSetRequestHeader(brokerName, brokerId, masterEpoch);
-        final ControllerResult<AlterSyncStateSetResponseHeader> result = this.replicasInfoManager.alterSyncStateSet(alterRequest,
-                new SyncStateSet(newSyncStateSet, syncStateSetEpoch), (cluster, brokerName1, brokerId1) -> true);
-        apply(result.getEvents());
-
-        final ControllerResult<GetReplicaInfoResponseHeader> resp = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName));
-        final GetReplicaInfoResponseHeader replicaInfo = resp.getResponse();
-        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
-
-        assertArrayEquals(syncStateSet.getSyncStateSet().toArray(), newSyncStateSet.toArray());
-        assertEquals(syncStateSet.getSyncStateSetEpoch(), syncStateSetEpoch + 1);
-        return true;
-    }
-
-    private void apply(final List<EventMessage> events) {
-        for (EventMessage event : events) {
-            this.replicasInfoManager.applyEvent(event);
-        }
-    }
-
-    public void mockMetaData() {
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, null);
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, null);
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, null);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 1L, DEFAULT_BROKER_NAME, DEFAULT_IP[0], true, true);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 2L, DEFAULT_BROKER_NAME, DEFAULT_IP[1], false, false);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, false);
-        final HashSet<Long> newSyncStateSet = new HashSet<>();
-        newSyncStateSet.add(1L);
-        newSyncStateSet.add(2L);
-        newSyncStateSet.add(3L);
-        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 1));
-    }
-
-    public void mockHeartbeatDataMasterStillAlive() {
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, 10000000000L, null,
-            1, 1L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
-            1, 2L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
-            1, 3L, -1L, 0);
-    }
-
-    public void mockHeartbeatDataHigherEpoch() {
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
-            1, 3L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
-            1, 2L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
-            0, 3L, -1L, 0);
-    }
-
-    public void mockHeartbeatDataHigherOffset() {
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
-            1, 3L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
-            1, 2L, -1L, 0);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
-            1, 3L, -1L, 0);
-    }
-
-    public void mockHeartbeatDataHigherPriority() {
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
-            1, 3L, -1L, 3);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
-            1, 3L, -1L, 2);
-        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
-            1, 3L, -1L, 1);
-    }
-
-    @Test
-    public void testRegisterBrokerSuccess() {
-        mockMetaData();
-
-        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
-        assertEquals(1L, replicasInfo.getMasterBrokerId().longValue());
-        assertEquals(DEFAULT_IP[0], replicasInfo.getMasterAddress());
-        assertEquals(1, replicasInfo.getMasterEpoch());
-        assertEquals(2, replicasInfo.getSyncStateSetEpoch());
-        assertEquals(3, replicasInfo.getInSyncReplicas().size());
-        assertEquals(0, replicasInfo.getNotInSyncReplicas().size());
-    }
-
-    @Test
-    public void testRegisterWithMasterExistResp() {
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, null);
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, null);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 1L, DEFAULT_BROKER_NAME, DEFAULT_IP[0], true, true);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 2L, DEFAULT_BROKER_NAME, DEFAULT_IP[1], false, false);
-        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 1L);
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, false);
-
-        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
-        assertEquals(1L, replicasInfo.getMasterBrokerId().longValue());
-        assertEquals(DEFAULT_IP[0], replicasInfo.getMasterAddress());
-        assertEquals(1, replicasInfo.getMasterEpoch());
-        assertEquals(1, replicasInfo.getSyncStateSetEpoch());
-        assertEquals(1, replicasInfo.getInSyncReplicas().size());
-        assertEquals(2, replicasInfo.getNotInSyncReplicas().size());
-    }
-
-    @Test
-    public void testRegisterWithOldMasterInactive() {
-        mockMetaData();
-        // If now only broker-3 alive, it will be elected to be a new master
-        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, true, (a, b, c) -> c.equals(3L));
-
-        // Check in statemachine
-        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
-        assertEquals(3L, replicasInfo.getMasterBrokerId().longValue());
-        assertEquals(DEFAULT_IP[2], replicasInfo.getMasterAddress());
-        assertEquals(2, replicasInfo.getMasterEpoch());
-        assertEquals(3, replicasInfo.getSyncStateSetEpoch());
-        assertEquals(1, replicasInfo.getInSyncReplicas().size());
-        assertEquals(2, replicasInfo.getNotInSyncReplicas().size());
-    }
-
-    @Test
-    public void testElectMasterOldMasterStillAlive() {
-        mockMetaData();
-        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
-        mockHeartbeatDataMasterStillAlive();
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
-            electPolicy);
-        assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, cResult.getResponseCode());
-    }
-
-    @Test
-    public void testElectMasterPreferHigherEpoch() {
-        mockMetaData();
-        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
-        mockHeartbeatDataHigherEpoch();
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
-            electPolicy);
-        final ElectMasterResponseHeader response = cResult.getResponse();
-        assertEquals(DEFAULT_IP[1], response.getMasterAddress());
-        assertEquals(2L, response.getMasterBrokerId().longValue());
-        assertEquals(2, response.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testElectMasterPreferHigherOffsetWhenEpochEquals() {
-        mockMetaData();
-        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
-        mockHeartbeatDataHigherOffset();
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
-            electPolicy);
-        final ElectMasterResponseHeader response = cResult.getResponse();
-        assertEquals(DEFAULT_IP[2], response.getMasterAddress());
-        assertEquals(3L, response.getMasterBrokerId().longValue());
-        assertEquals(2, response.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testElectMasterPreferHigherPriorityWhenEpochAndOffsetEquals() {
-        mockMetaData();
-        final ElectMasterRequestHeader request = new ElectMasterRequestHeader(DEFAULT_BROKER_NAME);
-        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
-        mockHeartbeatDataHigherPriority();
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
-            electPolicy);
-        final ElectMasterResponseHeader response = cResult.getResponse();
-        assertEquals(DEFAULT_IP[2], response.getMasterAddress());
-        assertEquals(3L, response.getMasterBrokerId().longValue());
-        assertEquals(2, response.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testElectMaster() {
-        mockMetaData();
-        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
-            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
-        final ElectMasterResponseHeader response = cResult.getResponse();
-        assertEquals(2, response.getMasterEpoch().intValue());
-        assertNotEquals(1L, response.getMasterBrokerId().longValue());
-        assertNotEquals(DEFAULT_IP[0], response.getMasterAddress());
-        apply(cResult.getEvents());
-
-        final Set<Long> brokerSet = new HashSet<>();
-        brokerSet.add(1L);
-        brokerSet.add(2L);
-        brokerSet.add(3L);
-        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, response.getMasterBrokerId(), response.getMasterEpoch(), brokerSet, response.getSyncStateSetEpoch()));
-
-        // test admin try to elect a assignedMaster, but it isn't alive
-        final ElectMasterRequestHeader assignRequest = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
-        final ControllerResult<ElectMasterResponseHeader> cResult1 = this.replicasInfoManager.electMaster(assignRequest,
-            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
-
-        assertEquals(cResult1.getResponseCode(), ResponseCode.CONTROLLER_ELECT_MASTER_FAILED);
-
-        // test admin try to elect a assignedMaster but old master still alive, and the old master is equals to assignedMaster
-        final ElectMasterRequestHeader assignRequest1 = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, response.getMasterBrokerId());
-        final ControllerResult<ElectMasterResponseHeader> cResult2 = this.replicasInfoManager.electMaster(assignRequest1,
-            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> true, null));
-        assertEquals(cResult2.getResponseCode(), ResponseCode.CONTROLLER_MASTER_STILL_EXIST);
-
-        // admin successful elect a assignedMaster.
-        final ElectMasterRequestHeader assignRequest2 = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
-        final ControllerResult<ElectMasterResponseHeader> cResult3 = this.replicasInfoManager.electMaster(assignRequest2,
-            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(response.getMasterBrokerId()), null));
-        assertEquals(cResult3.getResponseCode(), ResponseCode.SUCCESS);
-
-        final ElectMasterResponseHeader response3 = cResult3.getResponse();
-        assertEquals(1L, response3.getMasterBrokerId().longValue());
-        assertEquals(DEFAULT_IP[0], response3.getMasterAddress());
-        assertEquals(3, response3.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testAllReplicasShutdownAndRestart() {
-        mockMetaData();
-        final HashSet<Long> newSyncStateSet = new HashSet<>();
-        newSyncStateSet.add(1L);
-        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
-
-        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
-        // However, the syncStateSet in statemachine is {DEFAULT_IP[0]}, not more replicas can be elected as master, it will be failed.
-        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
-        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(electRequest,
-            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
-        final List<EventMessage> events = cResult.getEvents();
-        assertEquals(events.size(), 1);
-        final ElectMasterEvent event = (ElectMasterEvent) events.get(0);
-        assertFalse(event.getNewMasterElected());
-
-        apply(cResult.getEvents());
-
-        final GetReplicaInfoResponseHeader replicaInfo = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).getResponse();
-        assertEquals(replicaInfo.getMasterAddress(), null);
-        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
-    }
-
-    @Test
-    public void testCleanBrokerData() {
-        mockMetaData();
-        CleanControllerBrokerDataRequestHeader header1 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1");
-        ControllerResult<Void> result1 = this.replicasInfoManager.cleanBrokerData(header1, (cluster, brokerName, brokerId) -> true);
-        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result1.getResponseCode());
-
-        CleanControllerBrokerDataRequestHeader header2 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, null);
-        ControllerResult<Void> result2 = this.replicasInfoManager.cleanBrokerData(header2, (cluster, brokerName, brokerId) -> true);
-        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result2.getResponseCode());
-        assertEquals("Broker broker-set-a is still alive, clean up failure", result2.getRemark());
-
-        CleanControllerBrokerDataRequestHeader header3 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1");
-        ControllerResult<Void> result3 = this.replicasInfoManager.cleanBrokerData(header3, (cluster, brokerName, brokerId) -> false);
-        assertEquals(ResponseCode.SUCCESS, result3.getResponseCode());
-
-        CleanControllerBrokerDataRequestHeader header4 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1;2;3");
-        ControllerResult<Void> result4 = this.replicasInfoManager.cleanBrokerData(header4, (cluster, brokerName, brokerId) -> false);
-        assertEquals(ResponseCode.SUCCESS, result4.getResponseCode());
-
-        CleanControllerBrokerDataRequestHeader header5 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, "broker12", "1;2;3", true);
-        ControllerResult<Void> result5 = this.replicasInfoManager.cleanBrokerData(header5, (cluster, brokerName, brokerId) -> false);
-        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result5.getResponseCode());
-        assertEquals("Broker broker12 is not existed,clean broker data failure.", result5.getRemark());
-
-        CleanControllerBrokerDataRequestHeader header6 = new CleanControllerBrokerDataRequestHeader(null, "broker12", "1;2;3", true);
-        ControllerResult<Void> result6 = this.replicasInfoManager.cleanBrokerData(header6, (cluster, brokerName, brokerId) -> cluster != null);
-        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result6.getResponseCode());
-
-        CleanControllerBrokerDataRequestHeader header7 = new CleanControllerBrokerDataRequestHeader(null, DEFAULT_BROKER_NAME, "1;2;3", true);
-        ControllerResult<Void> result7 = this.replicasInfoManager.cleanBrokerData(header7, (cluster, brokerName, brokerId) -> false);
-        assertEquals(ResponseCode.SUCCESS, result7.getResponseCode());
-
-    }
-}
diff --git a/controller/src/test/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManagerTest.java b/controller/src/test/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManagerTest.java
new file mode 100644
index 0000000..19411e7
--- /dev/null
+++ b/controller/src/test/java/org/apache/rocketmq/controller/impl/manager/ReplicasInfoManagerTest.java
@@ -0,0 +1,466 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.controller.impl.manager;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.rocketmq.common.ControllerConfig;
+import org.apache.rocketmq.controller.elect.ElectPolicy;
+import org.apache.rocketmq.controller.elect.impl.DefaultElectPolicy;
+import org.apache.rocketmq.controller.helper.BrokerValidPredicate;
+import org.apache.rocketmq.controller.impl.heartbeat.DefaultBrokerHeartbeatManager;
+import org.apache.rocketmq.controller.impl.event.ControllerResult;
+import org.apache.rocketmq.controller.impl.event.ElectMasterEvent;
+import org.apache.rocketmq.controller.impl.event.EventMessage;
+import org.apache.rocketmq.remoting.protocol.RemotingSerializable;
+import org.apache.rocketmq.remoting.protocol.ResponseCode;
+import org.apache.rocketmq.remoting.protocol.body.BrokerReplicasInfo;
+import org.apache.rocketmq.remoting.protocol.body.SyncStateSet;
+import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.AlterSyncStateSetResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.admin.CleanControllerBrokerDataRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.ElectMasterResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.GetReplicaInfoResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.ApplyBrokerIdResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.GetNextBrokerIdResponseHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerRequestHeader;
+import org.apache.rocketmq.remoting.protocol.header.controller.register.RegisterBrokerToControllerResponseHeader;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_BROKER_NAME;
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_CLUSTER_NAME;
+import static org.apache.rocketmq.controller.ControllerTestBase.DEFAULT_IP;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ReplicasInfoManagerTest {
+    private ReplicasInfoManager replicasInfoManager;
+
+    private DefaultBrokerHeartbeatManager heartbeatManager;
+
+    private ControllerConfig config;
+
+
+    @Before
+    public void init() {
+        this.config = new ControllerConfig();
+        this.config.setEnableElectUncleanMaster(false);
+        this.config.setScanNotActiveBrokerInterval(300000000);
+        this.replicasInfoManager = new ReplicasInfoManager(config);
+        this.heartbeatManager = new DefaultBrokerHeartbeatManager(config);
+        this.heartbeatManager.initialize();
+        this.heartbeatManager.start();
+    }
+
+    @After
+    public void destroy() {
+        this.replicasInfoManager = null;
+        this.heartbeatManager.shutdown();
+        this.heartbeatManager = null;
+    }
+
+    private BrokerReplicasInfo.ReplicasInfo getReplicasInfo(String brokerName) {
+        ControllerResult<Void> syncStateData = this.replicasInfoManager.getSyncStateData(Arrays.asList(brokerName));
+        BrokerReplicasInfo replicasInfo = RemotingSerializable.decode(syncStateData.getBody(), BrokerReplicasInfo.class);
+        return replicasInfo.getReplicasInfoTable().get(brokerName);
+    }
+
+    public void registerNewBroker(String clusterName, String brokerName, String brokerAddress,
+                                  Long exceptBrokerId, Long exceptMasterBrokerId) {
+
+        // Get next brokerId
+        final GetNextBrokerIdRequestHeader getNextBrokerIdRequestHeader = new GetNextBrokerIdRequestHeader(clusterName, brokerName);
+        final ControllerResult<GetNextBrokerIdResponseHeader> nextBrokerIdResult = this.replicasInfoManager.getNextBrokerId(getNextBrokerIdRequestHeader);
+        Long nextBrokerId = nextBrokerIdResult.getResponse().getNextBrokerId();
+        String registerCheckCode = brokerAddress + ";" + System.currentTimeMillis();
+
+        // check response
+        assertEquals(ResponseCode.SUCCESS, nextBrokerIdResult.getResponseCode());
+        assertEquals(exceptBrokerId, nextBrokerId);
+
+        // Apply brokerId
+        final ApplyBrokerIdRequestHeader applyBrokerIdRequestHeader = new ApplyBrokerIdRequestHeader(clusterName, brokerName, nextBrokerId, registerCheckCode);
+        final ControllerResult<ApplyBrokerIdResponseHeader> applyBrokerIdResult = this.replicasInfoManager.applyBrokerId(applyBrokerIdRequestHeader);
+        apply(applyBrokerIdResult.getEvents());
+
+        // check response
+        assertEquals(ResponseCode.SUCCESS, applyBrokerIdResult.getResponseCode());
+
+        // check it in state machine
+        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(brokerName);
+        BrokerReplicasInfo.ReplicaIdentity replicaIdentity = replicasInfo.getNotInSyncReplicas().stream().filter(x -> x.getBrokerId().equals(nextBrokerId)).findFirst().get();
+        assertNotNull(replicaIdentity);
+        assertEquals(brokerName, replicaIdentity.getBrokerName());
+        assertEquals(exceptBrokerId, replicaIdentity.getBrokerId());
+        assertEquals(brokerAddress, replicaIdentity.getBrokerAddress());
+
+        // register success
+        final RegisterBrokerToControllerRequestHeader registerBrokerToControllerRequestHeader = new RegisterBrokerToControllerRequestHeader(clusterName, brokerName, exceptBrokerId, brokerAddress);
+        ControllerResult<RegisterBrokerToControllerResponseHeader> registerSuccessResult = this.replicasInfoManager.registerBroker(registerBrokerToControllerRequestHeader, (a, b, c) -> true);
+        apply(registerSuccessResult.getEvents());
+
+        // check response
+        assertEquals(ResponseCode.SUCCESS, registerSuccessResult.getResponseCode());
+        assertEquals(exceptMasterBrokerId, registerSuccessResult.getResponse().getMasterBrokerId());
+
+    }
+    public void brokerElectMaster(String clusterName, Long brokerId, String brokerName, String brokerAddress, boolean isFirstTryElect, boolean expectToBeElected) {
+        this.brokerElectMaster(clusterName, brokerId, brokerName, brokerAddress, isFirstTryElect,expectToBeElected, (a, b, c) -> true);
+    }
+    
+    public void brokerElectMaster(String clusterName, Long brokerId, String brokerName, String brokerAddress, boolean isFirstTryElect, boolean expectToBeElected, BrokerValidPredicate validPredicate) {
+
+        final GetReplicaInfoResponseHeader replicaInfoBefore = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).getResponse();
+        BrokerReplicasInfo.ReplicasInfo syncStateSetInfo = getReplicasInfo(brokerName);
+        // Try elect itself as a master
+        ElectMasterRequestHeader requestHeader = ElectMasterRequestHeader.ofBrokerTrigger(clusterName, brokerName, brokerId);
+        final ControllerResult<ElectMasterResponseHeader> result = this.replicasInfoManager.electMaster(requestHeader, new DefaultElectPolicy(validPredicate, null));
+        apply(result.getEvents());
+
+        final GetReplicaInfoResponseHeader replicaInfoAfter = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName)).getResponse();
+        final ElectMasterResponseHeader response = result.getResponse();
+
+        if (isFirstTryElect) {
+            // it should be elected
+            // check response
+            assertEquals(ResponseCode.SUCCESS, result.getResponseCode());
+            assertEquals(1, response.getMasterEpoch().intValue());
+            assertEquals(1, response.getSyncStateSetEpoch().intValue());
+            assertEquals(brokerAddress, response.getMasterAddress());
+            assertEquals(brokerId, response.getMasterBrokerId());
+            // check it in state machine
+            assertEquals(brokerAddress, replicaInfoAfter.getMasterAddress());
+            assertEquals(1, replicaInfoAfter.getMasterEpoch().intValue());
+            assertEquals(brokerId, replicaInfoAfter.getMasterBrokerId());
+        } else {
+
+            // failed because now master still exist
+            if (replicaInfoBefore.getMasterBrokerId() != null && validPredicate.check(clusterName, brokerName, replicaInfoBefore.getMasterBrokerId())) {
+                assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, result.getResponseCode());
+                assertEquals(replicaInfoBefore.getMasterAddress(), response.getMasterAddress());
+                assertEquals(replicaInfoBefore.getMasterEpoch(), response.getMasterEpoch());
+                assertEquals(replicaInfoBefore.getMasterBrokerId(), response.getMasterBrokerId());
+                assertEquals(replicaInfoBefore.getMasterBrokerId(), replicaInfoAfter.getMasterBrokerId());
+                return;
+            }
+            if (syncStateSetInfo.isExistInSync(brokerName, brokerId, brokerAddress) || this.config.isEnableElectUncleanMaster()) {
+                // a new master can be elected successfully
+                assertEquals(ResponseCode.SUCCESS, result.getResponseCode());
+                assertEquals(replicaInfoBefore.getMasterEpoch() + 1, replicaInfoAfter.getMasterEpoch().intValue());
+                
+                if (expectToBeElected) {
+                    assertEquals(brokerAddress, response.getMasterAddress());
+                    assertEquals(brokerId, response.getMasterBrokerId());
+                    assertEquals(brokerAddress, replicaInfoAfter.getMasterAddress());
+                    assertEquals(brokerId, replicaInfoAfter.getMasterBrokerId());
+                }
+
+            } else {
+                // failed because elect nothing
+                assertEquals(ResponseCode.CONTROLLER_ELECT_MASTER_FAILED, result.getResponseCode());
+            }
+        }
+    }
+
+    private boolean alterNewInSyncSet(String brokerName, Long brokerId, Integer masterEpoch,
+        Set<Long> newSyncStateSet, Integer syncStateSetEpoch) {
+        final AlterSyncStateSetRequestHeader alterRequest =
+            new AlterSyncStateSetRequestHeader(brokerName, brokerId, masterEpoch);
+        final ControllerResult<AlterSyncStateSetResponseHeader> result = this.replicasInfoManager.alterSyncStateSet(alterRequest,
+                new SyncStateSet(newSyncStateSet, syncStateSetEpoch), (cluster, brokerName1, brokerId1) -> true);
+        apply(result.getEvents());
+
+        final ControllerResult<GetReplicaInfoResponseHeader> resp = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(brokerName));
+        final GetReplicaInfoResponseHeader replicaInfo = resp.getResponse();
+        final SyncStateSet syncStateSet = RemotingSerializable.decode(resp.getBody(), SyncStateSet.class);
+
+        assertArrayEquals(syncStateSet.getSyncStateSet().toArray(), newSyncStateSet.toArray());
+        assertEquals(syncStateSet.getSyncStateSetEpoch(), syncStateSetEpoch + 1);
+        return true;
+    }
+
+    private void apply(final List<EventMessage> events) {
+        for (EventMessage event : events) {
+            this.replicasInfoManager.applyEvent(event);
+        }
+    }
+
+    public void mockMetaData() {
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, null);
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, null);
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, null);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 1L, DEFAULT_BROKER_NAME, DEFAULT_IP[0], true, true);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 2L, DEFAULT_BROKER_NAME, DEFAULT_IP[1], false, false);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, false);
+        final HashSet<Long> newSyncStateSet = new HashSet<>();
+        newSyncStateSet.add(1L);
+        newSyncStateSet.add(2L);
+        newSyncStateSet.add(3L);
+        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 1));
+    }
+
+    public void mockHeartbeatDataMasterStillAlive() {
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, 10000000000L, null,
+            1, 1L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
+            1, 2L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
+            1, 3L, -1L, 0);
+    }
+
+    public void mockHeartbeatDataHigherEpoch() {
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
+            1, 3L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
+            1, 2L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
+            0, 3L, -1L, 0);
+    }
+
+    public void mockHeartbeatDataHigherOffset() {
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
+            1, 3L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
+            1, 2L, -1L, 0);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
+            1, 3L, -1L, 0);
+    }
+
+    public void mockHeartbeatDataHigherPriority() {
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, -10000L, null,
+            1, 3L, -1L, 3);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, 10000000000L, null,
+            1, 3L, -1L, 2);
+        this.heartbeatManager.onBrokerHeartbeat(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 10000000000L, null,
+            1, 3L, -1L, 1);
+    }
+
+    @Test
+    public void testRegisterBrokerSuccess() {
+        mockMetaData();
+
+        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
+        assertEquals(1L, replicasInfo.getMasterBrokerId().longValue());
+        assertEquals(DEFAULT_IP[0], replicasInfo.getMasterAddress());
+        assertEquals(1, replicasInfo.getMasterEpoch());
+        assertEquals(2, replicasInfo.getSyncStateSetEpoch());
+        assertEquals(3, replicasInfo.getInSyncReplicas().size());
+        assertEquals(0, replicasInfo.getNotInSyncReplicas().size());
+    }
+
+    @Test
+    public void testRegisterWithMasterExistResp() {
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[0], 1L, null);
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[1], 2L, null);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 1L, DEFAULT_BROKER_NAME, DEFAULT_IP[0], true, true);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 2L, DEFAULT_BROKER_NAME, DEFAULT_IP[1], false, false);
+        registerNewBroker(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, DEFAULT_IP[2], 3L, 1L);
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, false);
+
+        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
+        assertEquals(1L, replicasInfo.getMasterBrokerId().longValue());
+        assertEquals(DEFAULT_IP[0], replicasInfo.getMasterAddress());
+        assertEquals(1, replicasInfo.getMasterEpoch());
+        assertEquals(1, replicasInfo.getSyncStateSetEpoch());
+        assertEquals(1, replicasInfo.getInSyncReplicas().size());
+        assertEquals(2, replicasInfo.getNotInSyncReplicas().size());
+    }
+
+    @Test
+    public void testRegisterWithOldMasterInactive() {
+        mockMetaData();
+        // If now only broker-3 alive, it will be elected to be a new master
+        brokerElectMaster(DEFAULT_CLUSTER_NAME, 3L, DEFAULT_BROKER_NAME, DEFAULT_IP[2], false, true, (a, b, c) -> c.equals(3L));
+
+        // Check in statemachine
+        BrokerReplicasInfo.ReplicasInfo replicasInfo = getReplicasInfo(DEFAULT_BROKER_NAME);
+        assertEquals(3L, replicasInfo.getMasterBrokerId().longValue());
+        assertEquals(DEFAULT_IP[2], replicasInfo.getMasterAddress());
+        assertEquals(2, replicasInfo.getMasterEpoch());
+        assertEquals(3, replicasInfo.getSyncStateSetEpoch());
+        assertEquals(1, replicasInfo.getInSyncReplicas().size());
+        assertEquals(2, replicasInfo.getNotInSyncReplicas().size());
+    }
+
+    @Test
+    public void testElectMasterOldMasterStillAlive() {
+        mockMetaData();
+        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
+        mockHeartbeatDataMasterStillAlive();
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
+            electPolicy);
+        assertEquals(ResponseCode.CONTROLLER_MASTER_STILL_EXIST, cResult.getResponseCode());
+    }
+
+    @Test
+    public void testElectMasterPreferHigherEpoch() {
+        mockMetaData();
+        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
+        mockHeartbeatDataHigherEpoch();
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
+            electPolicy);
+        final ElectMasterResponseHeader response = cResult.getResponse();
+        assertEquals(DEFAULT_IP[1], response.getMasterAddress());
+        assertEquals(2L, response.getMasterBrokerId().longValue());
+        assertEquals(2, response.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testElectMasterPreferHigherOffsetWhenEpochEquals() {
+        mockMetaData();
+        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
+        mockHeartbeatDataHigherOffset();
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
+            electPolicy);
+        final ElectMasterResponseHeader response = cResult.getResponse();
+        assertEquals(DEFAULT_IP[2], response.getMasterAddress());
+        assertEquals(3L, response.getMasterBrokerId().longValue());
+        assertEquals(2, response.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testElectMasterPreferHigherPriorityWhenEpochAndOffsetEquals() {
+        mockMetaData();
+        final ElectMasterRequestHeader request = new ElectMasterRequestHeader(DEFAULT_BROKER_NAME);
+        ElectPolicy electPolicy = new DefaultElectPolicy(this.heartbeatManager::isBrokerActive, this.heartbeatManager::getBrokerLiveInfo);
+        mockHeartbeatDataHigherPriority();
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
+            electPolicy);
+        final ElectMasterResponseHeader response = cResult.getResponse();
+        assertEquals(DEFAULT_IP[2], response.getMasterAddress());
+        assertEquals(3L, response.getMasterBrokerId().longValue());
+        assertEquals(2, response.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testElectMaster() {
+        mockMetaData();
+        final ElectMasterRequestHeader request = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(request,
+            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
+        final ElectMasterResponseHeader response = cResult.getResponse();
+        assertEquals(2, response.getMasterEpoch().intValue());
+        assertNotEquals(1L, response.getMasterBrokerId().longValue());
+        assertNotEquals(DEFAULT_IP[0], response.getMasterAddress());
+        apply(cResult.getEvents());
+
+        final Set<Long> brokerSet = new HashSet<>();
+        brokerSet.add(1L);
+        brokerSet.add(2L);
+        brokerSet.add(3L);
+        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, response.getMasterBrokerId(), response.getMasterEpoch(), brokerSet, response.getSyncStateSetEpoch()));
+
+        // test admin try to elect a assignedMaster, but it isn't alive
+        final ElectMasterRequestHeader assignRequest = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
+        final ControllerResult<ElectMasterResponseHeader> cResult1 = this.replicasInfoManager.electMaster(assignRequest,
+            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
+
+        assertEquals(cResult1.getResponseCode(), ResponseCode.CONTROLLER_ELECT_MASTER_FAILED);
+
+        // test admin try to elect a assignedMaster but old master still alive, and the old master is equals to assignedMaster
+        final ElectMasterRequestHeader assignRequest1 = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, response.getMasterBrokerId());
+        final ControllerResult<ElectMasterResponseHeader> cResult2 = this.replicasInfoManager.electMaster(assignRequest1,
+            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> true, null));
+        assertEquals(cResult2.getResponseCode(), ResponseCode.CONTROLLER_MASTER_STILL_EXIST);
+
+        // admin successful elect a assignedMaster.
+        final ElectMasterRequestHeader assignRequest2 = ElectMasterRequestHeader.ofAdminTrigger(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, 1L);
+        final ControllerResult<ElectMasterResponseHeader> cResult3 = this.replicasInfoManager.electMaster(assignRequest2,
+            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(response.getMasterBrokerId()), null));
+        assertEquals(cResult3.getResponseCode(), ResponseCode.SUCCESS);
+
+        final ElectMasterResponseHeader response3 = cResult3.getResponse();
+        assertEquals(1L, response3.getMasterBrokerId().longValue());
+        assertEquals(DEFAULT_IP[0], response3.getMasterAddress());
+        assertEquals(3, response3.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testAllReplicasShutdownAndRestart() {
+        mockMetaData();
+        final HashSet<Long> newSyncStateSet = new HashSet<>();
+        newSyncStateSet.add(1L);
+        assertTrue(alterNewInSyncSet(DEFAULT_BROKER_NAME, 1L, 1, newSyncStateSet, 2));
+
+        // Now we trigger electMaster api, which means the old master is shutdown and want to elect a new master.
+        // However, the syncStateSet in statemachine is {DEFAULT_IP[0]}, not more replicas can be elected as master, it will be failed.
+        final ElectMasterRequestHeader electRequest = ElectMasterRequestHeader.ofControllerTrigger(DEFAULT_BROKER_NAME);
+        final ControllerResult<ElectMasterResponseHeader> cResult = this.replicasInfoManager.electMaster(electRequest,
+            new DefaultElectPolicy((cluster, brokerName, brokerId)  -> !brokerId.equals(1L), null));
+        final List<EventMessage> events = cResult.getEvents();
+        assertEquals(events.size(), 1);
+        final ElectMasterEvent event = (ElectMasterEvent) events.get(0);
+        assertFalse(event.getNewMasterElected());
+
+        apply(cResult.getEvents());
+
+        final GetReplicaInfoResponseHeader replicaInfo = this.replicasInfoManager.getReplicaInfo(new GetReplicaInfoRequestHeader(DEFAULT_BROKER_NAME)).getResponse();
+        assertEquals(replicaInfo.getMasterAddress(), null);
+        assertEquals(2, replicaInfo.getMasterEpoch().intValue());
+    }
+
+    @Test
+    public void testCleanBrokerData() {
+        mockMetaData();
+        CleanControllerBrokerDataRequestHeader header1 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1");
+        ControllerResult<Void> result1 = this.replicasInfoManager.cleanBrokerData(header1, (cluster, brokerName, brokerId) -> true);
+        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result1.getResponseCode());
+
+        CleanControllerBrokerDataRequestHeader header2 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, null);
+        ControllerResult<Void> result2 = this.replicasInfoManager.cleanBrokerData(header2, (cluster, brokerName, brokerId) -> true);
+        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result2.getResponseCode());
+        assertEquals("Broker broker-set-a is still alive, clean up failure", result2.getRemark());
+
+        CleanControllerBrokerDataRequestHeader header3 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1");
+        ControllerResult<Void> result3 = this.replicasInfoManager.cleanBrokerData(header3, (cluster, brokerName, brokerId) -> false);
+        assertEquals(ResponseCode.SUCCESS, result3.getResponseCode());
+
+        CleanControllerBrokerDataRequestHeader header4 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, DEFAULT_BROKER_NAME, "1;2;3");
+        ControllerResult<Void> result4 = this.replicasInfoManager.cleanBrokerData(header4, (cluster, brokerName, brokerId) -> false);
+        assertEquals(ResponseCode.SUCCESS, result4.getResponseCode());
+
+        CleanControllerBrokerDataRequestHeader header5 = new CleanControllerBrokerDataRequestHeader(DEFAULT_CLUSTER_NAME, "broker12", "1;2;3", true);
+        ControllerResult<Void> result5 = this.replicasInfoManager.cleanBrokerData(header5, (cluster, brokerName, brokerId) -> false);
+        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result5.getResponseCode());
+        assertEquals("Broker broker12 is not existed,clean broker data failure.", result5.getRemark());
+
+        CleanControllerBrokerDataRequestHeader header6 = new CleanControllerBrokerDataRequestHeader(null, "broker12", "1;2;3", true);
+        ControllerResult<Void> result6 = this.replicasInfoManager.cleanBrokerData(header6, (cluster, brokerName, brokerId) -> cluster != null);
+        assertEquals(ResponseCode.CONTROLLER_INVALID_CLEAN_BROKER_METADATA, result6.getResponseCode());
+
+        CleanControllerBrokerDataRequestHeader header7 = new CleanControllerBrokerDataRequestHeader(null, DEFAULT_BROKER_NAME, "1;2;3", true);
+        ControllerResult<Void> result7 = this.replicasInfoManager.cleanBrokerData(header7, (cluster, brokerName, brokerId) -> false);
+        assertEquals(ResponseCode.SUCCESS, result7.getResponseCode());
+
+    }
+}

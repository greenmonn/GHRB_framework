diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherBaseTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherBaseTest.java
new file mode 100644
index 0000000..ba9e2d5
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherBaseTest.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.ConsumeQueue;
+import org.apache.rocketmq.store.DefaultMessageStore;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.common.TieredStoreExecutor;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+@Ignore
+public abstract class TieredDispatcherBaseTest {
+    private TieredMessageStoreConfig storeConfig;
+    private MessageQueue mq;
+    private TieredMetadataStore metadataStore;
+
+    protected final String storePath = FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID();
+
+    public abstract TieredMessageStoreConfig createTieredMessageStoreConfig();
+
+    public abstract TieredFileSegment createTieredFileSegment(TieredFileSegment.FileSegmentType type, MessageQueue mq, long baseOffset, TieredMessageStoreConfig storeConfig);
+
+    @Before
+    public void setUp() {
+        storeConfig = createTieredMessageStoreConfig();
+        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
+        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
+        TieredStoreExecutor.init();
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        TieredStoreTestUtil.destroyContainerManager();
+        TieredStoreTestUtil.destroyMetadataStore();
+        TieredStoreTestUtil.destroyTempDir(storePath);
+        TieredStoreExecutor.shutdown();
+    }
+
+    @Test
+    public void testDispatch() {
+        metadataStore.addQueue(mq, 6);
+        TieredFileSegment segment = createTieredFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
+        segment.initPosition(segment.getSize());
+        metadataStore.updateFileSegment(segment);
+        metadataStore.updateFileSegment(segment);
+        segment = createTieredFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 6 * TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, storeConfig);
+        metadataStore.updateFileSegment(segment);
+
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultMessageStore = Mockito.mock(DefaultMessageStore.class);
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultMessageStore, storeConfig);
+
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultMessageStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 6, 7, MessageBufferUtilTest.MSG_LEN, 1);
+        dispatcher.dispatch(request);
+        Assert.assertNotNull(containerManager.getMQContainer(mq));
+        Assert.assertEquals(7, containerManager.getMQContainer(mq).getDispatchOffset());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.commit(true);
+        Assert.assertEquals(6, container.getBuildCQMaxOffset());
+
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+
+        ByteBuffer buffer1 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        container.appendCommitLog(buffer1);
+        ByteBuffer buffer2 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 8);
+        container.appendCommitLog(buffer2);
+        ByteBuffer buffer3 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 9);
+        container.appendCommitLog(buffer3);
+        container.commitCommitLog();
+        Assert.assertEquals(10, container.getDispatchOffset());
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer2);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
+        Assert.assertEquals(7, container.getDispatchOffset());
+
+
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 7, 7, 0, 0, 0, buffer1);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer2);
+        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer3);
+        dispatcher.buildCQAndIndexFile();
+        Assert.assertEquals(10, container.getConsumeQueueMaxOffset());
+    }
+
+    @Test
+    public void testDispatchByMQContainer() {
+        metadataStore.addQueue(mq, 6);
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);
+        Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));
+        TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);
+
+        Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);
+        Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);
+
+        ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(7);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);
+
+        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
+        cqItem.putLong(8);
+        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
+        cqItem.putLong(1);
+        cqItem.flip();
+        mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
+
+        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);
+
+        mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        ByteBuffer msg = MessageBufferUtilTest.buildMockedMessageBuffer();
+        msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
+        mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);
+        Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
+
+        dispatcher.dispatchByMQContainer(containerManager.getOrCreateMQContainer(mq));
+        Assert.assertEquals(8, containerManager.getMQContainer(mq).getDispatchOffset());
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
deleted file mode 100644
index b5c4e9d..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredDispatcherTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.tieredstore;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.UUID;
-import org.apache.commons.io.FileUtils;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.ConsumeQueue;
-import org.apache.rocketmq.store.DefaultMessageStore;
-import org.apache.rocketmq.store.DispatchRequest;
-import org.apache.rocketmq.store.SelectMappedBufferResult;
-import org.apache.rocketmq.tieredstore.common.AppendResult;
-import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.tieredstore.common.TieredStoreExecutor;
-import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
-import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
-import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
-import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
-import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
-import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
-import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mockito;
-
-public class TieredDispatcherTest {
-    private TieredMessageStoreConfig storeConfig;
-    private MessageQueue mq;
-    private TieredMetadataStore metadataStore;
-
-    private final String storePath = FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID();
-
-    @Before
-    public void setUp() {
-        storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegmentWithoutCheck");
-        storeConfig.setBrokerName(storeConfig.getBrokerName());
-        mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
-        metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
-        TieredStoreExecutor.init();
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        TieredStoreTestUtil.destroyContainerManager();
-        TieredStoreTestUtil.destroyMetadataStore();
-        TieredStoreTestUtil.destroyTempDir(storePath);
-        TieredStoreExecutor.shutdown();
-    }
-
-    @Test
-    public void testDispatch() {
-        metadataStore.addQueue(mq, 6);
-        MemoryFileSegment segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG, mq, 1000, storeConfig);
-        segment.initPosition(segment.getSize());
-        metadataStore.updateFileSegment(segment);
-        metadataStore.updateFileSegment(segment);
-        segment = new MemoryFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, mq, 6 * TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, storeConfig);
-        metadataStore.updateFileSegment(segment);
-
-        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
-        DefaultMessageStore defaultMessageStore = Mockito.mock(DefaultMessageStore.class);
-        TieredDispatcher dispatcher = new TieredDispatcher(defaultMessageStore, storeConfig);
-
-        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
-        Mockito.when(defaultMessageStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
-        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 6, 7, MessageBufferUtilTest.MSG_LEN, 1);
-        dispatcher.dispatch(request);
-        Assert.assertNotNull(containerManager.getMQContainer(mq));
-        Assert.assertEquals(7, containerManager.getMQContainer(mq).getDispatchOffset());
-
-        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
-        container.commit(true);
-        Assert.assertEquals(6, container.getBuildCQMaxOffset());
-
-        dispatcher.buildCQAndIndexFile();
-        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
-
-        ByteBuffer buffer1 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
-        container.appendCommitLog(buffer1);
-        ByteBuffer buffer2 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 8);
-        container.appendCommitLog(buffer2);
-        ByteBuffer buffer3 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer3.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 9);
-        container.appendCommitLog(buffer3);
-        container.commitCommitLog();
-        Assert.assertEquals(10, container.getDispatchOffset());
-
-        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer1);
-        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer2);
-        dispatcher.buildCQAndIndexFile();
-        Assert.assertEquals(7, container.getConsumeQueueMaxOffset());
-        Assert.assertEquals(7, container.getDispatchOffset());
-
-
-        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 7, 7, 0, 0, 0, buffer1);
-        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 8, 8, 0, 0, 0, buffer2);
-        dispatcher.handleAppendCommitLogResult(AppendResult.SUCCESS, container, 9, 9, 0, 0, 0, buffer3);
-        dispatcher.buildCQAndIndexFile();
-        Assert.assertEquals(10, container.getConsumeQueueMaxOffset());
-    }
-
-    @Test
-    public void testDispatchByMQContainer() {
-        metadataStore.addQueue(mq, 6);
-        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
-        DefaultMessageStore defaultStore = Mockito.mock(DefaultMessageStore.class);
-        Mockito.when(defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).thenReturn(Mockito.mock(ConsumeQueue.class));
-        TieredDispatcher dispatcher = new TieredDispatcher(defaultStore, storeConfig);
-
-        Mockito.when(defaultStore.getMinOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(0L);
-        Mockito.when(defaultStore.getMaxOffsetInQueue(mq.getTopic(), mq.getQueueId())).thenReturn(9L);
-
-        ByteBuffer cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
-        cqItem.putLong(7);
-        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
-        cqItem.putLong(1);
-        cqItem.flip();
-        SelectMappedBufferResult mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
-        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(6)).thenReturn(mockResult);
-
-        cqItem = ByteBuffer.allocate(ConsumeQueue.CQ_STORE_UNIT_SIZE);
-        cqItem.putLong(8);
-        cqItem.putInt(MessageBufferUtilTest.MSG_LEN);
-        cqItem.putLong(1);
-        cqItem.flip();
-        mockResult = new SelectMappedBufferResult(0, cqItem, ConsumeQueue.CQ_STORE_UNIT_SIZE, null);
-
-        Mockito.when(((ConsumeQueue) defaultStore.getConsumeQueue(mq.getTopic(), mq.getQueueId())).getIndexBuffer(7)).thenReturn(mockResult);
-
-        mockResult = new SelectMappedBufferResult(0, MessageBufferUtilTest.buildMockedMessageBuffer(), MessageBufferUtilTest.MSG_LEN, null);
-        Mockito.when(defaultStore.selectOneMessageByOffset(7, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
-
-        ByteBuffer msg = MessageBufferUtilTest.buildMockedMessageBuffer();
-        msg.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 7);
-        mockResult = new SelectMappedBufferResult(0, msg, MessageBufferUtilTest.MSG_LEN, null);
-        Mockito.when(defaultStore.selectOneMessageByOffset(8, MessageBufferUtilTest.MSG_LEN)).thenReturn(mockResult);
-
-        dispatcher.dispatchByMQContainer(containerManager.getOrCreateMQContainer(mq));
-        Assert.assertEquals(8, containerManager.getMQContainer(mq).getDispatchOffset());
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherBaseTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherBaseTest.java
new file mode 100644
index 0000000..2158d6d
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherBaseTest.java
@@ -0,0 +1,303 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.tuple.Triple;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.store.DispatchRequest;
+import org.apache.rocketmq.store.GetMessageResult;
+import org.apache.rocketmq.store.GetMessageStatus;
+import org.apache.rocketmq.store.QueryMessageResult;
+import org.apache.rocketmq.store.SelectMappedBufferResult;
+import org.apache.rocketmq.tieredstore.common.AppendResult;
+import org.apache.rocketmq.tieredstore.common.BoundaryType;
+import org.apache.rocketmq.tieredstore.common.SelectMappedBufferResultWrapper;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.common.TieredStoreExecutor;
+import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
+import org.apache.rocketmq.tieredstore.container.TieredIndexFile;
+import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
+import org.awaitility.Awaitility;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+@Ignore
+public abstract class TieredMessageFetcherBaseTest {
+    protected TieredMessageStoreConfig storeConfig;
+    private MessageQueue mq;
+
+    private final String storePath = FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID();
+
+    public abstract void setTieredBackendProvider();
+
+    @Before
+    public void setUp() {
+        storeConfig = new TieredMessageStoreConfig();
+        setTieredBackendProvider();
+        storeConfig.setStorePathRootDir(storePath);
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setReadAheadCacheExpireDuration(Long.MAX_VALUE);
+        storeConfig.setObjectStoreRegion("ap-northeast-1");
+        storeConfig.setObjectStoreBucket("rocketmq-lcy");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setBrokerClusterName("test-cluster");
+        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
+        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
+        mq = new MessageQueue("TieredMessageFetcherTest", storeConfig.getBrokerName(), 0);
+        TieredStoreUtil.getMetadataStore(storeConfig);
+        TieredStoreExecutor.init();
+    }
+
+    @After
+    public void tearDown() throws IOException {
+        TieredStoreTestUtil.destroyContainerManager();
+        TieredStoreTestUtil.destroyMetadataStore();
+        TieredStoreTestUtil.destroyTempDir(storePath);
+        TieredStoreExecutor.shutdown();
+    }
+
+    public Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> buildFetcher() {
+        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE, getMessageResult.getStatus());
+
+        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.NO_MESSAGE_IN_QUEUE, getMessageResult.getStatus());
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+        return Triple.of(fetcher, msg1, msg2);
+    }
+
+    @Test
+    public void testGetMessageFromTieredStoreAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+
+        AppendResult result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 2, storeConfig.getReadAheadMessageSizeThreshold(), MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        container.commit(true);
+        getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+    }
+
+    @Test
+    public void testGetMessageFromCacheAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
+        Assert.assertNotNull(container);
+
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, new ArrayList<>());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+        fetcher.putMessageToCache(container, 0, new SelectMappedBufferResult(0, msg1, msg1.remaining(), null), 0, 0, 1);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        GetMessageResult getMessageResult = fetcher.getMessageFromCacheAsync(container, "group", 0, 32).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(1, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+
+        Awaitility.waitAtMost(3, TimeUnit.SECONDS)
+            .until(() -> fetcher.readAheadCache.estimatedSize() == 2);
+        ArrayList<SelectMappedBufferResultWrapper> wrapperList = new ArrayList<>();
+        wrapperList.add(fetcher.getMessageFromCache(container, 0));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+        wrapperList.clear();
+        wrapperList.add(fetcher.getMessageFromCache(container, 1));
+        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
+        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
+
+        SelectMappedBufferResult messageFromCache = fetcher.getMessageFromCache(container, 1).getDuplicateResult();
+        fetcher.recordCacheAccess(container, "group", 0, wrapperList);
+        Assert.assertNotNull(messageFromCache);
+        Assert.assertEquals(msg2, messageFromCache.getByteBuffer());
+        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
+    }
+
+    @Test
+    public void testGetMessageAsync() {
+        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
+        TieredMessageFetcher fetcher = triple.getLeft();
+        ByteBuffer msg1 = triple.getMiddle();
+        ByteBuffer msg2 = triple.getRight();
+
+        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), -1, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_TOO_SMALL, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 2, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_ONE, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 3, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_BADLY, getMessageResult.getStatus());
+
+        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
+        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
+        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
+        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
+        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
+    }
+
+    @Test
+    public void testGetMessageStoreTimeStampAsync() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        container.initOffset(0);
+
+        ByteBuffer msg1 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
+        long currentTimeMillis1 = System.currentTimeMillis();
+        msg1.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis1);
+        AppendResult result = container.appendCommitLog(msg1);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        ByteBuffer msg2 = MessageBufferUtilTest.buildMockedMessageBuffer();
+        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
+        long currentTimeMillis2 = System.currentTimeMillis();
+        msg2.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis2);
+        container.appendCommitLog(msg2);
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
+        Assert.assertEquals(AppendResult.SUCCESS, result);
+
+        container.commit(true);
+
+        long result1 = fetcher.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join();
+        long result2 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join();
+        Assert.assertEquals(result1, result2);
+        Assert.assertEquals(currentTimeMillis1, result1);
+
+        long result3 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 1).join();
+        Assert.assertEquals(currentTimeMillis2, result3);
+    }
+
+    @Test
+    public void testGetOffsetInQueueByTime() {
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 50, 0, MessageBufferUtilTest.MSG_LEN, 0), true);
+        container.commit(true);
+        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+
+
+        long timestamp = System.currentTimeMillis();
+        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp);
+        container.initOffset(50);
+        container.appendCommitLog(buffer, true);
+        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp, 50, "", "", 0, 0, null), true);
+        container.commit(true);
+        Assert.assertEquals(50, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
+    }
+
+    @Test
+    public void testQueryMessageAsync() {
+        // skip this test on windows
+        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
+
+        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
+        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        container.initOffset(0);
+        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
+        container.appendCommitLog(buffer);
+        buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 2);
+        container.appendCommitLog(buffer);
+
+        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
+        container.appendIndexFile(request);
+        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "another-key", 0, 0, null);
+        container.appendIndexFile(request);
+        container.commit(true);
+        TieredIndexFile indexFile = TieredContainerManager.getIndexFile(storeConfig);
+        indexFile.commit(true);
+        Assert.assertEquals(1, fetcher.queryMessageAsync(mq.getTopic(), "key", 1, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
+
+        QueryMessageResult result = fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join();
+        Assert.assertEquals(2, result.getMessageMapedList().size());
+        Assert.assertEquals(1, result.getMessageMapedList().get(0).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+        Assert.assertEquals(0, result.getMessageMapedList().get(1).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
deleted file mode 100644
index ddcc9fa..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageFetcherTest.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.tieredstore;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import org.apache.commons.io.FileUtils;
-import org.apache.commons.lang3.SystemUtils;
-import org.apache.commons.lang3.tuple.Triple;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.store.DispatchRequest;
-import org.apache.rocketmq.store.GetMessageResult;
-import org.apache.rocketmq.store.GetMessageStatus;
-import org.apache.rocketmq.store.QueryMessageResult;
-import org.apache.rocketmq.store.SelectMappedBufferResult;
-import org.apache.rocketmq.tieredstore.common.AppendResult;
-import org.apache.rocketmq.tieredstore.common.BoundaryType;
-import org.apache.rocketmq.tieredstore.common.SelectMappedBufferResultWrapper;
-import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.tieredstore.common.TieredStoreExecutor;
-import org.apache.rocketmq.tieredstore.container.TieredContainerManager;
-import org.apache.rocketmq.tieredstore.container.TieredIndexFile;
-import org.apache.rocketmq.tieredstore.container.TieredMessageQueueContainer;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
-import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
-import org.awaitility.Awaitility;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Assume;
-import org.junit.Before;
-import org.junit.Test;
-
-public class TieredMessageFetcherTest {
-    private TieredMessageStoreConfig storeConfig;
-    private MessageQueue mq;
-
-    private final String storePath = FileUtils.getTempDirectory() + File.separator + "tiered_store_unit_test" + UUID.randomUUID();
-
-    @Before
-    public void setUp() {
-        storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setBrokerName(storeConfig.getBrokerName());
-        storeConfig.setReadAheadCacheExpireDuration(Long.MAX_VALUE);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegmentWithoutCheck");
-        storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
-        storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
-        mq = new MessageQueue("TieredMessageFetcherTest", storeConfig.getBrokerName(), 0);
-        TieredStoreUtil.getMetadataStore(storeConfig);
-        TieredStoreExecutor.init();
-    }
-
-    @After
-    public void tearDown() throws IOException {
-        TieredStoreTestUtil.destroyContainerManager();
-        TieredStoreTestUtil.destroyMetadataStore();
-        TieredStoreTestUtil.destroyTempDir(storePath);
-        TieredStoreExecutor.shutdown();
-    }
-
-    public Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> buildFetcher() {
-        TieredContainerManager containerManager = TieredContainerManager.getInstance(storeConfig);
-        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
-        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE, getMessageResult.getStatus());
-
-        TieredMessageQueueContainer container = containerManager.getOrCreateMQContainer(mq);
-        container.initOffset(0);
-
-        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.NO_MESSAGE_IN_QUEUE, getMessageResult.getStatus());
-
-        ByteBuffer msg1 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
-        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
-        AppendResult result = container.appendCommitLog(msg1);
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        ByteBuffer msg2 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
-        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
-        container.appendCommitLog(msg2);
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        container.commit(true);
-        return Triple.of(fetcher, msg1, msg2);
-    }
-
-    @Test
-    public void testGetMessageFromTieredStoreAsync() {
-        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
-        TieredMessageFetcher fetcher = triple.getLeft();
-        ByteBuffer msg1 = triple.getMiddle();
-        ByteBuffer msg2 = triple.getRight();
-        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
-        Assert.assertNotNull(container);
-
-        GetMessageResult getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
-        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
-        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
-        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
-        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
-
-        AppendResult result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 2, storeConfig.getReadAheadMessageSizeThreshold(), MessageBufferUtilTest.MSG_LEN, 0));
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-        container.commit(true);
-        getMessageResult = fetcher.getMessageFromTieredStoreAsync(container, 0, 32).join();
-        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
-        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
-    }
-
-    @Test
-    public void testGetMessageFromCacheAsync() {
-        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
-        TieredMessageFetcher fetcher = triple.getLeft();
-        ByteBuffer msg1 = triple.getMiddle();
-        ByteBuffer msg2 = triple.getRight();
-        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getMQContainer(mq);
-        Assert.assertNotNull(container);
-
-        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, new ArrayList<>());
-        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
-        fetcher.putMessageToCache(container, 0, new SelectMappedBufferResult(0, msg1, msg1.remaining(), null), 0, 0, 1);
-        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
-
-        GetMessageResult getMessageResult = fetcher.getMessageFromCacheAsync(container, "group", 0, 32).join();
-        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
-        Assert.assertEquals(1, getMessageResult.getMessageBufferList().size());
-        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
-
-        Awaitility.waitAtMost(3, TimeUnit.SECONDS)
-            .until(() -> fetcher.readAheadCache.estimatedSize() == 2);
-        ArrayList<SelectMappedBufferResultWrapper> wrapperList = new ArrayList<>();
-        wrapperList.add(fetcher.getMessageFromCache(container, 0));
-        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
-        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
-        wrapperList.clear();
-        wrapperList.add(fetcher.getMessageFromCache(container, 1));
-        fetcher.recordCacheAccess(container, "prevent-invalid-cache", 0, wrapperList);
-        Assert.assertEquals(1, fetcher.readAheadCache.estimatedSize());
-
-        SelectMappedBufferResult messageFromCache = fetcher.getMessageFromCache(container, 1).getDuplicateResult();
-        fetcher.recordCacheAccess(container, "group", 0, wrapperList);
-        Assert.assertNotNull(messageFromCache);
-        Assert.assertEquals(msg2, messageFromCache.getByteBuffer());
-        Assert.assertEquals(0, fetcher.readAheadCache.estimatedSize());
-    }
-
-    @Test
-    public void testGetMessageAsync() {
-        Triple<TieredMessageFetcher, ByteBuffer, ByteBuffer> triple = buildFetcher();
-        TieredMessageFetcher fetcher = triple.getLeft();
-        ByteBuffer msg1 = triple.getMiddle();
-        ByteBuffer msg2 = triple.getRight();
-
-        GetMessageResult getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), -1, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.OFFSET_TOO_SMALL, getMessageResult.getStatus());
-
-        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 2, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_ONE, getMessageResult.getStatus());
-
-        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 3, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.OFFSET_OVERFLOW_BADLY, getMessageResult.getStatus());
-
-        getMessageResult = fetcher.getMessageAsync("group", mq.getTopic(), mq.getQueueId(), 0, 32, null).join();
-        Assert.assertEquals(GetMessageStatus.FOUND, getMessageResult.getStatus());
-        Assert.assertEquals(2, getMessageResult.getMessageBufferList().size());
-        Assert.assertEquals(msg1, getMessageResult.getMessageBufferList().get(0));
-        Assert.assertEquals(msg2, getMessageResult.getMessageBufferList().get(1));
-    }
-
-    @Test
-    public void testGetMessageStoreTimeStampAsync() {
-        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
-        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
-        container.initOffset(0);
-
-        ByteBuffer msg1 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        msg1.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
-        msg1.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, 0);
-        long currentTimeMillis1 = System.currentTimeMillis();
-        msg1.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis1);
-        AppendResult result = container.appendCommitLog(msg1);
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        ByteBuffer msg2 = MessageBufferUtilTest.buildMockedMessageBuffer();
-        msg2.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
-        msg2.putLong(MessageBufferUtil.PHYSICAL_OFFSET_POSITION, MessageBufferUtilTest.MSG_LEN);
-        long currentTimeMillis2 = System.currentTimeMillis();
-        msg2.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, currentTimeMillis2);
-        container.appendCommitLog(msg2);
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, 0, MessageBufferUtilTest.MSG_LEN, 0));
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-        result = container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 1, MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0));
-        Assert.assertEquals(AppendResult.SUCCESS, result);
-
-        container.commit(true);
-
-        long result1 = fetcher.getEarliestMessageTimeAsync(mq.getTopic(), mq.getQueueId()).join();
-        long result2 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 0).join();
-        Assert.assertEquals(result1, result2);
-        Assert.assertEquals(currentTimeMillis1, result1);
-
-        long result3 = fetcher.getMessageStoreTimeStampAsync(mq.getTopic(), mq.getQueueId(), 1).join();
-        Assert.assertEquals(currentTimeMillis2, result3);
-    }
-
-    @Test
-    public void testGetOffsetInQueueByTime() {
-        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
-        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
-
-        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
-        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
-        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 50, 0, MessageBufferUtilTest.MSG_LEN, 0), true);
-        container.commit(true);
-        Assert.assertEquals(-1, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
-
-
-        long timestamp = System.currentTimeMillis();
-        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 50);
-        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, timestamp);
-        container.initOffset(50);
-        container.appendCommitLog(buffer, true);
-        container.appendConsumeQueue(new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, timestamp, 50, "", "", 0, 0, null), true);
-        container.commit(true);
-        Assert.assertEquals(50, fetcher.getOffsetInQueueByTime(mq.getTopic(), mq.getQueueId(), 0, BoundaryType.LOWER));
-    }
-
-    @Test
-    public void testQueryMessageAsync() {
-        // skip this test on windows
-        Assume.assumeFalse(SystemUtils.IS_OS_WINDOWS);
-
-        TieredMessageFetcher fetcher = new TieredMessageFetcher(storeConfig);
-        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
-
-        TieredMessageQueueContainer container = TieredContainerManager.getInstance(storeConfig).getOrCreateMQContainer(mq);
-        Assert.assertEquals(0, fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
-
-        container.initOffset(0);
-        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 0);
-        container.appendCommitLog(buffer);
-        buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 1);
-        container.appendCommitLog(buffer);
-        buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, 2);
-        container.appendCommitLog(buffer);
-
-        DispatchRequest request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), 0, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
-        container.appendIndexFile(request);
-        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "key", 0, 0, null);
-        container.appendIndexFile(request);
-        request = new DispatchRequest(mq.getTopic(), mq.getQueueId(), MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN, 0, 0, 0, "", "another-key", 0, 0, null);
-        container.appendIndexFile(request);
-        container.commit(true);
-        TieredIndexFile indexFile = TieredContainerManager.getIndexFile(storeConfig);
-        indexFile.commit(true);
-        Assert.assertEquals(1, fetcher.queryMessageAsync(mq.getTopic(), "key", 1, 0, Long.MAX_VALUE).join().getMessageMapedList().size());
-
-        QueryMessageResult result = fetcher.queryMessageAsync(mq.getTopic(), "key", 32, 0, Long.MAX_VALUE).join();
-        Assert.assertEquals(2, result.getMessageMapedList().size());
-        Assert.assertEquals(1, result.getMessageMapedList().get(0).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
-        Assert.assertEquals(0, result.getMessageMapedList().get(1).getByteBuffer().getLong(MessageBufferUtil.QUEUE_OFFSET_POSITION));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
index c37ce2c..a6d1d15 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/TieredMessageStoreTest.java
@@ -85,7 +85,7 @@ public class TieredMessageStoreTest {
         brokerConfig.setBrokerName("broker");
         configuration = new Configuration(LoggerFactory.getLogger(TieredStoreUtil.TIERED_STORE_LOGGER_NAME), "/tmp/rmqut/config", storeConfig, brokerConfig);
         Properties properties = new Properties();
-        properties.setProperty("tieredBackendServiceProvider", "org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        properties.setProperty("tieredBackendServiceProvider", "org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         configuration.registerConfig(properties);
         MessageStorePluginContext context = new MessageStorePluginContext(new MessageStoreConfig(), null, null, brokerConfig, configuration);
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
index ec074b1..c690929 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredContainerManagerTest.java
@@ -44,7 +44,7 @@ public class TieredContainerManagerTest {
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
         storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         storeConfig.setBrokerName(storeConfig.getBrokerName());
         mq = new MessageQueue("TieredContainerManagerTest", storeConfig.getBrokerName(), 0);
         metadataStore = TieredStoreUtil.getMetadataStore(storeConfig);
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
index 60f751a..8f23751 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredFileQueueTest.java
@@ -25,7 +25,7 @@ import org.apache.rocketmq.common.message.MessageQueue;
 import org.apache.rocketmq.tieredstore.TieredStoreTestUtil;
 import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
 import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
-import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment;
 import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
 import org.apache.rocketmq.tieredstore.util.TieredStoreUtil;
 import org.junit.After;
@@ -43,7 +43,7 @@ public class TieredFileQueueTest {
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
         storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         queue = new MessageQueue("TieredFileQueueTest", storeConfig.getBrokerName(), 0);
     }
 
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
index 6a114e7..5fb6251 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredIndexFileTest.java
@@ -47,7 +47,7 @@ public class TieredIndexFileTest {
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
         storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegmentWithoutCheck");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         storeConfig.setTieredStoreIndexFileMaxHashSlotNum(2);
         storeConfig.setTieredStoreIndexFileMaxIndexNum(3);
         mq = new MessageQueue("TieredIndexFileTest", storeConfig.getBrokerName(), 1);
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
index ccfe18b..4ed5b00 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/container/TieredMessageQueueContainerTest.java
@@ -30,7 +30,7 @@ import org.apache.rocketmq.tieredstore.common.BoundaryType;
 import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
 import org.apache.rocketmq.tieredstore.metadata.QueueMetadata;
 import org.apache.rocketmq.tieredstore.metadata.TieredMetadataStore;
-import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment;
 import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
 import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
 import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
@@ -51,7 +51,7 @@ public class TieredMessageQueueContainerTest {
     public void setUp() {
         storeConfig = new TieredMessageStoreConfig();
         storeConfig.setStorePathRootDir(storePath);
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         storeConfig.setCommitLogRollingInterval(0);
         storeConfig.setCommitLogRollingMinimumSize(999);
         mq = new MessageQueue("TieredMessageQueueContainerTest", storeConfig.getBrokerName(), 0);
@@ -138,7 +138,7 @@ public class TieredMessageQueueContainerTest {
 
     @Test
     public void testBinarySearchInQueueByTime() throws ClassNotFoundException, NoSuchMethodException {
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegmentWithoutCheck");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegmentWithoutCheck");
 
         TieredMessageQueueContainer container = new TieredMessageQueueContainer(mq, storeConfig);
         container.initOffset(50);
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
index 96539d1..db1e9f0 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metadata/MetadataStoreTest.java
@@ -29,7 +29,7 @@ import org.apache.rocketmq.common.message.MessageQueue;
 import org.apache.rocketmq.tieredstore.TieredStoreTestUtil;
 import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
 import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
-import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
+import org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment;
 import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
 import org.junit.After;
 import org.junit.Assert;
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
index 170728d..b41c2e8 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/metrics/TieredStoreMetricsManagerTest.java
@@ -41,7 +41,7 @@ public class TieredStoreMetricsManagerTest {
     @Test
     public void init() {
         TieredMessageStoreConfig storeConfig = new TieredMessageStoreConfig();
-        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.mock.MemoryFileSegment");
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegment");
         TieredStoreMetricsManager.init(OpenTelemetrySdk.builder().build().getMeter(""),
             null, storeConfig, new TieredMessageFetcher(storeConfig), null);
     }
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
deleted file mode 100644
index 3c47d1c..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegment.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.tieredstore.mock;
-
-import java.io.File;
-import java.nio.ByteBuffer;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
-import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
-import org.junit.Assert;
-
-public class MemoryFileSegment extends TieredFileSegment {
-    protected final ByteBuffer memStore;
-
-    public CompletableFuture<Boolean> blocker;
-
-    protected boolean checkSize = true;
-
-    public MemoryFileSegment(TieredFileSegment.FileSegmentType fileType, MessageQueue messageQueue, long baseOffset,
-        TieredMessageStoreConfig storeConfig) {
-        super(fileType, messageQueue, baseOffset, storeConfig);
-        switch (fileType) {
-            case COMMIT_LOG:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            case CONSUME_QUEUE:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            case INDEX:
-                memStore = ByteBuffer.allocate(10000);
-                break;
-            default:
-                memStore = null;
-                break;
-        }
-        memStore.position((int) getSize());
-    }
-
-    @Override
-    public String getPath() {
-        return "/tiered/" + fileType + File.separator + baseOffset;
-    }
-
-    @Override
-    public long getSize() {
-        if (checkSize) {
-            return 1000;
-        }
-        return 0;
-    }
-
-    @Override
-    public void createFile() {
-
-    }
-
-    @Override
-    public CompletableFuture<ByteBuffer> read0(long position, int length) {
-        ByteBuffer buffer = memStore.duplicate();
-        buffer.position((int) position);
-        ByteBuffer slice = buffer.slice();
-        slice.limit(length);
-        return CompletableFuture.completedFuture(slice);
-    }
-
-    @Override
-    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
-                                              boolean append) {
-        try {
-            if (blocker != null && !blocker.get()) {
-                throw new IllegalStateException();
-            }
-        } catch (InterruptedException | ExecutionException e) {
-            Assert.fail(e.getMessage());
-        }
-
-        Assert.assertTrue(!checkSize || position >= getSize());
-
-        byte[] buffer = new byte[1024];
-
-        int startPos = memStore.position();
-        try {
-            int len;
-            while ((len = inputStream.read(buffer)) > 0) {
-                memStore.put(buffer, 0, len);
-            }
-            Assert.assertEquals(length, memStore.position() - startPos);
-        } catch (Exception e) {
-            Assert.fail(e.getMessage());
-            return CompletableFuture.completedFuture(false);
-        }
-        return CompletableFuture.completedFuture(true);
-    }
-
-    @Override
-    public boolean exists() {
-        return false;
-    }
-
-    @Override
-    public void destroyFile() {
-
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegmentWithoutCheck.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegmentWithoutCheck.java
deleted file mode 100644
index 741a38c..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/mock/MemoryFileSegmentWithoutCheck.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.tieredstore.mock;
-
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
-import org.junit.Assert;
-
-public class MemoryFileSegmentWithoutCheck extends MemoryFileSegment {
-
-    public MemoryFileSegmentWithoutCheck(FileSegmentType fileType,
-        MessageQueue messageQueue, long baseOffset,
-        TieredMessageStoreConfig storeConfig) {
-        super(fileType, messageQueue, baseOffset, storeConfig);
-    }
-
-    @Override
-    public long getSize() {
-        return 0;
-    }
-
-    @Override
-    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
-                                              boolean append) {
-        try {
-            if (blocker != null && !blocker.get()) {
-                throw new IllegalStateException();
-            }
-        } catch (InterruptedException | ExecutionException e) {
-            Assert.fail(e.getMessage());
-        }
-
-        byte[] buffer = new byte[1024];
-
-        int startPos = memStore.position();
-        try {
-            int len;
-            while ((len = inputStream.read(buffer)) > 0) {
-                memStore.put(buffer, 0, len);
-            }
-            Assert.assertEquals(length, memStore.position() - startPos);
-        } catch (Exception e) {
-            Assert.fail(e.getMessage());
-            return CompletableFuture.completedFuture(false);
-        }
-        return CompletableFuture.completedFuture(true);
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/MockTieredFileSegmentInputStream.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/MockTieredFileSegmentInputStream.java
new file mode 100644
index 0000000..a6566b7
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/MockTieredFileSegmentInputStream.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider;
+
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.List;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
+
+public class MockTieredFileSegmentInputStream extends TieredFileSegmentInputStream {
+
+    private final InputStream inputStream;
+
+    public MockTieredFileSegmentInputStream(InputStream inputStream) {
+        super(null, null, Integer.MAX_VALUE);
+        this.inputStream = inputStream;
+    }
+
+    @Override
+    public int read() {
+        int res = -1;
+        try {
+            res = inputStream.read();
+        } catch (Exception e) {
+            return -1;
+        }
+        return res;
+    }
+
+    @Override
+    public List<ByteBuffer> getUploadBufferList() {
+        return null;
+    }
+
+    @Override
+    public ByteBuffer getCodaBuffer() {
+        return null;
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentBaseTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentBaseTest.java
new file mode 100644
index 0000000..a81976a
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentBaseTest.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.provider;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.CompletableFuture;
+
+import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
+import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
+import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
+import org.junit.Assert;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+
+@Ignore
+public abstract class TieredFileSegmentBaseTest {
+    public int baseOffset = 1000;
+
+    public abstract TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType);
+
+    @Test
+    public void testCommitLog() {
+        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
+        segment.initPosition(segment.getSize());
+        long lastSize = segment.getSize();
+        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
+        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
+        Assert.assertTrue(segment.needCommit());
+
+        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+        long msg3StoreTime = System.currentTimeMillis();
+        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, msg3StoreTime);
+        long queueOffset = baseOffset * 1000L;
+        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, queueOffset);
+        segment.append(buffer, msg3StoreTime);
+
+        Assert.assertEquals(baseOffset, segment.getBaseOffset());
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
+        Assert.assertEquals(0, segment.getBeginTimestamp());
+        Assert.assertEquals(msg3StoreTime, segment.getEndTimestamp());
+
+        segment.setFull();
+        segment.commit();
+        Assert.assertFalse(segment.needCommit());
+        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
+        Assert.assertEquals(queueOffset, segment.getCommitMsgQueueOffset());
+
+        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
+
+        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
+
+        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
+
+        ByteBuffer coda = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 3, TieredCommitLog.CODA_SIZE);
+        Assert.assertEquals(msg3StoreTime, coda.getLong(4 + 4));
+    }
+
+    private ByteBuffer buildConsumeQueue(long commitLogOffset) {
+        ByteBuffer cqItem = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        cqItem.putLong(commitLogOffset);
+        cqItem.putInt(2);
+        cqItem.putLong(3);
+        cqItem.flip();
+        return cqItem;
+    }
+
+    @Test
+    public void testConsumeQueue() {
+        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE);
+        segment.initPosition(segment.getSize());
+        long lastSize = segment.getSize();
+        segment.append(buildConsumeQueue(baseOffset), 0);
+        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN), 0);
+        long cqItem3Timestamp = System.currentTimeMillis();
+        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN * 2), cqItem3Timestamp);
+
+        Assert.assertEquals(baseOffset + lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3, segment.getMaxOffset());
+        Assert.assertEquals(0, segment.getBeginTimestamp());
+        Assert.assertEquals(cqItem3Timestamp, segment.getEndTimestamp());
+
+        segment.commit();
+        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
+
+        ByteBuffer cqItem1 = segment.read(lastSize, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset, cqItem1.getLong());
+
+        ByteBuffer cqItem2 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN, cqItem2.getLong());
+
+        ByteBuffer cqItem3 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
+        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN * 2, cqItem3.getLong());
+    }
+
+    @Test
+    public void testCommitFailed() {
+        long startTime = System.currentTimeMillis();
+        TieredFileSegment segment = Mockito.spy(createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG));
+        long lastSize = segment.getSize();
+        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
+        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
+
+        CompletableFuture<Void> blocker = new CompletableFuture<>();
+        Mockito.doAnswer(invocation -> {
+            blocker.join();
+            CompletableFuture<Boolean> completableFuture = new CompletableFuture<>();
+            completableFuture.completeExceptionally(new RuntimeException("commit failed"));
+            return completableFuture;
+        }).when(segment).commit0(any(TieredFileSegmentInputStream.class), anyLong(), anyInt(), anyBoolean());
+
+        new Thread(() -> {
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                Assert.fail(e.getMessage());
+            }
+            // append msg3
+            ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
+            buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);
+            segment.append(buffer, 0);
+            // blocker complete, commit failed
+            blocker.complete(null);
+        }).start();
+
+        // first time try to commit these 2 messages but stuck for while until msg3 is appended, and then this commit failed
+        segment.commit();
+
+        // second time commit, expect success
+        Mockito.doCallRealMethod().when(segment).commit0(any(TieredFileSegmentInputStream.class), anyLong(), anyInt(), anyBoolean());
+        segment.commit();
+
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());
+
+        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
+
+        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
+
+        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
+        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
deleted file mode 100644
index 79b1883..0000000
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/TieredFileSegmentTest.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.rocketmq.tieredstore.provider;
-
-import java.nio.ByteBuffer;
-import java.util.concurrent.CompletableFuture;
-import org.apache.rocketmq.common.message.MessageQueue;
-import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
-import org.apache.rocketmq.tieredstore.container.TieredCommitLog;
-import org.apache.rocketmq.tieredstore.container.TieredConsumeQueue;
-import org.apache.rocketmq.tieredstore.mock.MemoryFileSegment;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtil;
-import org.apache.rocketmq.tieredstore.util.MessageBufferUtilTest;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class TieredFileSegmentTest {
-    public int baseOffset = 1000;
-
-    public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
-        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", new TieredMessageStoreConfig().getBrokerName(), 0),
-            baseOffset, new TieredMessageStoreConfig());
-    }
-
-    @Test
-    public void testCommitLog() {
-        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
-        segment.initPosition(segment.getSize());
-        long lastSize = segment.getSize();
-        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
-        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
-        Assert.assertTrue(segment.needCommit());
-
-        ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-        long msg3StoreTime = System.currentTimeMillis();
-        buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, msg3StoreTime);
-        long queueOffset = baseOffset * 1000L;
-        buffer.putLong(MessageBufferUtil.QUEUE_OFFSET_POSITION, queueOffset);
-        segment.append(buffer, msg3StoreTime);
-
-        Assert.assertEquals(baseOffset, segment.getBaseOffset());
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
-        Assert.assertEquals(0, segment.getBeginTimestamp());
-        Assert.assertEquals(msg3StoreTime, segment.getEndTimestamp());
-
-        segment.setFull();
-        segment.commit();
-        Assert.assertFalse(segment.needCommit());
-        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
-        Assert.assertEquals(queueOffset, segment.getCommitMsgQueueOffset());
-
-        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
-
-        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
-
-        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
-
-        ByteBuffer coda = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 3, TieredCommitLog.CODA_SIZE);
-        Assert.assertEquals(msg3StoreTime, coda.getLong(4 + 4));
-    }
-
-    private ByteBuffer buildConsumeQueue(long commitLogOffset) {
-        ByteBuffer cqItem = ByteBuffer.allocate(TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        cqItem.putLong(commitLogOffset);
-        cqItem.putInt(2);
-        cqItem.putLong(3);
-        cqItem.flip();
-        return cqItem;
-    }
-
-    @Test
-    public void testConsumeQueue() {
-        TieredFileSegment segment = createFileSegment(TieredFileSegment.FileSegmentType.CONSUME_QUEUE);
-        segment.initPosition(segment.getSize());
-        long lastSize = segment.getSize();
-        segment.append(buildConsumeQueue(baseOffset), 0);
-        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN), 0);
-        long cqItem3Timestamp = System.currentTimeMillis();
-        segment.append(buildConsumeQueue(baseOffset + MessageBufferUtilTest.MSG_LEN * 2), cqItem3Timestamp);
-
-        Assert.assertEquals(baseOffset + lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 3, segment.getMaxOffset());
-        Assert.assertEquals(0, segment.getBeginTimestamp());
-        Assert.assertEquals(cqItem3Timestamp, segment.getEndTimestamp());
-
-        segment.commit();
-        Assert.assertEquals(segment.getMaxOffset(), segment.getCommitOffset());
-
-        ByteBuffer cqItem1 = segment.read(lastSize, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset, cqItem1.getLong());
-
-        ByteBuffer cqItem2 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN, cqItem2.getLong());
-
-        ByteBuffer cqItem3 = segment.read(lastSize + TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE * 2, TieredConsumeQueue.CONSUME_QUEUE_STORE_UNIT_SIZE);
-        Assert.assertEquals(baseOffset + MessageBufferUtilTest.MSG_LEN * 2, cqItem3.getLong());
-    }
-
-    @Test
-    public void testCommitFailed() {
-        long startTime = System.currentTimeMillis();
-        MemoryFileSegment segment = (MemoryFileSegment) createFileSegment(TieredFileSegment.FileSegmentType.COMMIT_LOG);
-        long lastSize = segment.getSize();
-        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
-        segment.append(MessageBufferUtilTest.buildMockedMessageBuffer(), 0);
-
-        segment.blocker = new CompletableFuture<>();
-        new Thread(() -> {
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                Assert.fail(e.getMessage());
-            }
-            ByteBuffer buffer = MessageBufferUtilTest.buildMockedMessageBuffer();
-            buffer.putLong(MessageBufferUtil.STORE_TIMESTAMP_POSITION, startTime);
-            segment.append(buffer, 0);
-            segment.blocker.complete(false);
-        }).start();
-
-        segment.commit();
-        segment.blocker.join();
-
-        segment.blocker = new CompletableFuture<>();
-        segment.blocker.complete(true);
-        segment.commit();
-
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getMaxOffset());
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 3, segment.getCommitOffset());
-
-        ByteBuffer msg1 = segment.read(lastSize, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize, MessageBufferUtil.getCommitLogOffset(msg1));
-
-        ByteBuffer msg2 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN, MessageBufferUtil.getCommitLogOffset(msg2));
-
-        ByteBuffer msg3 = segment.read(lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtilTest.MSG_LEN);
-        Assert.assertEquals(baseOffset + lastSize + MessageBufferUtilTest.MSG_LEN * 2, MessageBufferUtil.getCommitLogOffset(msg3));
-    }
-}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegment.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegment.java
new file mode 100644
index 0000000..2d0eba6
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegment.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.provider.memory;
+
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
+import org.junit.Assert;
+
+public class MemoryFileSegment extends TieredFileSegment {
+    protected final ByteBuffer memStore;
+
+    public CompletableFuture<Boolean> blocker;
+
+    protected boolean checkSize = true;
+
+    public MemoryFileSegment(TieredFileSegment.FileSegmentType fileType, MessageQueue messageQueue, long baseOffset,
+        TieredMessageStoreConfig storeConfig) {
+        super(fileType, messageQueue, baseOffset, storeConfig);
+        switch (fileType) {
+            case COMMIT_LOG:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            case CONSUME_QUEUE:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            case INDEX:
+                memStore = ByteBuffer.allocate(10000);
+                break;
+            default:
+                memStore = null;
+                break;
+        }
+        memStore.position((int) getSize());
+    }
+
+    @Override
+    public String getPath() {
+        return "/tiered/" + fileType + File.separator + baseOffset;
+    }
+
+    @Override
+    public long getSize() {
+        if (checkSize) {
+            return 1000;
+        }
+        return 0;
+    }
+
+    @Override
+    public void createFile() {
+
+    }
+
+    @Override
+    public void sealFile() {
+
+    }
+
+    @Override
+    public CompletableFuture<ByteBuffer> read0(long position, int length) {
+        ByteBuffer buffer = memStore.duplicate();
+        buffer.position((int) position);
+        ByteBuffer slice = buffer.slice();
+        slice.limit(length);
+        return CompletableFuture.completedFuture(slice);
+    }
+
+    @Override
+    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
+                                              boolean append) {
+        try {
+            if (blocker != null && !blocker.get()) {
+                throw new IllegalStateException();
+            }
+        } catch (InterruptedException | ExecutionException e) {
+            Assert.fail(e.getMessage());
+        }
+
+        Assert.assertTrue(!checkSize || position >= getSize());
+
+        byte[] buffer = new byte[1024];
+
+        int startPos = memStore.position();
+        try {
+            int len;
+            while ((len = inputStream.read(buffer)) > 0) {
+                memStore.put(buffer, 0, len);
+            }
+            Assert.assertEquals(length, memStore.position() - startPos);
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+            return CompletableFuture.completedFuture(false);
+        }
+        return CompletableFuture.completedFuture(true);
+    }
+
+    @Override
+    public boolean exists() {
+        return false;
+    }
+
+    @Override
+    public void destroyFile() {
+
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegmentWithoutCheck.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegmentWithoutCheck.java
new file mode 100644
index 0000000..2c49c88
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/MemoryFileSegmentWithoutCheck.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.rocketmq.tieredstore.provider.memory;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
+import org.junit.Assert;
+
+public class MemoryFileSegmentWithoutCheck extends MemoryFileSegment {
+
+    public MemoryFileSegmentWithoutCheck(FileSegmentType fileType,
+        MessageQueue messageQueue, long baseOffset,
+        TieredMessageStoreConfig storeConfig) {
+        super(fileType, messageQueue, baseOffset, storeConfig);
+    }
+
+    @Override
+    public long getSize() {
+        return 0;
+    }
+
+    @Override
+    public CompletableFuture<Boolean> commit0(TieredFileSegmentInputStream inputStream, long position, int length,
+                                              boolean append) {
+        try {
+            if (blocker != null && !blocker.get()) {
+                throw new IllegalStateException();
+            }
+        } catch (InterruptedException | ExecutionException e) {
+            Assert.fail(e.getMessage());
+        }
+
+        byte[] buffer = new byte[1024];
+
+        int startPos = memStore.position();
+        try {
+            int len;
+            while ((len = inputStream.read(buffer)) > 0) {
+                memStore.put(buffer, 0, len);
+            }
+            Assert.assertEquals(length, memStore.position() - startPos);
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+            return CompletableFuture.completedFuture(false);
+        }
+        return CompletableFuture.completedFuture(true);
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredDispatcherForMemoryTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredDispatcherForMemoryTest.java
new file mode 100644
index 0000000..b938e26
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredDispatcherForMemoryTest.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.memory;
+
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.TieredDispatcherBaseTest;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+
+public class TieredDispatcherForMemoryTest extends TieredDispatcherBaseTest {
+    @Override
+    public TieredMessageStoreConfig createTieredMessageStoreConfig() {
+        TieredMessageStoreConfig storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(storePath);
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegmentWithoutCheck");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setBrokerClusterName("test-cluster");
+        return storeConfig;
+    }
+
+    @Override
+    public TieredFileSegment createTieredFileSegment(TieredFileSegment.FileSegmentType type, MessageQueue mq, long baseOffset, TieredMessageStoreConfig storeConfig) {
+        return new MemoryFileSegmentWithoutCheck(type, mq, baseOffset, storeConfig);
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredFileSegmentForMemoryTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredFileSegmentForMemoryTest.java
new file mode 100644
index 0000000..f1e33d4
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredFileSegmentForMemoryTest.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.memory;
+
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegmentBaseTest;
+
+public class TieredFileSegmentForMemoryTest extends TieredFileSegmentBaseTest {
+
+    @Override
+    public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
+        return new MemoryFileSegment(fileType, new MessageQueue("TieredFileSegmentTest", new TieredMessageStoreConfig().getBrokerName(), 0),
+                baseOffset, new TieredMessageStoreConfig());
+    }
+
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredMessageFetcherForMemoryTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredMessageFetcherForMemoryTest.java
new file mode 100644
index 0000000..04112da
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/memory/TieredMessageFetcherForMemoryTest.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.memory;
+
+import org.apache.rocketmq.tieredstore.TieredMessageFetcherBaseTest;
+
+public class TieredMessageFetcherForMemoryTest extends TieredMessageFetcherBaseTest {
+    @Override
+    public void setTieredBackendProvider() {
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.memory.MemoryFileSegmentWithoutCheck");
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3AsyncClient.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3AsyncClient.java
new file mode 100644
index 0000000..1ddd657
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3AsyncClient.java
@@ -0,0 +1,221 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.adobe.testing.s3mock.junit4.S3MockRule;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.junit.ClassRule;
+import software.amazon.awssdk.core.ResponseBytes;
+import software.amazon.awssdk.core.async.AsyncRequestBody;
+import software.amazon.awssdk.core.async.AsyncResponseTransformer;
+import software.amazon.awssdk.core.sync.RequestBody;
+import software.amazon.awssdk.core.sync.ResponseTransformer;
+import software.amazon.awssdk.services.s3.S3AsyncClient;
+import software.amazon.awssdk.services.s3.S3Client;
+import software.amazon.awssdk.services.s3.model.AbortMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.AbortMultipartUploadResponse;
+import software.amazon.awssdk.services.s3.model.CompleteMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CompleteMultipartUploadResponse;
+import software.amazon.awssdk.services.s3.model.CreateBucketRequest;
+import software.amazon.awssdk.services.s3.model.CreateBucketResponse;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadRequest;
+import software.amazon.awssdk.services.s3.model.CreateMultipartUploadResponse;
+import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;
+import software.amazon.awssdk.services.s3.model.DeleteObjectResponse;
+import software.amazon.awssdk.services.s3.model.DeleteObjectsRequest;
+import software.amazon.awssdk.services.s3.model.DeleteObjectsResponse;
+import software.amazon.awssdk.services.s3.model.GetObjectRequest;
+import software.amazon.awssdk.services.s3.model.GetObjectResponse;
+import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;
+import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
+import software.amazon.awssdk.services.s3.model.PutObjectRequest;
+import software.amazon.awssdk.services.s3.model.PutObjectResponse;
+import software.amazon.awssdk.services.s3.model.UploadPartCopyRequest;
+import software.amazon.awssdk.services.s3.model.UploadPartCopyResponse;
+
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+
+public class MockS3AsyncClient implements S3AsyncClient {
+
+    @ClassRule
+    public static final S3MockRule S3_MOCK_RULE = S3MockRule.builder().silent().build();
+
+    public static TieredStorageS3Client getMockTieredStorageS3Client(TieredMessageStoreConfig config,
+        S3MockStarterTestImpl s3MockApplication) {
+        TieredStorageS3Client tieredStorageS3Client = null;
+        try {
+            tieredStorageS3Client = new TieredStorageS3Client(config);
+            S3Client s3Client = s3MockApplication.createS3ClientV2();
+            S3AsyncClient asyncClient = new MockS3AsyncClient(s3Client);
+            Field clientField = tieredStorageS3Client.getClass().getDeclaredField("client");
+            clientField.setAccessible(true);
+            clientField.set(tieredStorageS3Client, asyncClient);
+            s3Client.createBucket(CreateBucketRequest.builder().bucket(config.getObjectStoreBucket()).build());
+        } catch (Exception ignore) {
+
+        }
+        return tieredStorageS3Client;
+    }
+
+    private final S3Client s3Client;
+
+    public MockS3AsyncClient(S3Client s3Client) {
+        this.s3Client = s3Client;
+    }
+
+    @Override
+    public String serviceName() {
+        return null;
+    }
+
+    @Override
+    public void close() {
+        this.s3Client.close();
+    }
+
+    @Override
+    public CompletableFuture<CreateBucketResponse> createBucket(CreateBucketRequest createBucketRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.createBucket(createBucketRequest));
+    }
+
+    @Override
+    public CompletableFuture<PutObjectResponse> putObject(PutObjectRequest putObjectRequest,
+        AsyncRequestBody requestBody) {
+        List<ByteBuffer> list = new LinkedList<>();
+        CompletableFuture<Void> future = requestBody.subscribe(bytebuffer -> {
+            list.add(bytebuffer);
+        });
+        future.join();
+        Integer len = list.stream().map(a -> a.limit()).reduce((a, b) -> a + b).get();
+        ByteBuffer realByteBuffer = ByteBuffer.allocate(len);
+        for (int i = 0; i < list.size(); i++) {
+            ByteBuffer byteBuffer = list.get(i);
+            byteBuffer.rewind();
+            realByteBuffer.put(byteBuffer);
+        }
+        realByteBuffer.flip();
+        RequestBody body = RequestBody.fromByteBuffer(realByteBuffer);
+        return CompletableFuture.completedFuture(this.s3Client.putObject(putObjectRequest, body));
+    }
+
+    @Override
+    public CompletableFuture<ListObjectsV2Response> listObjectsV2(
+        Consumer<ListObjectsV2Request.Builder> listObjectsV2Request) {
+        ListObjectsV2Request request = ListObjectsV2Request.builder().applyMutation(listObjectsV2Request).build();
+        return this.listObjectsV2(request);
+    }
+
+    @Override
+    public CompletableFuture<ListObjectsV2Response> listObjectsV2(ListObjectsV2Request listObjectsV2Request) {
+        return CompletableFuture.completedFuture(this.s3Client.listObjectsV2(listObjectsV2Request));
+    }
+
+    @Override
+    public CompletableFuture<DeleteObjectResponse> deleteObject(
+        Consumer<DeleteObjectRequest.Builder> deleteObjectRequest) {
+        DeleteObjectRequest request = DeleteObjectRequest.builder().applyMutation(deleteObjectRequest).build();
+        return this.deleteObject(request);
+    }
+
+    @Override
+    public CompletableFuture<DeleteObjectResponse> deleteObject(DeleteObjectRequest deleteObjectRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.deleteObject(deleteObjectRequest));
+    }
+
+    @Override
+    public CompletableFuture<DeleteObjectsResponse> deleteObjects(
+        Consumer<DeleteObjectsRequest.Builder> deleteObjectsRequest) {
+        DeleteObjectsRequest request = DeleteObjectsRequest.builder().applyMutation(deleteObjectsRequest).build();
+        return this.deleteObjects(request);
+    }
+
+    @Override
+    public CompletableFuture<DeleteObjectsResponse> deleteObjects(DeleteObjectsRequest deleteObjectsRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.deleteObjects(deleteObjectsRequest));
+    }
+
+    @Override
+    public <T> CompletableFuture<T> getObject(Consumer<GetObjectRequest.Builder> getObjectRequest,
+        AsyncResponseTransformer<GetObjectResponse, T> asyncResponseTransformer) {
+        GetObjectRequest request = GetObjectRequest.builder().applyMutation(getObjectRequest).build();
+        return this.getObject(request, asyncResponseTransformer);
+    }
+
+    @Override
+    public <T> CompletableFuture<T> getObject(GetObjectRequest getObjectRequest,
+        AsyncResponseTransformer<GetObjectResponse, T> asyncResponseTransformer) {
+        ResponseBytes<GetObjectResponse> resp = this.s3Client.getObject(getObjectRequest, ResponseTransformer.toBytes());
+        return CompletableFuture.completedFuture((T) resp);
+    }
+
+    @Override
+    public CompletableFuture<CreateMultipartUploadResponse> createMultipartUpload(
+        Consumer<CreateMultipartUploadRequest.Builder> createMultipartUploadRequest) {
+        CreateMultipartUploadRequest request = CreateMultipartUploadRequest.builder().applyMutation(createMultipartUploadRequest).build();
+        return this.createMultipartUpload(request);
+    }
+
+    @Override
+    public CompletableFuture<CreateMultipartUploadResponse> createMultipartUpload(
+        CreateMultipartUploadRequest createMultipartUploadRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.createMultipartUpload(createMultipartUploadRequest));
+    }
+
+    @Override
+    public CompletableFuture<UploadPartCopyResponse> uploadPartCopy(
+        Consumer<UploadPartCopyRequest.Builder> uploadPartCopyRequest) {
+        UploadPartCopyRequest request = UploadPartCopyRequest.builder().applyMutation(uploadPartCopyRequest).build();
+        return this.uploadPartCopy(request);
+    }
+
+    @Override
+    public CompletableFuture<UploadPartCopyResponse> uploadPartCopy(UploadPartCopyRequest uploadPartCopyRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.uploadPartCopy(uploadPartCopyRequest));
+    }
+
+    @Override
+    public CompletableFuture<CompleteMultipartUploadResponse> completeMultipartUpload(
+        Consumer<CompleteMultipartUploadRequest.Builder> completeMultipartUploadRequest) {
+        CompleteMultipartUploadRequest request = CompleteMultipartUploadRequest.builder().applyMutation(completeMultipartUploadRequest).build();
+        return this.completeMultipartUpload(request);
+    }
+
+    @Override
+    public CompletableFuture<CompleteMultipartUploadResponse> completeMultipartUpload(
+        CompleteMultipartUploadRequest completeMultipartUploadRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.completeMultipartUpload(completeMultipartUploadRequest));
+    }
+
+    @Override
+    public CompletableFuture<AbortMultipartUploadResponse> abortMultipartUpload(
+        Consumer<AbortMultipartUploadRequest.Builder> abortMultipartUploadRequest) {
+        AbortMultipartUploadRequest request = AbortMultipartUploadRequest.builder().applyMutation(abortMultipartUploadRequest).build();
+        return S3AsyncClient.super.abortMultipartUpload(request);
+    }
+
+    @Override
+    public CompletableFuture<AbortMultipartUploadResponse> abortMultipartUpload(
+        AbortMultipartUploadRequest abortMultipartUploadRequest) {
+        return CompletableFuture.completedFuture(this.s3Client.abortMultipartUpload(abortMultipartUploadRequest));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3TestBase.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3TestBase.java
new file mode 100644
index 0000000..fabd0be
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/MockS3TestBase.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.adobe.testing.s3mock.S3MockApplication;
+import org.apache.commons.io.FileUtils;
+import org.apache.rocketmq.common.UtilAll;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.junit.Assert;
+
+import java.io.File;
+import java.lang.reflect.Field;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+public class MockS3TestBase {
+
+    public static final String STORE_BASE_PATH = FileUtils.getTempDirectory() + File.separator + "MockS3TestBase-";
+
+    protected S3MockStarterTestImpl s3MockStater;
+
+    private String rootPath;
+
+    protected void startMockedS3() {
+        Map<String, Object> properties = new HashMap<String, Object>();
+        properties.put(S3MockApplication.PROP_HTTP_PORT, S3MockApplication.RANDOM_PORT);
+        properties.put(S3MockApplication.PROP_HTTPS_PORT, S3MockApplication.RANDOM_PORT);
+        rootPath = STORE_BASE_PATH + UUID.randomUUID();
+        properties.put(S3MockApplication.PROP_ROOT_DIRECTORY, rootPath);
+        properties.put(S3MockApplication.PROP_INITIAL_BUCKETS, "rocketmq_lcy");
+
+        TieredMessageStoreConfig config = new TieredMessageStoreConfig();
+        config.setObjectStoreRegion("ap-northeast-1");
+        config.setObjectStoreBucket("rocketmq-lcy");
+        config.setObjectStoreAccessKey("");
+        config.setObjectStoreSecretKey("");
+        s3MockStater = new S3MockStarterTestImpl(properties);
+        s3MockStater.start();
+        TieredStorageS3Client client = MockS3AsyncClient.getMockTieredStorageS3Client(config, s3MockStater);
+        try {
+            Field instanceField = TieredStorageS3Client.class.getDeclaredField("instance");
+            instanceField.setAccessible(true);
+            instanceField.set(null, client);
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+        }
+    }
+
+    protected void clearMockS3Data() {
+        this.s3MockStater.stop();
+        UtilAll.deleteFile(new File(rootPath));
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentMetadataTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentMetadataTest.java
new file mode 100644
index 0000000..78910be
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentMetadataTest.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class S3FileSegmentMetadataTest {
+
+    @Test
+    public void testBasicOperation() {
+        S3FileSegmentMetadata metadata = new S3FileSegmentMetadata();
+        // valid chunk adding
+        Assert.assertTrue(metadata.addChunk(new ChunkMetadata("test", 0, 10)));
+        Assert.assertTrue(metadata.addChunk(new ChunkMetadata("test", 10, 10)));
+        Assert.assertEquals(0, metadata.getStartPosition());
+        Assert.assertEquals(19, metadata.getEndPosition());
+        Assert.assertEquals(20, metadata.getSize());
+        Assert.assertEquals(2, metadata.getChunkCount());
+        Assert.assertFalse(metadata.isSealed());
+
+        // invalid chunk adding
+        Assert.assertFalse(metadata.addChunk(new ChunkMetadata("test", 0, 10)));
+
+        // seal
+        metadata.setSegment(new ChunkMetadata("test", 0, 10));
+        Assert.assertTrue(metadata.isSealed());
+        Assert.assertEquals(0, metadata.getStartPosition());
+        Assert.assertEquals(9, metadata.getEndPosition());
+        Assert.assertEquals(10, metadata.getSize());
+        Assert.assertEquals(2, metadata.getChunkCount());
+
+        // remove all chunks
+        metadata.removeAllChunks();
+        Assert.assertEquals(0, metadata.getChunkCount());
+
+    }
+
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentTest.java
new file mode 100644
index 0000000..d1f2095
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3FileSegmentTest.java
@@ -0,0 +1,236 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.adobe.testing.s3mock.S3MockApplication;
+import java.util.Arrays;
+import java.util.List;
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.exception.TieredStoreErrorCode;
+import org.apache.rocketmq.tieredstore.exception.TieredStoreException;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStream;
+import org.apache.rocketmq.tieredstore.provider.inputstream.TieredFileSegmentInputStreamFactory;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CompletionException;
+
+import static org.apache.rocketmq.tieredstore.util.TieredStoreUtil.MB;
+
+@Ignore
+public class S3FileSegmentTest extends MockS3TestBase {
+
+    private static final TieredMessageStoreConfig CONFIG = new TieredMessageStoreConfig();
+
+    static {
+        CONFIG.setBrokerClusterName("test-cluster");
+        CONFIG.setBrokerName("test-broker");
+        CONFIG.setObjectStoreRegion("ap-northeast-1");
+        CONFIG.setObjectStoreBucket("rocketmq-lcy");
+        CONFIG.setObjectStoreAccessKey("");
+        CONFIG.setObjectStoreSecretKey("");
+    }
+
+    private static final Map<String, Object> PROPERTIES = new HashMap<String, Object>();
+
+    static {
+        PROPERTIES.put(S3MockApplication.PROP_HTTP_PORT, S3MockApplication.RANDOM_PORT);
+        PROPERTIES.put(S3MockApplication.PROP_HTTPS_PORT, S3MockApplication.RANDOM_PORT);
+        PROPERTIES.put(S3MockApplication.PROP_INITIAL_BUCKETS, CONFIG.getObjectStoreBucket());
+    }
+
+    private static final MessageQueue MQ = new MessageQueue();
+
+    static {
+        MQ.setBrokerName("test-broker");
+        MQ.setQueueId(0);
+        MQ.setTopic("test-topic");
+    }
+
+    private static final long BASE_OFFSET = 1024;
+
+    private static final TieredFileSegment.FileSegmentType TYPE = TieredFileSegment.FileSegmentType.CONSUME_QUEUE;
+
+    private S3FileSegment segment;
+
+    @Before
+    public void setUp() {
+        startMockedS3();
+        segment = new S3FileSegment(TYPE, MQ, BASE_OFFSET, CONFIG);
+    }
+
+    @After
+    public void tearDown() {
+        clearMockS3Data();
+    }
+
+    @Test
+    public void testNewInstance() {
+        S3FileSegmentMetadata metadata = segment.getMetadata();
+        Assert.assertEquals(0, metadata.getSize());
+    }
+
+    @Test
+    public void testCommit() {
+        TieredFileSegmentInputStream inputStream = buildMockedInputStream("hello".getBytes());
+        segment.commit0(inputStream, 0, 5, false).join();
+        ByteBuffer read = segment.read0(0, 5).join();
+        Assert.assertEquals("hello", new String(read.array()));
+        Assert.assertEquals(5, segment.getSize());
+        Assert.assertEquals(0, segment.getMetadata().getStartPosition());
+        Assert.assertEquals(4, segment.getMetadata().getEndPosition());
+    }
+
+    @Test
+    public void testCommitAndRestart() {
+        TieredFileSegmentInputStream inputStream = buildMockedInputStream("hello".getBytes());
+        segment.commit0(inputStream, 0, 5, false).join();
+        ByteBuffer read = segment.read0(0, 5).join();
+        Assert.assertEquals("hello", new String(read.array()));
+        Assert.assertEquals(5, segment.getSize());
+        Assert.assertEquals(0, segment.getMetadata().getStartPosition());
+        Assert.assertEquals(4, segment.getMetadata().getEndPosition());
+
+        segment = new S3FileSegment(TYPE, MQ, BASE_OFFSET, CONFIG);
+        Assert.assertEquals(5, segment.getSize());
+        Assert.assertEquals(0, segment.getMetadata().getStartPosition());
+        Assert.assertEquals(4, segment.getMetadata().getEndPosition());
+        read = segment.read0(0, 5).join();
+        Assert.assertEquals("hello", new String(read.array()));
+    }
+
+    @Test
+    public void testRestartWithInvalidChunks() {
+        // write invalid chunks
+        TieredStorageS3Client client = TieredStorageS3Client.getInstance(CONFIG);
+        client.writeChunk(segment.getChunkPath() + File.separator + "chunk-" + 0, new ByteArrayInputStream("hello".getBytes()), 5).join();
+        client.writeChunk(segment.getChunkPath() + File.separator + "chunk-" + 1, new ByteArrayInputStream("world".getBytes()), 5).join();
+
+        // initialize invalid chunks
+        Assert.assertThrows(RuntimeException.class, () -> segment = new S3FileSegment(TYPE, MQ, BASE_OFFSET, CONFIG));
+    }
+
+    @Test
+    public void testRestartWithInvalidSegments() {
+        // write two segments
+        TieredStorageS3Client client = TieredStorageS3Client.getInstance(CONFIG);
+        client.writeChunk(segment.getSegmentPath() + File.separator + "segment-" + 0, new ByteArrayInputStream("hello".getBytes()), 5).join();
+        client.writeChunk(segment.getSegmentPath() + File.separator + "segment-" + 1, new ByteArrayInputStream("world".getBytes()), 5).join();
+
+        // initialize invalid segments
+        Assert.assertThrows(RuntimeException.class, () -> segment = new S3FileSegment(TYPE, MQ, BASE_OFFSET, CONFIG));
+    }
+
+    @Test
+    public void testCommitAndDelete() {
+        TieredFileSegmentInputStream inputStream = buildMockedInputStream("hello".getBytes());
+        segment.commit0(inputStream, 0, 5, false).join();
+        ByteBuffer read = segment.read0(0, 5).join();
+        Assert.assertEquals("hello", new String(read.array()));
+        segment.destroyFile();
+        segment = new S3FileSegment(TYPE, MQ, BASE_OFFSET, CONFIG);
+        Assert.assertEquals(0, segment.getSize());
+        Assert.assertEquals(-1, segment.getMetadata().getStartPosition());
+        Assert.assertEquals(-1, segment.getMetadata().getEndPosition());
+        Assert.assertTrue(segment.read0(0, 5).isCompletedExceptionally());
+    }
+
+    @Test
+    public void testBackwardCommitPosition() {
+        // write first chunk: "hello", size = 5, position: [0, 4]
+        TieredFileSegmentInputStream inputStream = buildMockedInputStream("hello".getBytes());
+        Assert.assertTrue(segment.commit0(inputStream, 0, 5, false).join());
+        ByteBuffer read = segment.read0(0, 5).join();
+        Assert.assertEquals("hello", new String(read.array()));
+        // write second chunk: ",world", size = 6, position: [5, 10]
+        inputStream = buildMockedInputStream(",world".getBytes());
+        Assert.assertTrue(segment.commit0(inputStream, 5, 6, false).join());
+        read = segment.read0(0, 11).join();
+        Assert.assertEquals("hello,world", new String(read.array()));
+        // write third chunk: " and lcy", size = 8, position: [11, 18]
+        inputStream = buildMockedInputStream(" and lcy".getBytes());
+        Assert.assertTrue(segment.commit0(inputStream, 11, 8, false).join());
+        read = segment.read0(0, 19).join();
+        Assert.assertEquals("hello,world and lcy", new String(read.array()));
+        // write a chunk from position 2, size = 2, data: "he", position: [2, 3]
+        inputStream = buildMockedInputStream("he".getBytes());
+        TieredStoreException exception = null;
+        try {
+            segment.commit0(inputStream, 2, 2, false).join();
+        } catch (CompletionException e) {
+            Throwable cause = e.getCause();
+            Assert.assertTrue(cause instanceof TieredStoreException);
+            exception = (TieredStoreException) cause;
+            Assert.assertEquals(TieredStoreErrorCode.ILLEGAL_OFFSET, exception.getErrorCode());
+            Assert.assertEquals(19, exception.getPosition());
+        }
+        Assert.assertNotNull(exception);
+    }
+
+    @Test
+    public void testSeal() throws Exception {
+        CONFIG.setEnableMerge(true);
+        int unit = (int) (5 * MB);
+        ByteBuffer byteBuffer = ByteBuffer.allocate(unit);
+        for (int i = 0; i < unit; i++) {
+            byteBuffer.put((byte) i);
+        }
+        byte[] array = byteBuffer.array();
+        for (int i = 0; i < 2; i++) {
+            TieredFileSegmentInputStream inputStream = buildMockedInputStream(array);
+            segment.commit0(inputStream, i * unit, unit, false).join();
+        }
+        // seal
+        segment.sealFile();
+        Thread.sleep(3000);
+
+        Assert.assertTrue(segment.isSealed());
+        S3FileSegmentMetadata metadata = segment.getMetadata();
+        Assert.assertEquals(0, metadata.getChunkCount());
+        Assert.assertEquals(0, metadata.getStartPosition());
+        Assert.assertEquals(2 * unit - 1, metadata.getEndPosition());
+        Assert.assertEquals(2 * unit, metadata.getSize());
+        TieredStoreException exception = null;
+        try {
+            segment.commit0(buildMockedInputStream("lcy".getBytes()), 2 * unit, 3, false).join();
+        } catch (CompletionException e) {
+            Throwable cause = e.getCause();
+            Assert.assertTrue(cause instanceof TieredStoreException);
+            exception = (TieredStoreException) cause;
+            Assert.assertEquals(TieredStoreErrorCode.SEGMENT_SEALED, exception.getErrorCode());
+        }
+        Assert.assertNotNull(exception);
+        CONFIG.setEnableMerge(false);
+    }
+
+    private TieredFileSegmentInputStream buildMockedInputStream(byte[] bytes) {
+        List<ByteBuffer> uploadBuffers = Arrays.asList(ByteBuffer.wrap(bytes));
+        return TieredFileSegmentInputStreamFactory.build(TieredFileSegment.FileSegmentType.CONSUME_QUEUE, 0, uploadBuffers, null, bytes.length);
+    }
+
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3MockStarterTestImpl.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3MockStarterTestImpl.java
new file mode 100644
index 0000000..f8a624d
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/S3MockStarterTestImpl.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import com.adobe.testing.s3mock.testsupport.common.S3MockStarter;
+
+import java.util.Map;
+
+public class S3MockStarterTestImpl extends S3MockStarter {
+    protected S3MockStarterTestImpl(Map<String, Object> properties) {
+        super(properties);
+    }
+
+    @Override
+    protected void start() {
+        super.start();
+    }
+
+    @Override
+    protected void stop() {
+        super.stop();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredDispatcherForS3Test.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredDispatcherForS3Test.java
new file mode 100644
index 0000000..89bf383
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredDispatcherForS3Test.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.TieredDispatcherBaseTest;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+
+import java.io.IOException;
+import org.junit.Ignore;
+
+@Ignore
+public class TieredDispatcherForS3Test extends TieredDispatcherBaseTest {
+
+    private MockS3TestBase mockS3TestBase = new MockS3TestBase();
+
+    @Override
+    public TieredMessageStoreConfig createTieredMessageStoreConfig() {
+        TieredMessageStoreConfig storeConfig = new TieredMessageStoreConfig();
+        storeConfig.setStorePathRootDir(storePath);
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.s3.S3FileSegment");
+        storeConfig.setBrokerName(storeConfig.getBrokerName());
+        storeConfig.setBrokerClusterName("test-cluster");
+        storeConfig.setObjectStoreRegion("ap-northeast-1");
+        storeConfig.setObjectStoreBucket("rocketmq-lcy");
+        return storeConfig;
+    }
+
+    @Override
+    public TieredFileSegment createTieredFileSegment(TieredFileSegment.FileSegmentType type, MessageQueue mq,
+        long baseOffset, TieredMessageStoreConfig storeConfig) {
+        return new S3FileSegment(type, mq, baseOffset, storeConfig);
+    }
+
+    @Override
+    public void setUp() {
+        mockS3TestBase.startMockedS3();
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws IOException {
+        super.tearDown();
+        mockS3TestBase.clearMockS3Data();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredFileSegmentForS3Test.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredFileSegmentForS3Test.java
new file mode 100644
index 0000000..9438118
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredFileSegmentForS3Test.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import org.apache.rocketmq.common.message.MessageQueue;
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegment;
+import org.apache.rocketmq.tieredstore.provider.TieredFileSegmentBaseTest;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+
+@Ignore
+public class TieredFileSegmentForS3Test extends TieredFileSegmentBaseTest {
+
+    private MockS3TestBase mockS3TestBase = new MockS3TestBase();
+
+    private static final TieredMessageStoreConfig CONFIG = new TieredMessageStoreConfig();
+
+    static {
+        CONFIG.setBrokerClusterName("test-cluster");
+        CONFIG.setBrokerName("test-broker");
+        CONFIG.setObjectStoreRegion("ap-northeast-1");
+        CONFIG.setObjectStoreBucket("rocketmq-lcy");
+        CONFIG.setObjectStoreAccessKey("");
+        CONFIG.setObjectStoreSecretKey("");
+    }
+
+    public TieredFileSegment createFileSegment(TieredFileSegment.FileSegmentType fileType) {
+        return new S3FileSegment(fileType, new MessageQueue("TieredFileSegmentTest", CONFIG.getBrokerName(), 0),
+            baseOffset, CONFIG);
+    }
+
+    @Before
+    public void setUp() {
+        mockS3TestBase.startMockedS3();
+    }
+
+    @After
+    public void tearDown() {
+        mockS3TestBase.clearMockS3Data();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredMessageFetcherForS3Test.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredMessageFetcherForS3Test.java
new file mode 100644
index 0000000..809d73d
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredMessageFetcherForS3Test.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import org.apache.rocketmq.tieredstore.TieredMessageFetcherBaseTest;
+
+import java.io.IOException;
+import org.junit.Ignore;
+
+@Ignore
+public class TieredMessageFetcherForS3Test extends TieredMessageFetcherBaseTest {
+
+    private MockS3TestBase mockS3TestBase = new MockS3TestBase();
+
+    @Override
+    public void setTieredBackendProvider() {
+        storeConfig.setTieredBackendServiceProvider("org.apache.rocketmq.tieredstore.provider.s3.S3FileSegment");
+    }
+
+    @Override
+    public void setUp() {
+        mockS3TestBase.startMockedS3();
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws IOException {
+        super.tearDown();
+        mockS3TestBase.clearMockS3Data();
+    }
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredStorageS3ClientTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredStorageS3ClientTest.java
new file mode 100644
index 0000000..35750d0
--- /dev/null
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/provider/s3/TieredStorageS3ClientTest.java
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.tieredstore.provider.s3;
+
+import org.apache.rocketmq.tieredstore.common.TieredMessageStoreConfig;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import static org.apache.rocketmq.tieredstore.util.TieredStoreUtil.MB;
+
+@Ignore
+public class TieredStorageS3ClientTest extends MockS3TestBase {
+
+    private static final TieredMessageStoreConfig CONFIG = new TieredMessageStoreConfig();
+
+    private static final String BASE_DIR = "123/c/b/t/0/CommitLog/seg-0";
+
+    static {
+        CONFIG.setBrokerClusterName("test-cluster");
+        CONFIG.setBrokerName("test-broker");
+        CONFIG.setObjectStoreRegion("ap-northeast-1");
+        CONFIG.setObjectStoreBucket("rocketmq-lcy");
+        CONFIG.setObjectStoreAccessKey("");
+        CONFIG.setObjectStoreSecretKey("");
+    }
+
+    private TieredStorageS3Client client;
+
+    @Before
+    public void setUp() {
+        startMockedS3();
+        client = MockS3AsyncClient.getMockTieredStorageS3Client(CONFIG, s3MockStater);
+    }
+
+    @After
+    public void tearDown() {
+        clearMockS3Data();
+    }
+
+    @Test
+    public void testWriteChunk() {
+        InputStream inputStream = new ByteArrayInputStream("test".getBytes());
+        String chunkName = BASE_DIR + File.separator + "chunk-0";
+        CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, 4);
+        Assert.assertTrue(completableFuture.join());
+    }
+
+    @Test
+    public void testReadChunk() {
+        InputStream inputStream = new ByteArrayInputStream("test".getBytes());
+        String chunkName = BASE_DIR + File.separator + "chunk-0";
+        CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, 4);
+        Assert.assertTrue(completableFuture.join());
+        byte[] bytes = client.readChunk(chunkName, 0, 4).join();
+        Assert.assertEquals("test", new String(bytes));
+    }
+
+    @Test
+    public void testListChunks() {
+        for (int i = 0; i < 10; i++) {
+            String chunkName = BASE_DIR + File.separator + "chunk-" + (i * 5);
+            InputStream inputStream = new ByteArrayInputStream(("test" + i).getBytes());
+            CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, 5);
+            Assert.assertTrue(completableFuture.join());
+        }
+        List<ChunkMetadata> chunks = client.listChunks(BASE_DIR).join();
+        Assert.assertEquals(10, chunks.size());
+        for (int i = 0; i < 10; i++) {
+            ChunkMetadata chunkMetadata = chunks.get(i);
+            String chunkName = BASE_DIR + File.separator + "chunk-" + (i * 5);
+            Assert.assertEquals(chunkName, chunkMetadata.getChunkName());
+            Assert.assertEquals(i * 5, chunkMetadata.getStartPosition());
+            Assert.assertEquals(5, chunkMetadata.getChunkSize());
+        }
+    }
+
+    @Test
+    public void testExist() {
+        String chunkName = BASE_DIR + File.separator + "chunk-0";
+        Assert.assertFalse(client.exist(chunkName).join());
+
+        InputStream inputStream = new ByteArrayInputStream("test".getBytes());
+        CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, 4);
+        Assert.assertTrue(completableFuture.join());
+
+        Assert.assertTrue(client.exist(chunkName).join());
+    }
+
+    @Test
+    public void testDeleteObjects() {
+        for (int i = 0; i < 10; i++) {
+            String chunkName = BASE_DIR + File.separator + "chunk-" + (i * 5);
+            InputStream inputStream = new ByteArrayInputStream(("test" + i).getBytes());
+            CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, 5);
+            Assert.assertTrue(completableFuture.join());
+        }
+        List<ChunkMetadata> chunks = client.listChunks(BASE_DIR).join();
+        Assert.assertEquals(10, chunks.size());
+        for (int i = 0; i < 10; i++) {
+            ChunkMetadata chunkMetadata = chunks.get(i);
+            String chunkName = BASE_DIR + File.separator + "chunk-" + (i * 5);
+            Assert.assertEquals(chunkName, chunkMetadata.getChunkName());
+            Assert.assertEquals(i * 5, chunkMetadata.getStartPosition());
+            Assert.assertEquals(5, chunkMetadata.getChunkSize());
+        }
+
+        List<String> undeleted = client.deleteObjects(BASE_DIR).join();
+        Assert.assertTrue(undeleted.isEmpty());
+
+        chunks = client.listChunks(BASE_DIR).join();
+        Assert.assertEquals(0, chunks.size());
+    }
+
+    @Test
+    public void testMergeAllChunksIntoSegment() {
+        int unit = (int) (5 * MB);
+        List<ChunkMetadata> chunks = new ArrayList<>(2);
+        ByteBuffer byteBuffer = ByteBuffer.allocate(unit);
+        for (int i = 0; i < unit; i++) {
+            byteBuffer.put((byte) i);
+        }
+        byte[] bytes = byteBuffer.array();
+        for (int i = 0; i < 2; i++) {
+            String chunkName = BASE_DIR + File.separator + "chunk-" + (i * unit);
+            chunks.add(new ChunkMetadata(chunkName, i * unit, unit));
+            InputStream inputStream = new ByteArrayInputStream(bytes);
+            CompletableFuture<Boolean> completableFuture = client.writeChunk(chunkName, inputStream, unit);
+            Assert.assertTrue(completableFuture.join());
+        }
+        String segName = BASE_DIR + File.separator + "segment-0";
+        Boolean merged = this.client.mergeAllChunksIntoSegment(chunks, segName).join();
+        Assert.assertTrue(merged);
+        byte[] segBytes = this.client.readChunk(segName, 0, 2 * unit).join();
+        Assert.assertEquals(2 * unit, segBytes.length);
+        for (int i = 0; i < 2; i++) {
+            int offset = i * unit;
+            for (int j = 0; j < unit; j++) {
+                Assert.assertEquals(bytes[j], segBytes[j + offset]);
+            }
+        }
+    }
+
+}
diff --git a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
index befd401..c16ffa4 100644
--- a/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
+++ b/tieredstore/src/test/java/org/apache/rocketmq/tieredstore/util/MessageBufferUtilTest.java
@@ -112,6 +112,31 @@ public class MessageBufferUtilTest {
     }
 
 
+    public static void verifyMockedMessageBuffer(ByteBuffer buffer, int phyOffset) {
+        Assert.assertEquals(MSG_LEN, buffer.remaining());
+        Assert.assertEquals(MSG_LEN, buffer.getInt());
+        Assert.assertEquals(MessageDecoder.MESSAGE_MAGIC_CODE_V2, buffer.getInt());
+        Assert.assertEquals(3, buffer.getInt());
+        Assert.assertEquals(4, buffer.getInt());
+        Assert.assertEquals(5, buffer.getInt());
+        Assert.assertEquals(6, buffer.getLong());
+        Assert.assertEquals(phyOffset, buffer.getLong());
+        Assert.assertEquals(8, buffer.getInt());
+        Assert.assertEquals(9, buffer.getLong());
+        Assert.assertEquals(10, buffer.getLong());
+        Assert.assertEquals(11, buffer.getLong());
+        Assert.assertEquals(10, buffer.getLong());
+        Assert.assertEquals(13, buffer.getInt());
+        Assert.assertEquals(14, buffer.getLong());
+        Assert.assertEquals(0, buffer.getInt());
+        Assert.assertEquals(0, buffer.getShort());
+        buffer.rewind();
+        Map<String, String> properties = MessageBufferUtil.getProperties(buffer);
+        Assert.assertEquals("uk", properties.get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));
+        Assert.assertEquals("uservalue0", properties.get("userkey"));
+    }
+
+
     @Test
     public void testGetTotalSize() {
         ByteBuffer buffer = buildMockedMessageBuffer();

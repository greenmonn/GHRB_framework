diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/CommonHeterogeneousSQLStatementCheckerTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/CommonHeterogeneousSQLStatementCheckerTest.java
new file mode 100644
index 0000000..8fd840f
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/CommonHeterogeneousSQLStatementCheckerTest.java
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.proxy.backend.hbase.result.HBaseSupportedSQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BetweenExpression;
+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.WhereSegment;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;
+import org.junit.Test;
+import java.util.Optional;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CommonHeterogeneousSQLStatementCheckerTest {
+    
+    @Test
+    public void assertIsSinglePoint() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey = '1'");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        commonHeterogeneousSQLStatementChecker.checkIsSinglePointQuery(sqlStatement.getWhere());
+    }
+    
+    @Test
+    public void assertIsSinglePointWithErrorKey() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where a = '1'");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        try {
+            commonHeterogeneousSQLStatementChecker.checkIsSinglePointQuery(sqlStatement.getWhere());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals(e.getMessage(), "a is not a allowed key");
+        }
+    }
+    
+    @Test
+    public void assertIsSinglePointWithErrorOperation() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey between '1' and '2' ");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        try {
+            commonHeterogeneousSQLStatementChecker.checkIsSinglePointQuery(sqlStatement.getWhere());
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals(e.getMessage(), "Only Support BinaryOperationExpression");
+        }
+    }
+    
+    @Test
+    public void assertInExpression() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey in ('1', '2') ");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        Optional<WhereSegment> whereSegment = sqlStatement.getWhere();
+        if (whereSegment.isPresent()) {
+            commonHeterogeneousSQLStatementChecker.checkInExpressionIsExpected(whereSegment.get().getExpr());
+        } else {
+            fail();
+        }
+    }
+    
+    @Test
+    public void assertInExpressionWithNotIn() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey not in ('1', '2') ");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        Optional<WhereSegment> whereSegment = sqlStatement.getWhere();
+        if (whereSegment.isPresent()) {
+            try {
+                commonHeterogeneousSQLStatementChecker.checkInExpressionIsExpected(whereSegment.get().getExpr());
+                fail();
+            } catch (IllegalArgumentException e) {
+                assertEquals(e.getMessage(), "Do not supported `not in`");
+            }
+        } else {
+            fail();
+        }
+    }
+    
+    @Test
+    public void assertInExpressionWithErrorKey() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where a in ('1', '2') ");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        Optional<WhereSegment> whereSegment = sqlStatement.getWhere();
+        if (whereSegment.isPresent()) {
+            try {
+                commonHeterogeneousSQLStatementChecker.checkInExpressionIsExpected(whereSegment.get().getExpr());
+                fail();
+            } catch (IllegalArgumentException e) {
+                assertEquals(e.getMessage(), "a is not a allowed key");
+            }
+        } else {
+            fail();
+        }
+    }
+    
+    @Test
+    public void assertIsAllowExpressionSegment() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey BETWEEN 'v1' AND 'v2' ");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        Optional<WhereSegment> whereSegment = sqlStatement.getWhere();
+        if (whereSegment.isPresent()) {
+            BetweenExpression betweenExpression = (BetweenExpression) whereSegment.get().getExpr();
+            assertTrue(commonHeterogeneousSQLStatementChecker.isAllowExpressionSegment(betweenExpression.getBetweenExpr()));
+            assertTrue(commonHeterogeneousSQLStatementChecker.isAllowExpressionSegment(betweenExpression.getAndExpr()));
+        } else {
+            fail();
+        }
+    }
+    
+    @Test
+    public void assertIsAllowExpressionSegmentError() {
+        SelectStatement sqlStatement = (SelectStatement) HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where rowKey = '1'");
+        CommonHeterogeneousSQLStatementChecker<SQLStatement> commonHeterogeneousSQLStatementChecker = new CommonHeterogeneousSQLStatementChecker<>(sqlStatement);
+        Optional<WhereSegment> whereSegment = sqlStatement.getWhere();
+        if (whereSegment.isPresent()) {
+            assertFalse(commonHeterogeneousSQLStatementChecker.isAllowExpressionSegment(whereSegment.get().getExpr()));
+        } else {
+            fail();
+        }
+    }
+}
diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HBaseDatabaseCheckerFactoryTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HBaseDatabaseCheckerFactoryTest.java
new file mode 100644
index 0000000..8984f1c
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HBaseDatabaseCheckerFactoryTest.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dal.MySQLShowCreateTableStatement;
+import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dml.MySQLDeleteStatement;
+import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dml.MySQLInsertStatement;
+import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dml.MySQLSelectStatement;
+import org.apache.shardingsphere.sql.parser.sql.dialect.statement.mysql.dml.MySQLUpdateStatement;
+import org.junit.Test;
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.mock;
+
+public final class HBaseDatabaseCheckerFactoryTest {
+    
+    @Test
+    public void assertExecuteSelectStatement() {
+        SQLStatement sqlStatement = mock(MySQLSelectStatement.class);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        assertThat(actual, instanceOf(HeterogeneousSelectStatementChecker.class));
+        assertThat(actual.getSqlStatement(), is(sqlStatement));
+    }
+    
+    @Test
+    public void assertExecuteInsertStatement() {
+        SQLStatement sqlStatement = mock(MySQLInsertStatement.class);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        assertThat(actual, instanceOf(HeterogeneousInsertStatementChecker.class));
+        assertThat(actual.getSqlStatement(), is(sqlStatement));
+    }
+    
+    @Test
+    public void assertExecuteUpdateStatement() {
+        SQLStatement sqlStatement = mock(MySQLUpdateStatement.class);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        assertThat(actual, instanceOf(HeterogeneousUpdateStatementChecker.class));
+        assertThat(actual.getSqlStatement(), is(sqlStatement));
+    }
+    
+    @Test
+    public void assertExecuteDeleteStatement() {
+        SQLStatement sqlStatement = mock(MySQLDeleteStatement.class);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        assertThat(actual, instanceOf(HeterogeneousDeleteStatementChecker.class));
+        assertThat(actual.getSqlStatement(), is(sqlStatement));
+    }
+    
+    @Test
+    public void assertExecuteOtherStatement() {
+        SQLStatement sqlStatement = mock(MySQLShowCreateTableStatement.class);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        assertThat(actual, instanceOf(CommonHeterogeneousSQLStatementChecker.class));
+        assertThat(actual.getSqlStatement(), is(sqlStatement));
+    }
+}
diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousDeleteStatementCheckerTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousDeleteStatementCheckerTest.java
new file mode 100644
index 0000000..ee5bc56
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousDeleteStatementCheckerTest.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.proxy.backend.hbase.result.HBaseSupportedSQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+public final class HeterogeneousDeleteStatementCheckerTest {
+    
+    @Rule
+    public ExpectedException expectedEx = ExpectedException.none();
+    
+    @Test
+    public void assertExecuteDeleteStatement() {
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(HBaseSupportedSQLStatement.getDeleteStatement());
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertOperatorIsNotEqual() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only Supported `=` operator");
+        String sql = "delete /*+ hbase */ from t_test_order where rowKey > 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertColumnIsNotRowKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("is not a allowed key");
+        String sql = "delete /*+ hbase */ from t_test_order where age = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertLeftIsNotColumn() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("left segment must is ColumnSegment");
+        String sql = "delete /*+ hbase */ from t_test_order where 1 = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertMultiExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported Multiple expressions");
+        String sql = "DELETE /*+ hbase */ FROM t_order WHERE order_id = ? AND user_id = ? AND status=?";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertWithBetweenExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only Support BinaryOperationExpression");
+        String sql = "DELETE /*+ hbase */ FROM t_order WHERE rowKey between 1 and 5";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertNotWhereSegment() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Must Have Where Segment");
+        String sql = "DELETE /*+ hbase */ FROM t_order";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+}
diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousInsertStatementCheckerTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousInsertStatementCheckerTest.java
new file mode 100644
index 0000000..543ded8
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousInsertStatementCheckerTest.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.proxy.backend.hbase.result.HBaseSupportedSQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+public final class HeterogeneousInsertStatementCheckerTest {
+    
+    @Rule
+    public ExpectedException expectedEx = ExpectedException.none();
+    
+    @Test
+    public void assertExecuteInsertStatement() {
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(HBaseSupportedSQLStatement.getInsertStatement());
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithoutRowKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("First column must be rowKey");
+        String sql = "INSERT /*+ HBase */ INTO t_order (order_id, user_id, status) VALUES (?, ?, ?)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithoutColumns() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("The inserted column must be explicitly specified");
+        String sql = "INSERT /*+ HBase */ INTO t_order VALUES (?, ?, ?)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithMultipleRowKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Cannot contain multiple rowKey");
+        String sql = "INSERT /*+ HBase */ INTO t_order (rowKey, id, status) VALUES (?, ?, ?)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithOnDuplicateKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported ON DUPLICATE KEY UPDATE");
+        String sql = "INSERT /*+ HBase */ INTO t_order (rowKey, user_id, status) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE status = ?";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithFunction() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Value must is literal or parameter marker");
+        String sql = "INSERT /*+ HBase */ INTO t_order_item (rowKey, order_id, user_id, status, creation_date) VALUES (?, ?, ?, 'insert', now())";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithLiteralAndParameterMarker() {
+        String sql = "INSERT /*+ HBase */ INTO t_order_item(rowKey, order_id, user_id, status, creation_date) VALUES (?, ?, ?, 'insert', '2017-08-08')";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertInsertWithSubQuery() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported `insert into...select...`");
+        String sql = "INSERT /*+ HBase */ INTO t_order_item(rowKey, order_id, user_id) select rowKey, order_id, user_id from t_order";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+}
diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousSelectStatementCheckerTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousSelectStatementCheckerTest.java
new file mode 100644
index 0000000..44ba3fb
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousSelectStatementCheckerTest.java
@@ -0,0 +1,259 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.proxy.backend.hbase.context.HBaseContext;
+import org.apache.shardingsphere.proxy.backend.hbase.props.HBaseProperties;
+import org.apache.shardingsphere.proxy.backend.hbase.props.HBasePropertyKey;
+import org.apache.shardingsphere.proxy.backend.hbase.result.HBaseSupportedSQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public final class HeterogeneousSelectStatementCheckerTest {
+    
+    @Rule
+    public ExpectedException expectedEx = ExpectedException.none();
+    
+    @Before
+    public void setUp() {
+        HBaseProperties props = mock(HBaseProperties.class);
+        when(props.getValue(HBasePropertyKey.MAX_SCAN_LIMIT_SIZE)).thenReturn(5000L);
+        HBaseContext.getInstance().setProps(props);
+    }
+    
+    @Test
+    public void assertSelectStatement() {
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(HBaseSupportedSQLStatement.getSelectStatement());
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithLargeRowCount() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("row count must less than 5000");
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where id = 1 limit 5001");
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithLimitSegment() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported offset segment");
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where id = 1 limit 5 offset 3");
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithLockSegment() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported lock segment");
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement("select /*+ hbase */ * from t_order where id = 1 lock in share mode");
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithFunction() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only supported ShorthandProjection and ColumnProjection");
+        String sql = "SELECT /*+ HBase */ sum(score) FROM person";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithJoinStatement() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only supported SimpleTableSegment");
+        String sql = "SELECT /*+ HBase */ * FROM t_order o JOIN t_order_item i ON o.user_id = i.user_id AND o.order_id = i.order_id";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithMultipleInExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("left segment must is ColumnSegment");
+        String sql = "SELECT /*+ HBase */ * FROM t_order WHERE rowKey IN (?, ?) AND id IN (?, ?)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithInExpression() {
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey in (1, 2, 3)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementWithErrorKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("age is not a allowed key");
+        String sql = "SELECT /*+ HBase */ * from t_order where age in (1, 2, 3)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithNotIn() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported `not in`");
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey not in (1, 2, 3)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithParameterMarker() {
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey in (?, ?, ?)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectStatementUseCrc32() {
+        String sql = "SELECT /*+ HBase */ crc32(concat_ws('#',rowKey)) from t_order where rowKey in (1, 2, 3)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithErrorInExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only supported ListExpression");
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey in (select rowKey from t_order_item)";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithBetween() {
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey between 1 and 2";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithNotBetween() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported `not between...and...`");
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey not between 1 and 2";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithBetweenErrorKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("age is not a allowed key");
+        String sql = "SELECT /*+ HBase */ * from t_order where age between 1 and 2";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertExecuteSelectWithErrorBetweenExpr() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("between expr must is literal or parameter marker");
+        String sql = "SELECT /*+ HBase */ * from t_order where rowKey between 1 and now()";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithGroupBy() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported group by segment");
+        String sql = "SELECT /*+ HBase */ * from t_order group by order_id";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithNotAllowOperator() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only Supported `=` operator");
+        String sql = "select /*+ hbase */ * from t_order where rowKey != 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithNotAllowColumn() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("age is not a allowed key");
+        String sql = "select /*+ hbase */ * from t_order where age = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithMultipleExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported Multiple expressions");
+        String sql = "select /*+ hbase */ * from t_order where rowKey = 1 and age = 2";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithNotColumnExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("left segment must is ColumnSegment");
+        String sql = "select /*+ hbase */ * from t_order where 1 = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertSelectWithParameterMarker() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only supported ShorthandProjection and ColumnProjection");
+        String sql = "select /*+ hbase */ rowKey, name, ? from t_order where rowKey = 'kid'";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+}
diff --git a/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousUpdateStatementCheckerTest.java b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousUpdateStatementCheckerTest.java
new file mode 100644
index 0000000..0ac5d34
--- /dev/null
+++ b/proxy/backend/type/hbase/src/test/java/org/apache/shardingsphere/proxy/backend/hbase/checker/HeterogeneousUpdateStatementCheckerTest.java
@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.shardingsphere.proxy.backend.hbase.checker;
+
+import org.apache.shardingsphere.proxy.backend.hbase.result.HBaseSupportedSQLStatement;
+import org.apache.shardingsphere.sql.parser.sql.common.statement.SQLStatement;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+public final class HeterogeneousUpdateStatementCheckerTest {
+    
+    @Rule
+    public ExpectedException expectedEx = ExpectedException.none();
+    
+    @Test
+    public void assertExecuteUpdateStatement() {
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(HBaseSupportedSQLStatement.getUpdateStatement());
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertUpdateWithFunction() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Assigment must is literal or parameter marker");
+        String sql = "update /*+ hbase */ t_test_order set age = 10, name = 'bob', time = now() where rowKey = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertOperatorIsNotEqual() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Only Supported `=` operator");
+        String sql = "update /*+ hbase */ t_test_order set age = 10 where rowKey > 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertColumnIsNotRowKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("is not a allowed key");
+        String sql = "update /*+ hbase */ t_test_order set age = 10 where age = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertLeftIsNotColumn() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("left segment must is ColumnSegment");
+        String sql = "update /*+ hbase */ t_test_order set age = 10 where 1 = 1";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertMultiExpression() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not supported Multiple expressions");
+        String sql = "update /*+ hbase */ t_test_order set age = 10 WHERE order_id = ? AND user_id = ? AND status=?";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertNotWhereSegment() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Must Have Where Segment");
+        String sql = "update /*+ hbase */ t_test_order set age = 10 ";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+    
+    @Test
+    public void assertUpdateRowKey() {
+        expectedEx.expect(IllegalArgumentException.class);
+        expectedEx.expectMessage("Do not allow update rowKey");
+        String sql = "update /*+ hbase */ t_test_order set rowKey = 10 where rowKey = 'kid'";
+        SQLStatement sqlStatement = HBaseSupportedSQLStatement.parseSQLStatement(sql);
+        HeterogeneousSQLStatementChecker<?> actual = HBaseCheckerFactory.newInstance(sqlStatement);
+        actual.execute();
+    }
+}

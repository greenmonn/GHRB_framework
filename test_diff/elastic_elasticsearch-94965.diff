diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleActionTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleActionTests.java
index 2d37c9a..bc174f9 100644
--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleActionTests.java
+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleActionTests.java
@@ -76,14 +76,14 @@ public class DownsampleActionTests extends AbstractActionTestCase<DownsampleActi
 
         assertTrue(steps.get(2) instanceof WaitForNoFollowersStep);
         assertThat(steps.get(2).getKey().name(), equalTo(WaitForNoFollowersStep.NAME));
-        assertThat(steps.get(2).getNextStepKey().name(), equalTo(CleanupTargetIndexStep.NAME));
+        assertThat(steps.get(2).getNextStepKey().name(), equalTo(ReadOnlyStep.NAME));
 
-        assertTrue(steps.get(3) instanceof CleanupTargetIndexStep);
-        assertThat(steps.get(3).getKey().name(), equalTo(CleanupTargetIndexStep.NAME));
-        assertThat(steps.get(3).getNextStepKey().name(), equalTo(ReadOnlyStep.NAME));
+        assertTrue(steps.get(3) instanceof ReadOnlyStep);
+        assertThat(steps.get(3).getKey().name(), equalTo(ReadOnlyStep.NAME));
+        assertThat(steps.get(3).getNextStepKey().name(), equalTo(CleanupTargetIndexStep.NAME));
 
-        assertTrue(steps.get(4) instanceof ReadOnlyStep);
-        assertThat(steps.get(4).getKey().name(), equalTo(ReadOnlyStep.NAME));
+        assertTrue(steps.get(4) instanceof CleanupTargetIndexStep);
+        assertThat(steps.get(4).getKey().name(), equalTo(CleanupTargetIndexStep.NAME));
         assertThat(steps.get(4).getNextStepKey().name(), equalTo(GENERATE_DOWNSAMPLE_STEP_NAME));
 
         assertTrue(steps.get(5) instanceof GenerateUniqueIndexNameStep);
diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleStepTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleStepTests.java
index c98443a..1d25442 100644
--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleStepTests.java
+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/DownsampleStepTests.java
@@ -17,6 +17,7 @@ import org.elasticsearch.cluster.metadata.IndexMetadata;
 import org.elasticsearch.cluster.metadata.LifecycleExecutionState;
 import org.elasticsearch.cluster.metadata.Metadata;
 import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;
+import org.elasticsearch.test.client.NoOpClient;
 import org.elasticsearch.xpack.core.downsample.DownsampleAction;
 import org.elasticsearch.xpack.core.ilm.Step.StepKey;
 import org.elasticsearch.xpack.core.rollup.ConfigTestHelpers;
@@ -39,7 +40,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         StepKey stepKey = randomStepKey();
         StepKey nextStepKey = randomStepKey();
         DateHistogramInterval fixedInterval = ConfigTestHelpers.randomInterval();
-        return new DownsampleStep(stepKey, nextStepKey, client, fixedInterval);
+        return new DownsampleStep(stepKey, nextStepKey, null, client, fixedInterval);
     }
 
     @Override
@@ -55,12 +56,12 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
             default -> throw new AssertionError("Illegal randomisation branch");
         }
 
-        return new DownsampleStep(key, nextKey, instance.getClient(), fixedInterval);
+        return new DownsampleStep(key, nextKey, null, instance.getClient(), fixedInterval);
     }
 
     @Override
     public DownsampleStep copyInstance(DownsampleStep instance) {
-        return new DownsampleStep(instance.getKey(), instance.getNextStepKey(), instance.getClient(), instance.getFixedInterval());
+        return new DownsampleStep(instance.getKey(), instance.getNextStepKey(), null, instance.getClient(), instance.getFixedInterval());
     }
 
     private IndexMetadata getIndexMetadata(String index, String lifecycleName, DownsampleStep step) {
@@ -69,7 +70,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         lifecycleState.setAction(step.getKey().action());
         lifecycleState.setStep(step.getKey().name());
         lifecycleState.setIndexCreationDate(randomNonNegativeLong());
-        lifecycleState.setRollupIndexName("rollup-index");
+        lifecycleState.setDownsampleIndexName("downsample-index");
 
         return IndexMetadata.builder(index)
             .settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, lifecycleName))
@@ -79,10 +80,10 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
             .build();
     }
 
-    private static void assertRollupActionRequest(DownsampleAction.Request request, String sourceIndex) {
+    private static void assertDownsampleActionRequest(DownsampleAction.Request request, String sourceIndex) {
         assertNotNull(request);
         assertThat(request.getSourceIndex(), equalTo(sourceIndex));
-        assertThat(request.getTargetIndex(), equalTo("rollup-index"));
+        assertThat(request.getTargetIndex(), equalTo("downsample-index"));
     }
 
     public void testPerformAction() throws Exception {
@@ -91,7 +92,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         String index = randomAlphaOfLength(5);
 
         IndexMetadata indexMetadata = getIndexMetadata(index, lifecycleName, step);
-        mockClientRollupCall(index);
+        mockClientDownsampleCall(index);
 
         ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT).metadata(Metadata.builder().put(indexMetadata, true)).build();
         PlainActionFuture.<Void, Exception>get(f -> step.performAction(indexMetadata, clusterState, null, f));
@@ -119,7 +120,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         step.performAction(indexMetadata, emptyClusterState(), null, new ActionListener<>() {
             @Override
             public void onResponse(Void unused) {
-                fail("expecting a failure as the index doesn't have any rollup index name in its ILM execution state");
+                fail("expecting a failure as the index doesn't have any downsample index name in its ILM execution state");
             }
 
             @Override
@@ -127,7 +128,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
                 assertThat(e, instanceOf(IllegalStateException.class));
                 assertThat(
                     e.getMessage(),
-                    is("rollup index name was not generated for policy [" + policyName + "] and index [" + indexName + "]")
+                    is("downsample index name was not generated for policy [" + policyName + "] and index [" + indexName + "]")
                 );
             }
         });
@@ -140,7 +141,7 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         String backingIndexName = DataStream.getDefaultBackingIndexName(dataStreamName, 1);
         IndexMetadata indexMetadata = getIndexMetadata(backingIndexName, lifecycleName, step);
 
-        mockClientRollupCall(backingIndexName);
+        mockClientDownsampleCall(backingIndexName);
 
         ClusterState clusterState = ClusterState.builder(ClusterName.DEFAULT)
             .metadata(Metadata.builder().put(newInstance(dataStreamName, List.of(indexMetadata.getIndex()))).put(indexMetadata, true))
@@ -149,9 +150,9 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
     }
 
     /**
-     * Test rollup step when a successfully completed rollup index already exists.
+     * Test downsample step when a successfully completed downsample index already exists.
      */
-    public void testPerformActionCompletedRollupIndexExists() {
+    public void testPerformActionCompletedDownsampleIndexExists() {
         String sourceIndexName = randomAlphaOfLength(10);
         String lifecycleName = randomAlphaOfLength(5);
         DownsampleStep step = createRandomInstance();
@@ -162,8 +163,8 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         lifecycleState.setStep(step.getKey().name());
         lifecycleState.setIndexCreationDate(randomNonNegativeLong());
 
-        String rollupIndex = GenerateUniqueIndexNameStep.generateValidIndexName(DOWNSAMPLED_INDEX_PREFIX, sourceIndexName);
-        lifecycleState.setRollupIndexName(rollupIndex);
+        String downsampleIndex = GenerateUniqueIndexNameStep.generateValidIndexName(DOWNSAMPLED_INDEX_PREFIX, sourceIndexName);
+        lifecycleState.setDownsampleIndexName(downsampleIndex);
 
         IndexMetadata sourceIndexMetadata = IndexMetadata.builder(sourceIndexName)
             .settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, lifecycleName))
@@ -172,18 +173,18 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
             .numberOfReplicas(randomIntBetween(0, 5))
             .build();
 
-        // Create a successfully completed rollup index (index.rollup.status: success)
-        IndexMetadata indexMetadata = IndexMetadata.builder(rollupIndex)
+        // Create a successfully completed downsample index (index.downsample.status: success)
+        IndexMetadata indexMetadata = IndexMetadata.builder(downsampleIndex)
             .settings(
                 settings(Version.CURRENT).put(IndexMetadata.INDEX_DOWNSAMPLE_STATUS.getKey(), IndexMetadata.DownsampleTaskStatus.SUCCESS)
             )
             .numberOfShards(1)
             .numberOfReplicas(0)
             .build();
-        Map<String, IndexMetadata> indices = Map.of(rollupIndex, indexMetadata);
+        Map<String, IndexMetadata> indices = Map.of(downsampleIndex, indexMetadata);
         ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE).metadata(Metadata.builder().indices(indices)).build();
 
-        Mockito.doThrow(new IllegalStateException("Rollup action should not be invoked"))
+        Mockito.doThrow(new IllegalStateException("Downsample action should not be invoked"))
             .when(client)
             .execute(Mockito.any(), Mockito.any(), Mockito.any());
 
@@ -199,9 +200,9 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
     }
 
     /**
-     * Test rollup step when an in-progress rollup index already exists.
+     * Test downsample step when an in-progress downsample index already exists.
      */
-    public void testPerformActionRollupInProgressIndexExists() {
+    public void testPerformActionDownsampleInProgressIndexExists() {
         String sourceIndexName = randomAlphaOfLength(10);
         String lifecycleName = randomAlphaOfLength(5);
         DownsampleStep step = createRandomInstance();
@@ -212,8 +213,8 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
         lifecycleState.setStep(step.getKey().name());
         lifecycleState.setIndexCreationDate(randomNonNegativeLong());
 
-        String rollupIndex = GenerateUniqueIndexNameStep.generateValidIndexName(DOWNSAMPLED_INDEX_PREFIX, sourceIndexName);
-        lifecycleState.setRollupIndexName(rollupIndex);
+        String downsampleIndex = GenerateUniqueIndexNameStep.generateValidIndexName(DOWNSAMPLED_INDEX_PREFIX, sourceIndexName);
+        lifecycleState.setDownsampleIndexName(downsampleIndex);
 
         IndexMetadata sourceIndexMetadata = IndexMetadata.builder(sourceIndexName)
             .settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, lifecycleName))
@@ -222,37 +223,113 @@ public class DownsampleStepTests extends AbstractStepTestCase<DownsampleStep> {
             .numberOfReplicas(randomIntBetween(0, 5))
             .build();
 
-        // Create an in-progress rollup index (index.rollup.status: started)
-        IndexMetadata indexMetadata = IndexMetadata.builder(rollupIndex)
+        // Create an in-progress downsample index (index.downsample.status: started)
+        IndexMetadata indexMetadata = IndexMetadata.builder(downsampleIndex)
             .settings(
                 settings(Version.CURRENT).put(IndexMetadata.INDEX_DOWNSAMPLE_STATUS.getKey(), IndexMetadata.DownsampleTaskStatus.STARTED)
             )
             .numberOfShards(1)
             .numberOfReplicas(0)
             .build();
-        Map<String, IndexMetadata> indices = Map.of(rollupIndex, indexMetadata);
+        Map<String, IndexMetadata> indices = Map.of(downsampleIndex, indexMetadata);
         ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE).metadata(Metadata.builder().indices(indices)).build();
 
         step.performAction(sourceIndexMetadata, clusterState, null, new ActionListener<>() {
             @Override
             public void onResponse(Void unused) {
-                fail("onResponse should not be called in this test, because there's an in-progress rollup index");
+                fail("onResponse should not be called in this test, because there's an in-progress downsample index");
             }
 
             @Override
             public void onFailure(Exception e) {
                 assertTrue(e instanceof IllegalStateException);
-                assertTrue(e.getMessage().contains("already exists with rollup status [started]"));
+                assertTrue(e.getMessage().contains("already exists with downsample status [started]"));
             }
         });
     }
 
-    private void mockClientRollupCall(String sourceIndex) {
+    public void testNextStepKey() {
+        String sourceIndexName = randomAlphaOfLength(10);
+        String lifecycleName = randomAlphaOfLength(5);
+
+        LifecycleExecutionState.Builder lifecycleState = LifecycleExecutionState.builder();
+        lifecycleState.setIndexCreationDate(randomNonNegativeLong());
+
+        String downsampleIndex = GenerateUniqueIndexNameStep.generateValidIndexName(DOWNSAMPLED_INDEX_PREFIX, sourceIndexName);
+        lifecycleState.setDownsampleIndexName(downsampleIndex);
+
+        IndexMetadata sourceIndexMetadata = IndexMetadata.builder(sourceIndexName)
+            .settings(settings(Version.CURRENT).put(LifecycleSettings.LIFECYCLE_NAME, lifecycleName))
+            .putCustom(ILM_CUSTOM_METADATA_KEY, lifecycleState.build().asMap())
+            .numberOfShards(randomIntBetween(1, 5))
+            .numberOfReplicas(randomIntBetween(0, 5))
+            .build();
+
+        ClusterState clusterState = ClusterState.builder(emptyClusterState())
+            .metadata(Metadata.builder().put(sourceIndexMetadata, true).build())
+            .build();
+        {
+            try (NoOpClient client = new NoOpClient(getTestName())) {
+                StepKey nextKeyOnComplete = randomStepKey();
+                StepKey nextKeyOnIncomplete = randomStepKey();
+                DateHistogramInterval fixedInterval = ConfigTestHelpers.randomInterval();
+                DownsampleStep completeStep = new DownsampleStep(
+                    randomStepKey(),
+                    nextKeyOnComplete,
+                    nextKeyOnIncomplete,
+                    client,
+                    fixedInterval
+                ) {
+                    void performDownsampleIndex(String indexName, String downsampleIndexName, ActionListener<Void> listener) {
+                        listener.onResponse(null);
+                    }
+                };
+                completeStep.performAction(sourceIndexMetadata, clusterState, null, ActionListener.noop());
+                assertThat(completeStep.getNextStepKey(), is(nextKeyOnComplete));
+            }
+        }
+        {
+            try (NoOpClient client = new NoOpClient(getTestName())) {
+                StepKey nextKeyOnComplete = randomStepKey();
+                StepKey nextKeyOnIncomplete = randomStepKey();
+                DateHistogramInterval fixedInterval = ConfigTestHelpers.randomInterval();
+                DownsampleStep doubleInvocationStep = new DownsampleStep(
+                    randomStepKey(),
+                    nextKeyOnComplete,
+                    nextKeyOnIncomplete,
+                    client,
+                    fixedInterval
+                ) {
+                    void performDownsampleIndex(String indexName, String downsampleIndexName, ActionListener<Void> listener) {
+                        listener.onFailure(
+                            new IllegalStateException(
+                                "failing ["
+                                    + DownsampleStep.NAME
+                                    + "] step for index ["
+                                    + indexName
+                                    + "] as part of policy ["
+                                    + lifecycleName
+                                    + "] because the downsample index ["
+                                    + downsampleIndexName
+                                    + "] already exists with downsample status ["
+                                    + IndexMetadata.DownsampleTaskStatus.UNKNOWN
+                                    + "]"
+                            )
+                        );
+                    }
+                };
+                doubleInvocationStep.performAction(sourceIndexMetadata, clusterState, null, ActionListener.noop());
+                assertThat(doubleInvocationStep.getNextStepKey(), is(nextKeyOnIncomplete));
+            }
+        }
+    }
+
+    private void mockClientDownsampleCall(String sourceIndex) {
         Mockito.doAnswer(invocation -> {
             DownsampleAction.Request request = (DownsampleAction.Request) invocation.getArguments()[1];
             @SuppressWarnings("unchecked")
             ActionListener<AcknowledgedResponse> listener = (ActionListener<AcknowledgedResponse>) invocation.getArguments()[2];
-            assertRollupActionRequest(request, sourceIndex);
+            assertDownsampleActionRequest(request, sourceIndex);
             listener.onResponse(AcknowledgedResponse.of(true));
             return null;
         }).when(client).execute(Mockito.any(), Mockito.any(), Mockito.any());
diff --git a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/LifecycleExecutionStateTests.java b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/LifecycleExecutionStateTests.java
index f57d3bf..1758c37 100644
--- a/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/LifecycleExecutionStateTests.java
+++ b/x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/ilm/LifecycleExecutionStateTests.java
@@ -181,7 +181,9 @@ public class LifecycleExecutionStateTests extends ESTestCase {
                 newState.setSnapshotName(randomValueOtherThan(toMutate.snapshotName(), () -> randomAlphaOfLengthBetween(5, 20)));
                 break;
             case 14:
-                newState.setRollupIndexName(randomValueOtherThan(toMutate.downsampleIndexName(), () -> randomAlphaOfLengthBetween(5, 20)));
+                newState.setDownsampleIndexName(
+                    randomValueOtherThan(toMutate.downsampleIndexName(), () -> randomAlphaOfLengthBetween(5, 20))
+                );
                 break;
             case 15:
                 newState.setIsAutoRetryableError(randomValueOtherThan(toMutate.isAutoRetryableError(), ESTestCase::randomBoolean));

diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeReplacementAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeReplacementAllocationDeciderTests.java
index 203255c..6f60a66 100644
--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeReplacementAllocationDeciderTests.java
+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeReplacementAllocationDeciderTests.java
@@ -9,6 +9,7 @@
 package org.elasticsearch.cluster.routing.allocation.decider;
 
 import org.elasticsearch.Version;
+import org.elasticsearch.cluster.ClusterName;
 import org.elasticsearch.cluster.ClusterState;
 import org.elasticsearch.cluster.ESAllocationTestCase;
 import org.elasticsearch.cluster.metadata.IndexMetadata;
@@ -18,9 +19,11 @@ import org.elasticsearch.cluster.metadata.SingleNodeShutdownMetadata;
 import org.elasticsearch.cluster.node.DiscoveryNode;
 import org.elasticsearch.cluster.node.DiscoveryNodeRole;
 import org.elasticsearch.cluster.node.DiscoveryNodes;
+import org.elasticsearch.cluster.routing.IndexRoutingTable;
 import org.elasticsearch.cluster.routing.RecoverySource;
 import org.elasticsearch.cluster.routing.RoutingNode;
 import org.elasticsearch.cluster.routing.RoutingNodesHelper;
+import org.elasticsearch.cluster.routing.RoutingTable;
 import org.elasticsearch.cluster.routing.ShardRouting;
 import org.elasticsearch.cluster.routing.UnassignedInfo;
 import org.elasticsearch.cluster.routing.allocation.RoutingAllocation;
@@ -31,6 +34,10 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 
+import static org.elasticsearch.cluster.metadata.IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS;
+import static org.elasticsearch.cluster.routing.ShardRoutingState.RELOCATING;
+import static org.elasticsearch.cluster.routing.ShardRoutingState.STARTED;
+import static org.elasticsearch.cluster.routing.TestShardRouting.newShardRouting;
 import static org.elasticsearch.common.settings.ClusterSettings.createBuiltInClusterSettings;
 import static org.hamcrest.Matchers.equalTo;
 
@@ -67,25 +74,18 @@ public class NodeReplacementAllocationDeciderTests extends ESAllocationTestCase
             .nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_B).add(NODE_C).build())
             .build();
 
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        RoutingAllocation allocation = createRoutingAllocation(state);
         DiscoveryNode node = randomFrom(NODE_A, NODE_B, NODE_C);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(node.getId(), node, shard);
-        allocation.debugDecision(true);
-
-        Decision decision = decider.canAllocate(shard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.YES));
-        assertThat(decision.getExplanation(), equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS.getExplanation()));
 
-        decision = decider.canRemain(null, shard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.YES));
-        assertThat(decision.getExplanation(), equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS.getExplanation()));
+        assertThat(decider.canAllocate(shard, routingNode, allocation), equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS));
+        assertThat(decider.canRemain(null, shard, routingNode, allocation), equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS));
     }
 
     public void testCanForceAllocate() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, NODE_A.getId(), NODE_B.getName());
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        ClusterState state = prepareState(NODE_A.getId(), NODE_B.getName());
+        RoutingAllocation allocation = createRoutingAllocation(state);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(NODE_A.getId(), NODE_A, shard);
-        allocation.debugDecision(true);
 
         ShardRouting assignedShard = ShardRouting.newUnassigned(
             new ShardId("myindex", "myindex", 0),
@@ -97,117 +97,344 @@ public class NodeReplacementAllocationDeciderTests extends ESAllocationTestCase
         assignedShard = assignedShard.initialize(NODE_A.getId(), null, 1);
         assignedShard = assignedShard.moveToStarted(ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);
 
-        Decision decision = decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.NO));
-        assertThat(
-            decision.getExplanation(),
-            equalTo("shard is not on the source of a node replacement relocated to the replacement target")
+        assertThatDecision(
+            decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation),
+            Decision.Type.NO,
+            "shard is not on the source of a node replacement relocated to the replacement target"
         );
 
         routingNode = RoutingNodesHelper.routingNode(NODE_B.getId(), NODE_B, assignedShard);
 
-        decision = decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.YES));
-        assertThat(
-            decision.getExplanation(),
-            equalTo(
-                "node [" + NODE_A.getId() + "] is being replaced by node [" + NODE_B.getId() + "], and can be force vacated to the target"
-            )
+        assertThatDecision(
+            decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation),
+            Decision.Type.YES,
+            "node [" + NODE_A.getId() + "] is being replaced by node [" + NODE_B.getId() + "], and can be force vacated to the target"
         );
 
         routingNode = RoutingNodesHelper.routingNode(NODE_C.getId(), NODE_C, assignedShard);
 
-        decision = decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.NO));
-        assertThat(
-            decision.getExplanation(),
-            equalTo("shard is not on the source of a node replacement relocated to the replacement target")
+        assertThatDecision(
+            decider.canForceAllocateDuringReplace(assignedShard, routingNode, allocation),
+            Decision.Type.NO,
+            "shard is not on the source of a node replacement relocated to the replacement target"
         );
     }
 
     public void testCannotRemainOnReplacedNode() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, NODE_A.getId(), NODE_B.getName());
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        ClusterState state = prepareState(NODE_A.getId(), NODE_B.getName());
+        RoutingAllocation allocation = createRoutingAllocation(state);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(NODE_A.getId(), NODE_A, shard);
-        allocation.debugDecision(true);
 
-        Decision decision = decider.canRemain(indexMetadata, shard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.NO));
-        assertThat(
-            decision.getExplanation(),
-            equalTo("node [" + NODE_A.getId() + "] is being replaced by node [" + NODE_B.getId() + "], so no data may remain on it")
+        assertThatDecision(
+            decider.canRemain(indexMetadata, shard, routingNode, allocation),
+            Decision.Type.NO,
+            "node [" + NODE_A.getId() + "] is being replaced by node [" + NODE_B.getId() + "], so no data may remain on it"
         );
 
         routingNode = RoutingNodesHelper.routingNode(NODE_B.getId(), NODE_B, shard);
 
-        decision = decider.canRemain(indexMetadata, shard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.YES));
-        assertEquals(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS, decision);
+        assertThat(
+            decider.canRemain(indexMetadata, shard, routingNode, allocation),
+            equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+        );
 
         routingNode = RoutingNodesHelper.routingNode(NODE_C.getId(), NODE_C, shard);
 
-        decision = decider.canRemain(indexMetadata, shard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.YES));
-        assertEquals(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS, decision);
+        assertThat(
+            decider.canRemain(indexMetadata, shard, routingNode, allocation),
+            equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+        );
     }
 
     public void testCanAllocateToNeitherSourceNorTarget() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, NODE_A.getId(), NODE_B.getName());
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        ClusterState state = prepareState(NODE_A.getId(), NODE_B.getName());
+        RoutingAllocation allocation = createRoutingAllocation(state);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(NODE_A.getId(), NODE_A, shard);
-        allocation.debugDecision(true);
 
         ShardRouting testShard = this.shard;
         if (randomBoolean()) {
             testShard = shard.initialize(NODE_C.getId(), null, 1);
             testShard = testShard.moveToStarted(ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);
         }
-        Decision decision = decider.canAllocate(testShard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.NO));
-        assertThat(
-            decision.getExplanation(),
-            equalTo("node [" + NODE_A.getId() + "] is being replaced by [" + NODE_B.getName() + "], so no data may be allocated to it")
+        assertThatDecision(
+            decider.canAllocate(testShard, routingNode, allocation),
+            Decision.Type.NO,
+            "node [" + NODE_A.getId() + "] is being replaced by [" + NODE_B.getName() + "], so no data may be allocated to it"
         );
 
         routingNode = RoutingNodesHelper.routingNode(NODE_B.getId(), NODE_B, testShard);
 
-        decision = decider.canAllocate(testShard, routingNode, allocation);
-        assertThat(decision.type(), equalTo(Decision.Type.NO));
+        assertThatDecision(
+            decider.canAllocate(testShard, routingNode, allocation),
+            Decision.Type.NO,
+            "node ["
+                + NODE_B.getId()
+                + "] is replacing the vacating node ["
+                + NODE_A.getId()
+                + "], only data currently allocated "
+                + "to the source node may be allocated to it until the replacement is complete"
+        );
+
+        routingNode = RoutingNodesHelper.routingNode(NODE_C.getId(), NODE_C, testShard);
+
         assertThat(
-            decision.getExplanation(),
-            equalTo(
+            decider.canAllocate(testShard, routingNode, allocation),
+            equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+        );
+    }
+
+    public void testShouldNotAutoExpandReplicasDuringUnrelatedNodeReplacement() {
+
+        var indexMetadata = IndexMetadata.builder(idxName)
+            .settings(indexSettings(Version.CURRENT, 1, 0).put(SETTING_AUTO_EXPAND_REPLICAS, "0-1"))
+            .build();
+        var shardId = new ShardId(indexMetadata.getIndex(), 0);
+
+        var state = ClusterState.builder(ClusterName.DEFAULT)
+            .nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_C).build())
+            .metadata(
+                Metadata.builder()
+                    .put(IndexMetadata.builder(indexMetadata))
+                    .putCustom(NodesShutdownMetadata.TYPE, createNodeShutdownReplacementMetadata(NODE_A.getId(), NODE_B.getName()))
+            )
+            .routingTable(
+                RoutingTable.builder()
+                    .add(
+                        IndexRoutingTable.builder(indexMetadata.getIndex())
+                            .addShard(newShardRouting(shardId, NODE_C.getId(), true, STARTED))
+                            .build()
+                    )
+                    .build()
+            )
+            .build();
+
+        // before replacement node has joined
+        {
+            var allocation = createRoutingAllocation(state);
+            assertThat(indexMetadata.getAutoExpandReplicas().getDesiredNumberOfReplicas(indexMetadata, allocation), equalTo(0));
+            assertThatDecision(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_A, allocation),
+                Decision.Type.NO,
+                "node [" + NODE_A.getId() + "] is being replaced by [" + NODE_B.getId() + "], shards cannot auto expand to be on it"
+            );
+            assertThat(allocation.getClusterState().nodes().hasByName(NODE_B.getName()), equalTo(false));
+            assertThatDecision(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_B, allocation),
+                Decision.Type.NO,
                 "node ["
                     + NODE_B.getId()
-                    + "] is replacing the vacating node ["
+                    + "] is a node replacement target for node ["
                     + NODE_A.getId()
-                    + "], only data currently allocated "
-                    + "to the source node may be allocated to it until the replacement is complete"
-            )
-        );
+                    + "], "
+                    + "shards cannot auto expand to be on it until the replacement is complete"
 
-        routingNode = RoutingNodesHelper.routingNode(NODE_C.getId(), NODE_C, testShard);
+            );
+            assertThat(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_C, allocation),
+                equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+            );
+        }
+
+        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_B).add(NODE_C).build()).build();
+
+        // after replacement node has joined
+        {
+            var allocation = createRoutingAllocation(state);
+            assertThat(indexMetadata.getAutoExpandReplicas().getDesiredNumberOfReplicas(indexMetadata, allocation), equalTo(0));
+            assertThatDecision(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_A, allocation),
+                Decision.Type.NO,
+                "node [" + NODE_A.getId() + "] is being replaced by [" + NODE_B.getId() + "], shards cannot auto expand to be on it"
+            );
+            assertThatDecision(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_B, allocation),
+                Decision.Type.NO,
+                "node ["
+                    + NODE_B.getId()
+                    + "] is a node replacement target for node ["
+                    + NODE_A.getId()
+                    + "], "
+                    + "shards cannot auto expand to be on it until the replacement is complete"
 
-        decision = decider.canAllocate(testShard, routingNode, allocation);
-        assertThat(decision.getExplanation(), decision.type(), equalTo(Decision.Type.YES));
-        assertEquals(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS, decision);
+            );
+            assertThat(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_C, allocation),
+                equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+            );
+        }
     }
 
-    private ClusterState prepareState(ClusterState initialState, String sourceNodeId, String targetNodeName) {
-        final SingleNodeShutdownMetadata nodeShutdownMetadata = SingleNodeShutdownMetadata.builder()
-            .setNodeId(sourceNodeId)
-            .setTargetNodeName(targetNodeName)
-            .setType(SingleNodeShutdownMetadata.Type.REPLACE)
-            .setReason(this.getTestName())
-            .setStartedAtMillis(1L)
+    public void testShouldNotContractAutoExpandReplicasDuringNodeReplacement() {
+
+        var indexMetadata = IndexMetadata.builder(idxName)
+            .settings(indexSettings(Version.CURRENT, 1, 0).put(SETTING_AUTO_EXPAND_REPLICAS, "0-1"))
+            .build();
+        var shardId = new ShardId(indexMetadata.getIndex(), 0);
+
+        var state = ClusterState.builder(ClusterName.DEFAULT)
+            .nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_C).build())
+            .metadata(Metadata.builder().put(IndexMetadata.builder(indexMetadata)))
+            .routingTable(
+                RoutingTable.builder()
+                    .add(
+                        IndexRoutingTable.builder(indexMetadata.getIndex())
+                            .addShard(newShardRouting(shardId, NODE_A.getId(), true, STARTED))
+                            .addShard(newShardRouting(shardId, NODE_C.getId(), false, STARTED))
+                            .build()
+                    )
+                    .build()
+            )
+            .build();
+
+        // index is already allocated on both nodes
+        {
+            var allocation = createRoutingAllocation(state);
+            assertThat(indexMetadata.getAutoExpandReplicas().getDesiredNumberOfReplicas(indexMetadata, allocation), equalTo(1));
+            assertThat(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_A, allocation),
+                equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS)
+            );
+            assertThat("node-b has not joined yet", allocation.getClusterState().nodes().hasByName(NODE_B.getName()), equalTo(false));
+            assertThat(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_C, allocation),
+                equalTo(NodeReplacementAllocationDecider.YES__NO_REPLACEMENTS)
+            );
+        }
+
+        // when registering node replacement
+        state = ClusterState.builder(state)
+            .metadata(
+                Metadata.builder(state.metadata())
+                    .putCustom(NodesShutdownMetadata.TYPE, createNodeShutdownReplacementMetadata(NODE_A.getId(), NODE_B.getName()))
+                    .build()
+            )
+            .build();
+        {
+            var allocation = createRoutingAllocation(state);
+            assertThat(indexMetadata.getAutoExpandReplicas().getDesiredNumberOfReplicas(indexMetadata, allocation), equalTo(1));
+            assertThatDecision(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_A, allocation),
+                Decision.Type.YES,
+                "node ["
+                    + NODE_A.getId()
+                    + "] is being replaced by ["
+                    + NODE_B.getId()
+                    + "], shards can auto expand to be on it "
+                    + "while replacement node has not joined the cluster"
+            );
+            assertThat("node-b has not joined yet", allocation.getClusterState().nodes().hasByName(NODE_B.getName()), equalTo(false));
+            assertThat(
+                decider.shouldAutoExpandToNode(indexMetadata, NODE_C, allocation),
+                equalTo(NodeReplacementAllocationDecider.YES__NO_APPLICABLE_REPLACEMENTS)
+            );
+        }
+
+        // when starting node replacement
+        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_B).add(NODE_C).build()).build();
+        {
+            var allocation = createRoutingAllocation(state);
+            assertThatDecision(
+                decider.canAllocate(
+                    allocation.routingNodes().node(NODE_A.getId()).getByShardId(shardId),
+                    allocation.routingNodes().node(NODE_B.getId()),
+                    allocation
+                ),
+                Decision.Type.YES,
+                "node [" + NODE_B.getId() + "] is replacing node [" + NODE_A.getId() + "], and may receive shards from it"
+            );
+            assertThatAutoExpandReplicasDidNotContract(indexMetadata, allocation);
+        }
+
+        // when index is relocating
+        state = ClusterState.builder(state)
+            .routingTable(
+                RoutingTable.builder()
+                    .add(
+                        IndexRoutingTable.builder(indexMetadata.getIndex())
+                            .addShard(newShardRouting(shardId, NODE_A.getId(), NODE_B.getId(), true, RELOCATING))
+                            .addShard(newShardRouting(shardId, NODE_C.getId(), false, STARTED))
+                            .build()
+                    )
+                    .build()
+            )
             .build();
-        NodesShutdownMetadata nodesShutdownMetadata = new NodesShutdownMetadata(new HashMap<>()).putSingleNodeMetadata(
-            nodeShutdownMetadata
+        assertThatAutoExpandReplicasDidNotContract(indexMetadata, createRoutingAllocation(state));
+
+        // when index is relocated
+        state = ClusterState.builder(state)
+            .routingTable(
+                RoutingTable.builder()
+                    .add(
+                        IndexRoutingTable.builder(indexMetadata.getIndex())
+                            .addShard(newShardRouting(shardId, NODE_B.getId(), true, STARTED))
+                            .addShard(newShardRouting(shardId, NODE_C.getId(), false, STARTED))
+                            .build()
+                    )
+                    .build()
+            )
+            .build();
+        assertThatAutoExpandReplicasDidNotContract(indexMetadata, createRoutingAllocation(state));
+
+        // when source node is removed
+        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(NODE_B).add(NODE_C).build()).build();
+        assertThatAutoExpandReplicasDidNotContract(indexMetadata, createRoutingAllocation(state));
+    }
+
+    private void assertThatAutoExpandReplicasDidNotContract(IndexMetadata indexMetadata, RoutingAllocation allocation) {
+        assertThat(indexMetadata.getAutoExpandReplicas().getDesiredNumberOfReplicas(indexMetadata, allocation), equalTo(1));
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, NODE_A, allocation),
+            Decision.Type.NO,
+            "node [" + NODE_A.getId() + "] is being replaced by [" + NODE_B.getId() + "], shards cannot auto expand to be on it"
+        );
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, NODE_B, allocation),
+            Decision.Type.YES,
+            "node ["
+                + NODE_B.getId()
+                + "] is a node replacement target for node ["
+                + NODE_A.getId()
+                + "], "
+                + "shard can auto expand to it as it was already present on the source node"
         );
-        return ClusterState.builder(initialState)
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, NODE_C, allocation),
+            Decision.Type.YES,
+            "none of the ongoing node replacements relate to the allocation of this shard"
+        );
+    }
+
+    private ClusterState prepareState(String sourceNodeId, String targetNodeName) {
+        return ClusterState.builder(ClusterName.DEFAULT)
             .nodes(DiscoveryNodes.builder().add(NODE_A).add(NODE_B).add(NODE_C).build())
             .metadata(
-                Metadata.builder().put(IndexMetadata.builder(indexMetadata)).putCustom(NodesShutdownMetadata.TYPE, nodesShutdownMetadata)
+                Metadata.builder()
+                    .put(IndexMetadata.builder(indexMetadata))
+                    .putCustom(NodesShutdownMetadata.TYPE, createNodeShutdownReplacementMetadata(sourceNodeId, targetNodeName))
             )
             .build();
     }
+
+    private NodesShutdownMetadata createNodeShutdownReplacementMetadata(String sourceNodeId, String targetNodeName) {
+        return new NodesShutdownMetadata(new HashMap<>()).putSingleNodeMetadata(
+            SingleNodeShutdownMetadata.builder()
+                .setNodeId(sourceNodeId)
+                .setTargetNodeName(targetNodeName)
+                .setType(SingleNodeShutdownMetadata.Type.REPLACE)
+                .setReason(this.getTestName())
+                .setStartedAtMillis(1L)
+                .build()
+        );
+    }
+
+    private RoutingAllocation createRoutingAllocation(ClusterState state) {
+        var allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        allocation.debugDecision(true);
+        return allocation;
+    }
+
+    private static void assertThatDecision(Decision decision, Decision.Type type, String explanation) {
+        assertThat(decision.type(), equalTo(type));
+        assertThat(decision.getExplanation(), equalTo(explanation));
+    }
 }
diff --git a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeShutdownAllocationDeciderTests.java b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeShutdownAllocationDeciderTests.java
index 12f5192..985877c 100644
--- a/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeShutdownAllocationDeciderTests.java
+++ b/server/src/test/java/org/elasticsearch/cluster/routing/allocation/decider/NodeShutdownAllocationDeciderTests.java
@@ -9,6 +9,7 @@
 package org.elasticsearch.cluster.routing.allocation.decider;
 
 import org.elasticsearch.Version;
+import org.elasticsearch.cluster.ClusterName;
 import org.elasticsearch.cluster.ClusterState;
 import org.elasticsearch.cluster.ESAllocationTestCase;
 import org.elasticsearch.cluster.metadata.IndexMetadata;
@@ -29,15 +30,15 @@ import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.index.shard.ShardId;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Set;
 
 import static org.elasticsearch.common.settings.ClusterSettings.createBuiltInClusterSettings;
 import static org.hamcrest.Matchers.equalTo;
 
 public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
-    private static final DiscoveryNode DATA_NODE = newNode("node-data", Collections.singleton(DiscoveryNodeRole.DATA_ROLE));
+    private static final DiscoveryNode DATA_NODE = newNode("node-data", Set.of(DiscoveryNodeRole.DATA_ROLE));
     private final ShardRouting shard = ShardRouting.newUnassigned(
         new ShardId("myindex", "myindex", 0),
         true,
@@ -64,10 +65,9 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
     );
 
     public void testCanAllocateShardsToRestartingNode() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, SingleNodeShutdownMetadata.Type.RESTART);
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        ClusterState state = prepareState(SingleNodeShutdownMetadata.Type.RESTART);
+        RoutingAllocation allocation = createRoutingAllocation(state);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(DATA_NODE.getId(), DATA_NODE, shard);
-        allocation.debugDecision(true);
 
         Decision decision = decider.canAllocate(shard, routingNode, allocation);
         assertThat(decision.type(), equalTo(Decision.Type.YES));
@@ -79,10 +79,9 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
 
     public void testCannotAllocateShardsToRemovingNode() {
         for (SingleNodeShutdownMetadata.Type type : REMOVE_SHUTDOWN_TYPES) {
-            ClusterState state = prepareState(ClusterState.EMPTY_STATE, type);
-            RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+            ClusterState state = prepareState(type);
+            RoutingAllocation allocation = createRoutingAllocation(state);
             RoutingNode routingNode = RoutingNodesHelper.routingNode(DATA_NODE.getId(), DATA_NODE, shard);
-            allocation.debugDecision(true);
 
             Decision decision = decider.canAllocate(shard, routingNode, allocation);
             assertThat(type.toString(), decision.type(), equalTo(Decision.Type.NO));
@@ -91,10 +90,9 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
     }
 
     public void testShardsCanRemainOnRestartingNode() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, SingleNodeShutdownMetadata.Type.RESTART);
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        ClusterState state = prepareState(SingleNodeShutdownMetadata.Type.RESTART);
+        RoutingAllocation allocation = createRoutingAllocation(state);
         RoutingNode routingNode = RoutingNodesHelper.routingNode(DATA_NODE.getId(), DATA_NODE, shard);
-        allocation.debugDecision(true);
 
         Decision decision = decider.canRemain(null, shard, routingNode, allocation);
         assertThat(decision.type(), equalTo(Decision.Type.YES));
@@ -106,10 +104,9 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
 
     public void testShardsCannotRemainOnRemovingNode() {
         for (SingleNodeShutdownMetadata.Type type : REMOVE_SHUTDOWN_TYPES) {
-            ClusterState state = prepareState(ClusterState.EMPTY_STATE, type);
-            RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+            ClusterState state = prepareState(type);
+            RoutingAllocation allocation = createRoutingAllocation(state);
             RoutingNode routingNode = RoutingNodesHelper.routingNode(DATA_NODE.getId(), DATA_NODE, shard);
-            allocation.debugDecision(true);
 
             Decision decision = decider.canRemain(null, shard, routingNode, allocation);
             assertThat(type.toString(), decision.type(), equalTo(Decision.Type.NO));
@@ -122,9 +119,8 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
     }
 
     public void testCanAutoExpandToRestartingNode() {
-        ClusterState state = prepareState(ClusterState.EMPTY_STATE, SingleNodeShutdownMetadata.Type.RESTART);
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
-        allocation.debugDecision(true);
+        ClusterState state = prepareState(SingleNodeShutdownMetadata.Type.RESTART);
+        RoutingAllocation allocation = createRoutingAllocation(state);
 
         Decision decision = decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, allocation);
         assertThat(decision.type(), equalTo(Decision.Type.YES));
@@ -135,8 +131,7 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
     }
 
     public void testCanAutoExpandToNodeIfNoNodesShuttingDown() {
-        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, ClusterState.EMPTY_STATE, null, null, 0);
-        allocation.debugDecision(true);
+        RoutingAllocation allocation = createRoutingAllocation(ClusterState.EMPTY_STATE);
 
         Decision decision = decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, allocation);
         assertThat(decision.type(), equalTo(Decision.Type.YES));
@@ -145,10 +140,9 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
 
     public void testCanAutoExpandToNodeThatIsNotShuttingDown() {
         for (SingleNodeShutdownMetadata.Type type : REMOVE_SHUTDOWN_TYPES) {
-            ClusterState state = prepareState(ClusterState.EMPTY_STATE, type, "other-node-id");
+            ClusterState state = prepareState(type, "other-node-id");
 
-            RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
-            allocation.debugDecision(true);
+            RoutingAllocation allocation = createRoutingAllocation(state);
 
             Decision decision = decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, allocation);
             assertThat(type.toString(), decision.type(), equalTo(Decision.Type.YES));
@@ -157,10 +151,12 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
     }
 
     public void testCannotAutoExpandToRemovingNode() {
-        for (SingleNodeShutdownMetadata.Type type : REMOVE_SHUTDOWN_TYPES) {
-            ClusterState state = prepareState(ClusterState.EMPTY_STATE, type);
-            RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
-            allocation.debugDecision(true);
+        for (SingleNodeShutdownMetadata.Type type : List.of(
+            SingleNodeShutdownMetadata.Type.REMOVE,
+            SingleNodeShutdownMetadata.Type.SIGTERM
+        )) {
+            ClusterState state = prepareState(type);
+            RoutingAllocation allocation = createRoutingAllocation(state);
 
             Decision decision = decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, allocation);
             assertThat(decision.type(), equalTo(Decision.Type.NO));
@@ -168,32 +164,89 @@ public class NodeShutdownAllocationDeciderTests extends ESAllocationTestCase {
         }
     }
 
-    private ClusterState prepareState(ClusterState initialState, SingleNodeShutdownMetadata.Type shutdownType) {
-        return prepareState(initialState, shutdownType, DATA_NODE.getId());
-    }
+    public void testAutoExpandDuringNodeReplacement() {
 
-    private ClusterState prepareState(ClusterState initialState, SingleNodeShutdownMetadata.Type shutdownType, String nodeId) {
-        final String targetNodeName = shutdownType == SingleNodeShutdownMetadata.Type.REPLACE ? randomAlphaOfLengthBetween(10, 20) : null;
-        final SingleNodeShutdownMetadata nodeShutdownMetadata = SingleNodeShutdownMetadata.builder()
-            .setNodeId(nodeId)
-            .setType(shutdownType)
-            .setReason(this.getTestName())
-            .setStartedAtMillis(1L)
-            .setTargetNodeName(targetNodeName)
-            .setGracePeriod(
-                shutdownType == SingleNodeShutdownMetadata.Type.SIGTERM
-                    ? TimeValue.parseTimeValue(randomTimeValue(), this.getTestName())
-                    : null
-            )
+        var state = ClusterState.builder(ClusterName.DEFAULT)
+            .nodes(DiscoveryNodes.builder().add(DATA_NODE).build())
+            .metadata(Metadata.builder().put(IndexMetadata.builder(indexMetadata)))
             .build();
-        NodesShutdownMetadata nodesShutdownMetadata = new NodesShutdownMetadata(new HashMap<>()).putSingleNodeMetadata(
-            nodeShutdownMetadata
+
+        // should auto-expand when no shutdown
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, createRoutingAllocation(state)),
+            Decision.Type.YES,
+            "no nodes are shutting down"
+        );
+
+        // should auto-expand to source when shutdown/replacement entry is registered and node replacement has not started
+        var shutdown = createNodesShutdownMetadata(SingleNodeShutdownMetadata.Type.REPLACE, DATA_NODE.getId());
+        state = ClusterState.builder(state)
+            .metadata(Metadata.builder(state.metadata()).putCustom(NodesShutdownMetadata.TYPE, shutdown).build())
+            .build();
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, createRoutingAllocation(state)),
+            Decision.Type.YES,
+            "node [" + DATA_NODE.getId() + "] is preparing to be removed from the cluster, but replacement is not yet present"
+        );
+
+        // should auto-expand to replacement when node replacement has started
+        var replacementName = shutdown.get(DATA_NODE.getId()).getTargetNodeName();
+        var replacementNode = newNode(replacementName, "node-data-1", Set.of(DiscoveryNodeRole.DATA_ROLE));
+        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.getNodes()).add(replacementNode).build()).build();
+
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, DATA_NODE, createRoutingAllocation(state)),
+            Decision.Type.NO,
+            "node [" + DATA_NODE.getId() + "] is preparing to be removed from the cluster"
+        );
+        assertThatDecision(
+            decider.shouldAutoExpandToNode(indexMetadata, replacementNode, createRoutingAllocation(state)),
+            Decision.Type.YES,
+            "this node is not shutting down"
         );
-        return ClusterState.builder(initialState)
+    }
+
+    private ClusterState prepareState(SingleNodeShutdownMetadata.Type shutdownType) {
+        return prepareState(shutdownType, DATA_NODE.getId());
+    }
+
+    private ClusterState prepareState(SingleNodeShutdownMetadata.Type shutdownType, String nodeId) {
+        return ClusterState.builder(ClusterName.DEFAULT)
             .nodes(DiscoveryNodes.builder().add(DATA_NODE).build())
             .metadata(
-                Metadata.builder().put(IndexMetadata.builder(indexMetadata)).putCustom(NodesShutdownMetadata.TYPE, nodesShutdownMetadata)
+                Metadata.builder()
+                    .put(IndexMetadata.builder(indexMetadata))
+                    .putCustom(NodesShutdownMetadata.TYPE, createNodesShutdownMetadata(shutdownType, nodeId))
             )
             .build();
     }
+
+    private NodesShutdownMetadata createNodesShutdownMetadata(SingleNodeShutdownMetadata.Type shutdownType, String nodeId) {
+        final String targetNodeName = shutdownType == SingleNodeShutdownMetadata.Type.REPLACE ? randomAlphaOfLengthBetween(10, 20) : null;
+        return new NodesShutdownMetadata(new HashMap<>()).putSingleNodeMetadata(
+            SingleNodeShutdownMetadata.builder()
+                .setNodeId(nodeId)
+                .setType(shutdownType)
+                .setReason(this.getTestName())
+                .setStartedAtMillis(1L)
+                .setTargetNodeName(targetNodeName)
+                .setGracePeriod(
+                    shutdownType == SingleNodeShutdownMetadata.Type.SIGTERM
+                        ? TimeValue.parseTimeValue(randomTimeValue(), this.getTestName())
+                        : null
+                )
+                .build()
+        );
+    }
+
+    private RoutingAllocation createRoutingAllocation(ClusterState state) {
+        var allocation = new RoutingAllocation(allocationDeciders, state, null, null, 0);
+        allocation.debugDecision(true);
+        return allocation;
+    }
+
+    private static void assertThatDecision(Decision decision, Decision.Type type, String explanation) {
+        assertThat(decision.type(), equalTo(type));
+        assertThat(decision.getExplanation(), equalTo(explanation));
+    }
 }

diff --git a/server/src/test/java/org/elasticsearch/http/AbstractHttpServerTransportTests.java b/server/src/test/java/org/elasticsearch/http/AbstractHttpServerTransportTests.java
index 1bccc94..ed42816 100644
--- a/server/src/test/java/org/elasticsearch/http/AbstractHttpServerTransportTests.java
+++ b/server/src/test/java/org/elasticsearch/http/AbstractHttpServerTransportTests.java
@@ -66,17 +66,23 @@ import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import static java.net.InetAddress.getByName;
 import static java.util.Arrays.asList;
 import static org.elasticsearch.http.AbstractHttpServerTransport.resolvePublishPort;
+import static org.elasticsearch.http.DefaultRestChannel.CLOSE;
+import static org.elasticsearch.http.DefaultRestChannel.CONNECTION;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_CLIENT_STATS_ENABLED;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_SERVER_SHUTDOWN_GRACE_PERIOD;
 import static org.elasticsearch.test.LambdaMatchers.transformedMatch;
 import static org.hamcrest.Matchers.allOf;
 import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
@@ -900,40 +906,7 @@ public class AbstractHttpServerTransportTests extends ESTestCase {
 
     @SuppressWarnings("unchecked")
     public void testSetGracefulClose() {
-        try (
-            AbstractHttpServerTransport transport = new AbstractHttpServerTransport(
-                Settings.EMPTY,
-                networkService,
-                recycler,
-                threadPool,
-                xContentRegistry(),
-                new HttpServerTransport.Dispatcher() {
-                    @Override
-                    public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {
-                        channel.sendResponse(emptyResponse(RestStatus.OK));
-                    }
-
-                    @Override
-                    public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) {
-                        channel.sendResponse(emptyResponse(RestStatus.BAD_REQUEST));
-                    }
-                },
-                new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS),
-                Tracer.NOOP
-            ) {
-
-                @Override
-                protected HttpServerChannel bind(InetSocketAddress hostAddress) {
-                    return null;
-                }
-
-                @Override
-                protected void doStart() {}
-
-                @Override
-                protected void stopInternal() {}
-            }
-        ) {
+        try (AbstractHttpServerTransport transport = new TestHttpServerTransport(Settings.EMPTY)) {
             final TestHttpRequest httpRequest = new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/");
 
             HttpChannel httpChannel = mock(HttpChannel.class);
@@ -944,7 +917,7 @@ public class AbstractHttpServerTransportTests extends ESTestCase {
             verify(httpChannel).sendResponse(response.capture(), listener.capture());
 
             listener.getValue().onResponse(null);
-            assertThat(response.getValue().containsHeader(DefaultRestChannel.CONNECTION), is(false));
+            assertThat(response.getValue().containsHeader(CONNECTION), is(false));
             verify(httpChannel, never()).close();
 
             httpChannel = mock(HttpChannel.class);
@@ -953,11 +926,226 @@ public class AbstractHttpServerTransportTests extends ESTestCase {
             verify(httpChannel).sendResponse(response.capture(), listener.capture());
 
             listener.getValue().onResponse(null);
-            assertThat(response.getValue().headers().get(DefaultRestChannel.CONNECTION), containsInAnyOrder(DefaultRestChannel.CLOSE));
+            assertThat(response.getValue().headers().get(CONNECTION), containsInAnyOrder(DefaultRestChannel.CLOSE));
             verify(httpChannel).close();
         }
     }
 
+    public void testStopDoesntWaitIfGraceIsZero() {
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(Settings.EMPTY)) {
+            transport.bindServer();
+            final TestHttpRequest httpRequest = new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/");
+
+            TestHttpChannel httpChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(httpChannel);
+            transport.incomingRequest(httpRequest, httpChannel);
+
+            transport.doStop();
+            assertFalse(transport.testHttpServerChannel.isOpen());
+            assertFalse(httpChannel.isOpen());
+        }
+    }
+
+    public void testStopWorksWithNoOpenRequests() {
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(gracePeriod(1))) {
+            transport.bindServer();
+
+            final TestHttpRequest httpRequest = new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/") {
+                @Override
+                public Map<String, List<String>> getHeaders() {
+                    // close connection before shutting down
+                    return Map.of(CONNECTION, List.of(CLOSE));
+                }
+            };
+            TestHttpChannel httpChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(httpChannel);
+            transport.incomingRequest(httpRequest, httpChannel);
+            assertFalse(httpChannel.isOpen());
+
+            // TestHttpChannel will throw if closed twice, so this ensures close is not called.
+            transport.doStop();
+            assertFalse(transport.testHttpServerChannel.isOpen());
+        }
+    }
+
+    public void testStopForceClosesConnection() {
+        final Logger mockLogger = LogManager.getLogger(AbstractHttpServerTransport.class);
+        Loggers.setLevel(mockLogger, Level.WARN);
+        final MockLogAppender appender = new MockLogAppender();
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(gracePeriod(10))) {
+            Loggers.addAppender(mockLogger, appender);
+            appender.start();
+
+            appender.addExpectation(
+                new MockLogAppender.SeenEventExpectation(
+                    "message",
+                    AbstractHttpServerTransport.class.getName(),
+                    Level.WARN,
+                    "timed out while waiting [10]ms for clients to close connections"
+                )
+            );
+
+            transport.bindServer();
+            final TestHttpRequest httpRequest = new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/");
+            TestHttpChannel httpChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(httpChannel);
+            transport.incomingRequest(httpRequest, httpChannel);
+            // idle connection
+            assertTrue(httpChannel.isOpen());
+            transport.doStop();
+            assertFalse(httpChannel.isOpen());
+            assertFalse(transport.testHttpServerChannel.isOpen());
+            // ensure we timed out waiting for connections to close naturally
+            appender.assertAllExpectationsMatched();
+        } finally {
+            appender.stop();
+            Loggers.removeAppender(mockLogger, appender);
+        }
+    }
+
+    public void testStopForceClosesConnectionDuringRequest() throws Exception {
+        final Logger mockLogger = LogManager.getLogger(AbstractHttpServerTransport.class);
+        Loggers.setLevel(mockLogger, Level.WARN);
+        final MockLogAppender appender = new MockLogAppender();
+        final var inDispatch = new CountDownLatch(1);
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(gracePeriod(10), new HttpServerTransport.Dispatcher() {
+            @Override
+            public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {
+                inDispatch.countDown();
+            }
+
+            @Override
+            public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) {
+                channel.sendResponse(emptyResponse(RestStatus.BAD_REQUEST));
+            }
+        })) {
+            Loggers.addAppender(mockLogger, appender);
+            appender.start();
+
+            appender.addExpectation(
+                new MockLogAppender.SeenEventExpectation(
+                    "message",
+                    AbstractHttpServerTransport.class.getName(),
+                    Level.WARN,
+                    "timed out while waiting [10]ms for clients to close connections"
+                )
+            );
+
+            transport.bindServer();
+            final TestHttpRequest httpRequest = new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/");
+            TestHttpChannel httpChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(httpChannel);
+            new Thread(
+                () -> transport.incomingRequest(httpRequest, httpChannel),
+                "testStopForceClosesConnectionDuringRequest -> incomingRequest"
+            ).start();
+            inDispatch.await();
+            assertTrue(httpChannel.isOpen());
+            transport.doStop();
+            assertFalse(httpChannel.isOpen());
+            assertFalse(transport.testHttpServerChannel.isOpen());
+            assertThat(httpChannel.responses, hasSize(0));
+            // ensure we timed out waiting for connections to close naturally
+            appender.assertAllExpectationsMatched();
+        } finally {
+            appender.stop();
+            Loggers.removeAppender(mockLogger, appender);
+        }
+    }
+
+    public void testStopClosesChannelAfterRequest() {
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(gracePeriod(1_000))) {
+            transport.bindServer();
+
+            TestHttpChannel httpChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(httpChannel);
+            transport.incomingRequest(new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/"), httpChannel);
+
+            TestHttpChannel idleChannel = new TestHttpChannel();
+            transport.serverAcceptedChannel(idleChannel);
+            transport.incomingRequest(new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/"), idleChannel);
+
+            CountDownLatch stopped = new CountDownLatch(1);
+
+            new Thread(() -> {
+                transport.doStop();
+                stopped.countDown();
+            }).start();
+
+            try {
+                assertTrue(transport.gracefullyCloseCalled.await(10, TimeUnit.SECONDS));
+            } catch (InterruptedException e) {
+                fail("server never called grace period");
+            }
+
+            // one last request, should cause httpChannel to close naturally now that we've set grace period
+            transport.incomingRequest(new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/"), httpChannel);
+            assertFalse(httpChannel.isOpen());
+
+            try {
+                assertTrue(stopped.await(10, TimeUnit.SECONDS));
+            } catch (InterruptedException e) {
+                fail("server never stopped");
+            }
+
+            assertFalse(transport.testHttpServerChannel.isOpen());
+            assertFalse(idleChannel.isOpen());
+
+            assertThat(httpChannel.responses, hasSize(2));
+            HttpResponse first = httpChannel.responses.get(0);
+            HttpResponse last = httpChannel.responses.get(1);
+            assertFalse(first.containsHeader(CONNECTION));
+            assertTrue(last.containsHeader(CONNECTION));
+            assertThat(last, instanceOf(TestHttpResponse.class));
+            assertThat(((TestHttpResponse) last).headers().get(CONNECTION).get(0), equalTo(CLOSE));
+        }
+    }
+
+    public void testForceClosesOpenChannels() {
+        try (TestHttpServerTransport transport = new TestHttpServerTransport(gracePeriod(1_000))) {
+            transport.bindServer();
+
+            TestHttpChannel httpChannel = new TestHttpChannel(true);
+            transport.serverAcceptedChannel(httpChannel);
+            transport.incomingRequest(new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/"), httpChannel);
+
+            CountDownLatch stopped = new CountDownLatch(1);
+
+            new Thread(() -> {
+                try {
+                    assertTrue(transport.gracefullyCloseCalled.await(100, TimeUnit.MILLISECONDS));
+                } catch (InterruptedException e) {
+                    fail("server never called grace period");
+                }
+                // one last request, will attempt to close naturally, but we are blocking it
+                transport.incomingRequest(new TestHttpRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/"), httpChannel);
+            }).start();
+
+            new Thread(() -> {
+                transport.doStop();
+                stopped.countDown();
+            }).start();
+
+            try {
+                assertTrue(stopped.await(10, TimeUnit.SECONDS));
+            } catch (InterruptedException e) {
+                fail("server never stopped");
+            }
+
+            assertFalse(transport.testHttpServerChannel.isOpen());
+            assertFalse(httpChannel.isOpen());
+
+            assertThat(httpChannel.responses, hasSize(2));
+            HttpResponse first = httpChannel.responses.get(0);
+            HttpResponse last = httpChannel.responses.get(1);
+            assertFalse(first.containsHeader(CONNECTION));
+            assertTrue(last.containsHeader(CONNECTION));
+            assertThat(last, instanceOf(TestHttpResponse.class));
+            assertThat(((TestHttpResponse) last).headers().get(CONNECTION).get(0), equalTo(CLOSE));
+        }
+
+    }
+
     private static RestResponse emptyResponse(RestStatus status) {
         return new RestResponse(status, RestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY);
     }
@@ -1003,4 +1191,140 @@ public class AbstractHttpServerTransportTests extends ESTestCase {
             List.of()
         );
     }
+
+    private class TestHttpServerTransport extends AbstractHttpServerTransport {
+        public TestHttpChannel testHttpServerChannel = new TestHttpChannel(false);
+        public CountDownLatch gracefullyCloseCalled = new CountDownLatch(1);
+
+        TestHttpServerTransport(Settings settings, HttpServerTransport.Dispatcher dispatcher) {
+            super(
+                Settings.builder().put(settings).put(SETTING_HTTP_CLIENT_STATS_ENABLED.getKey(), false).build(),
+                AbstractHttpServerTransportTests.this.networkService,
+                AbstractHttpServerTransportTests.this.recycler,
+                AbstractHttpServerTransportTests.this.threadPool,
+                xContentRegistry(),
+                dispatcher,
+                new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS),
+                Tracer.NOOP
+            );
+        }
+
+        TestHttpServerTransport(Settings settings) {
+            this(settings, new HttpServerTransport.Dispatcher() {
+                @Override
+                public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) {
+                    channel.sendResponse(emptyResponse(RestStatus.OK));
+                }
+
+                @Override
+                public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) {
+                    channel.sendResponse(emptyResponse(RestStatus.BAD_REQUEST));
+                }
+            });
+        }
+
+        @Override
+        void gracefullyCloseConnections() {
+            super.gracefullyCloseConnections();
+            gracefullyCloseCalled.countDown();
+        }
+
+        @Override
+        protected HttpServerChannel bind(InetSocketAddress hostAddress) {
+            testHttpServerChannel.setLocalAddress(hostAddress);
+            return testHttpServerChannel;
+        }
+
+        @Override
+        protected void doStart() {
+            bindServer();
+        }
+
+        @Override
+        protected void stopInternal() {}
+    }
+
+    private static class TestHttpChannel implements HttpChannel, HttpServerChannel {
+        private boolean open = true;
+        private int numCloses = 0;
+        private final CountDownLatch closeLatch;
+        private ActionListener<Void> closeListener;
+        private InetSocketAddress localAddress;
+
+        public List<HttpResponse> responses = new ArrayList<>();
+
+        TestHttpChannel() {
+            this(false);
+        }
+
+        TestHttpChannel(boolean blockFirstClose) {
+            closeLatch = blockFirstClose ? new CountDownLatch(1) : null;
+        }
+
+        @Override
+        public void sendResponse(HttpResponse response, ActionListener<Void> listener) {
+            responses.add(response);
+            listener.onResponse(null);
+        }
+
+        public void setLocalAddress(InetSocketAddress localAddress) {
+            this.localAddress = localAddress;
+        }
+
+        @Override
+        public InetSocketAddress getLocalAddress() {
+            return localAddress;
+        }
+
+        @Override
+        public InetSocketAddress getRemoteAddress() {
+            return null;
+        }
+
+        @Override
+        public void close() {
+            if (closeLatch != null) {
+                boolean waitForever;
+                synchronized (this) {
+                    waitForever = numCloses == 0;
+                    numCloses++;
+                }
+                if (waitForever) {
+                    try {
+                        closeLatch.await(1, TimeUnit.SECONDS);
+                    } catch (InterruptedException ie) {
+                        throw new RuntimeException(ie);
+                    }
+                }
+            }
+            if (open == false) {
+                throw new IllegalStateException("channel already closed!");
+            }
+            open = false;
+            if (closeListener != null) {
+                closeListener.onResponse(null);
+            }
+        }
+
+        @Override
+        public boolean isOpen() {
+            return open;
+        }
+
+        @Override
+        public void addCloseListener(ActionListener<Void> listener) {
+            if (open == false) {
+                listener.onResponse(null);
+            } else {
+                if (closeListener != null) {
+                    throw new IllegalStateException("close listener already set");
+                }
+                closeListener = listener;
+            }
+        }
+    }
+
+    private Settings gracePeriod(int ms) {
+        return Settings.builder().put(SETTING_HTTP_SERVER_SHUTDOWN_GRACE_PERIOD.getKey(), new TimeValue(ms)).build();
+    }
 }

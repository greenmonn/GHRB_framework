diff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/GeoLineAggregatorTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/GeoLineAggregatorTests.java
index cce7e59..183a663 100644
--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/GeoLineAggregatorTests.java
+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/GeoLineAggregatorTests.java
@@ -243,7 +243,7 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
         double[] lineSorts = Arrays.copyOf(sortValues, lineSize);
         PathArraySorter.forOrder(SortOrder.ASC).apply(linePoints, lineSorts).sort();
 
-        lines.put(groupOrd, new InternalGeoLine("track", linePoints, lineSorts, null, complete, true, SortOrder.ASC, size));
+        lines.put(groupOrd, new InternalGeoLine("track", linePoints, lineSorts, null, complete, true, SortOrder.ASC, size, false, false));
 
         testCase(aggregationBuilder, iw -> {
             for (int i = 0; i < points.length; i++) {
@@ -518,11 +518,11 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
      * Wrapper for points and sort fields that is also usable in the GeometrySimplifier library,
      * allowing us to track which points will survive geometry simplification during geo_line aggregations.
      */
-    private static class TestSimplifiablePoint extends StreamingGeometrySimplifier.PointError {
+    static class TestSimplifiablePoint extends StreamingGeometrySimplifier.PointError {
         private final double sortField;
         private final long encoded;
 
-        private TestSimplifiablePoint(int index, double x, double y, double sortField) {
+        TestSimplifiablePoint(int index, double x, double y, double sortField) {
             super(index, quantizeX(x), quantizeY(y));
             this.sortField = sortField;
             this.encoded = encode(x(), y());
@@ -554,9 +554,9 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
     }
 
     /** Allow test to use own objects for internal use in geometry simplifier, so we can track the sort-fields together with the points */
-    private static class TestLine implements Geometry {
-        private final long[] encodedPoints;
-        private final double[] sortValues;
+    static class TestLine implements Geometry {
+        final long[] encodedPoints;
+        final double[] sortValues;
 
         private TestLine(int length, StreamingGeometrySimplifier.PointError[] points) {
             this.encodedPoints = new long[length];
@@ -596,9 +596,9 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
         }
     }
 
-    private static class TestGeometrySimplifierMonitor implements StreamingGeometrySimplifier.Monitor {
-        private int addedCount;
-        private int removedCount;
+    static class TestGeometrySimplifierMonitor implements StreamingGeometrySimplifier.Monitor {
+        int addedCount;
+        int removedCount;
 
         public void reset() {
             addedCount = 0;
@@ -631,8 +631,8 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
     }
 
     /** Wrapping the Streaming GeometrySimplifier allowing the test to extract expected points and their sort fields after simplification */
-    private static class TestGeometrySimplifier extends StreamingGeometrySimplifier<TestLine> {
-        private TestGeometrySimplifier(int maxPoints, TestGeometrySimplifierMonitor monitor) {
+    static class TestGeometrySimplifier extends StreamingGeometrySimplifier<TestLine> {
+        TestGeometrySimplifier(int maxPoints, TestGeometrySimplifierMonitor monitor) {
             super("TestGeometrySimplifier", maxPoints, SimplificationErrorCalculator.TRIANGLE_AREA, monitor);
         }
 
@@ -865,7 +865,10 @@ public class GeoLineAggregatorTests extends AggregatorTestCase {
             }
             PathArraySorter.forOrder(sortOrder).apply(linePoints, lineSorts).sort();
 
-            lines.put(String.valueOf(groupOrd), new InternalGeoLine("track", linePoints, lineSorts, null, complete, true, sortOrder, size));
+            lines.put(
+                String.valueOf(groupOrd),
+                new InternalGeoLine("track", linePoints, lineSorts, null, complete, true, sortOrder, size, false, false)
+            );
 
             for (int i = 0; i < randomIntBetween(1, numPoints); i++) {
                 int idx1 = randomIntBetween(0, numPoints - 1);
diff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/InternalGeoLineTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/InternalGeoLineTests.java
index 2021cd8..432138f 100644
--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/InternalGeoLineTests.java
+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/InternalGeoLineTests.java
@@ -53,7 +53,7 @@ public class InternalGeoLineTests extends InternalAggregationTestCase<InternalGe
             }
         }
         boolean complete = length <= size;
-        return new InternalGeoLine(name, points, sortVals, metadata, complete, randomBoolean(), sortOrder, size);
+        return new InternalGeoLine(name, points, sortVals, metadata, complete, randomBoolean(), sortOrder, size, false, false);
     }
 
     @Override
@@ -90,7 +90,7 @@ public class InternalGeoLineTests extends InternalAggregationTestCase<InternalGe
             case 7 -> size = size + 1;
             default -> throw new AssertionError("Illegal randomisation branch");
         }
-        return new InternalGeoLine(name, line, sortVals, metadata, complete, includeSorts, sortOrder, size);
+        return new InternalGeoLine(name, line, sortVals, metadata, complete, includeSorts, sortOrder, size, false, false);
     }
 
     @Override
diff --git a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/MergedGeoLinesTests.java b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/MergedGeoLinesTests.java
index 3a4bc61..67287a5 100644
--- a/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/MergedGeoLinesTests.java
+++ b/x-pack/plugin/spatial/src/test/java/org/elasticsearch/xpack/spatial/search/aggregations/MergedGeoLinesTests.java
@@ -6,17 +6,27 @@
  */
 package org.elasticsearch.xpack.spatial.search.aggregations;
 
+import org.apache.lucene.geo.GeoEncodingUtils;
+import org.elasticsearch.common.util.ArrayUtils;
 import org.elasticsearch.search.sort.SortOrder;
 import org.elasticsearch.test.ESTestCase;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Matcher;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
+import java.util.TreeSet;
+
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.hamcrest.Matchers.lessThan;
 
 public class MergedGeoLinesTests extends ESTestCase {
 
-    public InternalGeoLine randomLine(SortOrder sortOrder, int maxLength, double magicDecimal) {
+    private InternalGeoLine randomLine(SortOrder sortOrder, int maxLength, double magicDecimal) {
         String name = randomAlphaOfLength(5);
         int length = randomBoolean() ? maxLength : randomIntBetween(1, maxLength);
         boolean complete = length <= maxLength;
@@ -26,7 +36,18 @@ public class MergedGeoLinesTests extends ESTestCase {
             points[i] = randomIntBetween(1, 100);
             sortValues[i] = i + magicDecimal;
         }
-        return new InternalGeoLine(name, points, sortValues, Collections.emptyMap(), complete, randomBoolean(), sortOrder, maxLength);
+        return new InternalGeoLine(
+            name,
+            points,
+            sortValues,
+            Collections.emptyMap(),
+            complete,
+            randomBoolean(),
+            sortOrder,
+            maxLength,
+            false,
+            false
+        );
     }
 
     public void testSimpleMerge() {
@@ -40,7 +61,7 @@ public class MergedGeoLinesTests extends ESTestCase {
             finalLength += geoLines.get(i).length();
         }
         finalLength = Math.min(maxLength, finalLength);
-        MergedGeoLines mergedGeoLines = new MergedGeoLines(geoLines, finalLength, sortOrder);
+        MergedGeoLines mergedGeoLines = new MergedGeoLines.Overlapping(geoLines, finalLength, sortOrder, false);
         mergedGeoLines.merge();
 
         // assert that the mergedGeoLines are sorted (does not necessarily validate correctness, but it is a good heuristic)
@@ -63,10 +84,12 @@ public class MergedGeoLinesTests extends ESTestCase {
             true,
             randomBoolean(),
             sortOrder,
-            maxLength
+            maxLength,
+            false,
+            false
         );
         List<InternalGeoLine> geoLines = List.of(lineWithPoints, emptyLine);
-        MergedGeoLines mergedGeoLines = new MergedGeoLines(geoLines, lineWithPoints.length(), sortOrder);
+        MergedGeoLines mergedGeoLines = new MergedGeoLines.Overlapping(geoLines, lineWithPoints.length(), sortOrder, false);
         mergedGeoLines.merge();
 
         // assert that the mergedGeoLines are sorted (does not necessarily validate correctness, but it is a good heuristic)
@@ -76,4 +99,191 @@ public class MergedGeoLinesTests extends ESTestCase {
         assertArrayEquals(sortedValues, mergedGeoLines.getFinalSortValues(), 0d);
         assertArrayEquals(sortedPoints, mergedGeoLines.getFinalPoints());
     }
+
+    public void testMergeNonOverlappingGeoLinesAppendOnly() {
+        int docsPerLine = 10;
+        int numLines = 10;
+        int finalLength = docsPerLine * numLines; // all docs included, only append, no truncation
+        for (SortOrder sortOrder : new SortOrder[] { SortOrder.ASC, SortOrder.DESC }) {
+            boolean simplify = randomBoolean();
+            List<InternalGeoLine> sorted = makeGeoLines(docsPerLine, numLines, simplify, sortOrder);
+            // Shuffle to ensure the tests cover geo_lines coming from data nodes in random order
+            List<InternalGeoLine> shuffled = shuffleGeoLines(sorted);
+            MergedGeoLines mergedGeoLines = new MergedGeoLines.NonOverlapping(shuffled, finalLength, sortOrder, simplify);
+            mergedGeoLines.merge();
+            assertLinesTruncated(sorted, docsPerLine, finalLength, mergedGeoLines);
+        }
+    }
+
+    public void testMergeNonOverlappingGeoLinesAppendAndTruncate() {
+        int docsPerLine = 10;
+        int numLines = 10;
+        int finalLength = 25;  // should get two and a half geolines appended and truncated
+        boolean simplify = false;
+        for (SortOrder sortOrder : new SortOrder[] { SortOrder.ASC, SortOrder.DESC }) {
+            List<InternalGeoLine> sorted = makeGeoLines(docsPerLine, numLines, simplify, sortOrder);
+            // Shuffle to ensure the tests cover geo_lines coming from data nodes in random order
+            List<InternalGeoLine> shuffled = shuffleGeoLines(sorted);
+            MergedGeoLines mergedGeoLines = new MergedGeoLines.NonOverlapping(shuffled, finalLength, sortOrder, simplify);
+            mergedGeoLines.merge();
+            assertLinesTruncated(sorted, docsPerLine, finalLength, mergedGeoLines);
+        }
+    }
+
+    public void testMergeNonOverlappingGeoLinesAppendAndSimplify() {
+        int docsPerLine = 10;
+        int numLines = 10;
+        int finalLength = 25;  // should get entire 100 points simplified down to 25
+        boolean simplify = true;
+        for (SortOrder sortOrder : new SortOrder[] { SortOrder.ASC, SortOrder.DESC }) {
+            List<InternalGeoLine> sorted = makeGeoLines(docsPerLine, numLines, simplify, sortOrder);
+            // Shuffle to ensure the tests cover geo_lines coming from data nodes in random order
+            List<InternalGeoLine> shuffled = shuffleGeoLines(sorted);
+            MergedGeoLines mergedGeoLines = new MergedGeoLines.NonOverlapping(shuffled, finalLength, sortOrder, simplify);
+            mergedGeoLines.merge();
+            assertLinesSimplified(sorted, sortOrder, finalLength, mergedGeoLines);
+        }
+    }
+
+    private void assertLinesTruncated(List<InternalGeoLine> lines, int docsPerLine, int finalLength, MergedGeoLines mergedGeoLines) {
+        double[] values = mergedGeoLines.getFinalSortValues();
+        long[] points = mergedGeoLines.getFinalPoints();
+        assertThat("Same length arrays", values.length, equalTo(points.length));
+        assertThat("Geoline is truncated", values.length, equalTo(finalLength));
+        for (int i = 0; i < values.length; i++) {
+            int doc = i % docsPerLine;
+            int line = i / docsPerLine;
+            InternalGeoLine original = lines.get(line);
+            long[] originalPoints = original.line();
+            double[] originalValues = original.sortVals();
+            assertThat("Point at " + i + " same as point at (" + line + ":" + doc + ")", originalPoints[doc], equalTo(points[i]));
+            assertThat("Value at " + i + " same as value at (" + line + ":" + doc + ")", originalValues[doc], equalTo(values[i]));
+        }
+    }
+
+    private void assertLinesSimplified(List<InternalGeoLine> lines, SortOrder sortOrder, int finalLength, MergedGeoLines mergedGeoLines) {
+        double[] values = mergedGeoLines.getFinalSortValues();
+        long[] points = mergedGeoLines.getFinalPoints();
+        assertThat("Same length arrays", values.length, equalTo(points.length));
+        assertThat("Geo-line is simplified", values.length, equalTo(finalLength));
+        GeoLineAggregatorTests.TestLine simplified = makeSimplifiedLine(lines, sortOrder, finalLength);
+        assertThat("Geo-line is simplified to correct length", values.length, equalTo(simplified.sortValues.length));
+        for (int i = 0; i < values.length; i++) {
+            assertThat("Point at " + i, simplified.encodedPoints[i], equalTo(points[i]));
+            assertThat("Value at " + i, simplified.sortValues[i], equalTo(values[i]));
+        }
+    }
+
+    private GeoLineAggregatorTests.TestLine makeSimplifiedLine(List<InternalGeoLine> geoLines, SortOrder sortOrder, int finalLength) {
+        TreeSet<InternalGeoLine> sorted = switch (sortOrder) {
+            case DESC -> new TreeSet<>((o1, o2) -> Double.compare(o2.sortVals()[0], o1.sortVals()[0]));
+            default -> new TreeSet<>(Comparator.comparingDouble(o -> o.sortVals()[0]));
+        };
+        sorted.addAll(geoLines);
+        GeoLineAggregatorTests.TestGeometrySimplifierMonitor monitor = new GeoLineAggregatorTests.TestGeometrySimplifierMonitor();
+        var simplifier = new GeoLineAggregatorTests.TestGeometrySimplifier(finalLength, monitor);
+        int index = 0;
+        for (InternalGeoLine geoLine : sorted) {
+            double[] values = geoLine.sortVals();
+            long[] points = geoLine.line();
+            for (int i = 0; i < values.length; i++) {
+                double x = GeoEncodingUtils.decodeLongitude((int) (points[i] >>> 32));
+                double y = GeoEncodingUtils.decodeLatitude((int) (points[i] & 0xffffffffL));
+                var point = new GeoLineAggregatorTests.TestSimplifiablePoint(index, x, y, values[i]);
+                simplifier.consume(point);
+                index++;
+            }
+        }
+        assertThat("Simplifier added points", monitor.addedCount, CoreMatchers.equalTo(index));
+        assertThat("Simplifier Removed points", monitor.removedCount, CoreMatchers.equalTo(index - finalLength));
+        return simplifier.produce();
+    }
+
+    private List<InternalGeoLine> makeGeoLines(int docsPerLine, int numLines, boolean simplify, SortOrder sortOrder) {
+        ArrayList<InternalGeoLine> lines = new ArrayList<>();
+        NonOverlappingConfig lineConfig = new NonOverlappingConfig(docsPerLine, -50, -50, 1, 1, 1000, 10);
+        while (lines.size() < numLines) {
+            lines.add(lineConfig.makeGeoLine("test", sortOrder, simplify));
+            lineConfig = lineConfig.nextNonOverlapping();
+        }
+        // Sort so we can make validity assertions
+        List<InternalGeoLine> sorted = sortGeoLines(lines, sortOrder);
+        for (int line = 1; line < sorted.size(); line++) {
+            InternalGeoLine previous = sorted.get(line - 1);
+            InternalGeoLine current = sorted.get(line);
+            double[] pv = previous.sortVals();
+            double[] cv = current.sortVals();
+            assertThat("Previous line ordered", pv[0], compareTo(pv[pv.length - 1], sortOrder));
+            assertThat("Current line ordered", cv[0], compareTo(cv[cv.length - 1], sortOrder));
+            assertThat("Lines non-overlapping", pv[pv.length - 1], compareTo(cv[0], sortOrder));
+        }
+        return sorted;
+    }
+
+    private static Matcher<Double> compareTo(double v, SortOrder sortOrder) {
+        if (sortOrder == SortOrder.ASC) {
+            return lessThan(v);
+        } else {
+            return greaterThan(v);
+        }
+    }
+
+    private static List<InternalGeoLine> sortGeoLines(List<InternalGeoLine> lines, SortOrder sortOrder) {
+        TreeSet<InternalGeoLine> sorted = switch (sortOrder) {
+            case DESC -> new TreeSet<>((o1, o2) -> Double.compare(o2.sortVals()[0], o1.sortVals()[0]));
+            default -> new TreeSet<>(Comparator.comparingDouble(o -> o.sortVals()[0]));
+        };
+        // The Comparator above relies on each line having at least one point, so filter out empty geo_lines
+        for (InternalGeoLine line : lines) {
+            if (line.length() > 0) {
+                sorted.add(line);
+            }
+        }
+        return new ArrayList<>(sorted);
+    }
+
+    private static List<InternalGeoLine> shuffleGeoLines(List<InternalGeoLine> lines) {
+        ArrayList<InternalGeoLine> shuffled = new ArrayList<>(lines);
+        Collections.shuffle(shuffled, random());
+        return shuffled;
+    }
+
+    private record NonOverlappingConfig(int docs, double startX, double startY, double dX, double dY, double startValue, double dV) {
+        private NonOverlappingConfig withStartPosition(double startX, double startY, double startValue) {
+            return new NonOverlappingConfig(docs, startX, startY, dX, dY, startValue, dV);
+        }
+
+        private NonOverlappingConfig nextNonOverlapping() {
+            return withStartPosition(startX + docs * dX, startY + docs * dY, startValue + docs * dV);
+        }
+
+        private InternalGeoLine makeGeoLine(String name, SortOrder sortOrder, boolean simplified) {
+            double[] values = new double[docs];
+            long[] points = new long[docs];
+            for (int i = 0; i < points.length; i++) {
+                double x = startX + i * dX;
+                double y = startY + i * dY;
+                points[i] = (((long) GeoEncodingUtils.encodeLongitude(x)) << 32) | GeoEncodingUtils.encodeLatitude(y) & 0xffffffffL;
+                values[i] = startValue + i * dV;
+            }
+            if (sortOrder == SortOrder.DESC) {
+                // We created 'ASC' above, so reverse the arrays
+                ArrayUtils.reverseSubArray(values, 0, values.length);
+                ArrayUtils.reverseSubArray(points, 0, points.length);
+            }
+            return new InternalGeoLine(
+                name,
+                points,
+                values,
+                Collections.emptyMap(),
+                randomBoolean(),
+                randomBoolean(),
+                sortOrder,
+                docs,
+                true,
+                simplified
+            );
+        }
+    }
+
 }

diff --git a/x-pack/qa/rolling-upgrade-multi-cluster/src/test/java/org/elasticsearch/upgrades/CcrRollingUpgradeIT.java b/x-pack/qa/rolling-upgrade-multi-cluster/src/test/java/org/elasticsearch/upgrades/CcrRollingUpgradeIT.java
index f1d7795..fc8c93a 100644
--- a/x-pack/qa/rolling-upgrade-multi-cluster/src/test/java/org/elasticsearch/upgrades/CcrRollingUpgradeIT.java
+++ b/x-pack/qa/rolling-upgrade-multi-cluster/src/test/java/org/elasticsearch/upgrades/CcrRollingUpgradeIT.java
@@ -13,10 +13,12 @@ import org.elasticsearch.client.RestClient;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.xcontent.support.XContentMapValues;
 import org.elasticsearch.core.Strings;
+import org.elasticsearch.rest.RestStatus;
 import org.elasticsearch.xcontent.ObjectPath;
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 
 import static org.elasticsearch.rest.action.search.RestSearchAction.TOTAL_HITS_AS_INT_PARAM;
 import static org.hamcrest.Matchers.containsString;
@@ -235,7 +237,6 @@ public class CcrRollingUpgradeIT extends AbstractMultiClusterUpgradeTestCase {
         }
     }
 
-    @AwaitsFix(bugUrl = "https://github.com/elastic/elasticsearch/issues/91458")
     public void testBiDirectionalIndexFollowing() throws Exception {
         logger.info("clusterName={}, upgradeState={}", clusterName, upgradeState);
 
@@ -244,8 +245,8 @@ public class CcrRollingUpgradeIT extends AbstractMultiClusterUpgradeTestCase {
                 case NONE -> {
                     createLeaderIndex(leaderClient(), "leader_index5");
                     index(leaderClient(), "leader_index5", 128);
-                    followIndex(followerClient(), "leader", "leader_index5", "follower_index5");
-                    followIndex(leaderClient(), "follower", "follower_index5", "follower_index6");
+                    followIndexIgnoringBadRequests(followerClient(), "leader", "leader_index5", "follower_index5");
+                    followIndexIgnoringBadRequests(leaderClient(), "follower", "follower_index5", "follower_index6");
                     assertTotalHitCount("follower_index5", 128, followerClient());
                     assertTotalHitCount("follower_index6", 128, leaderClient());
                     index(leaderClient(), "leader_index5", 128);
@@ -300,6 +301,26 @@ public class CcrRollingUpgradeIT extends AbstractMultiClusterUpgradeTestCase {
         assertOK(client.performRequest(request));
     }
 
+    private static void followIndexIgnoringBadRequests(RestClient client, String leaderCluster, String leaderIndex, String followIndex)
+        throws Exception {
+        assertBusy(() -> {
+            try {
+                followIndex(client, leaderCluster, leaderIndex, followIndex);
+            } catch (ResponseException e) {
+                if (e.getResponse().getStatusLine().getStatusCode() == RestStatus.BAD_REQUEST.getStatus()) {
+                    // Following a CCR leader index requires to retrieve the index stats at some point, which can return a Bad Request
+                    // response if the coordinating node on the remote cluster doesn't know about the leader index yet. It often fails in
+                    // bi-directionnal CCR test so we work around this issue by retrying with some assertBusy backoff.
+                    throw new AssertionError(
+                        "Receive bad request response after trying to follow index [" + leaderIndex + "], retrying",
+                        e
+                    );
+                }
+                throw e;
+            }
+        }, 30L, TimeUnit.SECONDS);
+    }
+
     private static void putAutoFollowPattern(RestClient client, String name, String remoteCluster, String pattern) throws IOException {
         Request request = new Request("PUT", "/_ccr/auto_follow/" + name);
         request.setJsonEntity(Strings.format("""

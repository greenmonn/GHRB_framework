diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index c0a1f08..51181b9 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -1455,7 +1455,8 @@ public abstract class CompilerTestCase {
         }
 
         if (gatherExternPropertiesEnabled && i == 0) {
-          new GatherExternProperties(compiler).process(externsRoot, mainRoot);
+          new GatherExternProperties(compiler, GatherExternProperties.Mode.CHECK_AND_OPTIMIZE)
+              .process(externsRoot, mainRoot);
         }
 
         if (i == 0) {
diff --git a/test/com/google/javascript/jscomp/GatherExternPropertiesTest.java b/test/com/google/javascript/jscomp/GatherExternPropertiesTest.java
index 4bb5761..2f56c86 100644
--- a/test/com/google/javascript/jscomp/GatherExternPropertiesTest.java
+++ b/test/com/google/javascript/jscomp/GatherExternPropertiesTest.java
@@ -26,31 +26,34 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class GatherExternPropertiesTest extends CompilerTestCase {
 
-  private static final String EXTERNS = lines(
-      "/**",
-      " * @constructor",
-      " * @param {*=} opt_value",
-      " * @return {!Object}",
-      " */",
-      "function Object(opt_value) {}",
-      "/**",
-      " * @constructor",
-      " * @param {...*} var_args",
-      " */",
-      "function Function(var_args) {}",
-      "/**",
-      " * @constructor",
-      " * @param {*=} arg",
-      " * @return {string}",
-      " */",
-      "function String(arg) {}",
-      "/**",
-      " * @template T",
-      " * @constructor ",
-      " * @param {...*} var_args",
-      " * @return {!Array<?>}",
-      " */",
-      "function Array(var_args) {}");
+  private static final String EXTERNS =
+      lines(
+          "/**",
+          " * @constructor",
+          " * @param {*=} opt_value",
+          " * @return {!Object}",
+          " */",
+          "function Object(opt_value) {}",
+          "/**",
+          " * @constructor",
+          " * @param {...*} var_args",
+          " */",
+          "function Function(var_args) {}",
+          "/**",
+          " * @constructor",
+          " * @param {*=} arg",
+          " * @return {string}",
+          " */",
+          "function String(arg) {}",
+          "/**",
+          " * @template T",
+          " * @constructor ",
+          " * @param {...*} var_args",
+          " * @return {!Array<?>}",
+          " */",
+          "function Array(var_args) {}");
+
+  private GatherExternProperties.Mode mode;
 
   public GatherExternPropertiesTest() {
     super(EXTERNS);
@@ -58,7 +61,8 @@ public final class GatherExternPropertiesTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new GatherExternProperties(compiler);
+    mode = this.mode == null ? GatherExternProperties.Mode.OPTIMIZE : mode;
+    return new GatherExternProperties(compiler, mode);
   }
 
   @Test
@@ -69,35 +73,28 @@ public final class GatherExternPropertiesTest extends CompilerTestCase {
   @Test
   public void testGatherExternProperties() {
     // Properties.
-    assertExternProperties(
-        "foo.bar;",
-        "bar");
+    assertExternProperties("foo.bar;", "bar");
 
     // Object literals.
-    assertExternProperties(
-        "foo = {bar: null, 'baz': {foobar: null}};",
-        "bar", "baz", "foobar");
+    assertExternProperties("foo = {bar: null, 'baz': {foobar: null}};", "bar", "baz", "foobar");
     // Object literal with numeric propertic.
-    assertExternProperties(
-        "foo = {0: null};",
-         "0");
+    assertExternProperties("foo = {0: null};", "0");
 
     // Top-level variables do not count.
-    assertExternProperties(
-        "var foo;");
+    assertExternProperties("var foo;");
 
     // String-key access does not count.
-    assertExternProperties(
-        "foo['bar'] = {};");
+    assertExternProperties("foo['bar'] = {};");
   }
 
   @Test
   public void testGatherExternTypedefProperties() {
+    this.mode = GatherExternProperties.Mode.CHECK_AND_OPTIMIZE;
     String typedefExtern =
         lines(
             "/**",
             " * @typedef {{",
-            " *    typedefPropA: { 'subTypedefProp': string },",  // quotes should be stripped
+            " *    typedefPropA: { 'subTypedefProp': string },", // quotes should be stripped
             " *  }}",
             " */",
             "var TypedefExtern;",
@@ -111,127 +108,124 @@ public final class GatherExternPropertiesTest extends CompilerTestCase {
 
   @Test
   public void testGatherExternPropertiesIncludingRecordTypes() {
+    this.mode = GatherExternProperties.Mode.CHECK_AND_OPTIMIZE;
     // Properties.
-    assertExternProperties(
-        "foo.bar;",
-        "bar");
+    assertExternProperties("foo.bar;", "bar");
 
     // Object literals.
-    assertExternProperties(
-        "foo = {bar: null, 'baz': {foobar: null}};",
-        "bar", "baz", "foobar");
+    assertExternProperties("foo = {bar: null, 'baz': {foobar: null}};", "bar", "baz", "foobar");
 
     // Object literal with numeric propertic.
-    assertExternProperties(
-        "foo = {0: null};",
-         "0");
+    assertExternProperties("foo = {0: null};", "0");
 
     // Top-level variables do not count.
-    assertExternProperties(
-        "var foo;");
+    assertExternProperties("var foo;");
 
     // String-key access does not count.
-    assertExternProperties(
-        "foo['bar'] = {};");
+    assertExternProperties("foo['bar'] = {};");
 
     // Record types on properties.
-    assertExternProperties(
-        "/** @type {{bar: string, baz: string}} */ var foo;",
-        "bar", "baz");
+    assertExternProperties("/** @type {{bar: string, baz: string}} */ var foo;", "bar", "baz");
 
     // Record types in typedef.
     assertExternProperties(
-        "/** @typedef {{bar: string, baz: string}} */ var FooType;",
-        "bar", "baz");
+        "/** @typedef {{bar: string, baz: string}} */ var FooType;", "bar", "baz");
 
     // Record types in type unions.
     assertExternProperties(
-        "/** @type {string|{bar: string}|{baz: string}} */ var foo;",
-        "bar", "baz");
+        "/** @type {string|{bar: string}|{baz: string}} */ var foo;", "bar", "baz");
 
     // Record types in function parameters and return types.
-    assertExternProperties(lines(
-        "/** @type {function(string, {bar: string}): {baz: string}} */",
-        "var foo;"),
-        "bar", "baz");
+    assertExternProperties(
+        lines("/** @type {function(string, {bar: string}): {baz: string}} */", "var foo;"),
+        "bar",
+        "baz");
 
     // Record types as template arguments.
     assertExternProperties(
-        "/** @type {Array<{bar: string, baz: string}>} */ var foo;",
-        "bar", "baz");
+        "/** @type {Array<{bar: string, baz: string}>} */ var foo;", "bar", "baz");
 
     // Record types in implemented interfaces.
-    assertExternProperties(lines(
-        "/**",
-        " * @interface",
-        " * @template T",
-        " */",
-        "var Foo = function() {};",
-        "/**",
-        " * @constructor",
-        " * @implements {Foo<{bar: string, baz: string}>}",
-        " */",
-        "var Bar;"),
-        "bar", "baz");
+    assertExternProperties(
+        lines(
+            "/**",
+            " * @interface",
+            " * @template T",
+            " */",
+            "var Foo = function() {};",
+            "/**",
+            " * @constructor",
+            " * @implements {Foo<{bar: string, baz: string}>}",
+            " */",
+            "var Bar;"),
+        "bar",
+        "baz");
 
     // Record types in extended class.
-    assertExternProperties(lines(
-        "/**",
-        " * @constructor",
-        " * @template T",
-        " */",
-        "var Foo = function() {};",
-        "/**",
-        " * @constructor",
-        " * @extends {Foo<{bar: string, baz: string}>}",
-        " */",
-        "var Bar = function() {};"),
-        "bar", "baz");
+    assertExternProperties(
+        lines(
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "var Foo = function() {};",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo<{bar: string, baz: string}>}",
+            " */",
+            "var Bar = function() {};"),
+        "bar",
+        "baz");
 
     // Record types in enum.
     // Note that "baz" exists only in the type of the enum,
     // but it is still picked up.
-    assertExternProperties(lines(
-        "/** @enum {{bar: string, baz: (string|undefined)}} */",
-        "var FooEnum = {VALUE: {bar: ''}};"),
-        "VALUE", "bar", "baz");
+    assertExternProperties(
+        lines(
+            "/** @enum {{bar: string, baz: (string|undefined)}} */",
+            "var FooEnum = {VALUE: {bar: ''}};"),
+        "VALUE",
+        "bar",
+        "baz");
 
     // Nested record types.
     assertExternProperties(
-        "/** @type {{bar: string, baz: {foobar: string}}} */ var foo;",
-        "bar", "baz", "foobar");
+        "/** @type {{bar: string, baz: {foobar: string}}} */ var foo;", "bar", "baz", "foobar");
 
     // Recursive @record types.
-    assertExternProperties(lines(
-        "/** @record */",
-        "function D1() { /** @type {D2} */ this.a; }",
-        "",
-        "/** @record */",
-        "function D2() { /** @type {D1} */ this.b; }"),
-        "a", "b");
-    assertExternProperties(lines(
-        "/** @record */",
-        "function D1() { /** @type {function(D2)} */ this.a; }",
-        "",
-        "/** @record */",
-        "function D2() { /** @type {D1} */ this.b; }"),
-        "a", "b");
+    assertExternProperties(
+        lines(
+            "/** @record */",
+            "function D1() { /** @type {D2} */ this.a; }",
+            "",
+            "/** @record */",
+            "function D2() { /** @type {D1} */ this.b; }"),
+        "a",
+        "b");
+    assertExternProperties(
+        lines(
+            "/** @record */",
+            "function D1() { /** @type {function(D2)} */ this.a; }",
+            "",
+            "/** @record */",
+            "function D2() { /** @type {D1} */ this.b; }"),
+        "a",
+        "b");
 
     // Recursive types
-    assertExternProperties(lines(
-        "/** @typedef {{a: D2}} */",
-        "var D1;",
-        "",
-        "/** @typedef {{b: D1}} */",
-        "var D2;"),
-        "a", "b");
-    assertExternProperties(lines(
-        "/** @typedef {{a: function(D2)}} */",
-        "var D1;",
-        "",
-        "/** @typedef {{b: D1}} */",
-        "var D2;"),
-        "a", "b");
+    assertExternProperties(
+        lines("/** @typedef {{a: D2}} */", "var D1;", "", "/** @typedef {{b: D1}} */", "var D2;"),
+        "a",
+        "b");
+    assertExternProperties(
+        lines(
+            "/** @typedef {{a: function(D2)}} */",
+            "var D1;",
+            "",
+            "/** @typedef {{b: D1}} */",
+            "var D2;"),
+        "a",
+        "b");
 
     // Record types defined in normal code and referenced in externs should
     // not bleed-through.
@@ -258,12 +252,34 @@ public final class GatherExternPropertiesTest extends CompilerTestCase {
 
   @Test
   public void testExternWithMethod() {
+    assertExternProperties(lines("foo = {", "  method() {}", "}"), "method");
+  }
+
+  @Test
+  public void testGatherExternsInCheckMode() {
+    this.mode = GatherExternProperties.Mode.CHECK;
+    assertExternProperties(
+        lines(
+            "/** @fileoverview @externs */ ", //
+            "var ns = {}; ",
+            "ns.x; ",
+            "/** @type {{y: string}} */ ",
+            "ns.yObj;"),
+        "y");
+  }
+
+  @Test
+  public void testGatherExternsInOptimizeMode() {
+    this.mode = GatherExternProperties.Mode.OPTIMIZE;
     assertExternProperties(
         lines(
-            "foo = {",
-            "  method() {}",
-            "}"),
-        "method");
+            "/** @fileoverview @externs */ ", //
+            "var ns = {}; ",
+            "ns.x; ",
+            "/** @type {{y: string}} */ ",
+            "ns.yObj;"),
+        "x",
+        "yObj");
   }
 
   private static Postcondition expectExterns(final String... properties) {
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index e8fe4e7..99cd81b 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -5492,6 +5492,25 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testGoogRequire_namedExportImportedAsNamespace_andModded() {
+    testSame(
+        srcs(
+            "goog.module('a'); class C { m() {} } exports = {C}; C: C;",
+            "goog.module('b'); const a = goog.require('a'); a.C.prototype.n = function() {};"));
+
+    Node cCtor = getLabeledStatement("C").statementNode.getOnlyChild();
+    assertNode(cCtor).hasJSTypeThat().isFunctionTypeThat().isConstructorFor("C");
+
+    FunctionType cCtorType = cCtor.getJSType().assertFunctionType();
+    ObjectType cPrototype = cCtorType.getPrototype();
+    assertType(cPrototype).hasDeclaredProperty("n");
+    assertType(cPrototype.getPropertyType("n"))
+        .isFunctionTypeThat()
+        .hasTypeOfThisThat()
+        .isEqualTo(cCtorType.getInstanceType());
+  }
+
+  @Test
   public void testGoogRequire_destructuringInferredNamedExport() {
     testSame(
         srcs(
diff --git a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
index f8d646a..84bf22d 100644
--- a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
@@ -473,7 +473,7 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
       table.put(
           nameOf(edge.getSource()), nameOf(edge.getDestination()), (EdgeReason) edge.getValue());
     }
-    return assertThat(table.build());
+    return assertThat(table.buildOrThrow());
   }
 
   /**
diff --git a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
index 07c84e7..954d1fd 100644
--- a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
@@ -202,8 +202,32 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
 
     Compiler compiler = compileTypedAstShards(options);
 
-    // TODO(b/207693227): stop renaming x and y to a and b
-    Node expectedRoot = parseExpectedCode("takeCoord({a: 1, b: 2});");
+    Node expectedRoot = parseExpectedCode("takeCoord({x: 1, y: 2});");
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
+  @Test
+  public void gatherExternProperties() throws IOException {
+    precompileLibrary(
+        extern(
+            new TestExternsBuilder()
+                .addExtra(
+                    lines(
+                        "/** @fileoverview @externs */ ", //
+                        "var ns = {}; ",
+                        "ns.x; "))
+                .addConsole()
+                .build()),
+        code("console.log(ns.x); console.log(ns.nonExternProperty);"));
+
+    CompilerOptions options = new CompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+
+    Compiler compiler = compileTypedAstShards(options);
+
+    Node expectedRoot = parseExpectedCode("console.log(ns.x);console.log(ns.a);");
     assertNode(compiler.getRoot().getSecondChild())
         .usingSerializer(compiler::toSource)
         .isEqualTo(expectedRoot);

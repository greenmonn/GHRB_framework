diff --git a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
index 806ce81..c9f4b2b 100644
--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
@@ -381,7 +381,7 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
             .setVersion(3)
             .setFile("testcode")
             .setLineCount(3)
-            .setMappings("A,aAAA,IAAIA,oBAAsB,QAAQC,CAAR;OACnBC,CADmB;OAEnBC,CAFmB;")
+            .setMappings("A,aAAA,IAAIA,oBAAuB,QAAOC,CAAP;OACpBC,CADoB;OAEpBC,CAFoB;")
             .setSources(getEncodedFileName())
             .setNames("myMultilineTemplate", "a", "b", "c")
             .build());
diff --git a/test/com/google/javascript/jscomp/AngularPassTest.java b/test/com/google/javascript/jscomp/AngularPassTest.java
index 353912d..26205e9 100644
--- a/test/com/google/javascript/jscomp/AngularPassTest.java
+++ b/test/com/google/javascript/jscomp/AngularPassTest.java
@@ -516,7 +516,6 @@ public final class AngularPassTest extends CompilerTestCase {
 
   @Test
   public void testInGoogScope() {
-    enableRewriteClosureCode();
     test(
         lines("goog.scope(function() {", "/** @ngInject */", "function fn(a, b) {}", "});"),
         lines(
diff --git a/test/com/google/javascript/jscomp/ChangeVerifierTest.java b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
index f910f4c..87502f4 100644
--- a/test/com/google/javascript/jscomp/ChangeVerifierTest.java
+++ b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
@@ -18,35 +18,52 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+/**
+ * Test class for ChangeVerifier.java. Test cases in this class roughly do the following:
+ *
+ * <p>1. Creates a compiler instance and parses a script using it.
+ *
+ * <p>2. Creates a new ChangeVerifier class with the same compiler.
+ *
+ * <p>3. Saves a clean snapshot of the parsed script from step#1 using the ChangeVerifier instance
+ * from step#2
+ *
+ * <p>4. Changes the script from step #1.
+ *
+ * <p>5. Either records/skips recording change to the script from #1 into the compiler.
+ *
+ * <p>6. Invokes changeVerifier (which already contains the clean snapshot) and gives it the changed
+ * script from step#1 to compare nodes.
+ */
 @RunWith(JUnit4.class)
 public final class ChangeVerifierTest {
+  private Compiler compiler;
+
+  @Before
+  public void setup() {
+    compiler = null;
+  }
 
   @Test
   public void testCorrectValidationOfScriptWithChangeAfterFunction() {
     Node script = parse("function A() {} if (0) { A(); }");
     checkState(script.isScript());
 
-    Compiler compiler = new Compiler();
-    compiler.incrementChangeStamp();
     ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
 
-    // Here we make a change in that doesn't change the script node
-    // child count.
     getCallNode(script).detach();
+    compiler.reportChangeToChangeScope(script);
 
-    // Mark the script as changed
-    compiler.incrementChangeStamp();
-    script.setChangeTime(compiler.getChangeStamp());
-
-    // will throw if no change is detected.
+    // checks that a change was made and reported.
     verifier.checkRecordedChanges("test1", script);
   }
 
@@ -55,22 +72,80 @@ public final class ChangeVerifierTest {
     Node script = parse("function A() {} if (0) { A(); }");
     checkState(script.isScript());
 
-    Compiler compiler = new Compiler();
-    compiler.incrementChangeStamp();
     ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
 
-    // no change
+    // no change, no problem
     verifier.checkRecordedChanges("test1", script);
 
     // add a statement, but don't report the change.
     script.addChildToBack(IR.exprResult(IR.nullNode()));
 
-    try {
-      verifier.checkRecordedChanges("test2", script);
-      assertWithMessage("exception expected").fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessageThat().contains("changed scope not marked as changed");
-    }
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", script));
+    assertThat(e).hasMessageThat().contains("changed scope not marked as changed");
+  }
+
+  @Test
+  public void testChangeToFunction_notReported() {
+    Node script = parse("function A() {}");
+    checkState(script.isScript());
+    Node function = script.getFirstChild();
+    checkState(function.isFunction());
+
+    ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
+
+    // no change, no problem.
+    verifier.checkRecordedChanges("test1", script);
+
+    // add a statement, but don't report the change.
+    function.addChildToBack(IR.exprResult(IR.nullNode()));
+
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", script));
+    assertThat(e).hasMessageThat().contains("changed scope not marked as changed");
+  }
+
+  @Test
+  public void testChangeToArrowFunction_notReported() {
+    Node script = parse("() => {}");
+    checkState(script.isScript());
+    Node function = script.getFirstFirstChild();
+    checkState(function.isArrowFunction());
+
+    ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
+
+    // no change, no problem.
+    verifier.checkRecordedChanges("test1", script);
+
+    // add a statement, but don't report the change.
+    function.addChildToBack(IR.exprResult(IR.nullNode()));
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", script));
+    assertThat(e).hasMessageThat().contains("changed scope not marked as changed");
+  }
+
+  @Test
+  public void testChangeToArrowFunction_correctlyReportedChange() {
+    Node script = parse("() => {}");
+    checkState(script.isScript());
+
+    Node function = script.getFirstFirstChild();
+    checkState(function.isArrowFunction());
+
+    ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
+
+    // no change, no problem.
+    verifier.checkRecordedChanges("test1", script);
+
+    // add a statement, and report the change.
+    function.addChildToBack(IR.exprResult(IR.nullNode()));
+    compiler.reportChangeToChangeScope(function);
+
+    // checks that a change was made and recorded.
+    verifier.checkRecordedChanges("test2", script);
   }
 
   @Test
@@ -79,8 +154,6 @@ public final class ChangeVerifierTest {
 
     checkState(script.isScript());
 
-    Compiler compiler = new Compiler();
-    compiler.incrementChangeStamp();
     ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
 
     // no change
@@ -91,12 +164,10 @@ public final class ChangeVerifierTest {
     fnNode.detach();
     compiler.reportChangeToChangeScope(script);
 
-    try {
-      verifier.checkRecordedChanges("test2", script);
-      assertWithMessage("exception expected").fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessageThat().contains("deleted scope was not reported");
-    }
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", script));
+    assertThat(e).hasMessageThat().contains("deleted scope was not reported");
 
     // now try again after reporting the function deletion.
     compiler.reportFunctionDeleted(fnNode);
@@ -111,8 +182,6 @@ public final class ChangeVerifierTest {
 
     checkState(script.isScript());
 
-    Compiler compiler = new Compiler();
-    compiler.incrementChangeStamp();
     ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(script);
 
     // no change
@@ -122,49 +191,48 @@ public final class ChangeVerifierTest {
     Node fnNode = script.getFirstChild();
     compiler.reportFunctionDeleted(fnNode);
 
-    try {
-      verifier.checkRecordedChanges("test2", script);
-      assertWithMessage("exception expected").fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessageThat().contains("existing scope is improperly marked as deleted");
-    }
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", script));
+    assertThat(e).hasMessageThat().contains("existing scope is improperly marked as deleted");
   }
 
   @Test
   public void testChangeVerification() {
-    Compiler compiler = new Compiler();
-
-    Node mainScript = IR.script();
-    Node main = IR.root(mainScript);
+    Node mainScript = parse("");
 
-    ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(main);
+    ChangeVerifier verifier = new ChangeVerifier(compiler).snapshot(mainScript);
 
-    verifier.checkRecordedChanges(main);
+    verifier.checkRecordedChanges(mainScript);
 
     mainScript.addChildToFront(
         IR.function(IR.name("A"), IR.paramList(), IR.block()));
-    compiler.incrementChangeStamp();
-    mainScript.setChangeTime(compiler.getChangeStamp());
-
-    try {
-      verifier.checkRecordedChanges(main);
-      assertWithMessage("method should throw").fail();
-    } catch (IllegalStateException e) {
-      // ensure that e was thrown from the right code-path
-      // especially important if it's something as frequent
-      // as an IllegalArgumentException, etc.
-      assertThat(e).hasMessageThat().startsWith("new scope not explicitly marked as changed:");
-    }
+    compiler.reportChangeToChangeScope(mainScript);
+
+    IllegalStateException e =
+        assertThrows(
+            IllegalStateException.class, () -> verifier.checkRecordedChanges("test2", mainScript));
+    // ensure that e was thrown from the right code-path
+    // especially important if it's something as frequent
+    // as an IllegalArgumentException, etc.
+    assertThat(e).hasMessageThat().contains("new scope not explicitly marked as changed:");
+
+    // works fine when the newly created function scope is marked as changed.
+    Node fnNode = mainScript.getFirstChild();
+    compiler.reportChangeToChangeScope(fnNode);
+    verifier.checkRecordedChanges(mainScript);
   }
 
-  private static Node parse(String js) {
-    Compiler compiler = new Compiler();
+  /** Initializes a new compiler, parses the script using it and returns the script node */
+  private Node parse(String js) {
+    compiler = new Compiler();
     compiler.initCompilerOptionsIfTesting();
     Node n = compiler.parseTestCode(js);
     assertThat(compiler.getErrors()).isEmpty();
     return n;
   }
 
+  /** Performs a depth first search and returns the first call node it finds */
   private static Node getCallNode(Node n) {
     if (n.isCall()) {
       return n;
diff --git a/test/com/google/javascript/jscomp/CheckClosureImportsTest.java b/test/com/google/javascript/jscomp/CheckClosureImportsTest.java
index c764f02..c609531 100644
--- a/test/com/google/javascript/jscomp/CheckClosureImportsTest.java
+++ b/test/com/google/javascript/jscomp/CheckClosureImportsTest.java
@@ -519,12 +519,11 @@ public class CheckClosureImportsTest extends CompilerTestCase {
   }
 
   @Test
-  public void moduleGetInGlobalScopeIsError() {
+  public void moduleGetInGlobalScopeIsOK() {
     moduleType = ModuleType.SCRIPT;
 
-    test(
-        srcs(ES_MODULE_SRC, makeTestFile("goog.module.get('es.module');")),
-        error(INVALID_GET_CALL_SCOPE));
+    // only global variable aliasing goog.module.get results are banned.
+    test(srcs(ES_MODULE_SRC, makeTestFile("goog.module.get('es.module');")));
   }
 
   @Test
@@ -569,6 +568,80 @@ public class CheckClosureImportsTest extends CompilerTestCase {
   }
 
   @Test
+  public void moduleGetAssignmentToNamespace() {
+    moduleType = ModuleType.GOOG_PROVIDE;
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('a.b.c');", //
+                    "goog.require('symbol');",
+                    "a.b.c = goog.module.get('symbol');"))));
+  }
+
+  @Test
+  public void moduleGetAssignmentToName() {
+    moduleType = ModuleType.GOOG_PROVIDE;
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "var sym = goog.module.get('symbol');"))),
+        error(INVALID_GET_CALL_SCOPE));
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "var sym = goog.module.get('symbol').sym;"))),
+        error(INVALID_GET_CALL_SCOPE));
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "var sym = goog.module.get('symbol')?.sym;"))),
+        error(INVALID_GET_CALL_SCOPE));
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "const {sym} = goog.module.get('symbol');"))),
+        error(INVALID_GET_CALL_SCOPE));
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "var sym",
+                    "sym = goog.module.get('symbol').sym;"))),
+        error(INVALID_GET_CALL_SCOPE));
+
+    test(
+        srcs(
+            PROVIDES_SYMBOL_SRC,
+            makeTestFile(
+                lines(
+                    "goog.provide('test');", //
+                    "let sym; ({sym} = goog.module.get('symbol'));"))),
+        error(INVALID_GET_CALL_SCOPE));
+  }
+
+  @Test
   public void moduleGetOtherAssignmentDeclareIsError() {
     moduleType = ModuleType.GOOG_MODULE;
 
diff --git a/test/com/google/javascript/jscomp/CheckConformanceTest.java b/test/com/google/javascript/jscomp/CheckConformanceTest.java
index 0deaf1b..5343886 100644
--- a/test/com/google/javascript/jscomp/CheckConformanceTest.java
+++ b/test/com/google/javascript/jscomp/CheckConformanceTest.java
@@ -1284,8 +1284,6 @@ public final class CheckConformanceTest extends CompilerTestCase {
 
   @Test
   public void testBannedPropertyWhitelist_recordType() {
-    // TODO(b/76025401): remove the enableTranspile() call once we natively typecheck classes
-    enableTranspile();
     configuration =
         lines(
             "requirement: {",
@@ -1323,8 +1321,6 @@ public final class CheckConformanceTest extends CompilerTestCase {
 
   @Test
   public void testBannedPropertyAllowlist_recordType() {
-    // TODO(b/76025401): remove the enableTranspile() call once we natively typecheck classes
-    enableTranspile();
     configuration =
         lines(
             "requirement: {",
@@ -1431,6 +1427,128 @@ public final class CheckConformanceTest extends CompilerTestCase {
   }
 
   @Test
+  public void testBannedPropertyWhitelist_bundledNamespacedType() {
+    disableRewriteClosureCode();
+
+    configuration =
+        lines(
+            "requirement: {",
+            "  type: BANNED_PROPERTY",
+            "  value: 'test.bns.BC.prototype.p'",
+            "  error_message: 'test.bns.BC.p is not allowed'",
+            "  whitelist: 'SRC1'",
+            "}");
+
+    String declarations =
+        lines(
+            "/** @fileoverview @typeSummary */",
+            "goog.loadModule(function(exports) {",
+            "goog.module('test.bns');",
+            "/** @constructor */ function SBC() {}",
+            "exports.SBC = SBC;",
+            "/** @constructor @extends {SBC} */",
+            "BC = function() {}",
+            "/** @type {string} */",
+            "BC.prototype.p;",
+            "exports.BC = BC;",
+            "/** @constructor */ function D() {}",
+            "exports.D = D;",
+            "/** @type {string} */",
+            "D.prototype.p;",
+            "return exports;",
+            "});");
+
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const {D} = goog.require('test.bns');",
+            "var d = new D();",
+            "d.p = 'boo';"));
+
+    // This case should be a certain violation, but the compiler cannot figure out that the imported
+    // type is the same as the one found from the type registry.
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const {BC} = goog.require('test.bns');",
+            "var bc = new BC();",
+            "bc.p = 'boo';"),
+        CheckConformance.CONFORMANCE_POSSIBLE_VIOLATION);
+
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const bns = goog.require('test.bns');",
+            "var bc = new bns.SBC();",
+            "bc.p = 'boo';"),
+        CheckConformance.CONFORMANCE_POSSIBLE_VIOLATION);
+  }
+
+  @Test
+  public void testBannedPropertyAllowlist_bundledNamespacedType() {
+    disableRewriteClosureCode();
+
+    configuration =
+        lines(
+            "requirement: {",
+            "  type: BANNED_PROPERTY",
+            "  value: 'test.bns.BC.prototype.p'",
+            "  error_message: 'test.bns.BC.p is not allowed'",
+            "  allowlist: 'SRC1'",
+            "}");
+
+    String declarations =
+        lines(
+            "/** @fileoverview @typeSummary */",
+            "goog.loadModule(function(exports) {",
+            "goog.module('test.bns');",
+            "/** @constructor */ function SBC() {}",
+            "exports.SBC = SBC;",
+            "/** @constructor @extends {SBC} */",
+            "BC = function() {}",
+            "/** @type {string} */",
+            "BC.prototype.p;",
+            "exports.BC = BC;",
+            "/** @constructor */ function D() {}",
+            "exports.D = D;",
+            "/** @type {string} */",
+            "D.prototype.p;",
+            "return exports;",
+            "});");
+
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const {D} = goog.require('test.bns');",
+            "var d = new D();",
+            "d.p = 'boo';"));
+
+    // This case should be a certain violation, but the compiler cannot figure out that the imported
+    // type is the same as the one found from the type registry.
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const {BC} = goog.require('test.bns');",
+            "var bc = new BC();",
+            "bc.p = 'boo';"),
+        CheckConformance.CONFORMANCE_POSSIBLE_VIOLATION);
+
+    testConformance(
+        declarations,
+        lines(
+            "goog.module('test');",
+            "const bns = goog.require('test.bns');",
+            "var bc = new bns.SBC();",
+            "bc.p = 'boo';"),
+        CheckConformance.CONFORMANCE_POSSIBLE_VIOLATION);
+  }
+
+  @Test
   public void testBannedPropertyWhitelist_destructuring() {
     configuration =
         lines(
@@ -2835,9 +2953,8 @@ public final class CheckConformanceTest extends CompilerTestCase {
 
   @Test
   public void testRequireUseStrictEs6Module() {
-    // TODO(b/76025401): remove the enableTranspile() call once we natively typecheck classes
-    enableTranspile();
     configuration = config(rule("RequireUseStrict"), "My rule message");
+    enableRewriteEsModules();
 
     testNoWarning("export var x = 2;");
   }
@@ -3201,7 +3318,59 @@ public final class CheckConformanceTest extends CompilerTestCase {
         CheckConformance.CONFORMANCE_VIOLATION,
         "Violation: BanSetAttribute Message");
 
+    testWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "const foo = 'safe';",
+                "var bar = foo;",
+                "(new HTMLScriptElement).setAttribute(bar, 'xxx');")),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSetAttribute Message");
+
     testNoWarning(externs(externs), srcs("(new HTMLScriptElement)['data-random'] = 'xxx';"));
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "const foo = 'safe';",
+                "const bar = foo;",
+                "(new HTMLScriptElement).setAttribute(bar, 'xxx');")));
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            new String[] {
+              lines(
+                  "goog.provide('test.Attribute');",
+                  "",
+                  "/** @enum {string} */",
+                  "test.Attribute = {SRC: 'src', HREF: 'href', SAFE: 'safe'};"),
+              lines(
+                  "goog.module('test.setAttribute');",
+                  "",
+                  "const Attribute = goog.require('test.Attribute');",
+                  "",
+                  "const attr = Attribute.SAFE;",
+                  "(new HTMLScriptElement).setAttribute(attr, 'xxx');")
+            }));
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "goog.provide('xid');",
+                "goog.provide('xid.String');",
+                "/** @enum {string} */ xid.String = {DO_NOT_USE: ''};",
+                "/**",
+                " * @param {string} id",
+                " * @return {xid.String}",
+                " */",
+                "xid = function(id) {return /** @type {xid.String} */ (id);};",
+                "const attr = xid('src');",
+                "(new HTMLScriptElement).setAttribute(attr, 'xxx');",
+                "(new HTMLScriptElement)[attr] = 'xxx';")));
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/CheckJsDocTest.java b/test/com/google/javascript/jscomp/CheckJsDocTest.java
index 752fada..a6c63da 100644
--- a/test/com/google/javascript/jscomp/CheckJsDocTest.java
+++ b/test/com/google/javascript/jscomp/CheckJsDocTest.java
@@ -552,6 +552,12 @@ public final class CheckJsDocTest extends CompilerTestCase {
     testWarning("/** @desc Foo. */ const {bar} = goog.getMsg('x');", MISPLACED_MSG_ANNOTATION);
     testWarning(
         "var bar;\n/** @desc Foo. */ ({bar} = goog.getMsg('x'));", MISPLACED_MSG_ANNOTATION);
+
+    // allow in TS code
+    testNoWarning(
+        srcs(
+            SourceFile.fromCode(
+                "foo.closure.js", "/** @desc Foo. */ var bar = goog.getMsg('hello');")));
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
index 12af2d6..3e38b3d 100644
--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java
@@ -142,32 +142,11 @@ public final class ClosureCodingConventionTest {
   }
 
   @Test
-  public void testInheritanceDetection10() {
-    assertDefinesClasses("goog.mixin(A.prototype, B.prototype);",
-        "A", "B");
-  }
-
-  @Test
   public void testInheritanceDetection11() {
     assertNotClassDefining("A.mixin(B)");
   }
 
   @Test
-  public void testInheritanceDetection12() {
-    assertDefinesClasses("goog.mixin(A.prototype, B)", "A", "B");
-  }
-
-  @Test
-  public void testInheritanceDetection13() {
-    assertDefinesClasses("goog.mixin(A, B)", "A", "B");
-  }
-
-  @Test
-  public void testInheritanceDetection14() {
-    assertNotClassDefining("goog$mixin((function(){}).prototype)");
-  }
-
-  @Test
   public void testInheritanceDetection15() {
     assertDefinesClasses("$jscomp.inherits(A, B)", "A", "B");
   }
diff --git a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
index 2412256..acf7651 100644
--- a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
+++ b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
@@ -22,7 +22,6 @@ import static com.google.javascript.jscomp.ClosurePrimitiveErrors.INVALID_GET_NA
 import static com.google.javascript.jscomp.ClosureRewriteModule.ILLEGAL_MODULE_RENAMING_CONFLICT;
 import static com.google.javascript.jscomp.ClosureRewriteModule.IMPORT_INLINING_SHADOWS_VAR;
 import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_EXPORT_COMPUTED_PROPERTY;
-import static com.google.javascript.jscomp.ClosureRewriteModule.INVALID_GET_ALIAS;
 import static com.google.javascript.jscomp.ClosureRewriteModule.LOAD_MODULE_FN_MISSING_RETURN;
 import static com.google.javascript.jscomp.modules.ModuleMapCreator.DOES_NOT_HAVE_EXPORT_WITH_DETAILS;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
@@ -1550,6 +1549,24 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   }
 
   @Test
+  public void testAliasedGoogModuleGetInGoogProvide() {
+    test(
+        srcs(
+            "goog.module('a.b.c.D');",
+            lines(
+                "goog.provide('x.y.z');",
+                "goog.require('a.b.c.D');",
+                "x.y.z = goog.module.get('a.b.c.D');",
+                "")),
+        expected(
+            "/** @const */ var module$exports$a$b$c$D = {};",
+            lines(
+                "goog.provide('x.y.z');", //
+                "x.y.z = module$exports$a$b$c$D;",
+                "")));
+  }
+
+  @Test
   public void testInvalidGoogForwardDeclareParameter() {
     // Wrong parameter count.
     testError(
@@ -1568,28 +1585,6 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   }
 
   @Test
-  public void testInvalidGoogModuleGetAlias() {
-    testError(
-        srcs("goog.provide('g');", lines("goog.module('a');", "x = goog.module.get('g');")),
-        INVALID_GET_ALIAS);
-
-    testError(
-        srcs(
-            "goog.provide('g');",
-            lines("goog.module('a');", "var x;", "x = goog.module.get('g');")),
-        INVALID_GET_ALIAS);
-
-    testError(
-        srcs(
-            "goog.provide('g'); goog.provide('z');",
-            lines(
-                "goog.module('a');",
-                "var x = goog.forwardDeclare('z');",
-                "x = goog.module.get('g');")),
-        INVALID_GET_ALIAS);
-  }
-
-  @Test
   public void testInvalidGoogModuleGet1() {
     testError(lines("function f() {", "  goog.module.get(a);", "}"), INVALID_GET_NAMESPACE);
   }
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 014ab93..1838479 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -51,7 +51,6 @@ public final class CodePrinterTest extends CodePrinterTestBase {
 
   @Test
   public void testTrailingCommaInArrayAndObjectWithPrettyPrint() {
-    languageMode = LanguageMode.ECMASCRIPT_NEXT_IN;
     assertPrettyPrintSame("({a:1, b:2,});\n");
     assertPrettyPrintSame("[1, 2, 3,];\n");
     // An array starting with a hole is printed ideally but this is very rare.
@@ -60,7 +59,6 @@ public final class CodePrinterTest extends CodePrinterTestBase {
 
   @Test
   public void testTrailingCommaInArrayAndObjectWithoutPrettyPrint() {
-    languageMode = LanguageMode.ECMASCRIPT_NEXT_IN;
     assertPrint("({a:1, b:2,})", "({a:1,b:2})");
     assertPrint("[1, 2, 3,]", "[1,2,3]");
 
@@ -931,10 +929,10 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   public void testForAwaitOf() {
     languageMode = LanguageMode.ECMASCRIPT_NEXT;
 
-    assertPrintSame("for await(a of b)c");
-    assertPrintSame("for await(var a of b)c");
-    assertPrintSame("for await(var a of b=c)d");
-    assertPrintSame("for await(var a of(b,c))d");
+    assertPrintSame("async()=>{for await(a of b)c}");
+    assertPrintSame("async()=>{for await(var a of b)c}");
+    assertPrintSame("async()=>{for await(var a of b=c)d}");
+    assertPrintSame("async()=>{for await(var a of(b,c))d}");
   }
 
   // In pretty-print mode, make sure there is a space before and after the 'of' in a for/of loop.
@@ -942,9 +940,9 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   public void testForAwaitOfPretty() {
     languageMode = LanguageMode.ECMASCRIPT_NEXT;
 
-    assertPrettyPrintSame("for await ([x, y] of b) {\n  c;\n}\n");
-    assertPrettyPrintSame("for await (x of [[1, 2]]) {\n  c;\n}\n");
-    assertPrettyPrintSame("for await ([x, y] of [[1, 2]]) {\n  c;\n}\n");
+    assertPrettyPrintSame("async() => {\n  for await ([x, y] of b) {\n    c;\n  }\n};\n");
+    assertPrettyPrintSame("async() => {\n  for await (x of [[1, 2]]) {\n    c;\n  }\n};\n");
+    assertPrettyPrintSame("async() => {\n  for await ([x, y] of [[1, 2]]) {\n    c;\n  }\n};\n");
   }
 
   @Test
@@ -953,7 +951,7 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("for(let a in b)c");
     assertPrintSame("for(let a of b)c");
     languageMode = LanguageMode.ECMASCRIPT_NEXT;
-    assertPrintSame("for await(let a of b)c");
+    assertPrintSame("async()=>{for await(let a of b)c}");
   }
 
   @Test
@@ -963,7 +961,7 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("for(const a of b)c");
 
     languageMode = LanguageMode.ECMASCRIPT_NEXT;
-    assertPrintSame("for await(const a of b)c");
+    assertPrintSame("async()=>{for await(const a of b)c}");
   }
 
   @Test
@@ -1959,6 +1957,95 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   }
 
   @Test
+  public void testNonJSDocCommentsPrinted_endOfFile_lineComment() {
+    preserveNonJSDocComments = true;
+    assertPrettyPrint(
+        lines(
+            "function f1() {}", //
+            "if (true) {",
+            "// first",
+            "f1();",
+            "}",
+            "// second"),
+        lines(
+            "function f1() {\n}", //
+            "if (true) {",
+            "  // first",
+            "  f1();",
+            "}",
+            " // second\n"));
+  }
+
+  @Test
+  public void testNonJSDocCommentsPrinted_endOfFile_blockComment() {
+    preserveNonJSDocComments = true;
+    assertPrettyPrint(
+        lines(
+            "function f1() {}", //
+            "if (true) {",
+            "// first",
+            "f1();",
+            "/* second */",
+            "}"),
+        lines(
+            "function f1() {\n}", //
+            "if (true) {",
+            "  // first",
+            "  f1();",
+            "}",
+            // The comment `/* second */` does not have an AST node to attach to
+            // that "starts" after it (the `if(true) {..}` block starts before the comment).
+            // Hence the comment gets attached to the SCRIPT node as a trailing comment and gets
+            // printed at the end.
+            " /* second */\n"));
+  }
+
+  @Test
+  public void testNonJSDocCommentsPrinted_endOfFile_manyMixedComments() {
+    preserveNonJSDocComments = true;
+    assertPrettyPrint(
+        lines(
+            "function f1() {}", //
+            "if (true) {",
+            "// first",
+            "f1();",
+            "// second",
+            "/* third */",
+            "// fourth",
+            "}"),
+        lines(
+            "function f1() {\n}", //
+            "if (true) {",
+            "  // first",
+            "  f1();",
+            "}",
+            " // second",
+            "/* third */",
+            "// fourth\n"));
+  }
+
+  @Test
+  public void testNonJSDocCommentsPrinted_lastTrailing() {
+    preserveNonJSDocComments = true;
+    assertPrettyPrint(
+        lines(
+            "function f1() {}", //
+            "if (true) {",
+            "// first",
+            "f1(); // second ",
+            "}"),
+        lines(
+            "function f1() {\n}", //
+            "if (true) {",
+            "  // first",
+            "  f1();",
+            "}",
+            // This is not ideal. Ideally the last comment `// second` attaches as a trailing
+            // comment of the `f1()` call.
+            " // second\n"));
+  }
+
+  @Test
   public void testNonJSDocCommentsPrinted_nonTrailing_lineComment() {
     preserveNonJSDocComments = true;
     assertPrettyPrint("// testComment\nfunction Foo(){}", "// testComment\nfunction Foo() {\n}\n");
@@ -2259,13 +2346,13 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintNumber("1E3", 1000);
     assertPrintNumber("1E4", 10000);
     assertPrintNumber("1E5", 100000);
-    assertPrintNumber("1E18", 1000000000000000000L);
+    assertPrintNumber("1E18", 1000000000000000000d);
     assertPrintNumber("1E5", 100000.0);
     assertPrintNumber("100000.1", 100000.1);
 
     assertPrintNumber("1E-6", 0.000001);
-    assertPrintNumber("0x38d7ea4c68001", 0x38d7ea4c68001L);
-    assertPrintNumber("0x7fffffffffffffff", 0x7fffffffffffffffL);
+    assertPrintNumber("0x38d7ea4c68001", 0x38d7ea4c68001p0d);
+    assertPrintNumber("0x7fffffffffffffff", 0x7fffffffffffffffp0d);
 
     assertPrintNumber(".01", 0.01);
     assertPrintNumber("1.01", 1.01);
@@ -2551,6 +2638,11 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   }
 
   @Test
+  public void testIjsWithProvideAlreadyProvided() {
+    assertPrettyPrintSame("/** @provideAlreadyProvided */ \ngoog.provide(\"a.b.c\");\n");
+  }
+
+  @Test
   public void testArrayLiteral() {
     assertPrint("var x = [,];", "var x=[,]");
     assertPrint("var x = [,,];", "var x=[,,]");
@@ -2796,8 +2888,6 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrint("/\\h/", "/h/");
     assertPrint("/\\i/", "/i/");
     assertPrint("/\\¡/", "/\\u00a1/");
-
-
   }
 
   @Test
@@ -3741,14 +3831,14 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             + "/**\n"
             + " * @param {ScopedType} obj\n"
             + " */\n"
-            + "var fn = /**\n"
+            + "var $jscomp$scope$3556498$1$fn = /**\n"
             + " * @param {ScopedType} obj\n"
             + " */\n"
             + "function(obj) {\n"
             + "  alert(STR);\n"
             + "  alert(Quux.someProperty);\n"
             + "};\n"
-            + "var STR = '3';\n";
+            + "var $jscomp$scope$3556498$0$STR = '3';\n";
 
     CompilerOptions compilerOptions = new CompilerOptions();
     compilerOptions.setChecksOnly(true);
@@ -3873,6 +3963,13 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             ""));
   }
 
+  @Test
+  public void testNonJSDocCommentsPrinted_getProp() {
+    preserveNonJSDocComments = true;
+    // TODO(b/228156705): Fix comment printing properly for GETPROP.
+    assertPrettyPrint("a.// testComment\nb", "// testComment\na.b;\n");
+  }
+
   private void checkWithOriginalName(
       String code, String expectedCode, CompilerOptions compilerOptions) {
     compilerOptions.setCheckSymbols(true);
diff --git a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java
index 8ed2056..74b121b 100644
--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java
+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java
@@ -216,8 +216,8 @@ public final class CombinedCompilerPassTest {
    */
   private static class ScopeRecordingCallback implements ScopedCallback {
 
-    Set<Node> visitedScopes = new HashSet<>();
-    Set<String> ignoring = new HashSet<>();
+    final Set<Node> visitedScopes = new HashSet<>();
+    final Set<String> ignoring = new HashSet<>();
 
     void ignore(String name) {
       ignoring.add(name);
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 1bca87d..ca66449 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -209,27 +209,30 @@ public final class CommandLineRunnerTest {
             srcFile.toString());
 
     // Run the compiler to generate the stage 1 save file
-    CommandLineRunner runner =
-        new CommandLineRunner(
-            createStringArray(commonFlags, "--save_stage1_to_file", stage1Save.toString()));
+    final ImmutableList<String> stage1Flags =
+        createStringList(
+            commonFlags, new String[] {"--save_stage1_to_file", stage1Save.toString()});
+    verifyFlagsAreIncompatibleWithChecksOnly(stage1Flags);
+    CommandLineRunner runner = new CommandLineRunner(stringListToArray(stage1Flags));
     assertThat(runner.doRun()).isEqualTo(0);
 
     assertThat(runner.getCompiler().toSource())
-        .isEqualTo(
-            "var __JSC_LOCALE_DATA__=[];"
-                + "const MSG_HELLO=goog.getMsg(\"hello\");console.log(MSG_HELLO);");
+        .isEqualTo("const MSG_HELLO=goog.getMsg(\"hello\");console.log(MSG_HELLO);");
 
     // Create a path for the stage 2 output
     File stage2Save = new File(testDir, "stage2.save");
     // run the compiler to generate the stage 2 save file
-    runner =
-        new CommandLineRunner(
-            createStringArray(
-                commonFlags,
-                "--restore_stage1_from_file",
-                stage1Save.toString(),
-                "--save_stage2_to_file",
-                stage2Save.toString()));
+    final ImmutableList<String> stage2Flags =
+        createStringList(
+            commonFlags,
+            new String[] {
+              "--restore_stage1_from_file",
+              stage1Save.toString(),
+              "--save_stage2_to_file",
+              stage2Save.toString()
+            });
+    verifyFlagsAreIncompatibleWithChecksOnly(stage2Flags);
+    runner = new CommandLineRunner(stringListToArray(stage2Flags));
     assertThat(runner.doRun()).isEqualTo(0);
 
     // During stage 2 the message is wrapped in a function call to protect it from mangling by
@@ -237,7 +240,6 @@ public final class CommandLineRunnerTest {
     assertThat(runner.getCompiler().toSource())
         .isEqualTo(
             concatStrings(
-                "var __JSC_LOCALE_DATA__=[];",
                 "console.log(",
                 "__jscomp_define_msg__({\"key\":\"MSG_HELLO\",\"msg_text\":\"hello\"})",
                 ");"));
@@ -246,14 +248,17 @@ public final class CommandLineRunnerTest {
     File compiledFile = new File(testDir, "compiled.js");
 
     // run the compiler to generate the final output
-    runner =
-        new CommandLineRunner(
-            createStringArray(
-                commonFlags,
-                "--restore_stage2_from_file",
-                stage2Save.toString(),
-                "--js_output_file",
-                compiledFile.toString()));
+    final ImmutableList<String> stage3Flags =
+        createStringList(
+            commonFlags,
+            new String[] {
+              "--restore_stage2_from_file",
+              stage2Save.toString(),
+              "--js_output_file",
+              compiledFile.toString()
+            });
+    verifyFlagsAreIncompatibleWithChecksOnly(stage3Flags);
+    runner = new CommandLineRunner(stringListToArray(stage3Flags));
     assertThat(runner.doRun()).isEqualTo(0);
 
     // During stage 3 the message is actually replaced and the output written to the compiled
@@ -263,11 +268,26 @@ public final class CommandLineRunnerTest {
     assertThat(compiledJs).isEqualTo("console.log(\"hola\");\n");
   }
 
-  private String[] createStringArray(Iterable<String> someStrings, String... additionalStrings) {
-    ImmutableList.Builder<String> builder = ImmutableList.builder();
-    builder.addAll(someStrings);
-    builder.add(additionalStrings);
-    return builder.build().toArray(new String[] {});
+  /** The given flags should be incompatible with `--checks_only`. */
+  private void verifyFlagsAreIncompatibleWithChecksOnly(ImmutableList<String> flags) {
+    final String additionalFlag = "--checks_only";
+    verifyFlagConflictIsReported(flags, additionalFlag);
+  }
+
+  private void verifyFlagConflictIsReported(ImmutableList<String> flags, String additionalFlag) {
+    final ImmutableList<String> combinedFlags =
+        ImmutableList.<String>builder().addAll(flags).add(additionalFlag).build();
+    CommandLineRunner checksOnlyRunner = new CommandLineRunner(stringListToArray(combinedFlags));
+    assertThrows(FlagUsageException.class, () -> checksOnlyRunner.doRun());
+  }
+
+  private String[] stringListToArray(ImmutableList<String> stringList) {
+    return stringList.toArray(new String[] {});
+  }
+
+  private ImmutableList<String> createStringList(
+      Iterable<String> someStrings, String[] additionalStrings) {
+    return (ImmutableList.<String>builder().addAll(someStrings).add(additionalStrings)).build();
   }
 
   private void writeLinesToFile(File file, String... lines) throws IOException {
diff --git a/test/com/google/javascript/jscomp/CompilerTest.java b/test/com/google/javascript/jscomp/CompilerTest.java
index 5c26c5c..6777982 100644
--- a/test/com/google/javascript/jscomp/CompilerTest.java
+++ b/test/com/google/javascript/jscomp/CompilerTest.java
@@ -25,6 +25,8 @@ import static com.google.javascript.jscomp.testing.JSErrorSubject.assertError;
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.stream;
+import static java.util.stream.Collectors.joining;
 import static org.junit.Assert.fail;
 
 import com.google.common.base.Joiner;
@@ -64,8 +66,6 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -1235,7 +1235,7 @@ public final class CompilerTest {
 
     CompilerOptions options = new CompilerOptions();
     options.setAssumeForwardDeclaredForMissingTypes(true);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
     options.setCheckTypes(true);
     options.setStrictModeInput(true);
@@ -1312,7 +1312,7 @@ public final class CompilerTest {
   }
 
   private String concatStrings(String... strings) {
-    return Stream.of(strings).collect(Collectors.joining());
+    return stream(strings).collect(joining());
   }
 
   private void restoreCompilerState(Compiler compiler, byte[] stateAfterChecks)
@@ -2345,11 +2345,8 @@ public final class CompilerTest {
       compiler.saveState(byteArrayOutputStream);
       byteArrayOutputStream.close();
 
-      // NOTE: The AST is not expected to be used after serialization to the save file
-      // and it has been modified to transport the locale data to the next stage via
-      // `__JSC_LOCALE_DATA__`
-      assertThat(compiler.toSource(m1))
-          .isEqualTo("var __JSC_LOCALE_DATA__=[];goog.provide(\"a.b\");");
+      // NOTE: The AST is not expected to be used after serialization to the save file.
+      assertThat(compiler.toSource(m1)).isEqualTo("goog.provide(\"a.b\");");
 
       restoreCompilerState(compiler, byteArrayOutputStream.toByteArray());
 
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 51181b9..1b150a7 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -52,9 +52,8 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -152,6 +151,9 @@ public abstract class CompilerTestCase {
 
   private boolean polymerPass;
 
+  /** Whether ES module rewriting runs before the pass being tested. */
+  private boolean rewriteEsModulesEnabled;
+
   /** Whether the transpilation passes run before the pass being tested. */
   private boolean transpileEnabled;
 
@@ -220,9 +222,9 @@ public abstract class CompilerTestCase {
    */
   private boolean scriptFeatureValidationEnabled;
 
-  private final Set<DiagnosticType> ignoredWarnings = new HashSet<>();
+  private final Set<DiagnosticType> ignoredWarnings = new LinkedHashSet<>();
 
-  private final Map<String, String> webpackModulesById = new HashMap<>();
+  private final Map<String, String> webpackModulesById = new LinkedHashMap<>();
 
   /** Whether {@link #setUp} has run. */
   private boolean setUpRan = false;
@@ -599,7 +601,7 @@ public abstract class CompilerTestCase {
   protected CompilerTestCase(String externs) {
     this.defaultExternsInputs =
         ImmutableList.of(SourceFile.fromCode(GENERATED_EXTERNS_NAME, externs));
-    librariesToInject = new HashSet<>();
+    librariesToInject = new LinkedHashSet<>();
   }
 
   /** Constructs a test. Uses AST comparison and no externs. */
@@ -649,6 +651,7 @@ public abstract class CompilerTestCase {
     this.processCommonJsModules = false;
     this.rewriteClosureCode = false;
     this.runTypeCheckAfterProcessing = false;
+    this.rewriteEsModulesEnabled = false;
     this.transpileEnabled = false;
     this.typeCheckEnabled = false;
 
@@ -956,6 +959,12 @@ public abstract class CompilerTestCase {
     normalizeEnabled = false;
   }
 
+  /** Perform ES module transpilation before running the test pass. */
+  protected final void enableRewriteEsModules() {
+    checkState(this.setUpRan, "Attempted to configure before running setUp().");
+    rewriteEsModulesEnabled = true;
+  }
+
   /**
    * Run the PureFunctionIdentifier pass before running the test pass.
    *
@@ -1429,6 +1438,10 @@ public abstract class CompilerTestCase {
           recentChange.reset();
           transpileToEs5(compiler, externsRoot, mainRoot);
           hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();
+        } else if (rewriteEsModulesEnabled && i == 0) {
+          recentChange.reset();
+          rewriteEsModules(compiler, externsRoot, mainRoot);
+          hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();
         }
 
         final boolean injectLibrariesFromTypedAsts =
@@ -1717,9 +1730,10 @@ public abstract class CompilerTestCase {
     }
   }
 
-  private static void transpileToEs5(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
+  private static void rewriteEsModules(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
     List<PassFactory> factories = new ArrayList<>();
     CompilerOptions options = compiler.getOptions();
+
     GatherModuleMetadata gatherModuleMetadata =
         new GatherModuleMetadata(
             compiler, options.getProcessCommonJSModules(), options.moduleResolutionMode);
@@ -1740,7 +1754,18 @@ public abstract class CompilerTestCase {
             .build());
     TranspilationPasses.addEs6ModulePass(
         factories, new PreprocessorSymbolTable.CachedInstanceFactory());
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    for (PassFactory factory : factories) {
+      factory.create(compiler).process(externsRoot, codeRoot);
+    }
+  }
+
+  private static void transpileToEs5(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
+    rewriteEsModules(compiler, externsRoot, codeRoot);
+
+    List<PassFactory> factories = new ArrayList<>();
+    CompilerOptions options = compiler.getOptions();
+
+    options.setLanguageIn(LanguageMode.UNSUPPORTED);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     TranspilationPasses.addTranspilationRuntimeLibraries(factories, options);
     TranspilationPasses.addRewritePolyfillPass(factories);
diff --git a/test/com/google/javascript/jscomp/ConvertToDottedPropertiesTest.java b/test/com/google/javascript/jscomp/ConvertToDottedPropertiesTest.java
index c80c28b..eb69098 100644
--- a/test/com/google/javascript/jscomp/ConvertToDottedPropertiesTest.java
+++ b/test/com/google/javascript/jscomp/ConvertToDottedPropertiesTest.java
@@ -193,4 +193,19 @@ public final class ConvertToDottedPropertiesTest extends CompilerTestCase {
   public void testComputedPropertyWithDefaultValue() {
     test("const {['o']: o = 0} = {};", "const {o:o = 0} = {};");
   }
+
+  @Test
+  public void testContinueOptionalChaining() {
+    test("const opt1 = window?.a?.['b'];", "const opt1 = window?.a?.b;");
+
+    test("const opt2 = window?.a['b'];", "const opt2 = window?.a.b;");
+    test(
+        lines(
+            "const chain =",
+            "window['a'].x.y.b.x.y['c'].x.y?.d.x.y['e'].x.y",
+            "['f-f'].x.y?.['g-g'].x.y?.['h'].x.y['i'].x.y;"),
+        lines(
+            "const chain = window.a.x.y.b.x.y.c.x.y?.d.x.y.e.x.y",
+            "['f-f'].x.y?.['g-g'].x.y?.h.x.y.i.x.y;"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java b/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
index f43936a..e197ad6 100644
--- a/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
+++ b/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
@@ -940,7 +940,7 @@ public final class CrossChunkCodeMotionTest extends CompilerTestCase {
     testSame(
         srcs(
             JSChunkGraphBuilder.forChain()
-                .addChunk("var f = {'hi': 'mom', 'bye': goog.nullFunction};")
+                .addChunk("var f = {'hi': 'mom', 'bye': shared};")
                 .addChunk("var h = f;")
                 .build()));
   }
@@ -967,7 +967,7 @@ public final class CrossChunkCodeMotionTest extends CompilerTestCase {
     testSame(
         srcs(
             JSChunkGraphBuilder.forChain()
-                .addChunk("var f = ['hi', goog.nullFunction];")
+                .addChunk("var f = ['hi', shared];")
                 .addChunk("var h = f;")
                 .build()));
   }
@@ -994,7 +994,7 @@ public final class CrossChunkCodeMotionTest extends CompilerTestCase {
     testSame(
         srcs(
             JSChunkGraphBuilder.forChain()
-                .addChunk("var f = `hi ${goog.nullFunction()}`;")
+                .addChunk("var f = `hi ${shared()}`;")
                 .addChunk("var h = f;")
                 .build()));
   }
diff --git a/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java b/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
index 98faf9e..b648147 100644
--- a/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
+++ b/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
@@ -863,7 +863,7 @@ public final class CrossChunkMethodMotionTest extends CompilerTestCase {
                 .addChunk(
                     lines(
                         "function Foo() {}", //
-                        "Foo.prototype.baz = goog.nullFunction;"))
+                        "Foo.prototype.baz = shared;"))
                 .addChunk("(new Foo).baz()")
                 .build()));
 
@@ -873,7 +873,7 @@ public final class CrossChunkMethodMotionTest extends CompilerTestCase {
                 .addChunk(
                     lines(
                         "class Foo {}", //
-                        "Foo.prototype.baz = goog.nullFunction;"))
+                        "Foo.prototype.baz = shared;"))
                 .addChunk("(new Foo).baz()")
                 .build()));
   }
diff --git a/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java b/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
index f1456c7..c486d8d 100644
--- a/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
+++ b/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
@@ -190,6 +190,14 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
+            "var foo = function() {",
+            "  a.b.c = 20;",
+            "  doSomething().b.c = 25;",
+            "  a.b.c = 30;",
+            "}"));
+
+    testSame(
+        lines(
             "var foo = function() {", // to preserve newlines
             "  a.b.c = 20;",
             "  doSomething?.();",
diff --git a/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java b/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java
index 06e6253..636f626 100644
--- a/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/DefaultCodingConventionTest.java
@@ -145,11 +145,6 @@ public final class DefaultCodingConventionTest {
   }
 
   @Test
-  public void testInheritanceDetection10() {
-    assertNotClassDefining("goog.mixin(A.prototype, B.prototype);");
-  }
-
-  @Test
   public void testInheritanceDetection11() {
     assertDefinesClasses("$jscomp.inherits(A, B)", "A", "B");
   }
diff --git a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
index 311b284..3e60386 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
@@ -19,8 +19,11 @@ import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
+import com.google.common.collect.Iterables;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.StandardColors;
+import com.google.javascript.jscomp.testing.CodeSubTree;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import org.junit.Before;
@@ -63,7 +66,7 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
     enableTypeCheck();
     enableTypeInfoValidation();
     replaceTypesWithColors();
-    // TODO(b/211899097): enable multistage compilation
+    enableMultistageCompilation();
   }
 
   @Override
@@ -1347,8 +1350,14 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
 
     Node yieldFn = callNode.getFirstChild();
     Node jscompGeneratorContext = yieldFn.getFirstChild();
-    assertThat(jscompGeneratorContext.getColor().getDebugInfo().getCompositeTypename())
-        .contains("$jscomp.generator.Context");
+    Color generatorContext =
+        Iterables.getOnlyElement(
+            CodeSubTree.findFirstNode(
+                    getLastCompiler().getExternsRoot(),
+                    (n) -> n.matchesQualifiedName("$jscomp.generator.Context"))
+                .getColor()
+                .getInstanceColors());
+    assertThat(jscompGeneratorContext.getColor()).isEqualTo(generatorContext);
 
     // Check types on "1 + 2" are still present after transpilation
     Node yieldedValue = callNode.getSecondChild(); // 1 + 2
@@ -1415,12 +1424,17 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
     // $jscomp$generator$forin$0 = $jscomp$generator$context.forIn([]);
     Node assign = case1Node.getSecondChild().getFirstFirstChild();
     checkState(assign.isAssign(), assign);
-    assertThat(assign.getColor().getDebugInfo().getCompositeTypename())
-        .contains("$jscomp.generator.Context.PropertyIterator");
-    assertThat(assign.getFirstChild().getColor().getDebugInfo().getCompositeTypename())
-        .contains("$jscomp.generator.Context.PropertyIterator");
-    assertThat(assign.getSecondChild().getColor().getDebugInfo().getCompositeTypename())
-        .contains("$jscomp.generator.Context.PropertyIterator");
+
+    Color propertyIterator =
+        Iterables.getOnlyElement(
+            CodeSubTree.findFirstNode(
+                    getLastCompiler().getExternsRoot(),
+                    (n) -> n.matchesQualifiedName("$jscomp.generator.Context.PropertyIterator"))
+                .getColor()
+                .getInstanceColors());
+    assertThat(assign.getColor()).isEqualTo(propertyIterator);
+    assertThat(assign.getFirstChild().getColor()).isEqualTo(propertyIterator);
+    assertThat(assign.getSecondChild().getColor()).isEqualTo(propertyIterator);
 
     // if (!((i = $jscomp$generator$forin$0.getNext()) != null)) {
     Node case2Node = case1Node.getNext();
@@ -1458,8 +1472,15 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
     Node jscompGeneratorContext = jumpToEndFn.getFirstChild();
 
     // assertThat(jumpToEndCall.getJSType().toString()).isEqualTo("undefined");
-    assertThat(jscompGeneratorContext.getColor().getDebugInfo().getCompositeTypename())
-        .contains("$jscomp.generator.Context");
+
+    Color generatorContext =
+        Iterables.getOnlyElement(
+            CodeSubTree.findFirstNode(
+                    getLastCompiler().getExternsRoot(),
+                    (n) -> n.matchesQualifiedName("$jscomp.generator.Context"))
+                .getColor()
+                .getInstanceColors());
+    assertThat(jscompGeneratorContext.getColor()).isEqualTo(generatorContext);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
index 2625c21..262f83d 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
@@ -690,7 +690,7 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
   }
 
   @Test
-  public void testGoogRequireTypeForNonEs6LhsNonConst() {
+  public void testGoogRequireTypeForNonEs6LhsNonConst1() {
     testError(
         srcs(
             SourceFile.fromCode("es6.js", "export var x; goog.declareModuleId('es6');"),
@@ -698,7 +698,10 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
                 "closure.js",
                 lines("goog.module('my.module');", "var es6 = goog.requireType('es6');"))),
         error(REQUIRE_TYPE_FOR_ES6_SHOULD_BE_CONST));
+  }
 
+  @Test
+  public void testGoogRequireTypeForNonEs6LhsNonConst2() {
     testError(
         srcs(
             SourceFile.fromCode("es6.js", "export var x; goog.declareModuleId('es6');"),
diff --git a/test/com/google/javascript/jscomp/Es7RewriteExponentialOperatorTest.java b/test/com/google/javascript/jscomp/Es7RewriteExponentialOperatorTest.java
index 6ed2448..e79885a 100644
--- a/test/com/google/javascript/jscomp/Es7RewriteExponentialOperatorTest.java
+++ b/test/com/google/javascript/jscomp/Es7RewriteExponentialOperatorTest.java
@@ -35,7 +35,7 @@ public final class Es7RewriteExponentialOperatorTest extends CompilerTestCase {
     enableTypeInfoValidation();
     enableTypeCheck();
     replaceTypesWithColors();
-    // TODO(b/211899097): enable multistage compilation
+    enableMultistageCompilation();
   }
 
   public Es7RewriteExponentialOperatorTest() {
diff --git a/test/com/google/javascript/jscomp/ExternExportsPassTest.java b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
index 3f2dd7e..9dcebcf 100644
--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java
+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
@@ -20,6 +20,7 @@ import static com.google.common.truth.Truth.assertThat;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import java.util.function.Consumer;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -48,7 +49,7 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   @Override
   public CompilerOptions getOptions() {
     CompilerOptions options = super.getOptions();
-    options.externExportsPath = "externs.js";
+    options.setExternExportsPath("exports.js");
     // Check types so we can make sure our exported externs have type information.
     options.setCheckSymbols(true);
     return options;
@@ -814,8 +815,7 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   }
 
   @Test
-  public void exportTranspiledClass() {
-    enableTranspile();
+  public void exportClass() {
     compileAndCheck(
         lines(
             "var internalName;",
@@ -888,7 +888,8 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   }
 
   @Test
-  public void exportTranspiledClassWithoutTypeCheck() {
+  @Ignore("(b/141729691): this test fails, but unlikely to fix as this feature is deprecated")
+  public void exportClassWithoutTypeCheck() {
     // For now, skipping type checking should prevent generating
     // annotations of any kind, so, e.g., @constructor is not preserved.
     // This is probably not ideal, but since JSDocInfo for functions is attached
@@ -896,7 +897,6 @@ public final class ExternExportsPassTest extends CompilerTestCase {
     // is false), we don't really have a choice.
 
     disableTypeCheck();
-    enableTranspile();
 
     compileAndCheck(
         lines(
@@ -933,7 +933,6 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   // x.Y is present in the generated externs but lacks the @constructor annotation.
   @Test
   public void exportMethodButNotTheClass() {
-    enableTranspile();
     compileAndCheck(
         lines(
             "x.Y = class {",
@@ -1287,8 +1286,7 @@ public final class ExternExportsPassTest extends CompilerTestCase {
    * initializer for prototype because every namespace has one automatically.
    */
   @Test
-  public void exportDontEmitPrototypePathPrefixForTranspiledClassMethod() {
-    enableTranspile();
+  public void exportDontEmitPrototypePathPrefixForClassMethod() {
     compileAndCheck(
         lines(
             "var Foo = class {",
@@ -1321,8 +1319,7 @@ public final class ExternExportsPassTest extends CompilerTestCase {
    * exported functions and the client uses them correctly.
    */
   @Test
-  public void useExportsAsExternsWithTranspiledClass() {
-    enableTranspile();
+  public void useExportsAsExternsWithClass() {
     String librarySource =
         lines(
             "var InternalName = class {",
diff --git a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
index b1a267c..c3854cb 100644
--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java
@@ -21,10 +21,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit tests for {@link FlowSensitiveInlineVariables}.
- *
- */
+/** Unit tests for {@link FlowSensitiveInlineVariables}. */
 @RunWith(JUnit4.class)
 public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
@@ -91,8 +88,9 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testSimpleForIn() {
-    inline("var a,b,x = a in b; x",
-           "var a,b,x; a in b");
+    inline(
+        "var a,b,x = a in b; x", //
+        "var a,b,x;  a in b;  ");
     noInline("var a, b; var x = a in b; print(1); x");
     noInline("var a,b,x = a in b; delete a[b]; x");
   }
@@ -125,7 +123,9 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testAssignmentBeforeDefinition() {
-    inline("x = 1; var x = 0; print(x)","x = 1; var x; print(0)" );
+    inline(
+        "x = 1; var x = 0; print(x)", //
+        "x = 1; var x    ; print(0)");
   }
 
   @Test
@@ -174,62 +174,68 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   @Test
   public void testDoNotInlineCatchExpression1() {
     noInline(
-        "var a;\n" +
-        "try {\n" +
-        "  throw Error(\"\");\n" +
-        "}catch(err) {" +
-        "   a = err;\n" +
-        "}\n" +
-        "return a.stack\n");
+        lines(
+            "var a;",
+            "try {",
+            "  throw Error(\"\");",
+            "}catch(err) {",
+            "   a = err;",
+            "}",
+            "return a.stack"));
   }
 
   @Test
   public void testDoNotInlineCatchExpression1a() {
     noInline(
-        "var a;\n" +
-        "try {\n" +
-        "  throw Error(\"\");\n" +
-        "}catch(err) {" +
-        "   a = err + 1;\n" +
-        "}\n" +
-        "return a.stack\n");
+        lines(
+            "var a;",
+            "try {",
+            "  throw Error(\"\");",
+            "} catch(err) {",
+            "   a = err + 1;",
+            "}",
+            "return a.stack"));
   }
 
   @Test
   public void testDoNotInlineCatchExpression2() {
     noInline(
-        "var a;\n" +
-        "try {\n" +
-        "  if (x) {throw Error(\"\");}\n" +
-        "}catch(err) {" +
-        "   a = err;\n" +
-        "}\n" +
-        "return a.stack\n");
+        lines(
+            "var a;",
+            "try {",
+            "  if (x) {throw Error(\"\");}",
+            "} catch(err) {",
+            "   a = err;",
+            "}",
+            "return a.stack"));
   }
 
   @Test
   public void testDoNotInlineCatchExpression3() {
     noInline(
-        "var a;\n" +
-        "try {\n" +
-        "  throw Error(\"\");\n" +
-        "} catch(err) {" +
-        "  err = x;\n" +
-        "  a = err;\n" +
-        "}\n" +
-        "return a.stack\n");
+        lines(
+            "var a;",
+            "try {",
+            "  throw Error(\"\");",
+            "} catch(err) {",
+            "  err = x;",
+            "  a = err;",
+            "}",
+            "return a.stack"));
   }
 
   @Test
   public void testDoNotInlineCatchExpression4() {
     // Note: it is valid to inline "x" here but we currently don't.
     noInline(
-        "try {\n" +
-        " stuff();\n" +
-        "} catch (e) {\n" +
-        " x = e;\n" +
-        " print(x);\n" +
-        "}");
+        lines(
+            "", //
+            "try {",
+            "  stuff();",
+            "} catch (e) {",
+            "  x = e;",
+            "  print(x);",
+            "}"));
   }
 
   @Test
@@ -239,20 +245,21 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineSameVariableInStraightLine() {
-    inline("var x; x = 1; print(x); x = 2; print(x)",
-        "var x; print(1); print(2)");
+    inline(
+        "var x; x = 1; print(x); x = 2; print(x)", //
+        "var x;        print(1);        print(2)");
   }
 
   @Test
   public void testInlineInDifferentPaths() {
-    inline("var x; if (print) {x = 1; print(x)} else {x = 2; print(x)}",
-        "var x; if (print) {print(1)} else {print(2)}");
+    inline(
+        "var x; if (print) {x = 1; print(x)} else {x = 2; print(x)}",
+        "var x; if (print) {       print(1)} else {       print(2)}");
   }
 
   @Test
   public void testNoInlineInMergedPath() {
-    noInline(
-        "var x,y;x = 1;while(y) { if(y){ print(x) } else { x = 1 } } print(x)");
+    noInline("var x,y;x = 1;while(y) { if(y){ print(x) } else { x = 1 } } print(x)");
   }
 
   @Test
@@ -273,8 +280,9 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineExpressions3() {
-    inline("var a,b,x; x=a+b; x=a-b ; print(x)",
-           "var a,b,x; x=a+b; print(a-b)");
+    inline(
+        "var a,b,x; x=a+b; x=a-b; print(  x)", //
+        "var a,b,x; x=a+b;        print(a-b)");
   }
 
   @Test
@@ -308,20 +316,16 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   public void testInlineExpression8() {
     // The same variable inlined twice.
     inline(
-        "var a,b;" +
-        "var x = a + b; print(x);      x = a - b; print(x)",
-        "var a,b;" +
-        "var x;         print(a + b);             print(a - b)");
+        "var a,b; var x = a + b; print(    x); x = a - b; print(    x)",
+        "var a,b; var x        ; print(a + b);            print(a - b)");
   }
 
   @Test
   public void testInlineExpression9() {
     // Check for actual control flow sensitivity.
     inline(
-        "var a,b;" +
-        "var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)",
-        "var a,b;" +
-        "var x; if (g) {           print(a + b)}             print(a - b)");
+        "var a,b; var x; if (g) { x= a + b; print(    x)}  x = a - b; print(    x)",
+        "var a,b; var x; if (g) {           print(a + b)}             print(a - b)");
   }
 
   @Test
@@ -345,21 +349,23 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineExpressions13() {
-    inline("var a = 1, b = 2;" +
-           "var x = a;" +
-           "var y = b;" +
-           "var z = x + y;" +
-           "var i = z;" +
-           "var j = z + y;" +
-           "var k = i;",
-
-           "var a, b;" +
-           "var x;" +
-           "var y = 2;" +
-           "var z = 1 + y;" +
-           "var i;" +
-           "var j = z + y;" +
-           "var k = z;");
+    inline(
+        lines(
+            "var a = 1, b = 2;",
+            "var x = a;",
+            "var y = b;",
+            "var z = x + y;",
+            "var i = z;",
+            "var j = z + y;",
+            "var k = i;"),
+        lines(
+            "var a, b;",
+            "var x;",
+            "var y = 2;",
+            "var z = 1 + y;",
+            "var i;",
+            "var j = z + y;",
+            "var k = z;"));
   }
 
   @Test
@@ -389,8 +395,9 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testShadowedVariableInnerFunction() {
-    inline("var x = 1; print(x) || (function() {  var x; x = 1; print(x)})()",
-        "var x; print(1) || (function() {  var x; print(1)})()");
+    inline(
+        "var x = 1; print(x) || (function() {  var x; x = 1; print(x)})()",
+        "var x    ; print(1) || (function() {  var x;        print(1)})()");
   }
 
   @Test
@@ -451,16 +458,27 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   @Test
   public void testInlineConstructorCallsIntoLoop() {
     // Don't inline construction into loops.
-    noInline("var x = new Iterator();" +
-             "for(i = 0; i < 10; i++) {j = x.next()}");
+    noInline(
+        lines(
+            "", //
+            "var x = new Iterator();",
+            "for(i = 0; i < 10; i++) {",
+            "  j = x.next();",
+            "}",
+            ""));
   }
 
   @Test
   public void testRemoveWithLabels() {
-    inline("var x = 1; L: x = 2; print(x)", "var x = 1; L:{} print(2)");
-    inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; L:M:{} print(2)");
-    inline("var x = 1; L: M: N: x = 2; print(x)",
-           "var x = 1; L:M:N:{} print(2)");
+    inline(
+        "var x = 1; L: x = 2; print(x)", //
+        "var x = 1; L: {    } print(2)");
+    inline(
+        "var x = 1; L: M: x = 2; print(x)", //
+        "var x = 1; L: M: {    } print(2)");
+    inline(
+        "var x = 1; L: M: N: x = 2; print(x)", //
+        "var x = 1; L: M: N: {    } print(2)");
   }
 
   @Test
@@ -470,7 +488,7 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
     //
     // noSFX must be both const and pure in order to inline it.
     noInline("var y; var x = noSFX(y); print(x)");
-    //inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))");
+    // inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))");
   }
 
   @Test
@@ -508,8 +526,16 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
     // the definition of noSFX. We should be able to mark noSFX as const
     // in some way.
     noInline(
-        "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)");
-    //inline(
+        lines(
+            "", //
+            "var y;",
+            "var x = noSFX(y),",
+            "z = noSFX();",
+            "noSFX();",
+            "noSFX(),",
+            "print(x)",
+            ""));
+    // inline(
     //    "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)",
     //    "var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))");
   }
@@ -527,9 +553,63 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineIfNameIsLeftSideOfAssign() {
-    inline("var x = 1; x = print(x) + 1", "var x; x = print(1) + 1");
-    inline("var x = 1; L: x = x + 2", "var x; L: x = 1 + 2");
-    inline("var x = 1; x = (x = x + 1)", "var x; x = (x = 1 + 1)");
+    inline(
+        "var x = 1; x = print(x) + 1", //
+        "var x    ; x = print(1) + 1");
+    inline(
+        "var x = 1; L: x = x + 2", //
+        "var x    ; L: x = 1 + 2");
+    inline(
+        "var x = 1; x = (x = x + 1)", //
+        "var x    ; x = (x = 1 + 1)");
+
+    inline(
+        lines(
+            "", //
+            // Create a block scope within the function
+            "{",
+            "  const C1 = 1;",
+            "  const C2 = 2;",
+            // `var` gives `x` a larger scope than `C1`
+            "  var x = C1;",
+            "  x = x == C1 ? C1 * 2 : C2 * 2;",
+            "}",
+            // `x` still exists here
+            "console.log(x);",
+            ""),
+        lines(
+            "", //
+            "{",
+            "  const C1 = 1;",
+            "  const C2 = undefined;", // C2 was inlined
+            "  var x = C1;",
+            "  x = x == C1 ? C1 * 2 : 2 * 2;",
+            "}",
+            // Inlining `C1` to replace `x` here would not work, since `C1` is out of scope here.
+            "console.log(x);",
+            ""));
+
+    inline(
+        lines(
+            "", //
+            // Create a block scope within the function
+            "{",
+            "  const C1 = 1;",
+            "  const C2 = 2;",
+            // `let` gives `x` the same scope as `C1`
+            "  let x = C1;",
+            "  x = x == C1 ? C1 * 2 : C2 * 2;",
+            "}",
+            ""),
+        lines(
+            "", //
+            "{",
+            "  const C1 = 1;",
+            "  const C2 = undefined;", // C2 was inlined
+            "  let x;", // x was inlined
+            "  x = C1 == C1 ? C1 * 2 : 2 * 2;",
+            "}",
+            ""));
 
     noInline("var x = 1; x = (x = (x = 10) + x)");
     noInline("var x = 1; x = (f(x) + (x = 10) + x);");
@@ -542,25 +622,44 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
     testSame("function _func(x) { print(x) }");
     testSame("function _func(x,y) { if(y) { x = 1 }; print(x) }");
 
-    test("function f(x, y) { x = 1; print(x) }",
-         "function f(x, y) { print(1) }");
+    test(
+        "function f(x, y) { x = 1; print(x) }", //
+        "function f(x, y) {        print(1) }");
 
-    test("function f(x, y) { if (y) { x = 1; print(x) }}",
-         "function f(x, y) { if (y) { print(1) }}");
+    test(
+        "function f(x, y) { if (y) { x = 1; print(x) }}",
+        "function f(x, y) { if (y) {        print(1) }}");
   }
 
   @Test
   public void testInvalidInlineArguments1() {
     testSame("function f(x, y) { x = 1; arguments[0] = 2; print(x) }");
-    testSame("function f(x, y) { x = 1; var z = arguments;" +
-        "z[0] = 2; z[1] = 3; print(x)}");
+    testSame(
+        lines(
+            "", //
+            "function f(x, y) {",
+            "  x = 1;",
+            "  var z = arguments;",
+            "  z[0] = 2;",
+            "  z[1] = 3;",
+            "  print(x);",
+            "}",
+            ""));
     testSame("function g(a){a[0]=2} function f(x){x=1;g(arguments);print(x)}");
   }
 
   @Test
   public void testInvalidInlineArguments2() {
-    testSame("function f(c) {var f = c; arguments[0] = this;" +
-             "f.apply(this, arguments); return this;}");
+    testSame(
+        lines(
+            "", //
+            "function f(c) {",
+            "  var f = c;",
+            "  arguments[0] = this;",
+            "  f.apply(this, arguments);",
+            "  return this;",
+            "}",
+            ""));
   }
 
   @Test
@@ -594,53 +693,57 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
     // sure the algorithm bails out appropriately if it sees
     // a var that it doesn't know about.
     inline(
-        "var x = ''; "
-        + "unknown.length < 2 && (unknown='0' + unknown);"
-        + "x = x + unknown; "
-        + "unknown.length < 3 && (unknown='0' + unknown);"
-        + "x = x + unknown; "
-        + "return x;",
-        "var x; "
-        + "unknown.length < 2 && (unknown='0' + unknown);"
-        + "x = '' + unknown; "
-        + "unknown.length < 3 && (unknown='0' + unknown);"
-        + "x = x + unknown; "
-        + "return x;");
+        lines(
+            "var x = ''; ",
+            "unknown.length < 2 && (unknown='0' + unknown);",
+            "x = x + unknown; ",
+            "unknown.length < 3 && (unknown='0' + unknown);",
+            "x = x + unknown; ",
+            "return x;"),
+        lines(
+            "var x; ",
+            "unknown.length < 2 && (unknown='0' + unknown);",
+            "x = '' + unknown; ",
+            "unknown.length < 3 && (unknown='0' + unknown);",
+            "x = x + unknown; ",
+            "return x;"));
   }
 
   @Test
   public void testIssue777() {
     test(
-        "function f(cmd, ta) {" +
-        "  var temp = cmd;" +
-        "  var temp2 = temp >> 2;" +
-        "  cmd = STACKTOP;" +
-        "  for (var src = temp2, dest = cmd >> 2, stop = src + 37;" +
-        "       src < stop;" +
-        "       src++, dest++) {" +
-        "    HEAP32[dest] = HEAP32[src];" +
-        "  }" +
-        "  temp = ta;" +
-        "  temp2 = temp >> 2;" +
-        "  ta = STACKTOP;" +
-        "  STACKTOP += 8;" +
-        "  HEAP32[ta >> 2] = HEAP32[temp2];" +
-        "  HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];" +
-        "}",
-        "function f(cmd, ta){" +
-        "  var temp;" +
-        "  var temp2 = cmd >> 2;" +
-        "  cmd = STACKTOP;" +
-        "  var src = temp2;" +
-        "  var dest = cmd >> 2;" +
-        "  var stop = src + 37;" +
-        "  for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];" +
-        "  temp2 = ta >> 2;" +
-        "  ta = STACKTOP;" +
-        "  STACKTOP += 8;" +
-        "  HEAP32[ta>>2] = HEAP32[temp2];" +
-        "  HEAP32[ta+4>>2] = HEAP32[temp2+1];" +
-        "}");
+        lines(
+            "function f(cmd, ta) {",
+            "  var temp = cmd;",
+            "  var temp2 = temp >> 2;",
+            "  cmd = STACKTOP;",
+            "  for (var src = temp2, dest = cmd >> 2, stop = src + 37;",
+            "       src < stop;",
+            "       src++, dest++) {",
+            "    HEAP32[dest] = HEAP32[src];",
+            "  }",
+            "  temp = ta;",
+            "  temp2 = temp >> 2;",
+            "  ta = STACKTOP;",
+            "  STACKTOP += 8;",
+            "  HEAP32[ta >> 2] = HEAP32[temp2];",
+            "  HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];",
+            "}"),
+        lines(
+            "function f(cmd, ta){",
+            "  var temp;",
+            "  var temp2 = cmd >> 2;",
+            "  cmd = STACKTOP;",
+            "  var src = temp2;",
+            "  var dest = cmd >> 2;",
+            "  var stop = src + 37;",
+            "  for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];",
+            "  temp2 = ta >> 2;",
+            "  ta = STACKTOP;",
+            "  STACKTOP += 8;",
+            "  HEAP32[ta>>2] = HEAP32[temp2];",
+            "  HEAP32[ta+4>>2] = HEAP32[temp2+1];",
+            "}"));
   }
 
   @Test
@@ -660,21 +763,23 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   @Test
   public void testIssue794a() {
     noInline(
-        "var x = 1; " +
-        "try { x += someFunction(); } catch (e) {}" +
-        "x += 1;" +
-        "try { x += someFunction(); } catch (e) {}" +
-        "return x;");
+        lines(
+            "var x = 1; ",
+            "try { x += someFunction(); } catch (e) {}",
+            "x += 1;",
+            "try { x += someFunction(); } catch (e) {}",
+            "return x;"));
   }
 
   @Test
   public void testIssue794b() {
     noInline(
-        "var x = 1; " +
-        "try { x = x + someFunction(); } catch (e) {}" +
-        "x = x + 1;" +
-        "try { x = x + someFunction(); } catch (e) {}" +
-        "return x;");
+        lines(
+            "var x = 1; ",
+            "try { x = x + someFunction(); } catch (e) {}",
+            "x = x + 1;",
+            "try { x = x + someFunction(); } catch (e) {}",
+            "return x;"));
   }
 
   @Test
@@ -688,96 +793,105 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   // GitHub issue #250: https://github.com/google/closure-compiler/issues/250
   @Test
   public void testInlineStringConcat() {
-    test(lines(
-        "function f() {",
-        "  var x = '';",
-        "  x = x + '1';",
-        "  x = x + '2';",
-        "  x = x + '3';",
-        "  x = x + '4';",
-        "  x = x + '5';",
-        "  x = x + '6';",
-        "  x = x + '7';",
-        "  return x;",
-        "}"),
+    test(
+        lines(
+            "function f() {",
+            "  var x = '';",
+            "  x = x + '1';",
+            "  x = x + '2';",
+            "  x = x + '3';",
+            "  x = x + '4';",
+            "  x = x + '5';",
+            "  x = x + '6';",
+            "  x = x + '7';",
+            "  return x;",
+            "}"),
         "function f() { var x; return '' + '1' + '2' + '3' + '4' + '5' + '6' + '7'; }");
   }
 
   @Test
   public void testInlineInArrowFunctions() {
-    test("() => {var v; v = 1; return v;} ",
-        "() => {var v; return 1;}");
+    test(
+        "() => {var v; v = 1; return v;} ", //
+        "() => {var v       ; return 1;}");
 
-    test("(v) => {v = 1; return v;}",
-        "(v) => {return 1;}");
+    test(
+        "(v) => {v = 1; return v;}", //
+        "(v) => {       return 1;}");
   }
 
   @Test
   public void testInlineInClassMemberFunctions() {
     test(
         lines(
+            "", //
             "class C {",
             "  func() {",
             "    var x;",
             "    x = 1;",
             "    return x;",
             "  }",
-            "}"
-        ),
+            "}",
+            ""),
         lines(
+            "", //
             "class C {",
             "  func() {",
             "    var x;",
             "    return 1;",
             "  }",
-            "}"
-        )
-    );
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineLet() {
-    inline("let a = 1; print(a + 1)",
-         "let a; print(1 + 1)");
+    inline(
+        "let a = 1; print(a + 1)", //
+        "let a;     print(1 + 1)");
 
-    inline("let a; a = 1; print(a + 1)",
-        "let a; print(1 + 1)");
+    inline(
+        "let a; a = 1; print(a + 1)", //
+        "let a;        print(1 + 1)");
 
     noInline("let a = noSFX(); print(a)");
   }
 
   @Test
   public void testInlineConst() {
-    inline("const a = 1; print(a + 1)",
+    inline(
+        "const a = 1        ; print(a + 1)", //
         "const a = undefined; print(1 + 1)");
 
-    inline("const a = 1; const b = a; print(b + 1)",
+    inline(
+        "const a =         1; const b =         a; print(b + 1)",
         "const a = undefined; const b = undefined; print(1 + 1)");
 
     noInline("const a = noSFX(); print(a)");
-
   }
 
   @Test
   public void testSpecific() {
-    inline("let a = 1; print(a + 1)",
-        "let a; print(1 + 1)");
+    inline(
+        "let a = 1; print(a + 1)", //
+        "let a    ; print(1 + 1)");
   }
 
   @Test
   public void testBlockScoping() {
     inline(
         lines(
+            "", //
             "let a = 1",
             "print(a + 1);",
             "{",
             "  let b = 2;",
             "  print(b + 1);",
-            "}"
-        ),
+            "}"),
         lines(
+            "", //
             "let a;",
-            "print(1 + 1);",
+            "print(1 + 1);", //
             "{",
             "  let b;",
             "  print(2 + 1);",
@@ -785,36 +899,43 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
     inline(
         lines(
+            "", //
             "let a = 1",
             "{",
             "  let a = 2;",
             "  print(a + 1);",
             "}",
-            "print(a + 1);"
-        ),
+            "print(a + 1);",
+            ""),
         lines(
+            "", //
             "let a = 1",
             "{",
             "  let a;",
             "  print(2 + 1);",
             "}",
-            "print(a + 1);"));
+            "print(a + 1);",
+            ""));
 
     inline(
         lines(
+            "", //
             "let a = 1;",
             "  {let b;}",
-            "print(a)"
-        ),
+            "print(a)",
+            ""),
         lines(
+            "", //
             "let a;",
             "  {let b;}",
-            "print(1)"));
+            "print(1)",
+            ""));
 
     // This test fails to inline due to CheckPathsBetweenNodes analysis in the canInline function
     // in FlowSensitiveInlineVariables.
     noInline(
         lines(
+            "", //
             "let a = 1;",
             "{",
             "  let b;",
@@ -840,16 +961,16 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
     // test let/const shadowing of a var
     noInline(
         lines(
-        "var JSCompiler_inline_result;",
-        "var a = 0;",
-        "{",
-        "  let a = 1;",
-        "  if (3 < 4) {",
-        "    a = 2;",
-        "  }",
-        "  JSCompiler_inline_result = a;",
-        "}",
-        "alert(JSCompiler_inline_result);"));
+            "var JSCompiler_inline_result;",
+            "var a = 0;",
+            "{",
+            "  let a = 1;",
+            "  if (3 < 4) {",
+            "    a = 2;",
+            "  }",
+            "  JSCompiler_inline_result = a;",
+            "}",
+            "alert(JSCompiler_inline_result);"));
 
     noInline("{ let value = 1; var g = () => value; } return g;");
   }
@@ -858,18 +979,17 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   public void testInlineInGenerators() {
     test(
         lines(
+            "", //
             "function* f() {",
             "  var x = 1;",
             "  return x + 1;",
-            "}"
-        ),
+            "}"),
         lines(
+            "", //
             "function* f() {",
             "  var x;",
             "  return 1 + 1;",
-            "}"
-        )
-    );
+            "}"));
   }
 
   @Test
@@ -895,14 +1015,17 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testTemplateStrings() {
-    inline("var name = 'Foo'; `Hello ${name}`",
-        "var name; `Hello ${'Foo'}`");
+    inline(
+        "var name = 'Foo'; `Hello ${ name}`", //
+        "var name        ; `Hello ${'Foo'}`");
 
-    inline("var name = 'Foo'; var foo = name; `Hello ${foo}`",
-        "var name; var foo; `Hello ${'Foo'}`");
+    inline(
+        "var name = 'Foo'; var foo = name; `Hello ${ foo }`", //
+        "var name        ; var foo       ; `Hello ${'Foo'}`");
 
-    inline(" var age = 3; `Age: ${age}`",
-        "var age; `Age: ${3}`");
+    inline(
+        "var age = 3; `Age: ${age}`", //
+        "var age    ; `Age: ${  3}`");
   }
 
   @Test
@@ -1047,7 +1170,17 @@ public final class FlowSensitiveInlineVariablesTest extends CompilerTestCase {
   private void inline(String input, String expected) {
     test(
         externs(EXTERN_FUNCTIONS),
-        srcs("function _func() {" + input + "}"),
-        expected("function _func() {" + expected + "}"));
+        srcs(
+            lines(
+                "", //
+                "function _func() {",
+                input,
+                "}")),
+        expected(
+            lines(
+                "", //
+                "function _func() {",
+                expected,
+                "}")));
   }
 }
diff --git a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
index 8edfb5a..54d13a4 100644
--- a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
+++ b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
@@ -533,7 +533,7 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
 
   @Test
   public void testUsesGlobalClosureNoFunctionCall() {
-    testSame("var b = goog.nullFunction;");
+    testSame("var b = goog.isArray;");
     ModuleMetadata m = metadataMap().getModulesByPath().get("testcode");
     assertThat(m.usesClosure()).isTrue();
   }
diff --git a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
index 16df81f..bf17238 100644
--- a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
@@ -142,12 +142,6 @@ public final class GoogleCodingConventionTest {
   }
 
   @Test
-  public void testInheritanceDetection10() {
-    assertDefinesClasses("goog.mixin(A.prototype, B.prototype);",
-        "A", "B");
-  }
-
-  @Test
   public void testInheritanceDetectionPostCollapseProperties() {
     assertDefinesClasses("goog$inherits(A, B);", "A", "B");
     assertNotClassDefining("goog$inherits(A);");
diff --git a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
index 0bc63c6..ef5014d 100644
--- a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
@@ -2411,6 +2411,45 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testToStringValueOfPropertiesInObjectLiteral() {
+    // toString/valueOf are not collapsed because they are properties implicitly used as part of the
+    // JS language
+    testSame(
+        lines(
+            "let z = {",
+            "  toString() { return 'toString'; },",
+            "  valueOf() { return 'valueOf'; }",
+            "};",
+            "var zAsString = z + \"\";"));
+  }
+
+  @Test
+  public void testToStringValueOfNonMethodPropertiesInObjectLiteral() {
+    testSame(
+        lines(
+            "let z = {",
+            "  toString: function() { return 'a'; },",
+            "  valueOf: function() { return 3; },",
+            "};"));
+  }
+
+  @Test
+  public void testToStringValueOfPropertiesInObjectLiteralAssignmentDepth() {
+    test(
+        lines(
+            "var a = {}; a.b = {}; a.b.c = {};",
+            "a.b.c.d = {",
+            "  toString() { return 'a'; },",
+            "  valueOf: function() { return 3; },",
+            "};"),
+        lines(
+            "var a$b$c$d = {",
+            "  toString() { return 'a'; },",
+            "  valueOf: function() { return 3; },",
+            "};"));
+  }
+
+  @Test
   public void testLoopInAliasChainOfTypedefConstructorProperty() {
     test(
         lines(
diff --git a/test/com/google/javascript/jscomp/InlineFunctionsTest.java b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
index ba7e30b..8cd6376 100644
--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java
+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
@@ -123,6 +123,13 @@ public class InlineFunctionsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testInline_optChain_1() {
+    // Empty function, no params.
+    test("(function(){}).call?.(this)", "void 0;");
+    test("(function(){})?.call(this)", "void 0;");
+  }
+
+  @Test
   public void testInlineEmptyFunction2() {
     // Empty function, params with no side-effects.
     test("function foo(){}\n foo(1, new Date, function(){});", "void 0;");
diff --git a/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java b/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java
index a25531a..5a24b70 100644
--- a/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java
+++ b/test/com/google/javascript/jscomp/InlineObjectLiteralsTest.java
@@ -207,6 +207,122 @@ public final class InlineObjectLiteralsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testObject6_let() {
+    testLocal(
+        "for (let i = 0; i < 5; i++) { let a = {i:i,x:x}; f(a.i, a.x); }",
+        "for (let i = 0; i < 5; i++) {"
+            + "  var JSCompiler_object_inline_i_0=i;"
+            + "  var JSCompiler_object_inline_x_1=x;"
+            + "  f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)"
+            + "}");
+    testLocal(
+        "if (c) { var a = {i:i,x:x}; f(a.i, a.x); }",
+        "if (c) {"
+            + "  var JSCompiler_object_inline_i_0=i;"
+            + "  var JSCompiler_object_inline_x_1=x;"
+            + "  f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)"
+            + "}");
+  }
+
+  @Test
+  public void testObjectSwitch() {
+    testLocal(
+        "let x;"
+            + "switch (x) {"
+            + "  case 'h':"
+            + "    let a;"
+            + "    if (Math.random() > 0.5) {"
+            + "      a = {i:i,x:x};"
+            + "      f(a.i, a.x);"
+            + "      break;"
+            + "    }"
+            + "}",
+        "let x;"
+            + "var JSCompiler_object_inline_i_0;"
+            + "var JSCompiler_object_inline_x_1;"
+            + " switch (x) {"
+            + "   case 'h': "
+            + "    if (Math.random() > .5) {"
+            + "      JSCompiler_object_inline_i_0 = i, JSCompiler_object_inline_x_1 = x, true;"
+            + "      f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1);"
+            + "      break;"
+            + "    }"
+            + "}");
+    testLocal(
+        "let x;"
+            + " switch (x) {"
+            + "   case 'h':"
+            + "   case 'i':"
+            + "     let a;"
+            + "     if (true) {"
+            + "       a = {i:i,x:x};"
+            + "       f(a.i, a.x);"
+            + "     }"
+            + "     break;"
+            + "}",
+        "let x;"
+            + "var JSCompiler_object_inline_i_0;"
+            + "var JSCompiler_object_inline_x_1;"
+            + " switch (x) {"
+            + " case 'h':"
+            + " case 'i': "
+            + "  if (true) {"
+            + "    JSCompiler_object_inline_i_0 = i, JSCompiler_object_inline_x_1 = x, true;"
+            + "    f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1);"
+            + "  }"
+            + "break;"
+            + "}");
+    testLocal(
+        "let x;"
+            + "switch (x) {"
+            + "  case 'h':"
+            + "    let a;"
+            + "    if (Math.random() > 0.5) {"
+            + "      a = {i:i,x:x};"
+            + "      f(a.i, a.x);"
+            + "      break;"
+            + "    }"
+            + "}",
+        "let x;"
+            + "var JSCompiler_object_inline_i_0;"
+            + "var JSCompiler_object_inline_x_1;"
+            + " switch (x) {"
+            + " case 'h': "
+            + "  if (Math.random() > .5) {"
+            + "    JSCompiler_object_inline_i_0 = i, JSCompiler_object_inline_x_1 = x, true;"
+            + "    f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1);"
+            + "    break;"
+            + "  }"
+            + "}");
+    testLocal(
+        "let x;"
+            + "let z;"
+            + "switch (x) {"
+            + "  case 'h':"
+            + "    if (Math.random() > 0.5) {"
+            + "      z = {i:i,x:x};"
+            + "      f(z.i, z.x);"
+            + "    }"
+            + "  case 'i':"
+            + "    ({x:x} = f(z.i, z.x));"
+            + "    break;"
+            + "}",
+        "var JSCompiler_object_inline_i_0;"
+            + "var JSCompiler_object_inline_x_1;"
+            + "let x;"
+            + " switch (x) {"
+            + " case 'h': "
+            + "  if (Math.random() > .5) {"
+            + "    JSCompiler_object_inline_i_0 = i, JSCompiler_object_inline_x_1 = x, true;"
+            + "    f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1);"
+            + "  }"
+            + "  case 'i':"
+            + "    ({x:x} = f(JSCompiler_object_inline_i_0, JSCompiler_object_inline_x_1));"
+            + "    break;"
+            + "}");
+  }
+
+  @Test
   public void testObject7() {
     testLocal("var a = {x:x, y:f()}; g(a.x);",
       "var JSCompiler_object_inline_x_0=x;" +
diff --git a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
index ff11ee4..424cc95 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java
@@ -29,12 +29,9 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class InlineVariablesConstantsTest extends CompilerTestCase {
 
-  private boolean inlineAllStrings = false;
-
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
-    return new InlineVariables(
-        compiler, InlineVariables.Mode.CONSTANTS_ONLY, inlineAllStrings);
+    return new InlineVariables(compiler, InlineVariables.Mode.CONSTANTS_ONLY);
   }
 
   @Override
@@ -42,7 +39,6 @@ public final class InlineVariablesConstantsTest extends CompilerTestCase {
   public void setUp() throws Exception {
     super.setUp();
     enableNormalize();
-    inlineAllStrings = false;
   }
 
   @Test
@@ -58,11 +54,16 @@ public final class InlineVariablesConstantsTest extends CompilerTestCase {
     // Make sure that nothing explodes if there are undeclared variables.
     testSame("var x = AA;");
 
-    // Don't inline if it will make the output larger.
-    testSame("var AA = '1234567890'; foo(AA); foo(AA); foo(AA);");
+    // Inline even if it will make the output larger,
+    // because we expect on average to get more gains from the logic we can pre-compute
+    // than we lose from redundant strings.
+    // However, see also AliasStrings, which attempts to reduce this redundancy after we
+    // have already pre-computed all of the logic we can.
+    test(
+        "var AA = '1234567890'; foo(          AA); foo(          AA); foo(          AA);",
+        "                       foo('1234567890'); foo('1234567890'); foo('1234567890');");
 
-    test("var AA = '123456789012345';AA;",
-         "'123456789012345'");
+    test("var AA = '123456789012345';AA;", "'123456789012345'");
   }
 
   @Test
@@ -82,11 +83,30 @@ public final class InlineVariablesConstantsTest extends CompilerTestCase {
     test("/** @const */var aa; aa=1;", "1");
     testSame("/** @const */var aa;(function () {var y; aa=y})(); var z=aa");
 
-    // Don't inline if it will make the output larger.
-    testSame("/** @const */var aa = '1234567890'; foo(aa); foo(aa); foo(aa);");
-
-    test("/** @const */var aa = '123456789012345';aa;",
-         "'123456789012345'");
+    // Inline even if it will make the output larger,
+    // because we expect on average to get more gains from the logic we can pre-compute
+    // than we lose from redundant strings.
+    // However, see also AliasStrings, which attempts to reduce this redundancy after we
+    // have already pre-computed all of the logic we can.
+    test(
+        lines(
+            "", //
+            "/** @const */",
+            "var aa = '1234567890';",
+            "foo(aa);",
+            "foo(aa);",
+            "foo(aa);",
+            ""),
+        lines(
+            "", //
+            "",
+            "",
+            "foo('1234567890');",
+            "foo('1234567890');",
+            "foo('1234567890');",
+            ""));
+
+    test("/** @const */var aa = '123456789012345';aa;", "'123456789012345'");
   }
 
   @Test
@@ -95,46 +115,43 @@ public final class InlineVariablesConstantsTest extends CompilerTestCase {
     // run-time behavior of code (e.g. when y is true and x is false in the
     // example below). We inline them anyway because if the code author didn't
     // want one inlined, they could define it as a non-const variable instead.
-    test("if (x) var ABC = 2; if (y) f(ABC);",
-         "if (x); if (y) f(2);");
+    test("if (x) var ABC = 2; if (y) f(ABC);", "if (x); if (y) f(2);");
   }
 
   @Test
   public void testInlineConditionallyDefinedConstant2() {
-    test("if (x); else var ABC = 2; if (y) f(ABC);",
-         "if (x); else; if (y) f(2);");
+    test("if (x); else var ABC = 2; if (y) f(ABC);", "if (x); else; if (y) f(2);");
   }
 
   @Test
   public void testInlineConditionallyDefinedConstant3() {
-    test("if (x) { var ABC = 2; } if (y) { f(ABC); }",
-         "if (x) {} if (y) { f(2); }");
+    test("if (x) { var ABC = 2; } if (y) { f(ABC); }", "if (x) {} if (y) { f(2); }");
   }
 
   @Test
   public void testInlineDefinedConstant() {
     test(
-        "/**\n" +
-        " * @define {string}\n" +
-        " */\n" +
-        "var aa = '1234567890';\n" +
-        "foo(aa); foo(aa); foo(aa);",
+        "/**\n"
+            + " * @define {string}\n"
+            + " */\n"
+            + "var aa = '1234567890';\n"
+            + "foo(aa); foo(aa); foo(aa);",
         "foo('1234567890');foo('1234567890');foo('1234567890')");
 
     test(
-        "/**\n" +
-        " * @define {string}\n" +
-        " */\n" +
-        "var ABC = '1234567890';\n" +
-        "foo(ABC); foo(ABC); foo(ABC);",
+        "/**\n"
+            + " * @define {string}\n"
+            + " */\n"
+            + "var ABC = '1234567890';\n"
+            + "foo(ABC); foo(ABC); foo(ABC);",
         "foo('1234567890');foo('1234567890');foo('1234567890')");
   }
 
   @Test
   public void testInlineVariablesConstantsWithInlineAllStringsOn() {
-    inlineAllStrings = true;
-    test("var AA = '1234567890'; foo(AA); foo(AA); foo(AA);",
-         "foo('1234567890'); foo('1234567890'); foo('1234567890')");
+    test(
+        "var AA = '1234567890'; foo(AA); foo(AA); foo(AA);",
+        "foo('1234567890'); foo('1234567890'); foo('1234567890')");
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/InlineVariablesTest.java b/test/com/google/javascript/jscomp/InlineVariablesTest.java
index 4b40bda..bec59ad 100644
--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java
+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java
@@ -16,7 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import org.junit.After;
 import org.junit.Before;
@@ -26,12 +25,10 @@ import org.junit.runners.JUnit4;
 
 /**
  * Verifies that valid candidates for inlining are inlined, but that no dangerous inlining occurs.
- *
  */
 @RunWith(JUnit4.class)
 public final class InlineVariablesTest extends CompilerTestCase {
 
-  private boolean inlineAllStrings = false;
   private boolean inlineLocalsOnly = false;
 
   @Override
@@ -40,32 +37,97 @@ public final class InlineVariablesTest extends CompilerTestCase {
     super.setUp();
     enableNormalize();
     disableCompareJsDoc();
-  }
-
-  @Override
-  protected int getNumRepetitions() {
-    // TODO(b/33104006): remove this override.
-    return 2;
+    // NOTE: We are not enabling var checks here, so it is OK to use undeclared variables in
+    // these tests. They will be treated as if they were externs.
   }
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
     return new InlineVariables(
-        compiler,
-        (inlineLocalsOnly)
-            ? InlineVariables.Mode.LOCALS_ONLY
-            : InlineVariables.Mode.ALL,
-        inlineAllStrings);
+        compiler, inlineLocalsOnly ? InlineVariables.Mode.LOCALS_ONLY : InlineVariables.Mode.ALL);
   }
 
   @Override
   @After
   public void tearDown() {
-    inlineAllStrings = false;
     inlineLocalsOnly = false;
   }
 
   @Test
+  public void testArgAlias() {
+    // same scope
+    test(
+        lines(
+            "", //
+            "function foo(arg) {",
+            "  const argAlias = arg;",
+            "  const argAliasAlias = argAlias",
+            "  use(argAliasAlias);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function foo(arg) {",
+            "  use(arg);",
+            "}",
+            ""));
+    // nested scope
+    test(
+        lines(
+            "", //
+            "function foo(arg) {",
+            "  const argAlias = arg;",
+            "  {",
+            "    const argAliasAlias = argAlias",
+            "    use(argAliasAlias);",
+            "  }",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function foo(arg) {",
+            "  {",
+            "    use(arg);",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
+  public void testInlineExpressionUsingAlias() {
+    test(
+        lines(
+            "", //
+            "function foo(arg1, arg2) {",
+            "  const arg1Alias = arg1;",
+            "  const arg2Alias = arg2;",
+            // Create an inner scope to force analysis of `product` before the alias
+            // variables.
+            "  {",
+            "    const product = arg1Alias * arg2Alias;",
+            // Use `product` twice so if it gets inlined, it will have to create new
+            // references to the operands.
+            // Either the expression should not be inlined, or some effort will have
+            // to be made to avoid creating new references to `arg1Alias` and `arg2Alias`
+            // before they are considered for inlining themselves.
+            "    use(product);",
+            "    use(product);",
+            "  }",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function foo(arg1, arg2) {",
+            "  {",
+            "    const product = arg1 * arg2;",
+            "    use(product);",
+            "    use(product);",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
   public void testPassDoesntProduceInvalidCode1() {
     testSame(
         lines(
@@ -97,7 +159,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testPassDoesntProduceInvalidCode3() {
-   test(
+    test(
         lines(
             "function f(x = void 0) {",
             "  var z;",
@@ -110,8 +172,10 @@ public final class InlineVariablesTest extends CompilerTestCase {
             "}"),
         lines(
             "function f(x = void 0) {",
+            "",
             "  const y = {};",
             "  x && (y['x'] = x);",
+            "  y;",
             "  {",
             "    return y;",
             "  }",
@@ -127,7 +191,10 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testNoInlineAnnotation() {
-    testSame("/** @noinline */ var x = 1; var z = x;");
+    testSame("/** @noinline */ var x = 1; use(x);");
+    test(
+        "/** @noinline */ var x = 1; use(x); var z = x; use(z);", //
+        "/** @noinline */ var x = 1; use(x);            use(x);");
   }
 
   @Test
@@ -137,8 +204,14 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testNoInlineExportedName2() {
-    testSame("var f = function() {}; var _x = f;" +
-             "var y = function() { _x(); }; var _y = f;");
+    testSame(
+        lines(
+            "", //
+            "var f = function() {};",
+            "var _x = f;",
+            "var y = function() { _x(); };",
+            "var _y = f;",
+            ""));
   }
 
   @Test
@@ -170,74 +243,92 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineInFunction1() {
-    test("function baz() { var x = 1; var z = x; }",
-        "function baz() { var z = 1; }");
+    test(
+        "function baz() { var x = 1; var z = x; }", //
+        "function baz() { var z = 1;            }");
   }
 
   @Test
   public void testInlineInFunction2() {
-    test("function baz() { " +
-            "var a = new obj();" +
-            "result = a;" +
-         "}",
-         "function baz() { " +
-            "result = new obj()" +
-         "}");
+    test(
+        lines(
+            "", //
+            "function baz() {",
+            "  var a = new obj();",
+            "  result = a;",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function baz() {",
+            "  result = new obj();",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineInFunction3() {
     testSame(
-        "function baz() { " +
-           "var a = new obj();" +
-           "(function(){a;})();" +
-           "result = a;" +
-        "}");
+        lines(
+            "", //
+            "function baz() {",
+            "  var a = new obj();",
+            "  (function(){a;})();",
+            "  result = a;",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineInFunction4() {
     testSame(
-        "function baz() { " +
-           "var a = new obj();" +
-           "foo.result = a;" +
-        "}");
+        lines(
+            "", //
+            "function baz() {",
+            "  var a = new obj();",
+            "  foo.result = a;",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineInFunction5() {
     testSame(
-        "function baz() { " +
-           "var a = (foo = new obj());" +
-           "foo.x();" +
-           "result = a;" +
-        "}");
+        lines(
+            "", //
+            "function baz() { ",
+            "var a = (foo = new obj());",
+            "foo.x();",
+            "result = a;",
+            "}"));
   }
 
   @Test
   public void testInlineInFunction6() {
-    test("function baz() { { var x = 1; var z = x; } }",
-        "function baz() { { var z = 1; } }");
+    test(
+        "function baz() { { var x = 1; var z = x; } }", //
+        "function baz() { { var z = 1;            } }");
   }
 
   @Test
   public void testInlineInFunction7() {
-    test("function baz() { var x = 1; { var z = x; } }",
-        "function baz() { { var z = 1; } }");
+    test(
+        "function baz() { var x = 1; { var z = x; } }", //
+        "function baz() {            { var z = 1; } }");
   }
 
   @Test
   public void testInlineIntoArrowFunction1() {
     test(
-        "var x = 0; var f = () => x + 1;",
-        "var f = () => 0 + 1;");
+        "var x = 0; var f = () => x + 1;", //
+        "           var f = () => 0 + 1;");
   }
 
   @Test
   public void testInlineIntoArrowFunction2() {
     test(
-        "var x = 0; var f = () => { return x + 1; }",
-        "var f = () => { return 0 + 1; }");
+        "var x = 0; var f = () => { return x + 1; }", //
+        "           var f = () => { return 0 + 1; }");
   }
 
   @Test
@@ -254,44 +345,100 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testDoNotExitConditional1() {
-    testSame("if (true) { var x = 1; } var z = x;");
+    test(
+        "if (true) { var x = 1; } var z = x; use(z);", //
+        "if (true) { var x = 1; }            use(x);");
   }
 
   @Test
   public void testDoNotExitConditional2() {
-    testSame("if (true) var x = 1; var z = x;");
+    test(
+        "if (true) var x = 1; var z = x; use(z);", //
+        "if (true) var x = 1;            use(x);");
   }
 
   @Test
   public void testDoNotExitConditional3() {
-    testSame("var x; if (true) x=1; var z = x;");
+    test(
+        "var x; if (true) x=1; var z = x; use(z);", //
+        "var x; if (true) x=1;            use(x);");
   }
 
   @Test
   public void testDoNotExitLoop() {
-    testSame("while (z) { var x = 3; } var y = x;");
+    test(
+        "while (z) { var x = 3; } var y = x; use(y);", //
+        "while (z) { var x = 3; }            use(x);");
   }
 
   @Test
   public void testDoNotExitForLoop() {
-    test("for (var i = 1; false; false) var z = i;",
-         "for (;false;false) var z = 1;");
+    test(
+        "for (var i = 1; false; false) var z = i;", //
+        "for (         ; false; false) var z = 1;");
     testSame("for (; false; false) var i = 1; var z = i;");
     testSame("for (var i in {}); var z = i;");
   }
 
   @Test
-  public void testDoNotEnterSubscope() {
-    testSame(
-        "var x = function() {" +
-        "  var self = this; " +
-        "  return function() { var y = self; };" +
-        "}");
-    testSame(
-        "var x = function() {" +
-        "  var y = [1]; " +
-        "  return function() { var z = y; };" +
-        "}");
+  public void testInlineSubscopeAlias() {
+    test(
+        lines(
+            "", //
+            "var x = function() {",
+            "  var self = this; ",
+            "  return function() {",
+            "    var y = self;",
+            "    use(y);",
+            "  }",
+            "}"),
+        lines(
+            "", //
+            "var x = function() {",
+            "  var self = this; ",
+            "  return function() {",
+            "",
+            "    use(self);",
+            "  }",
+            "}"));
+    test(
+        lines(
+            "", //
+            "var x = function() {",
+            "  var y = [1]; ",
+            "  return function() {",
+            "    var z = y;",
+            "    use(z);",
+            "  };",
+            "}"),
+        lines(
+            "", //
+            "var x = function() {",
+            "  var y = [1]; ",
+            "  return function() {",
+            "",
+            "    use(y);",
+            "  };",
+            "}"));
+    test(
+        lines(
+            "", //
+            "var x = function() {",
+            "  var y = 1;",
+            "  return function() {",
+            "    var z = y;",
+            "    use(z);",
+            "  };",
+            "}"),
+        lines(
+            "", //
+            "var x = function() {",
+            "",
+            "  return function() {",
+            "",
+            "    use(1);",
+            "  };",
+            "}"));
   }
 
   @Test
@@ -307,8 +454,17 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testDoNotEnterFinally() {
-    testSame("try { throw e; var x = 1; } catch (e) {} " +
-             "finally  { var z = x; } ");
+    test(
+        lines(
+            "", //
+            "try { throw e; var x = 1; } catch (e) {} ",
+            "finally  { var z = x; use(z); } ",
+            ""),
+        lines(
+            "", //
+            "try { throw e; var x = 1; } catch (e) {} ",
+            "finally  {            use(x); } ",
+            ""));
   }
 
   @Test
@@ -322,19 +478,24 @@ public final class InlineVariablesTest extends CompilerTestCase {
     test("var a; a = foo();", "foo();");
     test("var a; if (a = foo()) { alert(3); }", "if (foo()) { alert(3); }");
     test("var a; switch (a = foo()) {}", "switch(foo()) {}");
-    test("var a; function f(){ return a = foo(); }",
-         "function f(){ return foo(); }");
-    test("function f(){ var a; return a = foo(); }",
-         "function f(){ return foo(); }");
+    test(
+        "var a; function f(){ return a = foo(); }", //
+        "       function f(){ return     foo(); }");
+    test(
+        "function f(){ var a; return a = foo(); }", //
+        "function f(){        return     foo(); }");
     test("var a; with (a = foo()) { alert(3); }", "with (foo()) { alert(3); }");
 
     test("var a; b = (a = foo());", "b = foo();");
-    test("var a; while(a = foo()) { alert(3); }",
-         "while(foo()) { alert(3); }");
-    test("var a; for(;a = foo();) { alert(3); }",
-         "for(;foo();) { alert(3); }");
-    test("var a; do {} while(a = foo()) { alert(3); }",
-         "do {} while(foo()) { alert(3); }");
+    test(
+        "var a; while(a = foo()) { alert(3); }", //
+        "       while(    foo()) { alert(3); }");
+    test(
+        "var a; for(;a = foo();) { alert(3); }", //
+        "       for(;    foo();) { alert(3); }");
+    test(
+        "var a; do {} while(a = foo()) { alert(3); }", //
+        "       do {} while(    foo()) { alert(3); }");
   }
 
   @Test
@@ -342,19 +503,24 @@ public final class InlineVariablesTest extends CompilerTestCase {
     test("var a; a = 1;", "1;");
     test("var a; if (a = 1) { alert(3); }", "if (1) { alert(3); }");
     test("var a; switch (a = 1) {}", "switch(1) {}");
-    test("var a; function f(){ return a = 1; }",
-         "function f(){ return 1; }");
-    test("function f(){ var a; return a = 1; }",
-         "function f(){ return 1; }");
+    test(
+        "var a; function f(){ return a = 1; }", //
+        "       function f(){ return 1; }");
+    test(
+        "function f(){ var a; return a = 1; }", //
+        "function f(){        return     1; }");
     test("var a; with (a = 1) { alert(3); }", "with (1) { alert(3); }");
 
     test("var a; b = (a = 1);", "b = 1;");
-    test("var a; while(a = 1) { alert(3); }",
-         "while(1) { alert(3); }");
-    test("var a; for(;a = 1;) { alert(3); }",
-         "for(;1;) { alert(3); }");
-    test("var a; do {} while(a = 1) { alert(3); }",
-         "do {} while(1) { alert(3); }");
+    test(
+        "var a; while(a = 1) { alert(3); }", //
+        "       while(    1) { alert(3); }");
+    test(
+        "var a; for(;a = 1;) { alert(3); }", //
+        "       for(;    1;) { alert(3); }");
+    test(
+        "var a; do {} while(a = 1) { alert(3); }", //
+        "       do {} while(    1) { alert(3); }");
   }
 
   @Test
@@ -398,8 +564,9 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInsideHookConditional() {
-    test("var a = foo(); a ? alert(1) : alert(3)",
-         "foo() ? alert(1) : alert(3)");
+    test(
+        "var a = foo(); a ? alert(1) : alert(3)", //
+        "        foo()    ? alert(1) : alert(3)");
   }
 
   @Test
@@ -422,30 +589,58 @@ public final class InlineVariablesTest extends CompilerTestCase {
     test(
         srcs("var x = function() {};", "", "var cow = function() {}; var z = x;"),
         expected("", "", "var cow = function() {}; var z = function() {};"));
-    testSame(srcs("var x = a;", "", "(function() { a++; })(); var z = x;"));
     test(
-        srcs("var x = a;", "", "function cow() { a++; }; cow(); var z = x;"),
-        expected("var x = a;", "", ";(function cow(){ a++; })(); var z = x;"));
-    testSame(srcs("var x = a;", "", "cow(); var z = x; function cow() { a++; };"));
+        "var x = a; (function() { a++; })(); var z = x; use(z);",
+        "var x = a; (function() { a++; })();            use(x);");
+    test(
+        lines(
+            "", //
+            "var x = a;",
+            "function cow(){ a++; }",
+            "cow();",
+            "var z = x;"),
+        lines(
+            "", //
+            "var x = a;",
+            "", // declaration removed
+            "(function cow(){ a++; })();",
+            "", // unused `z` removed
+            ""));
+    test(
+        "var x = a; cow(); var z = x; z; function cow() { a++; };",
+        "var x = a; cow();            x; function cow() { a++; };");
   }
 
   // Test movement of constant values
 
   @Test
   public void testDoCrossFunction() {
-    // We know foo() does not affect x because we require that x is only
-    // referenced twice.
-    test("var x = 1; foo(); var z = x;", "foo(); var z = 1;");
+    test(
+        "var x = 1; foo(); var z = x; use(z);", //
+        "           foo();            use(1);");
   }
 
   @Test
   public void testDoNotCrossReferencingFunction() {
-    testSame(
-        "var f = function() { var z = x; };" +
-        "var x = 1;" +
-        "f();" +
-        "var z = x;" +
-        "f();");
+    test(
+        lines(
+            "", //
+            "var f = function() { var z = x; };",
+            "var x = 1;",
+            "f();",
+            "var z = x;",
+            "use(z)",
+            "f();",
+            ""),
+        lines(
+            "", //
+            "var f = function() { var z$jscomp$1 = x; };",
+            "var x = 1;",
+            "f();",
+            "",
+            "use(x)",
+            "f();",
+            ""));
   }
 
   // Test tricky declarations and references
@@ -475,63 +670,126 @@ public final class InlineVariablesTest extends CompilerTestCase {
   }
 
   @Test
-  public void testDoNotCrossFunctionCalls() {
-    testSame("var x = foo(); bar(); var z = x;");
+  public void testAliasAfterFunctionCall() {
+    test(
+        "var x = foo(); bar(); var z = x; use(z);", //
+        "var x = foo(); bar();            use(x);");
   }
 
   // Test movement of values that are complex but lack side effects
 
   @Test
   public void testDoNotCrossAssignment() {
-    testSame("var x = {}; var y = x.a; x.a = 1; var z = y;");
+    test(
+        "var x = {}; var y = x.a; x.a = 1; var z = y; use(z);", //
+        "var x = {}; var y = x.a; x.a = 1;            use(y);");
     testSame("var a = this.id; foo(this.id = 3, a);");
   }
 
   @Test
-  public void testDoNotCrossDelete() {
-    testSame("var x = {}; var y = x.a; delete x.a; var z = y;");
+  public void testAliasAfterDelete() {
+    test(
+        "var x = {}; var y = x.a; delete x.a; var z = y; use(z);", //
+        "var x = {}; var y = x.a; delete x.a;            use(y);");
   }
 
   @Test
-  public void testDoNotCrossAssignmentPlus() {
-    testSame("var a = b; b += 2; var c = a;");
+  public void testInlineAliasButNotSnapshot() {
+    test(
+        "var b = 1; var a = b; b += 2; var c = a; use(c);", //
+        "var b = 1; var a = b; b += 2;            use(a);");
   }
 
   @Test
-  public void testDoNotCrossIncrement() {
-    testSame("var a = b.c; b.c++; var d = a;");
+  public void testAliasAfterIncrement() {
+    test(
+        "var a = b.c; b.c++; var d = a; use(d);", //
+        "var a = b.c; b.c++;            use(a);");
   }
 
   @Test
-  public void testDoNotCrossConstructor() {
-    testSame("var a = b; new Foo(); var c = a;");
+  public void testConstructorBeforeAlias() {
+    test(
+        "var a = b; new Foo(); var c = a; use(c);", //
+        "var a = b; new Foo();            use(a);");
   }
 
   @Test
-  public void testDoCrossVar() {
+  public void testDoNotInlineAliasAssignedBeforeAliasedVar() {
+    // TODO(bradfordcsmith): This is consistent with past behavior, but it would be good to fix it.
     // Assumes we do not rely on undefined variables (not technically correct!)
-    test("var a = b; var b = 3; alert(a)", "alert(3);");
+    test(
+        "var a = b; var b = 3; alert(a)", //
+        "           var b = 3; alert(b);");
+    test(
+        lines(
+            "", //
+            "f();",
+            "function f() {",
+            "  var alias = original;",
+            "  alert(alias)",
+            "}",
+            "var original = 3;",
+            ""),
+        lines(
+            "", //
+            "f();",
+            "function f() {",
+            "",
+            "  alert(original)",
+            "}",
+            "var original = 3;",
+            ""));
+    test(
+        lines(
+            "", //
+            "f();",
+            "var original = 3;",
+            "function f() {",
+            "  var alias = original;",
+            "  alert(alias)",
+            "}",
+            ""),
+        lines(
+            "", //
+            "f();",
+            "var original = 3;",
+            "function f() {",
+            "",
+            "  alert(original)",
+            "}",
+            ""));
   }
 
   @Test
   public void testOverlappingInlines() {
     String source =
-        "a = function(el, x, opt_y) { " +
-        "  var cur = bar(el); " +
-        "  opt_y = x.y; " +
-        "  x = x.x; " +
-        "  var dx = x - cur.x; " +
-        "  var dy = opt_y - cur.y;" +
-        "  foo(el, el.offsetLeft + dx, el.offsetTop + dy); " +
-        "};";
+        lines(
+            "",
+            "a = function(el, x, opt_y) {",
+            "  var cur = bar(el);",
+            "  opt_y = x.y;",
+            "  x = x.x;",
+            "  var dx = x - cur.x;",
+            "  var dy = opt_y - cur.y;",
+            "  foo(",
+            "      el,",
+            "      el.offsetLeft + dx,",
+            "      el.offsetTop + dy);",
+            "};",
+            "");
     String expected =
-      "a = function(el, x, opt_y) { " +
-      "  var cur = bar(el); " +
-      "  opt_y = x.y; " +
-      "  x = x.x; " +
-      "  foo(el, el.offsetLeft + (x - cur.x)," +
-      "      el.offsetTop + (opt_y - cur.y)); " +
-      "};";
+        lines(
+            "", //
+            "a = function(el, x, opt_y) {",
+            "  var cur = bar(el);",
+            "  opt_y = x.y;",
+            "  x = x.x;",
+            "  foo(",
+            "      el,",
+            "      el.offsetLeft + (x - cur.x),",
+            "      el.offsetTop + (opt_y - cur.y)); ",
+            "};");
 
     test(source, expected);
   }
@@ -539,32 +797,41 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testOverlappingInlineFunctions() {
     String source =
-        "a = function() { " +
-        "  var b = function(args) {var n;}; " +
-        "  var c = function(args) {}; " +
-        "  d(b,c); " +
-        "};";
+        lines(
+            "", //
+            "a = function() { ",
+            "  var b = function(args) {var n;}; ",
+            "  var c = function(args) {}; ",
+            "  d(b,c); ",
+            "};",
+            "");
     String expected =
-      "a = function() { " +
-      "  d(function(args){var n;}, function(args){}); " +
-      "};";
+        lines(
+            "", //
+            "a = function() {",
+            "  d(function(args){var n;}, function(args){});",
+            "};",
+            "");
 
     test(source, expected);
   }
 
   @Test
   public void testInlineIntoLoops() {
-    test("var x = true; while (true) alert(x);",
-         "while (true) alert(true);");
-    test("var x = true; while (true) for (var i in {}) alert(x);",
-         "while (true) for (var i in {}) alert(true);");
+    test(
+        "var x = true; while (true) alert(   x);", //
+        "              while (true) alert(true);");
+    test(
+        "var x = true; while (true) for (var i in {}) alert(   x);",
+        "              while (true) for (var i in {}) alert(true);");
     testSame("var x = [true]; while (true) alert(x);");
   }
 
   @Test
   public void testInlineIntoFunction() {
-    test("var x = false; var f = function() { alert(x); };",
-         "var f = function() { alert(false); };");
+    test(
+        "var x = false; var f = function() { alert(    x); };",
+        "               var f = function() { alert(false); };");
     testSame("var x = [false]; var f = function() { alert(x); };");
   }
 
@@ -575,8 +842,9 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineIntoNestedNonHoistedNamedFunctions() {
-    test("f(); var x = false; if (false) function f() { alert(x); };",
-         "f(); if (false) function f() { alert(false); };");
+    test(
+        "f(); var x = false; if (false) function f() { alert(    x); };",
+        "f();                if (false) function f() { alert(false); };");
   }
 
   @Test
@@ -591,23 +859,27 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineImmutableMultipleTimes() {
-    test("var x = null; var y = x, z = x;",
-         "var y = null, z = null;");
-    test("var x = 3; var y = x, z = x;",
-         "var y = 3, z = 3;");
-  }
-
-  @Test
-  public void testNoInlineStringMultipleTimesIfNotWorthwhile() {
-    testSame("var x = 'abcdefghijklmnopqrstuvwxyz'; var y = x, z = x;");
+    test(
+        "var x = null; var y =    x, z =    x;", //
+        "              var y = null, z = null;");
+    test(
+        "var x = 3; var y = x, z = x;", //
+        "           var y = 3, z = 3;");
   }
 
   @Test
-  public void testInlineStringMultipleTimesWhenAliasingAllStrings() {
-    inlineAllStrings = true;
-    test("var x = 'abcdefghijklmnopqrstuvwxyz'; var y = x, z = x;",
-         "var y = 'abcdefghijklmnopqrstuvwxyz', " +
-         "    z = 'abcdefghijklmnopqrstuvwxyz';");
+  public void testInlineStringMultipleTimesAllStrings() {
+    test(
+        lines(
+            "", //
+            "var x = 'abcdefghijklmnopqrstuvwxyz';",
+            "var y = x, z = x;",
+            ""),
+        lines(
+            "", //
+            "var y = 'abcdefghijklmnopqrstuvwxyz', ",
+            "    z = 'abcdefghijklmnopqrstuvwxyz';",
+            ""));
   }
 
   @Test
@@ -622,27 +894,32 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInterferingInlines() {
-    test("var a = 3; var f = function() { var x = a; alert(x); };",
-         "var f = function() { alert(3); };");
+    test(
+        "var a = 3; var f = function() { var x = a; alert(x); };",
+        "           var f = function() {            alert(3); };");
   }
 
   @Test
   public void testInlineIntoTryCatch() {
-    test("var a = true; " +
-         "try { var b = a; } " +
-         "catch (e) { var c = a + b; var d = true; } " +
-         "finally { var f = a + b + c + d; }",
-         "try { var b = true; } " +
-         "catch (e) { var c = true + b; var d = true; } " +
-         "finally { var f = true + b + c + d; }");
+    test(
+        lines(
+            "var a = true; ",
+            "try { var b = a; } ",
+            "catch (e) { var c = a + b; var d = true; } ",
+            "finally { var f = a + b + c + d; }"),
+        lines(
+            "try { var b = true; } ",
+            "catch (e) { var c = true + b; var d = true; } ",
+            "finally { var f = true + b + c + d; }"));
   }
 
   // Make sure that we still inline constants that are not provably
   // written before they're read.
   @Test
   public void testInlineConstants() {
-    test("function foo() { return XXX; } var XXX = true;",
-         "function foo() { return true; }");
+    test(
+        "function foo() { return  XXX; } var XXX = true;", //
+        "function foo() { return true; }                ");
   }
 
   @Test
@@ -652,27 +929,44 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineConstantAlias() {
-    test("var XXX = new Foo(); q(XXX); var YYY = XXX; bar(YYY)",
-         "var XXX = new Foo(); q(XXX); bar(XXX)");
+    test(
+        "var XXX = new Foo(); q(XXX); var YYY = XXX; bar(YYY)",
+        "var XXX = new Foo(); q(XXX);                bar(XXX)");
   }
 
   @Test
   public void testInlineConstantAliasWithAnnotation() {
-    test("/** @const */ var xxx = new Foo(); q(xxx); var YYY = xxx; bar(YYY)",
-         "/** @const */ var xxx = new Foo(); q(xxx); bar(xxx)");
+    test(
+        "/** @const */ var xxx = new Foo(); q(xxx); var YYY = xxx; bar(YYY)",
+        "/** @const */ var xxx = new Foo(); q(xxx);                bar(xxx)");
   }
 
   @Test
   public void testInlineConstantAliasWithNonConstant() {
-    test("var XXX = new Foo(); q(XXX); var y = XXX; bar(y); baz(y)",
-         "var XXX = new Foo(); q(XXX); bar(XXX); baz(XXX)");
+    test(
+        "var XXX = new Foo(); q(XXX); var y = XXX; bar(  y); baz(  y)",
+        "var XXX = new Foo(); q(XXX);              bar(XXX); baz(XXX)");
   }
 
   @Test
   public void testCascadingInlines() {
-    test("var XXX = 4; " +
-         "function f() { var YYY = XXX; bar(YYY); baz(YYY); }",
-         "function f() { bar(4); baz(4); }");
+    test(
+        lines(
+            "", //
+            "var XXX = 4;",
+            "function f() {",
+            "  var YYY = XXX;",
+            "  bar(YYY);",
+            "  baz(YYY);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function f() {",
+            "  bar(4);",
+            "  baz(4);",
+            "}",
+            ""));
   }
 
   @Test
@@ -684,25 +978,38 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineFunctionDeclaration() {
-    test("var f = function () {}; var a = f;",
-         "var a = function () {};");
-    test("var f = function () {}; foo(); var a = f;",
-         "foo(); var a = function () {};");
-    test("var f = function () {}; foo(f);",
-         "foo(function () {});");
-
-    testSame("var f = function () {}; function g() {var a = f;}");
+    test(
+        "var f = function () {}; var a =              f;", //
+        "                        var a = function () {};");
+    test(
+        "var f = function () {}; foo(); var a =              f;", //
+        "                        foo(); var a = function () {};");
+    test(
+        "var f = function () {}; foo(             f);", //
+        "                        foo(function () {});");
+
+    test(
+        "var f = function () {}; function g() {var a = f; return a;}", //
+        "var f = function () {}; function g() {           return f;}");
     testSame("var f = function () {}; function g() {h(f);}");
   }
 
   @Test
   public void test2388531() {
-    testSame("var f = function () {};" +
-             "var g = function () {};" +
-             "goog.inherits(f, g);");
-    testSame("var f = function () {};" +
-             "var g = function () {};" +
-             "goog$inherits(f, g);");
+    testSame(
+        lines(
+            "", //
+            "var f = function () {};",
+            "var g = function () {};",
+            "goog.inherits(f, g);",
+            ""));
+    testSame(
+        lines(
+            "", //
+            "var f = function () {};",
+            "var g = function () {};",
+            "goog$inherits(f, g);",
+            ""));
   }
 
   @Test
@@ -727,198 +1034,369 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineAliases1() {
-    test("var x = this.foo(); this.bar(); var y = x; this.baz(y);",
-         "var x = this.foo(); this.bar(); this.baz(x);");
+    test(
+        "var x = this.foo(); this.bar(); var y = x; this.baz(y);",
+        "var x = this.foo(); this.bar();            this.baz(x);");
   }
 
   @Test
   public void testInlineAliases1b() {
-    test("var x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
-         "var x = this.foo(); this.bar(); x; this.baz(x);");
+    test(
+        "var x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
+        "var x = this.foo(); this.bar();            x; this.baz(x);");
   }
 
   @Test
   public void testInlineAliases1c() {
-    test("var x; x = this.foo(); this.bar(); var y = x; this.baz(y);",
-         "var x; x = this.foo(); this.bar(); this.baz(x);");
+    test(
+        "var x; x = this.foo(); this.bar(); var y = x; this.baz(y);",
+        "var x; x = this.foo(); this.bar();            this.baz(x);");
   }
 
   @Test
   public void testInlineAliases1d() {
-    test("var x; x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
-         "var x; x = this.foo(); this.bar(); x; this.baz(x);");
+    test(
+        "var x; x = this.foo(); this.bar(); var y; y = x; this.baz(y);",
+        "var x; x = this.foo(); this.bar();            x; this.baz(x);");
   }
 
   @Test
   public void testInlineAliases2() {
-    test("var x = this.foo(); this.bar(); " +
-         "function f() { var y = x; this.baz(y); }",
-         "var x = this.foo(); this.bar(); function f() { this.baz(x); }");
+    test(
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y = x;",
+            "  this.baz(y);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  this.baz(x);",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineAliases2b() {
-    test("var x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; this.baz(y); }",
-         "var x = this.foo(); this.bar(); function f() { this.baz(x); }");
+    test(
+        lines(
+            "",
+            "var x = this.foo();",
+            "this.bar(); ",
+            "function f() {",
+            "  var y;",
+            "  y = x;",
+            "  this.baz(y);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "",
+            "  x;",
+            "  this.baz(x);",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineAliases2c() {
-    test("var x; x = this.foo(); this.bar(); " +
-         "function f() { var y = x; this.baz(y); }",
-         "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }");
+    test(
+        lines(
+            "", //
+            "var x;",
+            "x = this.foo();",
+            "this.bar(); ",
+            "function f() {",
+            "  var y = x;",
+            "  this.baz(y);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "var x;",
+            "x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  this.baz(x);",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineAliases2d() {
-    test("var x; x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; this.baz(y); }",
-         "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }");
+    test(
+        lines(
+            "", //
+            "var x;",
+            "x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y;",
+            "  y = x;",
+            "  this.baz(y);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "var x;",
+            "x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "",
+            "  x;",
+            "  this.baz(x);",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineAliasesInLoop() {
     test(
-        "function f() { " +
-        "  var x = extern();" +
-        "  for (var i = 0; i < 5; i++) {" +
-        "    (function() {" +
-        "       var y = x; window.setTimeout(function() { extern(y); }, 0);" +
-        "     })();" +
-        "  }" +
-        "}",
-        "function f() { " +
-        "  var x = extern();" +
-        "  for (var i = 0; i < 5; i++) {" +
-        "    (function() {" +
-        "       window.setTimeout(function() { extern(x); }, 0);" +
-        "     })();" +
-        "  }" +
-        "}");
+        lines(
+            "function f() { ",
+            "  var x = extern();",
+            "  for (var i = 0; i < 5; i++) {",
+            "    (function() {",
+            "       var y = x; window.setTimeout(function() { extern(y); }, 0);",
+            "     })();",
+            "  }",
+            "}"),
+        lines(
+            "function f() { ",
+            "  var x = extern();",
+            "  for (var i = 0; i < 5; i++) {",
+            "    (function() {",
+            "       window.setTimeout(function() { extern(x); }, 0);",
+            "     })();",
+            "  }",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliasesInLoop() {
     testSame(
-        "function f() { " +
-        "  for (var i = 0; i < 5; i++) {" +
-        "    var x = extern();" +
-        "    (function() {" +
-        "       var y = x; window.setTimeout(function() { extern(y); }, 0);" +
-        "     })();" +
-        "  }" +
-        "}");
+        lines(
+            "function f() { ",
+            "  for (var i = 0; i < 5; i++) {",
+            "    var x = extern();",
+            "    (function() {",
+            "       var y = x; window.setTimeout(function() { extern(y); }, 0);",
+            "     })();",
+            "  }",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliases1() {
-    testSame(
-        "var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);");
+    testSame("var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);");
   }
 
   @Test
   public void testNoInlineAliases1b() {
-    testSame(
-        "var x = this.foo(); this.bar(); var y; y = x; x = 3; this.baz(y);");
+    testSame("var x = this.foo(); this.bar(); var y; y = x; x = 3; this.baz(y);");
   }
 
   @Test
   public void testNoInlineAliases2() {
-    testSame(
-        "var x = this.foo(); this.bar(); var y = x; y = 3; this.baz(y); ");
+    testSame("var x = this.foo(); this.bar(); var y = x; y = 3; this.baz(y); ");
   }
 
   @Test
   public void testNoInlineAliases2b() {
-    testSame(
-        "var x = this.foo(); this.bar(); var y; y = x; y = 3; this.baz(y); ");
+    testSame("var x = this.foo(); this.bar(); var y; y = x; y = 3; this.baz(y); ");
   }
 
   @Test
   public void testNoInlineAliases3() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y = x; g(); this.baz(y); } " +
-         "function g() { x = 3; }");
+        lines(
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y = x;",
+            "  g();",
+            "  this.baz(y);",
+            "}",
+            "function g() {",
+            "  x = 3;",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliases3b() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; g(); this.baz(y); } " +
-         "function g() { x = 3; }");
+        lines(
+            "var x = this.foo();",
+            "this.bar();",
+            "",
+            "function f() {",
+            "var y;",
+            "y = x;",
+            "g();",
+            "this.baz(y);",
+            "} ",
+            "function g() {",
+            "x = 3;",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliases4() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y = x; y = 3; this.baz(y); }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y = x;",
+            "  y = 3;",
+            "  this.baz(y);",
+            "}",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases4b() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; y = 3; this.baz(y); }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y;",
+            "  y = x;",
+            "  y = 3;",
+            "  this.baz(y);",
+            "}",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases5() {
     testSame(
-        "var x = this.foo(); this.bar(); var y = x; this.bing();" +
-        "this.baz(y); x = 3;");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "var y = x;",
+            "this.bing();",
+            "this.baz(y);",
+            "x = 3;",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases5b() {
     testSame(
-        "var x = this.foo(); this.bar(); var y; y = x; this.bing();" +
-        "this.baz(y); x = 3;");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "var y;",
+            "y = x;",
+            "this.bing();",
+            "this.baz(y);",
+            "x = 3;",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases6() {
     testSame(
-        "var x = this.foo(); this.bar(); var y = x; this.bing();" +
-        "this.baz(y); y = 3;");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "var y = x;",
+            "this.bing();",
+            "this.baz(y);",
+            "y = 3;",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases6b() {
     testSame(
-        "var x = this.foo(); this.bar(); var y; y = x; this.bing();" +
-        "this.baz(y); y = 3;");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "var y;",
+            "y = x;",
+            "this.bing();",
+            "this.baz(y);",
+            "y = 3;",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases7() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y = x; this.bing(); this.baz(y); x = 3; }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y = x;",
+            "  this.bing();",
+            "  this.baz(y);",
+            "  x = 3;",
+            "}",
+            ""));
   }
 
   @Test
   public void testNoInlineAliases7b() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; this.bing(); this.baz(y); x = 3; }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y;",
+            "  y = x;",
+            "  this.bing();",
+            "  this.baz(y);",
+            "  x = 3;",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliases8() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y = x; this.baz(y); y = 3; }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y = x;",
+            "  this.baz(y);",
+            "  y = 3;",
+            "}"));
   }
 
   @Test
   public void testNoInlineAliases8b() {
     testSame(
-         "var x = this.foo(); this.bar(); " +
-         "function f() { var y; y = x; this.baz(y); y = 3; }");
+        lines(
+            "", //
+            "var x = this.foo();",
+            "this.bar();",
+            "function f() {",
+            "  var y;",
+            "  y = x;",
+            "  this.baz(y);",
+            "  y = 3;",
+            "}"));
   }
 
   @Test
@@ -926,9 +1404,9 @@ public final class InlineVariablesTest extends CompilerTestCase {
     // z can not be changed by the call to y, so x can be inlined.
     String EXTERNS = "var z; function f(){}";
     test(
-        externs(EXTERNS),
-        srcs("var x = f(y.a, y); z = x;"),
-        expected("z = f(y.a, y);"));
+        externs(EXTERNS), //
+        srcs("var x = f(y.a, y); z =          x"),
+        expected("               z = f(y.a, y);"));
     // z.b can be changed by the call to y, so x can not be inlined.
     testSame(externs(EXTERNS), srcs("var x = f(y.a, y); z.b = x;"));
   }
@@ -936,99 +1414,129 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testInlineParameterAlias1() {
     test(
-      "function f(x) {" +
-      "  var y = x;" +
-      "  g();" +
-      "  y;y;" +
-      "}",
-      "function f(x) {" +
-      "  g();" +
-      "  x;x;" +
-      "}"
-      );
+        lines(
+            "", //
+            "function f(x) {",
+            "  var y = x;",
+            "  g();",
+            "  y;y;",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function f(x) {",
+            "  g();",
+            "  x;x;",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineParameterAlias2() {
     test(
-      "function f(x) {" +
-      "  var y; y = x;" +
-      "  g();" +
-      "  y;y;" +
-      "}",
-      "function f(x) {" +
-      "  x;" +
-      "  g();" +
-      "  x;x;" +
-      "}"
-      );
+        lines(
+            "", //
+            "function f(x) {",
+            "  var y; y = x;",
+            "  g();",
+            "  y;y;",
+            "}",
+            ""),
+        lines(
+            "", //
+            "function f(x) {",
+            "  x;",
+            "  g();",
+            "  x;x;",
+            "}",
+            ""));
   }
 
   @Test
   public void testInlineFunctionAlias1a() {
     test(
-      "function f(x) {}" +
-      "var y = f;" +
-      "g();" +
-      "y();y();",
-      "var y = function f(x) {};" +
-      "g();" +
-      "y();y();"
-      );
+        lines(
+            "", //
+            "function f(x) {}",
+            "var y = f;",
+            "g();",
+            "y();y();",
+            ""),
+        lines(
+            "", //
+            "var y = function f(x) {};",
+            "g();",
+            "y();y();",
+            ""));
   }
 
   @Test
   public void testInlineFunctionAlias1b() {
     test(
-      "function f(x) {};" +
-      "f;var y = f;" +
-      "g();" +
-      "y();y();",
-      "function f(x) {};" +
-      "f;g();" +
-      "f();f();"
-      );
+        lines(
+            "", //
+            "function f(x) {};",
+            "f;var y = f;",
+            "g();",
+            "y();y();",
+            ""),
+        lines(
+            "", //
+            "function f(x) {};",
+            "f;g();",
+            "f();f();",
+            ""));
   }
 
   @Test
   public void testInlineFunctionAlias2a() {
     test(
-      "function f(x) {}" +
-      "var y; y = f;" +
-      "g();" +
-      "y();y();",
-      "var y; y = function f(x) {};" +
-      "g();" +
-      "y();y();"
-      );
+        lines(
+            "", //
+            "function f(x) {}",
+            "var y; y = f;",
+            "g();",
+            "y();y();",
+            ""),
+        lines(
+            "", //
+            "var y; y = function f(x) {};",
+            "g();",
+            "y();y();",
+            ""));
   }
 
   @Test
   public void testInlineFunctionAlias2b() {
     test(
-      "function f(x) {};" +
-      "f; var y; y = f;" +
-      "g();" +
-      "y();y();",
-      "function f(x) {};" +
-      "f; f;" +
-      "g();" +
-      "f();f();"
-      );
+        lines(
+            "", //
+            "function f(x) {};",
+            "f; var y; y = f;",
+            "g();",
+            "y();y();",
+            ""),
+        lines(
+            "", //
+            "function f(x) {};",
+            "f; f;",
+            "g();",
+            "f();f();",
+            ""));
   }
 
   @Test
   public void testInlineSwitchVar() {
     test(
-        "var x = y; switch (x) {}",
-        "switch (y) {}");
+        "var x = y; switch (x) {}", //
+        "           switch (y) {}");
   }
 
   @Test
   public void testInlineSwitchLet() {
     test(
-        "let x = y; switch (x) {}",
-        "switch (y) {}");
+        "let x = y; switch (x) {}", //
+        "           switch (y) {}");
   }
 
   // Successfully inlines 'values' and 'e'
@@ -1088,11 +1596,12 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testNoInlineCatchAliasVar1() {
     testSame(
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  var y = e;",
-            "  g();" ,
-            "  y;y;" ,
+            "  g();",
+            "  y;y;",
             "}"));
   }
 
@@ -1101,6 +1610,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testNoInlineCatchAliasVar2() {
     testSame(
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  var y; y = e;",
@@ -1113,13 +1623,15 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testInlineCatchAliasLet1() {
     test(
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  let y = e;",
-            "  g();" ,
-            "  y;y;" ,
+            "  g();",
+            "  y;y;",
             "}"),
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  g();",
@@ -1131,6 +1643,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testInlineCatchAliasLet2() {
     test(
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  let y; y = e;",
@@ -1138,6 +1651,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
             "  y;y;",
             "}"),
         lines(
+            "", //
             "try {",
             "} catch (e) {",
             "  e;",
@@ -1171,8 +1685,8 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testVarInBlock1() {
     test(
-        "function f(x) { if (true) {var y = x; y; y;} }",
-        "function f(x) { if (true) {x; x;} }");
+        "function f(x) { if (true) {var y = x; y; y;} }", //
+        "function f(x) { if (true) {           x; x;} }");
   }
 
   @Test
@@ -1186,8 +1700,8 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testLocalsOnly1() {
     inlineLocalsOnly = true;
     test(
-        "var x=1; x; function f() {var x = 1; x;}",
-        "var x=1; x; function f() {1;}");
+        "var x=1; x; function f() {var x = 1; x;}", //
+        "var x=1; x; function f() {           1;}");
   }
 
   @Test
@@ -1196,18 +1710,25 @@ public final class InlineVariablesTest extends CompilerTestCase {
     test(
         lines(
             "/** @const */",
-            "var X=1; X;",
+            "var X=1;",
+            "X;",
             "function f() {",
             "  /** @const */",
             "  var X = 1; X;",
             "}"),
-        "/** @const */var X=1; X; function f() {1;}");
+        lines(
+            "", //
+            "/** @const */",
+            "var X=1;",
+            "X;",
+            "function f() {",
+            "  1;",
+            "}"));
   }
 
   @Test
   public void testInlineUndefined1() {
-    test("var x; x;",
-         "void 0;");
+    test("var x; x;", "void 0;");
   }
 
   @Test
@@ -1222,8 +1743,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testInlineUndefined4() {
-    test("var x; x; x;",
-         "void 0; void 0;");
+    test("var x; x; x;", "void 0; void 0;");
   }
 
   @Test
@@ -1233,26 +1753,30 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testIssue90() {
-    test("var x; x && alert(1)",
-         "void 0 && alert(1)");
+    test(
+        "var x;      x && alert(1)", //
+        "       void 0 && alert(1)");
   }
 
   @Test
   public void testRenamePropertyFunction() {
-    testSame("var JSCompiler_renameProperty; " +
-             "JSCompiler_renameProperty('foo')");
+    testSame(
+        lines(
+            "", //
+            "var JSCompiler_renameProperty; ",
+            "JSCompiler_renameProperty('foo')"));
   }
 
   @Test
   public void testThisAlias() {
-    test("function f() { var a = this; a.y(); a.z(); }",
-         "function f() { this.y(); this.z(); }");
+    test(
+        "function f() { var a = this;    a.y();    a.z(); }", //
+        "function f() {               this.y(); this.z(); }");
   }
 
   @Test
   public void testThisEscapedAlias() {
-    testSame(
-        "function f() { var a = this; var g = function() { a.y(); }; a.z(); }");
+    testSame("function f() { var a = this; var g = function() { a.y(); }; a.z(); }");
   }
 
   @Test
@@ -1263,152 +1787,180 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testIssue378ModifiedArguments1() {
     testSame(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  arguments[0] = this;\n" +
-        "  f.apply(this, arguments);\n" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  arguments[0] = this;",
+            "  f.apply(this, arguments);",
+            "}"));
   }
 
   @Test
   public void testIssue378ModifiedArguments2() {
     testSame(
-        "function g(callback) {\n" +
-        "  /** @const */\n" +
-        "  var f = callback;\n" +
-        "  arguments[0] = this;\n" +
-        "  f.apply(this, arguments);\n" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  /** @const */",
+            "  var f = callback;",
+            "  arguments[0] = this;",
+            "  f.apply(this, arguments);",
+            "}"));
   }
 
   @Test
   public void testIssue378EscapedArguments1() {
     testSame(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  h(arguments,this);\n" +
-        "  f.apply(this, arguments);\n" +
-        "}\n" +
-        "function h(a,b) {\n" +
-        "  a[0] = b;" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  h(arguments,this);",
+            "  f.apply(this, arguments);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"));
   }
 
   @Test
   public void testIssue378EscapedArguments2() {
     testSame(
-        "function g(callback) {\n" +
-        "  /** @const */\n" +
-        "  var f = callback;\n" +
-        "  h(arguments,this);\n" +
-        "  f.apply(this);\n" +
-        "}\n" +
-        "function h(a,b) {\n" +
-        "  a[0] = b;" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  /** @const */",
+            "  var f = callback;",
+            "  h(arguments,this);",
+            "  f.apply(this);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"));
   }
 
   @Test
   public void testIssue378EscapedArguments3() {
     test(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  f.apply(this, arguments);\n" +
-        "}\n",
-        "function g(callback) {\n" +
-        "  callback.apply(this, arguments);\n" +
-        "}\n");
+        lines(
+            "", //
+            "function g(callback) {",
+            "  var f = callback;",
+            "  f.apply(this, arguments);",
+            "}"),
+        lines(
+            "", //
+            "function g(callback) {",
+            "",
+            "  callback.apply(this, arguments);",
+            "}"));
   }
 
   @Test
   public void testIssue378EscapedArguments4() {
-    testSame(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  h(arguments[0],this);\n" +
-        "  f.apply(this, arguments);\n" +
-        "}\n" +
-        "function h(a,b) {\n" +
-        "  a[0] = b;" +
-        "}");
+    test(
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  h(arguments[0],this);",
+            "  f.apply(this, arguments);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"),
+        lines(
+            "function g(callback) {",
+            "",
+            "  h(arguments[0],this);",
+            "  callback.apply(this, arguments);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"));
   }
 
   @Test
   public void testIssue378ArgumentsRead1() {
     test(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  var g = arguments[0];\n" +
-        "  f.apply(this, arguments);\n" +
-        "}",
-        "function g(callback) {\n" +
-        "  var g = arguments[0];\n" +
-        "  callback.apply(this, arguments);\n" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  var g = arguments[0];",
+            "  f.apply(this, arguments);",
+            "}"),
+        lines(
+            "function g(callback) {",
+            "",
+            "  var g = arguments[0];",
+            "  callback.apply(this, arguments);",
+            "}"));
   }
 
   @Test
   public void testIssue378ArgumentsRead2() {
     test(
-        "function g(callback) {\n" +
-        "  var f = callback;\n" +
-        "  h(arguments[0],this);\n" +
-        "  f.apply(this, arguments[0]);\n" +
-        "}\n" +
-        "function h(a,b) {\n" +
-        "  a[0] = b;" +
-        "}",
-        "function g(callback) {\n" +
-        "  h(arguments[0],this);\n" +
-        "  callback.apply(this, arguments[0]);\n" +
-        "}\n" +
-        "function h(a,b) {\n" +
-        "  a[0] = b;" +
-        "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  h(arguments[0],this);",
+            "  f.apply(this, arguments[0]);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"),
+        lines(
+            "function g(callback) {",
+            "  h(arguments[0],this);",
+            "  callback.apply(this, arguments[0]);",
+            "}",
+            "function h(a,b) {",
+            "  a[0] = b;",
+            "}"));
   }
 
   @Test
   public void testArgumentsModifiedInOuterFunction() {
     test(
-      "function g(callback) {\n" +
-      "  var f = callback;\n" +
-      "  arguments[0] = this;\n" +
-      "  f.apply(this, arguments);\n" +
-      "  function inner(callback) {" +
-      "    var x = callback;\n" +
-      "    x.apply(this);\n" +
-      "  }" +
-      "}",
-      "function g(callback) {\n" +
-      "  var f = callback;\n" +
-      "  arguments[0] = this;\n" +
-      "  f.apply(this, arguments);\n" +
-      "  function inner(callback) {" +
-      "    callback.apply(this);\n" +
-      "  }" +
-      "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  arguments[0] = this;",
+            "  f.apply(this, arguments);",
+            "  function inner(callback) {",
+            "    var x = callback;",
+            "    x.apply(this);",
+            "  }",
+            "}"),
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  arguments[0] = this;",
+            "  f.apply(this, arguments);",
+            "  function inner(callback) {",
+            "    callback.apply(this);",
+            "  }",
+            "}"));
   }
 
   @Test
   public void testArgumentsModifiedInInnerFunction() {
     test(
-      "function g(callback) {\n" +
-      "  var f = callback;\n" +
-      "  f.apply(this, arguments);\n" +
-      "  function inner(callback) {" +
-      "    var x = callback;\n" +
-      "    arguments[0] = this;\n" +
-      "    x.apply(this);\n" +
-      "  }" +
-      "}",
-      "function g(callback) {\n" +
-      "  callback.apply(this, arguments);\n" +
-      "  function inner(callback) {" +
-      "    var x = callback;\n" +
-      "    arguments[0] = this;\n" +
-      "    x.apply(this);\n" +
-      "  }" +
-      "}");
+        lines(
+            "function g(callback) {",
+            "  var f = callback;",
+            "  f.apply(this, arguments);",
+            "  function inner(callback) {",
+            "    var x = callback;",
+            "    arguments[0] = this;",
+            "    x.apply(this);",
+            "  }",
+            "}"),
+        lines(
+            "function g(callback) {",
+            "  callback.apply(this, arguments);",
+            "  function inner(callback) {",
+            "    var x = callback;",
+            "    arguments[0] = this;",
+            "    x.apply(this);",
+            "  }",
+            "}"));
   }
 
   @Test
@@ -1421,15 +1973,15 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testBug6598844() {
     testSame(
-        "function F() { this.a = 0; }" +
-        "F.prototype.inc = function() { this.a++; return 10; };" +
-        "F.prototype.bar = function() { var x = this.inc(); this.a += x; };");
+        lines(
+            "function F() { this.a = 0; }",
+            "F.prototype.inc = function() { this.a++; return 10; };",
+            "F.prototype.bar = function() { var x = this.inc(); this.a += x; };"));
   }
 
   @Test
   public void testExternalIssue1053() {
-    testSame(
-        "var u; function f() { u = Random(); var x = u; f(); alert(x===u)}");
+    testSame("var u; function f() { u = Random(); var x = u; f(); alert(x===u)}");
   }
 
   @Test
@@ -1440,84 +1992,99 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testHoistedFunction2() {
     testSame(
-        "var impl_0;" +
-        "b(a());" +
-        "function a() { impl_0 = {}; }" +
-        "function b() { window['f'] = impl_0; }");
+        lines(
+            "var impl_0;",
+            "b(a());",
+            "function a() { impl_0 = {}; }",
+            "function b() { window['f'] = impl_0; }"));
   }
 
   @Test
   public void testHoistedFunction3() {
     testSame(
-        "var impl_0;" +
-        "b();" +
-        "impl_0 = 1;" +
-        "function b() { window['f'] = impl_0; }");
+        lines(
+            "", //
+            "var impl_0;",
+            "b();",
+            "impl_0 = 1;",
+            "function b() { window['f'] = impl_0; }"));
   }
 
   @Test
   public void testHoistedFunction4() {
     test(
-        "var impl_0;" +
-        "impl_0 = 1;" +
-        "b();" +
-        "function b() { window['f'] = impl_0; }",
-        "1; b(); function b() { window['f'] = 1; }");
+        lines(
+            "", //
+            "var impl_0;",
+            "impl_0 = 1;",
+            "b();",
+            "function b() { window['f'] = impl_0; }"),
+        lines(
+            "", //
+            "1;",
+            "b();",
+            "function b() { window['f'] = 1; }"));
   }
 
   @Test
   public void testHoistedFunction5() {
     testSame(
-        "a();" +
-        "var debug = 1;" +
-        "function b() { return debug; }" +
-        "function a() { return b(); }");
+        lines(
+            "a();",
+            "var debug = 1;",
+            "function b() { return debug; }",
+            "function a() { return b(); }"));
   }
 
   @Test
   public void testHoistedFunction6() {
     test(
-        "var debug = 1;" +
-        "a();" +
-        "function b() { return debug; }" +
-        "function a() { return b(); }",
-        "a();" +
-        "function b() { return 1; }" +
-        "function a() { return b(); }");
+        lines(
+            "var debug = 1;",
+            "a();",
+            "function b() { return debug; }",
+            "function a() { return b(); }"),
+        lines(
+            "", //
+            "a();",
+            "function b() { return 1; }",
+            "function a() { return b(); }"));
   }
 
   @Test
   public void testIssue354() {
     test(
-        "var enabled = true;" +
-        "function Widget() {}" +
-        "Widget.prototype = {" +
-        "  frob: function() {" +
-        "    search();" +
-        "  }" +
-        "};" +
-        "function search() {" +
-        "  if (enabled)" +
-        "    alert(1);" +
-        "  else" +
-        "    alert(2);" +
-        "}" +
-        "window.foo = new Widget();" +
-        "window.bar = search;",
-        "function Widget() {}" +
-        "Widget.prototype = {" +
-        "  frob: function() {" +
-        "    search();" +
-        "  }" +
-        "};" +
-        "function search() {" +
-        "  if (true)" +
-        "    alert(1);" +
-        "  else" +
-        "    alert(2);" +
-        "}" +
-        "window.foo = new Widget();" +
-        "window.bar = search;");
+        lines(
+            "var enabled = true;",
+            "function Widget() {}",
+            "Widget.prototype = {",
+            "  frob: function() {",
+            "    search();",
+            "  }",
+            "};",
+            "function search() {",
+            "  if (enabled)",
+            "    alert(1);",
+            "  else",
+            "    alert(2);",
+            "}",
+            "window.foo = new Widget();",
+            "window.bar = search;"),
+        lines(
+            "function Widget() {}",
+            "Widget.prototype = {",
+            "  frob: function() {",
+            "    search();",
+            "  }",
+            "};",
+            "function search() {",
+            "  if (true)",
+            "    alert(1);",
+            "  else",
+            "    alert(2);",
+            "}",
+            "window.foo = new Widget();",
+            "window.bar = search;"));
   }
 
   // Test respect for scopes and blocks
@@ -1545,15 +2112,40 @@ public final class InlineVariablesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testLateGuardedAssign() {
+    test(
+        lines(
+            "", //
+            "let x;",
+            "function f() {",
+            "  x === void 0 && (x = 1);",
+            "  const y = x;",
+            "  use(y);",
+            "}",
+            ""),
+        lines(
+            "", //
+            "let x;",
+            "function f() {",
+            "  x === void 0 && (x = 1);",
+            "",
+            "  use(x);",
+            "}",
+            ""));
+  }
+
+  @Test
   public void testLetConst() {
     test(
         lines(
+            "", //
             "function f(x) {",
             "  if (true) {",
             "    let y = x; y; y;",
             "  }",
             "}"),
         lines(
+            "", //
             "function f(x) {",
             "  if (true) {",
             "    x; x;",
@@ -1562,12 +2154,14 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
     test(
         lines(
+            "", //
             "function f(x) {",
             "  if (true) {",
             "    const y = x; y; y;",
             "    }",
             "  }"),
         lines(
+            "", //
             "function f(x) {",
             "  if (true) {",
             "    x; x;",
@@ -1576,6 +2170,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
     test(
         lines(
+            "", //
             "function f(x) {",
             "  let y;",
             "  {",
@@ -1583,6 +2178,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
             "  }",
             "}"),
         lines(
+            "", //
             "function f(x) {",
             "  let y;",
             "  {",
@@ -1599,6 +2195,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
             "  }",
             "}"),
         lines(
+            "", //
             "function f(x) {",
             "  x; const g = 2;",
             "  {3;}",
@@ -1609,24 +2206,26 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testGenerators() {
     test(
         lines(
+            "", //
             "function* f() {",
             "  let x = 1;",
             "  yield x;",
-            "}"
-        ),
+            "}"),
         lines(
+            "", //
             "function* f() {",
             "  yield 1;",
             "}"));
 
     test(
         lines(
+            "", //
             "function* f(x) {",
             "  let y = x++",
             "  yield y;",
-            "}"
-        ),
+            "}"),
         lines(
+            "", //
             "function* f(x) {",
             "  yield x++;",
             "}"));
@@ -1641,14 +2240,17 @@ public final class InlineVariablesTest extends CompilerTestCase {
 
   @Test
   public void testTemplateStrings() {
-    test(" var name = 'Foo'; `Hello ${name}`",
-        "`Hello ${'Foo'}`");
+    test(
+        " var name = 'Foo'; `Hello ${name}`", //
+        "                   `Hello ${'Foo'}`");
 
-    test(" var name = 'Foo'; var foo = name; `Hello ${foo}`",
-        " `Hello ${'Foo'}`");
+    test(
+        "var name = 'Foo'; var foo = name; `Hello ${foo}`", //
+        "                                  `Hello ${'Foo'}`");
 
-    test(" var age = 3; `Age: ${age}`",
-        "`Age: ${3}`");
+    test(
+        "var age = 3; `Age: ${age}`", //
+        "             `Age: ${3}`");
   }
 
   @Test
@@ -1664,8 +2266,7 @@ public final class InlineVariablesTest extends CompilerTestCase {
             "    modStr = nameExp + 'BarBar'",
             "  }",
             "}",
-            "var output = myTag`My name is ${name} ${3}`;"
-        ),
+            "var output = myTag`My name is ${name} ${3}`;"),
         lines(
             "var output = function myTag(strings, nameExp, numExp) {",
             "  var modStr;",
@@ -1706,11 +2307,12 @@ public final class InlineVariablesTest extends CompilerTestCase {
   public void testDestructuring() {
     test(
         lines(
+            "", //
             "var [a, b, c] = [1, 2, 3]",
             "var x = a;",
-            "x; x;"
-        ),
+            "x; x;"),
         lines(
+            "", //
             "var [a, b, c] = [1, 2, 3]",
             "a; a;"));
 
@@ -1725,12 +2327,12 @@ public final class InlineVariablesTest extends CompilerTestCase {
   @Test
   public void testFunctionInlinedAcrossScript() {
     String[] srcs = {
-      "function f() {}",
+      "function f() {}", //
       "use(f);"
     };
 
     String[] expected = {
-      "",
+      "", //
       "use(function f() {});"
     };
 
diff --git a/test/com/google/javascript/jscomp/JSDocInfoPrinterTest.java b/test/com/google/javascript/jscomp/JSDocInfoPrinterTest.java
index 100ae06..44fe411 100644
--- a/test/com/google/javascript/jscomp/JSDocInfoPrinterTest.java
+++ b/test/com/google/javascript/jscomp/JSDocInfoPrinterTest.java
@@ -620,6 +620,16 @@ public final class JSDocInfoPrinterTest {
                 ""));
   }
 
+  @Test
+  public void testDeprecated_noReason() {
+    builder.recordDeprecated();
+    builder.recordType(
+        new JSTypeExpression(JsDocInfoParser.parseTypeString("string"), "<testDeprecated>"));
+    JSDocInfo info = builder.buildAndReset();
+    assertThat(jsDocInfoPrinter.print(info))
+        .isEqualTo(LINE_JOINER.join("/**", " * @type {string}", " * @deprecated", " */", ""));
+  }
+
   // Tests that a {@code @see} is sufficient to populate a JSDocInfo.
   @Test
   public void testJSDocIsPopulated_withSeeReferenceAlone() {
diff --git a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
index 624d6d0..3aa39ea 100644
--- a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableMap;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -31,10 +32,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit test for {@link JsMessageExtractor}.
- *
- */
+/** Unit test for {@link JsMessageExtractor}. */
 @RunWith(JUnit4.class)
 public final class JsMessageExtractorTest {
 
@@ -86,13 +84,52 @@ public final class JsMessageExtractorTest {
   public void testExtractNewStyleMessage1() {
     // A simple message with no description.
     assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendStringPart("silly test message")
-            .build(),
+        new JsMessage.Builder("MSG_SILLY").appendStringPart("silly test message").build(),
         extractMessage("var MSG_SILLY = goog.getMsg('silly test message');"));
   }
 
   @Test
+  public void testOriginalCodeAndExampleMaps() {
+    // A message with placeholders and original code annotations.
+    assertEquals(
+        new JsMessage.Builder("MSG_WELCOME")
+            .appendStringPart("Hi ")
+            .appendPlaceholderReference("interpolation_0")
+            .appendStringPart("! Welcome to ")
+            .appendPlaceholderReference("interpolation_1")
+            .appendStringPart(".")
+            .setPlaceholderNameToOriginalCodeMap(
+                ImmutableMap.of(
+                    "interpolation_0", "foo.getUserName()",
+                    "interpolation_1", "bar.getProductName()"))
+            .setPlaceholderNameToExampleMap(
+                ImmutableMap.of(
+                    "interpolation_0", "Ginny Weasley",
+                    "interpolation_1", "Google Muggle Finder"))
+            .setDesc("The welcome message.")
+            .build(),
+        extractMessage(
+            "/** @desc The welcome message. */",
+            "var MSG_WELCOME = goog.getMsg(",
+            "    'Hi {$interpolation_0}! Welcome to {$interpolation_1}.',",
+            "    {",
+            "        'interpolation_0': 'magic-string-0',",
+            "        'interpolation_1': 'magic-string-1',",
+            "    },",
+            "    {",
+            "        original_code: {",
+            "            'interpolation_0': 'foo.getUserName()',",
+            "            'interpolation_1': 'bar.getProductName()',",
+            "        },",
+            "        example: {",
+            "            'interpolation_0': 'Ginny Weasley',",
+            "            'interpolation_1': 'Google Muggle Finder',",
+            "        },",
+            "    },",
+            ");"));
+  }
+
+  @Test
   public void testExtractNewStyleMessage2() {
     // A message with placeholders and meta data.
     assertEquals(
@@ -126,8 +163,7 @@ public final class JsMessageExtractorTest {
             .setDesc("Description.")
             .build(),
         extractMessage(
-            "var MSG_SILLY_HELP = 'Description.';",
-            "var MSG_SILLY = 'silly test message';"));
+            "var MSG_SILLY_HELP = 'Description.';", "var MSG_SILLY = 'silly test message';"));
   }
 
   @Test
@@ -139,8 +175,7 @@ public final class JsMessageExtractorTest {
             .setDesc("Description.")
             .build(),
         extractMessage(
-            "var MSG_SILLY = 'silly test message';",
-            "var MSG_SILLY_HELP = 'Descrip' + 'tion.';"));
+            "var MSG_SILLY = 'silly test message';", "var MSG_SILLY_HELP = 'Descrip' + 'tion.';"));
   }
 
   @Test
@@ -162,16 +197,18 @@ public final class JsMessageExtractorTest {
   @Test
   public void testExtractMixedMessages() {
     // Several mixed-style messages in succession, one containing newlines.
-    Iterator<JsMessage> msgs = extractMessages(
-        "var MSG_MONEY = function(amount) {",
-        "  return 'You owe $' + amount +",
-        "         ' to the credit card company.';",
-        "};",
-        "var MSG_TIME = goog.getMsg('You need to finish your work in ' +",
-        "                           '{$duration} hours.', {'duration': d});",
-        "var MSG_NAG = 'Clean your room.\\n\\nWash your clothes.';",
-        "var MSG_NAG_HELP = 'Just some ' +",
-        "                   'nags.';").iterator();
+    Iterator<JsMessage> msgs =
+        extractMessages(
+                "var MSG_MONEY = function(amount) {",
+                "  return 'You owe $' + amount +",
+                "         ' to the credit card company.';",
+                "};",
+                "var MSG_TIME = goog.getMsg('You need to finish your work in ' +",
+                "                           '{$duration} hours.', {'duration': d});",
+                "var MSG_NAG = 'Clean your room.\\n\\nWash your clothes.';",
+                "var MSG_NAG_HELP = 'Just some ' +",
+                "                   'nags.';")
+            .iterator();
 
     assertEquals(
         new JsMessage.Builder("MSG_MONEY")
@@ -199,13 +236,14 @@ public final class JsMessageExtractorTest {
   public void testDuplicateUnnamedVariables() {
     // Make sure that duplicate unnamed variables don't get swallowed when using
     // a Google-specific ID generator.
-    Collection<JsMessage> msgs = extractMessages(
-        "function a() {",
-        "  var MSG_UNNAMED_2 = goog.getMsg('foo');",
-        "}",
-        "function b() {",
-        "  var MSG_UNNAMED_2 = goog.getMsg('bar');",
-        "}");
+    Collection<JsMessage> msgs =
+        extractMessages(
+            "function a() {",
+            "  var MSG_UNNAMED_2 = goog.getMsg('foo');",
+            "}",
+            "function b() {",
+            "  var MSG_UNNAMED_2 = goog.getMsg('bar');",
+            "}");
 
     assertThat(msgs).hasSize(2);
     final Iterator<JsMessage> iter = msgs.iterator();
@@ -215,18 +253,20 @@ public final class JsMessageExtractorTest {
 
   @Test
   public void testMeaningAnnotation() {
-    List<JsMessage> msgs = new ArrayList<>(
-        extractMessages(
-            "var MSG_UNNAMED_1 = goog.getMsg('foo');",
-            "var MSG_UNNAMED_2 = goog.getMsg('foo');"));
+    List<JsMessage> msgs =
+        new ArrayList<>(
+            extractMessages(
+                "var MSG_UNNAMED_1 = goog.getMsg('foo');",
+                "var MSG_UNNAMED_2 = goog.getMsg('foo');"));
     assertThat(msgs).hasSize(2);
     assertThat(msgs.get(0).getId()).isEqualTo(msgs.get(1).getId());
     assertEquals(msgs.get(0), msgs.get(1));
 
-    msgs = new ArrayList<>(
-        extractMessages(
-            "var MSG_UNNAMED_1 = goog.getMsg('foo');",
-            "/** @meaning bar */ var MSG_UNNAMED_2 = goog.getMsg('foo');"));
+    msgs =
+        new ArrayList<>(
+            extractMessages(
+                "var MSG_UNNAMED_1 = goog.getMsg('foo');",
+                "/** @meaning bar */ var MSG_UNNAMED_2 = goog.getMsg('foo');"));
     assertThat(msgs).hasSize(2);
     assertThat(msgs.get(0).getId().equals(msgs.get(1).getId())).isFalse();
   }
diff --git a/test/com/google/javascript/jscomp/JsMessageTest.java b/test/com/google/javascript/jscomp/JsMessageTest.java
index 91ff590..d828ff2 100644
--- a/test/com/google/javascript/jscomp/JsMessageTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageTest.java
@@ -22,7 +22,9 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** @author anatol@google.com (Anatol Pomazau) */
+/**
+ * @author anatol@google.com (Anatol Pomazau)
+ */
 @RunWith(JUnit4.class)
 public final class JsMessageTest {
 
@@ -39,10 +41,8 @@ public final class JsMessageTest {
 
   @Test
   public void testMeaningChangesId() {
-    String id1 = new JsMessage.Builder()
-        .appendStringPart("foo").build().getId();
-    String id2 = new JsMessage.Builder()
-        .appendStringPart("foo").setMeaning("bar").build().getId();
+    String id1 = new JsMessage.Builder().appendStringPart("foo").build().getId();
+    String id2 = new JsMessage.Builder().appendStringPart("foo").setMeaning("bar").build().getId();
     assertThat(id1.equals(id2)).isFalse();
   }
 
@@ -73,6 +73,19 @@ public final class JsMessageTest {
   }
 
   @Test
+  public void testGenerateIdWithGoogScope() {
+    JsMessage msg1 =
+        new JsMessage.Builder().setDesc("Hello.").setKey("$jscomp$scope$12345$0$MSG_HELLO").build();
+    assertThat(msg1.getDesc()).isEqualTo("Hello.");
+    assertThat(msg1.getId()).isEqualTo("MSG_HELLO");
+
+    JsMessage msg2 =
+        new JsMessage.Builder().setDesc("Test.").setKey("$jscomp$scope$m12345$0$MSG_TEST").build();
+    assertThat(msg2.getDesc()).isEqualTo("Test.");
+    assertThat(msg2.getId()).isEqualTo("MSG_TEST");
+  }
+
+  @Test
   public void testAlternateId() {
     JsMessage msg =
         new JsMessage.Builder()
diff --git a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
index b03b0a8..1a1a839 100644
--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
@@ -43,10 +43,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Test for {@link JsMessageVisitor}.
- *
- */
+/** Test for {@link JsMessageVisitor}. */
 @RunWith(JUnit4.class)
 public final class JsMessageVisitorTest {
   private static final Joiner LINE_JOINER = Joiner.on('\n');
@@ -86,8 +83,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testJsMessageOnVar() {
-    extractMessagesSafely(
-        "/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')");
+    extractMessagesSafely("/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -100,8 +96,7 @@ public final class JsMessageVisitorTest {
   @Test
   public void testJsMessageOnLet() {
     compilerOptions = new CompilerOptions();
-    extractMessagesSafely(
-        "/** @desc Hello */ let MSG_HELLO = goog.getMsg('a')");
+    extractMessagesSafely("/** @desc Hello */ let MSG_HELLO = goog.getMsg('a')");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -114,8 +109,7 @@ public final class JsMessageVisitorTest {
   @Test
   public void testJsMessageOnConst() {
     compilerOptions = new CompilerOptions();
-    extractMessagesSafely(
-        "/** @desc Hello */ const MSG_HELLO = goog.getMsg('a')");
+    extractMessagesSafely("/** @desc Hello */ const MSG_HELLO = goog.getMsg('a')");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -128,21 +122,30 @@ public final class JsMessageVisitorTest {
   @Test
   public void testJsMessagesWithSrcMap() throws Exception {
     SourceMapGeneratorV3 sourceMap = new SourceMapGeneratorV3();
-    sourceMap.addMapping("source1.html", null, new FilePosition(10, 0),
-        new FilePosition(0, 0), new FilePosition(0, 100));
-    sourceMap.addMapping("source2.html", null, new FilePosition(10, 0),
-        new FilePosition(1, 0), new FilePosition(1, 100));
+    sourceMap.addMapping(
+        "source1.html",
+        null,
+        new FilePosition(10, 0),
+        new FilePosition(0, 0),
+        new FilePosition(0, 100));
+    sourceMap.addMapping(
+        "source2.html",
+        null,
+        new FilePosition(10, 0),
+        new FilePosition(1, 0),
+        new FilePosition(1, 100));
     StringBuilder output = new StringBuilder();
     sourceMap.appendTo(output, "unused.js");
 
     compilerOptions = new CompilerOptions();
-    compilerOptions.inputSourceMaps = ImmutableMap.of(
-       "[testcode]", new SourceMapInput(
-           SourceFile.fromCode("example.srcmap", output.toString())));
+    compilerOptions.inputSourceMaps =
+        ImmutableMap.of(
+            "[testcode]",
+            new SourceMapInput(SourceFile.fromCode("example.srcmap", output.toString())));
 
     extractMessagesSafely(
         "/** @desc Hello */ var MSG_HELLO = goog.getMsg('a');\n"
-        + "/** @desc Hi */ var MSG_HI = goog.getMsg('b');\n");
+            + "/** @desc Hi */ var MSG_HI = goog.getMsg('b');\n");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(2);
 
@@ -159,8 +162,8 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testJsMessageOnProperty() {
-    extractMessagesSafely("/** @desc a */ " +
-        "pint.sub.MSG_MENU_MARK_AS_UNREAD = goog.getMsg('a')");
+    extractMessagesSafely(
+        "/** @desc a */ " + "pint.sub.MSG_MENU_MARK_AS_UNREAD = goog.getMsg('a')");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -192,12 +195,7 @@ public final class JsMessageVisitorTest {
   public void testMsgInEnum() {
     extractMessages(
         LINE_JOINER.join(
-            "/**",
-            " * @enum {number}",
-            " */",
-            "var MyEnum = {",
-            "  MSG_ONE: 0",
-            "};"));
+            "/**", " * @enum {number}", " */", "var MyEnum = {", "  MSG_ONE: 0", "};"));
     assertThat(compiler.getErrors()).hasSize(1);
     assertError(compiler.getErrors().get(0)).hasType(MESSAGE_TREE_MALFORMED);
   }
@@ -221,9 +219,8 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testJsMessageOnObjLit() {
-    extractMessagesSafely("" +
-        "pint.sub = {" +
-        "/** @desc a */ MSG_MENU_MARK_AS_UNREAD: goog.getMsg('a')}");
+    extractMessagesSafely(
+        "" + "pint.sub = {" + "/** @desc a */ MSG_MENU_MARK_AS_UNREAD: goog.getMsg('a')}");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -234,20 +231,19 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testInvalidJsMessageOnObjLit() {
-    extractMessages(""
-        + "pint.sub = {"
-        + "  /** @desc a */ MSG_MENU_MARK_AS_UNREAD: undefined"
-        + "}");
+    extractMessages(
+        "" + "pint.sub = {" + "  /** @desc a */ MSG_MENU_MARK_AS_UNREAD: undefined" + "}");
     assertThat(compiler.getErrors()).hasSize(1);
     assertError(compiler.getErrors().get(0)).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
   }
 
   @Test
   public void testJsMessageAliasOnObjLit() {
-    extractMessagesSafely(""
-        + "pint.sub = {"
-        + "  MSG_MENU_MARK_AS_UNREAD: another.namespace.MSG_MENU_MARK_AS_UNREAD"
-        + "}");
+    extractMessagesSafely(
+        ""
+            + "pint.sub = {"
+            + "  MSG_MENU_MARK_AS_UNREAD: another.namespace.MSG_MENU_MARK_AS_UNREAD"
+            + "}");
   }
 
   @Test
@@ -289,11 +285,12 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testMessageDefinedInExportsIsNotOrphaned() {
-    extractMessagesSafely(""
-        + "exports = {"
-        + "  /** @desc Description. */"
-        + "  MSG_FOO: goog.getMsg('Foo'),"
-        + "};");
+    extractMessagesSafely(
+        ""
+            + "exports = {"
+            + "  /** @desc Description. */"
+            + "  MSG_FOO: goog.getMsg('Foo'),"
+            + "};");
     assertThat(compiler.getWarnings()).isEmpty();
   }
 
@@ -410,8 +407,8 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testLegacyFormatDescription() {
-    extractMessagesSafely("var MSG_SILLY = 'silly test message';\n"
-        + "var MSG_SILLY_HELP = 'help text';");
+    extractMessagesSafely(
+        "var MSG_SILLY = 'silly test message';\n" + "var MSG_SILLY_HELP = 'help text';");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -422,9 +419,10 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testLegacyFormatParametizedFunction() {
-    extractMessagesSafely("var MSG_SILLY = function(one, two) {"
-        + "  return one + ', ' + two + ', buckle my shoe';"
-        + "};");
+    extractMessagesSafely(
+        "var MSG_SILLY = function(one, two) {"
+            + "  return one + ', ' + two + ', buckle my shoe';"
+            + "};");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -437,8 +435,7 @@ public final class JsMessageVisitorTest {
   public void testLegacyMessageWithDescAnnotation() {
     // Well, is was better do not allow legacy messages with @desc annotations,
     // but people love to mix styles so we need to check @desc also.
-    extractMessagesSafely(
-        "/** @desc The description */ var MSG_A = 'The Message';");
+    extractMessagesSafely("/** @desc The description */ var MSG_A = 'The Message';");
 
     assertThat(messages).hasSize(1);
     assertThat(compiler.getWarnings()).isEmpty();
@@ -455,8 +452,8 @@ public final class JsMessageVisitorTest {
     // Well, is was better do not allow legacy messages with @desc annotations,
     // but people love to mix styles so we need to check @desc also.
     extractMessagesSafely(
-        "var MSG_A_HELP = 'This is a help var';\n" +
-        "/** @desc The description in @desc*/ var MSG_A = 'The Message';");
+        "var MSG_A_HELP = 'This is a help var';\n"
+            + "/** @desc The description in @desc*/ var MSG_A = 'The Message';");
 
     assertThat(messages).hasSize(1);
     assertThat(compiler.getWarnings()).hasSize(1);
@@ -468,8 +465,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testClosureMessageWithHelpPostfix() {
-    extractMessagesSafely("/** @desc help text */\n"
-        + "var MSG_FOO_HELP = goog.getMsg('Help!');");
+    extractMessagesSafely("/** @desc help text */\n" + "var MSG_FOO_HELP = goog.getMsg('Help!');");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -533,9 +529,10 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testClosureFormatParametizedFunction() {
-    extractMessagesSafely("/** @desc help text */"
-        + "var MSG_SILLY = goog.getMsg('{$adjective} ' + 'message', "
-        + "{'adjective': 'silly'});");
+    extractMessagesSafely(
+        "/** @desc help text */"
+            + "var MSG_SILLY = goog.getMsg('{$adjective} ' + 'message', "
+            + "{'adjective': 'silly'});");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -546,26 +543,27 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testHugeMessage() {
-    extractMessagesSafely("/**" +
-        " * @desc A message with lots of stuff.\n" +
-        " * @hidden\n" +
-        " */" +
-        "var MSG_HUGE = goog.getMsg(" +
-        "    '{$startLink_1}Google{$endLink}' +" +
-        "    '{$startLink_2}blah{$endLink}{$boo}{$foo_001}{$boo}' +" +
-        "    '{$foo_002}{$xxx_001}{$image}{$image_001}{$xxx_002}'," +
-        "    {'startLink_1': '<a href=http://www.google.com/>'," +
-        "     'endLink': '</a>'," +
-        "     'startLink_2': '<a href=\"' + opt_data.url + '\">'," +
-        "     'boo': opt_data.boo," +
-        "     'foo_001': opt_data.foo," +
-        "     'foo_002': opt_data.boo.foo," +
-        "     'xxx_001': opt_data.boo + opt_data.foo," +
-        "     'image': htmlTag7," +
-        "     'image_001': opt_data.image," +
-        "     'xxx_002': foo.callWithOnlyTopLevelKeys(" +
-        "         bogusFn, opt_data, null, 'bogusKey1'," +
-        "         opt_data.moo, 'bogusKey2', param10)});");
+    extractMessagesSafely(
+        "/**"
+            + " * @desc A message with lots of stuff.\n"
+            + " * @hidden\n"
+            + " */"
+            + "var MSG_HUGE = goog.getMsg("
+            + "    '{$startLink_1}Google{$endLink}' +"
+            + "    '{$startLink_2}blah{$endLink}{$boo}{$foo_001}{$boo}' +"
+            + "    '{$foo_002}{$xxx_001}{$image}{$image_001}{$xxx_002}',"
+            + "    {'startLink_1': '<a href=http://www.google.com/>',"
+            + "     'endLink': '</a>',"
+            + "     'startLink_2': '<a href=\"' + opt_data.url + '\">',"
+            + "     'boo': opt_data.boo,"
+            + "     'foo_001': opt_data.foo,"
+            + "     'foo_002': opt_data.boo.foo,"
+            + "     'xxx_001': opt_data.boo + opt_data.foo,"
+            + "     'image': htmlTag7,"
+            + "     'image_001': opt_data.image,"
+            + "     'xxx_002': foo.callWithOnlyTopLevelKeys("
+            + "         bogusFn, opt_data, null, 'bogusKey1',"
+            + "         opt_data.moo, 'bogusKey2', param10)});");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -603,8 +601,8 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testEmptyTextComplexMessage() {
-    extractMessagesSafely("/** @desc text */ var MSG_BAR = goog.getMsg("
-        + "'' + '' + ''     + ''\n+'');");
+    extractMessagesSafely(
+        "/** @desc text */ var MSG_BAR = goog.getMsg(" + "'' + '' + ''     + ''\n+'');");
 
     assertThat(messages).hasSize(1);
     assertThat(compiler.getWarnings())
@@ -676,13 +674,14 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testExtractPropertyMessage() {
-    extractMessagesSafely("/**"
-        + " * @desc A message that demonstrates placeholders\n"
-        + " * @hidden\n"
-        + " */"
-        + "a.b.MSG_SILLY = goog.getMsg(\n"
-        + "    '{$adjective} ' + '{$someNoun}',\n"
-        + "    {'adjective': adj, 'someNoun': noun});");
+    extractMessagesSafely(
+        "/**"
+            + " * @desc A message that demonstrates placeholders\n"
+            + " * @hidden\n"
+            + " */"
+            + "a.b.MSG_SILLY = goog.getMsg(\n"
+            + "    '{$adjective} ' + '{$someNoun}',\n"
+            + "    {'adjective': adj, 'someNoun': noun});");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -694,16 +693,17 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testExtractPropertyMessageInFunction() {
-    extractMessagesSafely(""
-        + "function f() {\n"
-        + "  /**\n"
-        + "   * @desc A message that demonstrates placeholders\n"
-        + "   * @hidden\n"
-        + "   */\n"
-        + "  a.b.MSG_SILLY = goog.getMsg(\n"
-        + "      '{$adjective} ' + '{$someNoun}',\n"
-        + "      {'adjective': adj, 'someNoun': noun});\n"
-        + "}");
+    extractMessagesSafely(
+        ""
+            + "function f() {\n"
+            + "  /**\n"
+            + "   * @desc A message that demonstrates placeholders\n"
+            + "   * @hidden\n"
+            + "   */\n"
+            + "  a.b.MSG_SILLY = goog.getMsg(\n"
+            + "      '{$adjective} ' + '{$someNoun}',\n"
+            + "      {'adjective': adj, 'someNoun': noun});\n"
+            + "}");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -715,8 +715,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testAlmostButNotExternalMessage() {
-    extractMessagesSafely(
-        "/** @desc External */ var MSG_EXTERNAL = goog.getMsg('External');");
+    extractMessagesSafely("/** @desc External */ var MSG_EXTERNAL = goog.getMsg('External');");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
     assertThat(messages.get(0).isExternal()).isFalse();
@@ -794,8 +793,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testUnusedReferenesAreNotOK() {
-    extractMessages("/** @desc AA */ "
-        + "var MSG_FOO = goog.getMsg('lalala:', {foo:1});");
+    extractMessages("/** @desc AA */ " + "var MSG_FOO = goog.getMsg('lalala:', {foo:1});");
     assertThat(messages).isEmpty();
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
@@ -807,8 +805,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testDuplicatePlaceHoldersAreBad() {
-    extractMessages("var MSG_FOO = goog.getMsg("
-        + "'{$foo}:', {'foo': 1, 'foo' : 2});");
+    extractMessages("var MSG_FOO = goog.getMsg(" + "'{$foo}:', {'foo': 1, 'foo' : 2});");
 
     assertThat(messages).isEmpty();
     ImmutableList<JSError> errors = compiler.getErrors();
@@ -821,8 +818,7 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testDuplicatePlaceholderReferencesAreOk() {
-    extractMessagesSafely("var MSG_FOO = goog.getMsg("
-        + "'{$foo}:, {$foo}', {'foo': 1});");
+    extractMessagesSafely("var MSG_FOO = goog.getMsg(" + "'{$foo}:, {$foo}', {'foo': 1});");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -831,8 +827,9 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testCamelcasePlaceholderNamesAreOk() {
-    extractMessagesSafely("var MSG_WITH_CAMELCASE = goog.getMsg("
-        + "'Slide {$slideNumber}:', {'slideNumber': opt_index + 1});");
+    extractMessagesSafely(
+        "var MSG_WITH_CAMELCASE = goog.getMsg("
+            + "'Slide {$slideNumber}:', {'slideNumber': opt_index + 1});");
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
@@ -845,8 +842,9 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testWithNonCamelcasePlaceholderNamesAreNotOk() {
-    extractMessages("var MSG_WITH_CAMELCASE = goog.getMsg("
-        + "'Slide {$slide_number}:', {'slide_number': opt_index + 1});");
+    extractMessages(
+        "var MSG_WITH_CAMELCASE = goog.getMsg("
+            + "'Slide {$slide_number}:', {'slide_number': opt_index + 1});");
 
     assertThat(messages).isEmpty();
     ImmutableList<JSError> errors = compiler.getErrors();
@@ -861,8 +859,8 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testUnquotedPlaceholdersAreOk() {
-    extractMessagesSafely("/** @desc Hello */ "
-        + "var MSG_FOO = goog.getMsg('foo {$unquoted}:', {unquoted: 12});");
+    extractMessagesSafely(
+        "/** @desc Hello */ " + "var MSG_FOO = goog.getMsg('foo {$unquoted}:', {unquoted: 12});");
 
     assertThat(messages).hasSize(1);
     assertThat(compiler.getWarnings()).isEmpty();
@@ -894,8 +892,8 @@ public final class JsMessageVisitorTest {
   @Test
   public void testDuplicateMessageError() {
     extractMessages(
-        "(function () {/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')})" +
-        "(function () {/** @desc Hello2 */ var MSG_HELLO = goog.getMsg('a')})");
+        "(function () {/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')})"
+            + "(function () {/** @desc Hello2 */ var MSG_HELLO = goog.getMsg('a')})");
 
     assertThat(compiler.getWarnings()).isEmpty();
     assertOneError(JsMessageVisitor.MESSAGE_DUPLICATE_KEY);
@@ -904,21 +902,21 @@ public final class JsMessageVisitorTest {
   @Test
   public void testNoDuplicateErrorOnExternMessage() {
     extractMessagesSafely(
-        "(function () {/** @desc Hello */ " +
-        "var MSG_EXTERNAL_2 = goog.getMsg('a')})" +
-        "(function () {/** @desc Hello2 */ " +
-        "var MSG_EXTERNAL_2 = goog.getMsg('a')})");
+        "(function () {/** @desc Hello */ "
+            + "var MSG_EXTERNAL_2 = goog.getMsg('a')})"
+            + "(function () {/** @desc Hello2 */ "
+            + "var MSG_EXTERNAL_2 = goog.getMsg('a')})");
   }
 
   @Test
   public void testUsingMsgPrefixWithFallback() {
     extractMessages(
-        "function f() {\n" +
-        "/** @desc Hello */ var MSG_UNNAMED_1 = goog.getMsg('hello');\n" +
-        "/** @desc Hello */ var MSG_UNNAMED_2 = goog.getMsg('hello');\n" +
-        "var x = goog.getMsgWithFallback(\n" +
-        "    MSG_UNNAMED_1, MSG_UNNAMED_2);\n" +
-        "}\n");
+        "function f() {\n"
+            + "/** @desc Hello */ var MSG_UNNAMED_1 = goog.getMsg('hello');\n"
+            + "/** @desc Hello */ var MSG_UNNAMED_2 = goog.getMsg('hello');\n"
+            + "var x = goog.getMsgWithFallback(\n"
+            + "    MSG_UNNAMED_1, MSG_UNNAMED_2);\n"
+            + "}\n");
     assertNoErrors();
   }
 
@@ -978,10 +976,10 @@ public final class JsMessageVisitorTest {
   @Test
   public void testErrorWhenUsingMsgPrefixWithFallback() {
     extractMessages(
-        "/** @desc Hello */ var MSG_HELLO_1 = goog.getMsg('hello');\n" +
-        "/** @desc Hello */ var MSG_HELLO_2 = goog.getMsg('hello');\n" +
-        "/** @desc Hello */ " +
-        "var MSG_HELLO_3 = goog.getMsgWithFallback(MSG_HELLO_1, MSG_HELLO_2);");
+        "/** @desc Hello */ var MSG_HELLO_1 = goog.getMsg('hello');\n"
+            + "/** @desc Hello */ var MSG_HELLO_2 = goog.getMsg('hello');\n"
+            + "/** @desc Hello */ "
+            + "var MSG_HELLO_3 = goog.getMsgWithFallback(MSG_HELLO_1, MSG_HELLO_2);");
     assertOneError(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
   }
 
@@ -989,8 +987,7 @@ public final class JsMessageVisitorTest {
   public void testRenamedMessages_var() {
     renameMessages = true;
 
-    extractMessagesSafely(
-        "/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')");
+    extractMessagesSafely("/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')");
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
@@ -1024,6 +1021,22 @@ public final class JsMessageVisitorTest {
     assertThat(msg.getDesc()).isEqualTo("Hello");
   }
 
+  @Test
+  public void testGetMsgWithGoogScope() {
+    extractMessagesSafely(
+        lines(
+            "/** @desc Suggestion Code found outside of <head> tag. */",
+            "var $jscomp$scope$12345$0$MSG_CONSUMER_SURVEY_CODE_OUTSIDE_BODY_TAG =",
+            "goog.getMsg('Code should be added to <body> tag.');"));
+    assertThat(compiler.getWarnings()).isEmpty();
+    assertThat(messages).hasSize(1);
+
+    JsMessage msg = messages.get(0);
+    assertThat(msg.getId()).isEqualTo("MSG_CONSUMER_SURVEY_CODE_OUTSIDE_BODY_TAG");
+    assertThat(msg.getKey())
+        .isEqualTo("$jscomp$scope$12345$0$MSG_CONSUMER_SURVEY_CODE_OUTSIDE_BODY_TAG");
+  }
+
   private void assertNoErrors() {
     assertThat(compiler.getErrors()).isEmpty();
   }
@@ -1060,8 +1073,7 @@ public final class JsMessageVisitorTest {
     }
 
     @Override
-    protected void processJsMessage(JsMessage message,
-        JsMessageDefinition definition) {
+    protected void processJsMessage(JsMessage message, JsMessageDefinition definition) {
       messages.add(message);
     }
   }
@@ -1073,8 +1085,7 @@ public final class JsMessageVisitorTest {
     }
 
     @Override
-    protected void processJsMessage(JsMessage message,
-        JsMessageDefinition definition) {
+    protected void processJsMessage(JsMessage message, JsMessageDefinition definition) {
       // no-op
     }
   }
diff --git a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
index 4a0b926..b450c5f 100644
--- a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
@@ -276,16 +276,17 @@ public final class LiveVariablesAnalysisTest {
 
   @Test
   public void testForAwaitOfLoopsVar() {
-    assertLiveBeforeX("var a; for await (a of [1, 2, 3]) {X:{}}", "a");
-    assertLiveAfterX("for await (var a of [1, 2, 3]) {X:{}}", "a");
-    assertLiveBeforeX("var a,b; for await (var y of a = [0, 1, 2]) { X:a[y] }", "a");
+    assertLiveBeforeX("var a; for await (a of [1, 2, 3]) {X:{}}", "a", true);
+    assertLiveAfterX("for await (var a of [1, 2, 3]) {X:{}}", "a", true);
+    assertLiveBeforeX("var a,b; for await (var y of a = [0, 1, 2]) { X:a[y] }", "a", true);
   }
 
   @Test
   public void testForAwaitOfLoopsDestructuring() {
-    assertLiveBeforeX("var key, value; X:for await ([key, value] of arr) {value;} value;", "value");
-    assertLiveBeforeX("let x = 3; X:for await (var [y = x] of arr) { y; }", "x");
-    assertLiveBeforeX("for await (let [key, value] of arr) { X: key; value; }", "key");
+    assertLiveBeforeX(
+        "var key, value; X:for await ([key, value] of arr) {value;} value;", "value", true);
+    assertLiveBeforeX("let x = 3; X:for await (var [y = x] of arr) { y; }", "x", true);
+    assertLiveBeforeX("for await (let [key, value] of arr) { X: key; value; }", "key", true);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/LocaleDataPassesTest.java b/test/com/google/javascript/jscomp/LocaleDataPassesTest.java
index 910894e..1b0e203 100644
--- a/test/com/google/javascript/jscomp/LocaleDataPassesTest.java
+++ b/test/com/google/javascript/jscomp/LocaleDataPassesTest.java
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.javascript.jscomp.LocaleDataPasses.ProtectGoogLocale;
 import com.google.javascript.rhino.Node;
 import org.junit.Before;
 import org.junit.Test;
@@ -74,23 +75,18 @@ public final class LocaleDataPassesTest extends CompilerTestCase {
         return new CompilerPass() {
           @Override
           public void process(Node externs, Node root) {
-            final LocaleDataPasses.ExtractAndProtect extract =
-                new LocaleDataPasses.ExtractAndProtect(compiler);
+            final ProtectGoogLocale extract = new ProtectGoogLocale(compiler);
             extract.process(externs, root);
-            compiler.setLocaleSubstitutionData(extract.getLocaleValuesDataMaps());
           }
         };
       case REPLACE_PROTECTED_DATA:
         return new CompilerPass() {
           @Override
           public void process(Node externs, Node root) {
-            final LocaleDataPasses.ExtractAndProtect extract =
-                new LocaleDataPasses.ExtractAndProtect(compiler);
+            final ProtectGoogLocale extract = new ProtectGoogLocale(compiler);
             extract.process(externs, root);
-            compiler.setLocaleSubstitutionData(extract.getLocaleValuesDataMaps());
             final LocaleDataPasses.LocaleSubstitutions subs =
-                new LocaleDataPasses.LocaleSubstitutions(
-                    compiler, compiler.getOptions().locale, compiler.getLocaleSubstitutionData());
+                new LocaleDataPasses.LocaleSubstitutions(compiler, compiler.getOptions().locale);
             subs.process(externs, root);
           }
         };
@@ -149,20 +145,6 @@ public final class LocaleDataPassesTest extends CompilerTestCase {
     multiTest(srcs(originalJs), expected(protectedJs), allExpected);
   }
 
-  /**
-   * Test for errors that are detected before attempting to look up the messages in the bundle.
-   *
-   * @param originalJs The original, input JS code
-   * @param diagnosticType expected error
-   */
-  private void multiTestProtectionError(
-      String originalJs, DiagnosticType diagnosticType, String description) {
-    // The PROTECT_DATA mode needs to add externs for the protection functions.
-    allowExternsChanges();
-    testMode = TestMode.PROTECT_DATA;
-    testError(originalJs, diagnosticType, description);
-  }
-
   @Test
   public void testBaseJsGoogLocaleRef() {
     // We're confirming that there won't be any error reported for the use of `goog.LOCALE`.
@@ -183,7 +165,7 @@ public final class LocaleDataPassesTest extends CompilerTestCase {
             " */",
             "goog.provide('some.Obj');",
             "goog.LOCALE = __JSC_LOCALE__;",
-            "console.log(goog.LOCALE);",
+            "console.log(__JSC_LOCALE__);",
             ""),
         new LocaleResult(
             "es_ES",
@@ -194,7 +176,7 @@ public final class LocaleDataPassesTest extends CompilerTestCase {
                 " */",
                 "goog.provide('some.Obj');",
                 "goog.LOCALE = 'es_ES';",
-                "console.log(goog.LOCALE);",
+                "console.log('es_ES');",
                 "")));
   }
 }
diff --git a/test/com/google/javascript/jscomp/MultiPassTest.java b/test/com/google/javascript/jscomp/MultiPassTest.java
index e174f30..a5fe6b1 100644
--- a/test/com/google/javascript/jscomp/MultiPassTest.java
+++ b/test/com/google/javascript/jscomp/MultiPassTest.java
@@ -95,8 +95,8 @@ public final class MultiPassTest extends CompilerTestCase {
   @Test
   public void testInlineVarsAndDeadCodeElim() {
     passes = new ArrayList<>();
-    addDeadCodeElimination();
     addInlineVariables();
+    addDeadCodeElimination();
     test("function f() { var x = 1; return x; x = 3; }", "function f() { return 1; }");
   }
 
@@ -420,7 +420,7 @@ public final class MultiPassTest extends CompilerTestCase {
             .setName("inlineVariables")
             .setRunInFixedPointLoop(true)
             .setInternalFactory(
-                (compiler) -> new InlineVariables(compiler, InlineVariables.Mode.ALL, true))
+                (compiler) -> new InlineVariables(compiler, InlineVariables.Mode.ALL))
             .setFeatureSet(ES2017_MODULES)
             .build());
   }
diff --git a/test/com/google/javascript/jscomp/NodeIteratorsTest.java b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
index 271430e..c7b1bc2 100644
--- a/test/com/google/javascript/jscomp/NodeIteratorsTest.java
+++ b/test/com/google/javascript/jscomp/NodeIteratorsTest.java
@@ -200,7 +200,7 @@ public final class NodeIteratorsTest {
     assertWithMessage("Variable X not found! " + root.toStringTree()).that(found).isTrue();
 
     List<Node> currentAncestors = searchIt.currentAncestors();
-    assertThat(currentAncestors.size() >= 3).isTrue();
+    assertThat(currentAncestors.size()).isAtLeast(3);
     Iterator<Node> moveIt =
         LocalVarMotion.forVar(
             compiler, currentAncestors.get(0), currentAncestors.get(1), currentAncestors.get(2));
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index 3c85b0e..bcb04f8 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -48,6 +48,7 @@ import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import static org.mockito.Mockito.verify;
 
+import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
@@ -3987,10 +3988,11 @@ public final class NodeUtilTest {
       assertThat(NodeUtil.isSimpleOperator(parseExpr("x = 5"))).isFalse();
       assertThat(NodeUtil.isSimpleOperator(parseExpr("x++"))).isFalse();
       assertThat(NodeUtil.isSimpleOperator(parseExpr("--y"))).isFalse();
-      // prop access are simple
+      // prop access with IN are simple
       assertThat(NodeUtil.isSimpleOperator(parseExpr("y in x"))).isTrue();
-      assertThat(NodeUtil.isSimpleOperator(parseExpr("x.y"))).isTrue();
-      assertThat(NodeUtil.isSimpleOperator(parseExpr("x[y]"))).isTrue();
+      // prop access have side effects because of getters/setters
+      assertThat(NodeUtil.isSimpleOperator(parseExpr("x.y"))).isFalse();
+      assertThat(NodeUtil.isSimpleOperator(parseExpr("x[y]"))).isFalse();
     }
 
     @Test
@@ -4736,6 +4738,29 @@ public final class NodeUtilTest {
     }
   }
 
+  @RunWith(JUnit4.class)
+  public static final class NodeMetricsTest {
+    @Test
+    public void testEstimateNumLines() {
+      assertThat(NodeUtil.estimateNumLines(parse(""))).isEqualTo(2);
+      assertThat(NodeUtil.estimateNumLines(parse("const x = 1;\nconst y = 2;\n"))).isEqualTo(3);
+      assertThat(
+              NodeUtil.estimateNumLines(
+                  parse(
+                      lines(
+                          "/* some",
+                          "long",
+                          "multi",
+                          "line",
+                          "comment",
+                          "*/",
+                          "const x = 1;",
+                          "const y = 2;",
+                          ""))))
+          .isEqualTo(9);
+    }
+  }
+
   private static Node getNameNodeFrom(String code, String name) {
     Node ast = parse(code);
     return getNameNode(ast, name);
@@ -4825,7 +4850,9 @@ public final class NodeUtilTest {
     return null;
   }
 
-  /** @return The first node in {@code tree} that is an array pattern or object pattern. */
+  /**
+   * @return The first node in {@code tree} that is an array pattern or object pattern.
+   */
   @Nullable
   private static Node getPattern(Node tree) {
     if (tree.isDestructuringPattern()) {
@@ -4847,4 +4874,8 @@ public final class NodeUtilTest {
   private static boolean isValidQualifiedName(String s) {
     return NodeUtil.isValidQualifiedName(FeatureSet.ES3, s);
   }
+
+  private static String lines(String... lines) {
+    return Joiner.on('\n').join(lines);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/OptimizeCallsIntegrationTest.java b/test/com/google/javascript/jscomp/OptimizeCallsIntegrationTest.java
index b216ff5..0f482a4 100644
--- a/test/com/google/javascript/jscomp/OptimizeCallsIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeCallsIntegrationTest.java
@@ -770,13 +770,17 @@ public final class OptimizeCallsIntegrationTest extends CompilerTestCase {
     test(
         "function f(c = 1, d = 2){};f(1,2,3);f(4,5,6)",
         "function f(            ){};f(     );f(     )");
-    testSame("function f(c = alert()){};f(undefined);f(4)");
+    test(
+        "function f(c = alert()){};f(undefined);f(4)",
+        "function f(c = alert()){};f(         );f(4)");
     test(
         "function f(c = alert()){};f();f()", //
         "function f(){var c = alert();};f();f()");
     // TODO(johnlenz): handle this like the "no value" case above and
     // allow the default value to inlined into the body.
-    testSame("function f(c = alert()){};f(undefined);f(undefined)");
+    test(
+        "function f(c = alert()){};f(undefined);f(undefined)",
+        "function f(c = alert()){};f(          );f(        )");
   }
 
   @Test
@@ -854,4 +858,22 @@ public final class OptimizeCallsIntegrationTest extends CompilerTestCase {
             "x.foo = function(param) { return param; };",
             "x.foo();"));
   }
+
+  @Test
+  public void testUndefinedLiterals_beforeOtherUnused() {
+    test(
+        lines(
+            "", //
+            "function foo(a, b) { use(a); }",
+            // check that this undefined gets removed if it is before another unused param
+            "foo(undefined, 3);",
+            "foo(void 0, 4);",
+            ""),
+        lines(
+            "", //
+            "function foo(a) { use(a); }",
+            "foo();",
+            "foo();",
+            ""));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/OptimizeParametersTest.java b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
index 70dcbad..8cd66a9 100644
--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
@@ -282,7 +282,7 @@ public final class OptimizeParametersTest extends CompilerTestCase {
     // so that this can be inlined into the function body
     testSame("function f(a = 2){} f(alert);");
 
-    testSame("function f(a = 2){} f(void 0);");
+    test("function f(a = 2){} f(void 0);", "function f(a = 2){} f();");
 
     // Make sure `sideEffects()` is always evaluated before `x`;
     testSame("var x = 0; function f(a = sideEffects(), b = x) {}; f(void 0, something);");
@@ -1832,4 +1832,55 @@ public final class OptimizeParametersTest extends CompilerTestCase {
             "}",
             "new C().x(1,2)"));
   }
+
+  @Test
+  public void testTrailingUndefinedLiterals() {
+    test(
+        "function foo(a) { use(a);}; foo(undefined); foo(2);",
+        "function foo(a) { use(a);}; foo(         ); foo(2);");
+  }
+
+  @Test
+  public void testTrailingUndefinedLiterals_multiple() {
+    test(
+        lines(
+            "", //
+            "function foo(a, b, c) { use(a, b, c); }",
+            "foo(undefined);",
+            "foo(undefined, void 0);",
+            "foo(undefined, void 0, undefined);",
+            "foo(2);",
+            ""),
+        lines(
+            "", //
+            "function foo(a, b, c) { use(a, b, c); }",
+            "foo();",
+            "foo();",
+            "foo();",
+            "foo(2);",
+            ""));
+  }
+
+  @Test
+  public void testTrailingUndefinedLiterals_functionRefsArguments() {
+    testSame("function foo(a) { use(arguments);}; foo(undefined); foo(2);");
+  }
+
+  @Test
+  public void testTrailingUndefinedLiterals_afterASpread() {
+    testSame("function foo(a,b) { use(a)}; foo(...[1], undefined, undefined);");
+    testSame("function foo(a,b) { use(a)}; foo(undefined, ...[1], undefined); foo(2);");
+  }
+
+  @Test
+  public void testTrailingUndefinedLiterals_afterAllFormalParameters() {
+    test(
+        "function foo(a, b) { use(a)}; foo('used', undefined, undefined, 2, 'a'); foo(2);",
+        "function foo(a, b) { use(a)}; foo('used');                               foo(2);");
+  }
+
+  @Test
+  public void testTrailingUndefinedLiterals_afterAllFormalParameters_sideEffects() {
+    testSame("function foo(a, b) { use(a)}; foo('used', undefined, sideEffects()); foo(2);");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
index af844cf..e37e41c 100644
--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
@@ -30,16 +30,12 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Random;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link PhaseOptimizer}.
- *
- */
+/** Tests for {@link PhaseOptimizer}. */
 @RunWith(JUnit4.class)
 public final class PhaseOptimizerTest {
   private final List<String> passesRun = new ArrayList<>();
@@ -186,43 +182,6 @@ public final class PhaseOptimizerTest {
   }
 
   @Test
-  public void testPassOrdering() {
-    Loop loop = optimizer.addFixedPointLoop();
-    List<String> optimalOrder = new ArrayList<>(
-        PhaseOptimizer.OPTIMAL_ORDER);
-    Random random = new Random();
-    while (!optimalOrder.isEmpty()) {
-      addLoopedPass(
-          loop, optimalOrder.remove(random.nextInt(optimalOrder.size())), 0);
-    }
-    optimizer.process(null, dummyRoot);
-    assertThat(passesRun).isEqualTo(PhaseOptimizer.OPTIMAL_ORDER);
-  }
-
-  @Test
-  public void testProgress() {
-    final List<Double> progressList = new ArrayList<>();
-    compiler = new Compiler() {
-      @Override void setProgress(double p, String name) {
-        progressList.add(p);
-      }
-    };
-    compiler.initCompilerOptionsIfTesting();
-    optimizer = new PhaseOptimizer(compiler, null).withProgress(
-        new PhaseOptimizer.ProgressRange(0, 100));
-    addOneTimePass("x1");
-    addOneTimePass("x2");
-    addOneTimePass("x3");
-    addOneTimePass("x4");
-    optimizer.process(null, dummyRoot);
-    assertThat(progressList).hasSize(4);
-    assertThat(Math.round(progressList.get(0))).isEqualTo(25);
-    assertThat(Math.round(progressList.get(1))).isEqualTo(50);
-    assertThat(Math.round(progressList.get(2))).isEqualTo(75);
-    assertThat(Math.round(progressList.get(3))).isEqualTo(100);
-  }
-
-  @Test
   public void testSetSkipUnsupportedPasses() {
     compiler.getOptions().setSkipUnsupportedPasses(true);
     addUnsupportedPass("testPassFactory");
@@ -247,19 +206,17 @@ public final class PhaseOptimizerTest {
         .containsExactly(FEATURES_NOT_SUPPORTED_BY_PASS);
   }
 
-  public void assertPasses(String ... names) {
+  public void assertPasses(String... names) {
     optimizer.process(null, dummyRoot);
     assertThat(passesRun).isEqualTo(ImmutableList.copyOf(names));
   }
 
   private void addOneTimePass(String name) {
-    optimizer.addOneTimePass(
-        createPassFactory(name, 0, true));
+    optimizer.addOneTimePass(createPassFactory(name, 0, true));
   }
 
   private void addLoopedPass(Loop loop, String name, int numChanges) {
-    loop.addLoopedPass(
-        createPassFactory(name, numChanges, false));
+    loop.addLoopedPass(createPassFactory(name, numChanges, false));
   }
 
   /** Adds a pass with the given name that does not support some of the features used in the AST. */
@@ -269,13 +226,11 @@ public final class PhaseOptimizerTest {
         createPassFactory(name, createPass(name, 0), true, FeatureSet.BARE_MINIMUM));
   }
 
-  private PassFactory createPassFactory(
-      String name, int numChanges, boolean isOneTime) {
+  private PassFactory createPassFactory(String name, int numChanges, boolean isOneTime) {
     return createPassFactory(name, createPass(name, numChanges), isOneTime);
   }
 
-  private PassFactory createPassFactory(
-      String name, final CompilerPass pass, boolean isOneTime) {
+  private PassFactory createPassFactory(String name, final CompilerPass pass, boolean isOneTime) {
     return createPassFactory(name, pass, isOneTime, FeatureSet.latest());
   }
 
@@ -293,7 +248,8 @@ public final class PhaseOptimizerTest {
     final PhaseOptimizerTest self = this;
     final int[] numChangesClosure = new int[] {numChanges};
     return new CompilerPass() {
-      @Override public void process(Node externs, Node root) {
+      @Override
+      public void process(Node externs, Node root) {
         passesRun.add(name);
         if (numChangesClosure[0] > 0) {
           numChangesClosure[0] = numChangesClosure[0] - 1;
diff --git a/test/com/google/javascript/jscomp/ProcessClosureProvidesAndRequiresTest.java b/test/com/google/javascript/jscomp/ProcessClosureProvidesAndRequiresTest.java
index a5a81ca..3f81cb9 100644
--- a/test/com/google/javascript/jscomp/ProcessClosureProvidesAndRequiresTest.java
+++ b/test/com/google/javascript/jscomp/ProcessClosureProvidesAndRequiresTest.java
@@ -194,6 +194,18 @@ public class ProcessClosureProvidesAndRequiresTest extends CompilerTestCase {
   }
 
   @Test
+  public void testProvideAlreadyProvided() {
+    test(
+        srcs(
+            lines(
+                "goog.provide('a.b')",
+                "/** @provideAlreadyProvided */",
+                "goog.provide('a.b.c')",
+                "a.b = something;")),
+        expected(lines("/** @const */ var a = {};", "a.b = something;")));
+  }
+
+  @Test
   public void testRemovalOfProvidedObjLit() {
     test(srcs("goog.provide('foo'); foo = 0;"), expected("var foo = 0;"));
     test(srcs("goog.provide('foo'); foo = {a: 0};"), expected("var foo = {a: 0};"));
diff --git a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
index 2a6feb0..64f0722 100644
--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
@@ -594,10 +594,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
             "externObj5.prototype.propWithAnnotatedStubAfter;");
 
     enableTypeCheck();
-    testSame(
-        externs(externs),
-        srcs("o.prototype.propWithAnnotatedStubAfter"),
-        warning(TypeValidator.DUP_VAR_DECLARATION_TYPE_MISMATCH));
+    testSame(externs(externs), srcs("o.prototype.propWithAnnotatedStubAfter"));
     assertThat(noSideEffectCalls).isEmpty();
   }
 
@@ -621,10 +618,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
             "externObj5.prototype.propWithAnnotatedStubAfter;");
 
     enableTypeCheck();
-    testSame(
-        externs(externs),
-        srcs("o.prototype.propWithAnnotatedStubAfter"),
-        warning(TypeValidator.DUP_VAR_DECLARATION));
+    testSame(externs(externs), srcs("o.prototype.propWithAnnotatedStubAfter"));
     assertThat(noSideEffectCalls).isEmpty();
   }
 
@@ -2695,7 +2689,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
     // TODO(b/127862986): We could consider iteration over a known Array value to be pure.
     assertNoPureCalls(
         lines(
-            "function foo(a) { for await (const t of a) { } }", //
+            "async function foo(a) { for await (const t of a) { } }", //
             "foo(x);"));
   }
 
@@ -2813,7 +2807,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
     assertNoPureCalls(
         lines(
             // We use an array-literal so that it's not just the iteration that's impure.
-            "function foo() { for await (const t of []) { } }", //
+            "async function foo() { for await (const t of []) { } }", //
             "foo();"));
   }
 
diff --git a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
index a0b2963..0a80042 100644
--- a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
+++ b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
@@ -104,7 +104,7 @@ public class RecoverableJsAstTest {
   }
 
   private void setSourceCode(String code) throws IOException {
-    Files.write(tempFile, code.getBytes(UTF_8));
+    Files.writeString(tempFile, code);
   }
 
   private SourceAst createRealAst() {
diff --git a/test/com/google/javascript/jscomp/RemoveTrailingCommaFromParamListTest.java b/test/com/google/javascript/jscomp/RemoveTrailingCommaFromParamListTest.java
index dd427b5..5641075 100644
--- a/test/com/google/javascript/jscomp/RemoveTrailingCommaFromParamListTest.java
+++ b/test/com/google/javascript/jscomp/RemoveTrailingCommaFromParamListTest.java
@@ -34,7 +34,7 @@ public class RemoveTrailingCommaFromParamListTest extends CompilerTestCase {
     enableTypeCheck();
     enableTypeInfoValidation();
     replaceTypesWithColors();
-    // TODO(b/211899097): enable multistage compilation
+    enableMultistageCompilation();
     // Trailing commas are not considered when comparing Nodes for equality, so we must do a text
     // comparison.
     disableCompareAsTree();
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedCodeNameAnalyzerTest.java b/test/com/google/javascript/jscomp/RemoveUnusedCodeNameAnalyzerTest.java
index 71e6571..49182df 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedCodeNameAnalyzerTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedCodeNameAnalyzerTest.java
@@ -77,8 +77,8 @@ public final class RemoveUnusedCodeNameAnalyzerTest extends CompilerTestCase {
   }
 
   private static class MarkNoSideEffectCallsAndRemoveUnusedCodeRunner implements CompilerPass {
-    PureFunctionIdentifier.Driver pureFunctionIdentifier;
-    RemoveUnusedCode removeUnusedCode;
+    final PureFunctionIdentifier.Driver pureFunctionIdentifier;
+    final RemoveUnusedCode removeUnusedCode;
 
     MarkNoSideEffectCallsAndRemoveUnusedCodeRunner(Compiler compiler) {
       this.pureFunctionIdentifier = new PureFunctionIdentifier.Driver(compiler);
@@ -820,66 +820,6 @@ public final class RemoveUnusedCodeNameAnalyzerTest extends CompilerTestCase {
   }
 
   @Test
-  public void testMixin1() {
-    testSame("Function.prototype.mixin = function(base) { goog.mixin(this.prototype, base); };");
-  }
-
-  @Test
-  public void testMixin2() {
-    testSame("var a = {}; goog.mixin(externfoo.prototype, a.prototype);");
-  }
-
-  @Test
-  public void testMixin3() {
-    test("var b = {}; goog.mixin(b.prototype, externfoo.prototype);", "");
-  }
-
-  @Test
-  public void testMixin4() {
-    testSame("var b = {}; goog.mixin(b.prototype, externfoo.prototype); new b()");
-  }
-
-  @Test
-  public void testMixin5() {
-    test(
-        lines(
-            "var b = {}; var c = {};",
-            "goog.mixin(b.prototype, externfoo.prototype);",
-            "goog.mixin(c.prototype, externfoo.prototype);",
-            "new b()"),
-        lines("var b = {};", "goog.mixin(b.prototype, externfoo.prototype);", "new b()"));
-  }
-
-  @Test
-  public void testMixin6() {
-    test(
-        lines(
-            "var b = {}; var c = {};",
-            "goog.mixin(c.prototype, externfoo.prototype), ",
-            "goog.mixin(b.prototype, externfoo.prototype);",
-            "new b()"),
-        lines(
-            "var b = {};            ",
-            "                                              ",
-            "goog.mixin(b.prototype, externfoo.prototype);",
-            "new b()"));
-  }
-
-  @Test
-  public void testMixin7() {
-    test(
-        lines(
-            "var b = {}; var c = {};",
-            "var d = (goog.mixin(c.prototype, externfoo.prototype), ",
-            "    goog.mixin(b.prototype, externfoo.prototype));",
-            "new b()"),
-        lines(
-            "var b = {};", // preserve newline
-            "goog.mixin(b.prototype, externfoo.prototype);",
-            "new b()"));
-  }
-
-  @Test
   public void testConstants1() {
     testSame("var bar = function(){}; var EXP_FOO = true; if (EXP_FOO) bar();");
   }
@@ -1320,30 +1260,6 @@ public final class RemoveUnusedCodeNameAnalyzerTest extends CompilerTestCase {
   }
 
   @Test
-  public void testUnintendedUseOfInheritsInLocalScope1() {
-    testSame(
-        "goog.mixin = function() {}; "
-            + "(function() { var x = {}; var y = {}; goog.mixin(x, y); })();");
-  }
-
-  @Test
-  public void testUnintendedUseOfInheritsInLocalScope3() {
-    testSame(
-        "goog.mixin = function() {}; "
-            + "var x = {}; var y = {}; (function() { goog.mixin(x, y); })(); "
-            + "window.alert(x);");
-  }
-
-  @Test
-  public void testUnintendedUseOfInheritsInLocalScope4() {
-    // Ensures that the "goog$mixin" variable doesn't get stripped out,
-    // even when it's only used in a local scope.
-    testSame(
-        "var goog$mixin = function() {}; "
-            + "(function() { var x = {}; var y = {}; goog$mixin(x, y); })();");
-  }
-
-  @Test
   public void testPrototypePropertySetInLocalScope1() {
     test(
         "(function() { var x = function(){}; x.prototype.bar = 3; })();",
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
index 8afe921..05b5a3b 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
@@ -57,7 +57,6 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
             "goog.reflect.object = function(obj, propertiesObj) {};",
             "goog.reflect.objectProperty = function(prop, obj) {};",
             "function goog$inherits(subClass, superClass) {}",
-            "function goog$mixin(dstPrototype, srcPrototype) {}",
             "function valueType$mixin(dstPrototype, srcPrototype, flags, ...args) {}",
             "function alert() {}",
             "function use() {}",
@@ -1269,34 +1268,6 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
   }
 
   @Test
-  public void testRemoveInheritedClass6() {
-    test(
-        lines(
-            "/** @constructor*/ function a(){}",
-            "/** @constructor*/ function b(){}",
-            "/** @constructor*/ function c(){}",
-            "/** @constructor*/ function d(){}",
-            "goog$mixin(b.prototype,a.prototype);",
-            "goog$mixin(c.prototype,a.prototype); new c;",
-            "goog$mixin(d.prototype,a.prototype)"),
-        lines(
-            "/** @constructor*/ function a(){}",
-            "/** @constructor*/ function c(){}",
-            "goog$mixin(c.prototype,a.prototype); new c"));
-  }
-
-  @Test
-  public void testRemoveInheritedClass7() {
-    test(
-        lines(
-            "/**@constructor*/function a(){alert(goog$mixin(a, a))}",
-            "/**@constructor*/function b(){}",
-            "goog$mixin(b.prototype,a.prototype); new a"),
-        lines(
-            "/**@constructor*/function a(){alert(goog$mixin(a, a))} new a"));
-  }
-
-  @Test
   public void testRemoveInheritedClass8() {
     testSame("/**@constructor*/function a(){}" +
         "/**@constructor*/function b(){}" +
@@ -1322,16 +1293,6 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
   }
 
   @Test
-  public void testRemoveInheritedClass10() {
-    testSame(
-        lines(
-            "/**@constructor*/function a(){}",
-            "/**@constructor*/function b(){}",
-            "goog$mixin(b.prototype,a.prototype);",
-            "new b"));
-  }
-
-  @Test
   public void testRemoveInheritedClass11() {
     testSame(
         lines(
diff --git a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
index f502481..4352188 100644
--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
@@ -118,6 +118,11 @@ public final class RenameLocalVarsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testRenameParamsWithLeadingUnderscores() {
+    test("function Foo(_v1, _v2) {return _v1;} Foo();", "function Foo(a, b) {return a;} Foo();");
+  }
+
+  @Test
   public void testRenameWithNameOverlap() {
     test("function local() { var a = 1; var b = 2; b + b; }",
         "function local() { var b = 1; var a = 2; a + a; }");
diff --git a/test/com/google/javascript/jscomp/RenameVarsTest.java b/test/com/google/javascript/jscomp/RenameVarsTest.java
index 5b4310f..76975bb 100644
--- a/test/com/google/javascript/jscomp/RenameVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java
@@ -155,6 +155,11 @@ public final class RenameVarsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testRenameParamsWithLeadingUnderscores() {
+    test("(function (_v1, _v2) {});", "(function (a, b) {});");
+  }
+
+  @Test
   public void testRenameLocalsToSame() {
     preferStableNames = true;
     testSame("(function(a) {})");
diff --git a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
index f3e317d..3024e62 100644
--- a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
@@ -611,6 +611,53 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testNameReplacementWithFullOptionsBag() {
+    registerMessage(
+        new JsMessage.Builder("MSG_B")
+            .appendStringPart("One ")
+            .appendPlaceholderReference("measly")
+            .appendStringPart(" ph")
+            .build());
+
+    multiPhaseTest(
+        lines(
+            "/** @desc d */",
+            "var MSG_B =",
+            "    goog.getMsg(",
+            "        'asdf {$measly}',",
+            "        {measly: x},",
+            "        {",
+            // use all allowed options
+            "          html: true,",
+            "          unescapeHtmlEntities: true,",
+            // original_code and example get dropped, because they're only used
+            // when generating the XMB file.
+            "          original_code: {",
+            "            'measly': 'getMeasley()'",
+            "          },",
+            "          example: {",
+            "            'measly': 'very little'",
+            "          },",
+            "        });"),
+        lines(
+            "/**",
+            " * @desc d",
+            " */",
+            "var MSG_B =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":\"MSG_B\",",
+            "          \"msg_text\":\"asdf {$measly}\",",
+            "          \"escapeLessThan\":\"\",",
+            "          \"unescapeHtmlEntities\":\"\"",
+            "        },",
+            "        {'measly': x});"),
+        lines(
+            "/** @desc d */", //
+            "var MSG_B = 'One ' + x + ' ph';"));
+  }
+
+  @Test
   public void testGetPropReplacement() {
     registerMessage(new JsMessage.Builder("MSG_C").appendPlaceholderReference("amount").build());
 
@@ -1168,6 +1215,105 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testTranslatedBadBooleanOptionValue() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        // used an object when a boolean is required
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { html: {} });",
+        MESSAGE_TREE_MALFORMED);
+    multiPhaseTestPreLookupError(
+        // used an object when a boolean is required
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { unescapeHtmlEntities: {} });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedMisspelledExamples() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        // mistakenly used "examples" instead of "example"
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { examples: { 'a': 'example a' } });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedMisspelledOriginalCode() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        // mistakenly used "original" instead of "original_code"
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { original: { 'a': 'code' } });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedExampleWithUnknownPlaceholder() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { example: { 'b': 'example a' } });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedExampleWithNonStringPlaceholderValue() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { example: { 'a': 1 } });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedExampleWithBadValue() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { example: 'bad value' });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testTranslatedExampleWithComputedProperty() {
+    registerMessage(
+        new JsMessage.Builder("MSG_A")
+            .appendPlaceholderReference("a")
+            .appendStringPart("!")
+            .build());
+
+    multiPhaseTestPreLookupError(
+        // computed property is not allowed for examples
+        "var MSG_A = goog.getMsg('{$a}', {'a': 'something'}, { example: { ['a']: 'wrong' } });",
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
   public void testBadFallbackSyntax1() {
     multiPhaseTestPreLookupError(
         lines(
diff --git a/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java b/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java
index 0a82b62..e27cb26 100644
--- a/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java
+++ b/test/com/google/javascript/jscomp/RescopeGlobalSymbolsTest.java
@@ -24,9 +24,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit tests for {@link RescopeGlobalSymbols}
- */
+/** Unit tests for {@link RescopeGlobalSymbols} */
 @RunWith(JUnit4.class)
 public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
@@ -34,12 +32,9 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
   private boolean assumeCrossModuleNames = true;
 
-  @Override protected CompilerPass getProcessor(Compiler compiler) {
-    return new RescopeGlobalSymbols(
-        compiler,
-        NAMESPACE,
-        false,
-        assumeCrossModuleNames);
+  @Override
+  protected CompilerPass getProcessor(Compiler compiler) {
+    return new RescopeGlobalSymbols(compiler, NAMESPACE, false, assumeCrossModuleNames);
   }
 
   @Override
@@ -601,24 +596,16 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
   @Test
   public void testForLoops_acrossModules() {
-    test(
-        "for (var i = 0; i < 1000; i++);",
-        "for (_.i = 0; _.i < 1000; _.i++);");
-    test(
-        "for (var i = 0, c = 2; i < 1000; i++);",
-        "for (_.i = 0, _.c = 2; _.i < 1000; _.i++);");
+    test("for (var i = 0; i < 1000; i++);", "for (_.i = 0; _.i < 1000; _.i++);");
+    test("for (var i = 0, c = 2; i < 1000; i++);", "for (_.i = 0, _.c = 2; _.i < 1000; _.i++);");
     test(
         "for (var i = 0, c = 2, d = 3; i < 1000; i++);",
         "for (_.i = 0, _.c = 2, _.d = 3; _.i < 1000; _.i++);");
     test(
         "for (var i = 0, c = 2, d = 3, e = 4; i < 1000; i++);",
         "for (_.i = 0, _.c = 2, _.d = 3, _.e = 4; _.i < 1000; _.i++);");
-    test(
-        "for (var i = 0; i < 1000;)i++;",
-        "for (_.i = 0; _.i < 1000;)_.i++;");
-    test(
-        "for (var i = 0,b; i < 1000;)i++;b++",
-        "for (_.i = 0,_.b; _.i < 1000;)_.i++;_.b++");
+    test("for (var i = 0; i < 1000;)i++;", "for (_.i = 0; _.i < 1000;)_.i++;");
+    test("for (var i = 0,b; i < 1000;)i++;b++", "for (_.i = 0,_.b; _.i < 1000;)_.i++;_.b++");
     test("var o={};for (var i in o)i++;", "_.o={};for (_.i in _.o)_.i++;");
 
     // Test destructuring.
@@ -698,45 +685,42 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
   @Test
   public void testForAwaitOfLoops_allSameModule() {
     assumeCrossModuleNames = false;
-    testSame("for await (var i of [1, 2, 3]);");
-    testSame("for await (var [a] of []);");
-    testSame("for await (var {a: a} of {});");
+    testSame("async () => { for await (var i of [1, 2, 3]);}");
+    testSame("async () => { for await (var [a] of []);}");
+    testSame("async () => { for await (var {a: a} of {});}");
   }
 
   @Test
   public void testForAwaitOfLoops_acrossModules() {
+    // TODO(b/128938049): re-enable it once we support top-level await.
     assumeCrossModuleNames = false;
-    test(
+    testError(
         srcs(
             JSChunkGraphBuilder.forUnordered()
                 .addChunk("for await (var i of []);")
                 .addChunk("i")
                 .build()),
-        expected("for await (_.i of []);", "_.i"));
-    test(
+        RhinoErrorReporter.PARSE_ERROR);
+    testError(
         srcs(
             JSChunkGraphBuilder.forUnordered()
                 .addChunk("       for await (var [  a, b] of []);")
                 .addChunk("a;")
                 .build()),
-        expected("var b; for await (    [_.a, b] of []);", "_.a"));
-    test(
+        RhinoErrorReporter.PARSE_ERROR);
+    testError(
         srcs(
             JSChunkGraphBuilder.forUnordered()
                 .addChunk("       for await (var {i: i, c:   c} of []);")
                 .addChunk("c")
                 .build()),
-        expected("var i; for await (    {i: i, c: _.c} of []);", "_.c"));
+        RhinoErrorReporter.PARSE_ERROR);
   }
 
   @Test
   public void testFunctionStatements() {
-    test(
-        "function test(){}",
-        "_.test=function (){}");
-    test(
-        "if(1)function test(){}",
-        "if(1)_.test=function (){}");
+    test("function test(){}", "_.test=function (){}");
+    test("if(1)function test(){}", "if(1)_.test=function (){}");
     test("async function test() {}", "_.test = async function() {}");
     test("function *test() {}", "_.test = function *() {}");
   }
@@ -756,32 +740,20 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
     test(
         "function x(){this};var y=function(){var val=x()||{}}",
         "_.x=function(){this};_.y=function(){var val=(0,_.x)()||{}}");
-    test(
-        "function x(){this;x()}",
-        "_.x=function(){this;(0,_.x)()}");
-    test(
-        "var a=function(){this};a()",
-        "_.a=function(){this};(0,_.a)()");
+    test("function x(){this;x()}", "_.x=function(){this;(0,_.x)()}");
+    test("var a=function(){this};a()", "_.a=function(){this};(0,_.a)()");
     // Always trigger free calls for variables assigned through destructuring.
     test("var {a: a} = {a: function() {}}; a();", "({a:_.a}={a:function(){}});(0,_.a)()");
 
-    test(
-        "var ns = {}; ns.a = function() {}; ns.a()",
-        "_.ns={};_.ns.a=function(){};_.ns.a()");
+    test("var ns = {}; ns.a = function() {}; ns.a()", "_.ns={};_.ns.a=function(){};_.ns.a()");
   }
 
   @Test
   public void testFunctionStatements_freeCallSemantics2() {
     // Cases where free call forcing through (0, foo)() is not necessary.
-    test(
-        "var a=function(){};a()",
-        "_.a=function(){};_.a()");
-    test(
-        "function a(){};a()",
-        "_.a=function(){};;_.a()");
-    test(
-        "var a;a=function(){};a()",
-        "_.a=function(){};_.a()");
+    test("var a=function(){};a()", "_.a=function(){};_.a()");
+    test("function a(){};a()", "_.a=function(){};;_.a()");
+    test("var a;a=function(){};a()", "_.a=function(){};_.a()");
 
     // Test that calls to arrow functions are not forced to be free calls
     test("var a = () => {}; a();", "_.a = () => {}; _.a();");
@@ -794,9 +766,7 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
     // Ambiguous cases.
     test("var a=1;a=function(){};a()", "_.a=1;_.a=function(){};(0,_.a)()");
-    test(
-        "var b;var a=b;a()",
-        "_.a=_.b;(0,_.a)()");
+    test("var b;var a=b;a()", "_.a=_.b;(0,_.a)()");
   }
 
   @Test
@@ -806,15 +776,9 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
   @Test
   public void testDeeperScopes() {
-    test(
-        "var a = function(b){return b}",
-        "_.a = function(b){return b}");
-    test(
-        "var a = function(b){var a; return a+b}",
-        "_.a = function(b){var a; return a+b}");
-    test(
-        "var a = function(a,b){return a+b}",
-        "_.a = function(a,b){return a+b}");
+    test("var a = function(b){return b}", "_.a = function(b){return b}");
+    test("var a = function(b){var a; return a+b}", "_.a = function(b){var a; return a+b}");
+    test("var a = function(a,b){return a+b}", "_.a = function(a,b){return a+b}");
     test(
         "var x=1,a = function(b){var a; return a+b+x}",
         "_.x=1;_.a = function(b){var a; return a+b+_.x}");
@@ -825,16 +789,12 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
 
   @Test
   public void testTryCatch() {
-    test(
-        "try{var a = 1}catch(e){throw e}",
-        "try{_.a = 1}catch(e){throw e}");
+    test("try{var a = 1}catch(e){throw e}", "try{_.a = 1}catch(e){throw e}");
   }
 
   @Test
   public void testShadowInFunctionScope() {
-    test(
-        "var _ = 1; (function () { _ = 2 })()",
-        "_._ = 1; (function () { _._ = 2 })()");
+    test("var _ = 1; (function () { _ = 2 })()", "_._ = 1; (function () { _._ = 2 })()");
     test(
         "function foo() { var _ = {}; _.foo = foo; _.bar = 1; }",
         "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1}");
@@ -849,22 +809,20 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
             "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; ",
             "(function() { var _$ = 0;})() }"));
     test(
-        "function foo() { var _ = {}; _.foo = foo; _.bar = 1; "
-        + "var _$ = 1; }",
-        "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; "
-        + "var _$$ = 1; }");
+        "function foo() { var _ = {}; _.foo = foo; _.bar = 1; " + "var _$ = 1; }",
+        "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; " + "var _$$ = 1; }");
     test(
         "function foo() { var _ = {}; _.foo = foo; _.bar = 1; "
-        + "var _$ = 1; (function() { _ = _$ })() }",
+            + "var _$ = 1; (function() { _ = _$ })() }",
         "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; "
-        + "var _$$ = 1; (function() { _$ = _$$ })() }");
+            + "var _$$ = 1; (function() { _$ = _$$ })() }");
     test(
         "function foo() { var _ = {}; _.foo = foo; _.bar = 1; "
-        + "var _$ = 1, _$$ = 2 (function() { _ = _$ = _$$; " +
-        "var _$, _$$$ })() }",
+            + "var _$ = 1, _$$ = 2 (function() { _ = _$ = _$$; "
+            + "var _$, _$$$ })() }",
         "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; "
-        + "var _$$ = 1, _$$$ = 2 (function() { _$ = _$$ = _$$$; "
-        + "var _$$, _$$$$ })() }");
+            + "var _$$ = 1, _$$$ = 2 (function() { _$ = _$$ = _$$$; "
+            + "var _$$, _$$$$ })() }");
     test(
         "var a = 5; function foo(_) { return _; }", "_.a = 5; _.foo = function(_$) { return _$; }");
     test(
@@ -929,8 +887,8 @@ public final class RescopeGlobalSymbolsTest extends CompilerTestCase {
     // Javascript builtin objects
     testSame(
         "Object;Function;Array;String;Boolean;Number;Math;"
-        + "Date;RegExp;JSON;Error;EvalError;ReferenceError;"
-        + "SyntaxError;TypeError;URIError;");
+            + "Date;RegExp;JSON;Error;EvalError;ReferenceError;"
+            + "SyntaxError;TypeError;URIError;");
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java b/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
index 4437bf8..c55bc94 100644
--- a/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
+++ b/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
@@ -44,7 +44,7 @@ public class RewriteNewDotTargetTest extends CompilerTestCase {
   @Override
   protected CompilerOptions getOptions() {
     CompilerOptions options = super.getOptions();
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5_STRICT);
     return options;
   }
diff --git a/test/com/google/javascript/jscomp/RewriteOptionalChainingOperatorTest.java b/test/com/google/javascript/jscomp/RewriteOptionalChainingOperatorTest.java
index 9d8786d..3b3c785 100644
--- a/test/com/google/javascript/jscomp/RewriteOptionalChainingOperatorTest.java
+++ b/test/com/google/javascript/jscomp/RewriteOptionalChainingOperatorTest.java
@@ -308,6 +308,36 @@ public final class RewriteOptionalChainingOperatorTest {
                       + " =>",
                   "{ return p;}")
             },
+            {
+              lines(
+                  "const a = { b: [3] };",
+                  "label: for (const val of a?.b) {",
+                  "  if (val != 3) {",
+                  "    continue label;",
+                  "  }",
+                  "}"),
+              lines(
+                  "const a = {b:[3]};",
+                  "let tmp0;",
+                  "label: for (const val of (tmp0 = a) == null ? void 0 : tmp0.b) {",
+                  "  if (val != 3) {",
+                  "  continue label;",
+                  "  }",
+                  "}")
+            },
+            {
+              lines(
+                  "{", //
+                  "  const x = 1;",
+                  "  label: for (const a of b?.c) {}",
+                  "}"),
+              lines(
+                  "{", //
+                  "  const x = 1;",
+                  "  let tmp0;",
+                  "  label: for (const a of (tmp0 = b) == null ? void 0 : tmp0.c) {}",
+                  "}")
+            }
           });
     }
 
diff --git a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
index ad0c1cd..b27595d 100644
--- a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
+++ b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
@@ -294,8 +294,8 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
 
   @Test
   public void testStaticMethodsNotInstalledIfGuardedByNullishCoalesce() {
-    setAcceptedLanguage(LanguageMode.ECMASCRIPT_NEXT_IN);
-    addLibrary("Array.of", "es_next_in", "es5", "es6/array/of");
+    setAcceptedLanguage(LanguageMode.UNSTABLE);
+    addLibrary("Array.of", "es_unstable", "es5", "es6/array/of");
 
     testDoesNotInject("!Array.of ?? Array.of();");
     // NOTE: ?? is not safe by itself.
@@ -450,8 +450,8 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
 
   @Test
   public void testPrototypeMethodsNotInstalledIfGuardedByNullishCoalesce() {
-    setAcceptedLanguage(LanguageMode.ECMASCRIPT_NEXT_IN);
-    addLibrary("String.prototype.endsWith", "es_next_in", "es5", "es6/string/endswith");
+    setAcceptedLanguage(LanguageMode.UNSTABLE);
+    addLibrary("String.prototype.endsWith", "es_unstable", "es5", "es6/string/endswith");
 
     testDoesNotInject("!String.prototype.endsWith ?? x.endsWith();");
     // NOTE: ?? is not safe by itself.
diff --git a/test/com/google/javascript/jscomp/ScopedAliasesTest.java b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
index 9107d7a..9b8b731 100644
--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java
+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
@@ -40,23 +40,14 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link ScopedAliases}
- *
- */
+/** Tests for {@link ScopedAliases} */
 @RunWith(JUnit4.class)
 public final class ScopedAliasesTest extends CompilerTestCase {
 
-  private static final String GOOG_SCOPE_START_BLOCK =
-      "goog.scope(function() {";
+  private static final String GOOG_SCOPE_START_BLOCK = "goog.scope(function() {";
   private static final String GOOG_SCOPE_END_BLOCK = "});";
 
-  private static final String SCOPE_NAMESPACE =
-      "/** @const */ var $jscomp = $jscomp || {}; /** @const */ $jscomp.scope = {};";
-
-  private static final String EXTERNS = lines(
-      MINIMAL_EXTERNS,
-      "var window;");
+  private static final String EXTERNS = lines(MINIMAL_EXTERNS, "var window;");
 
   private InvalidModuleGetHandling invalidModuleGetHandling;
 
@@ -78,10 +69,12 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   }
 
   private void testScoped(String code, String expected, Postcondition... postconditions) {
-    ImmutableList<TestPart> parts = ImmutableList.<TestPart>builder()
-        .add(srcs(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK))
-        .add(expected(expected))
-        .addAll(Arrays.asList(postconditions)).build();
+    ImmutableList<TestPart> parts =
+        ImmutableList.<TestPart>builder()
+            .add(srcs(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK))
+            .add(expected(expected))
+            .addAll(Arrays.asList(postconditions))
+            .build();
     test(parts.toArray(new TestPart[0]));
   }
 
@@ -95,37 +88,36 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testLet() {
-    testScoped(
-        "let d = goog.dom; d.createElement(DIV);",
-        "goog.dom.createElement(DIV)");
+    testScoped("let d = goog.dom; d.createElement(DIV);", "goog.dom.createElement(DIV)");
   }
 
   @Test
   public void testConst() {
-    testScoped(
-        "const d = goog.dom; d.createElement(DIV);",
-        "goog.dom.createElement(DIV)");
+    testScoped("const d = goog.dom; d.createElement(DIV);", "goog.dom.createElement(DIV)");
   }
 
   @Test
   public void testOneLevel() {
-    testScoped("var g = goog;g.dom.createElement(g.dom.TagName.DIV);",
+    testScoped(
+        "var g = goog;g.dom.createElement(g.dom.TagName.DIV);",
         "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testTwoLevel() {
-    testScoped("var d = goog.dom;d.createElement(d.TagName.DIV);",
-               "goog.dom.createElement(goog.dom.TagName.DIV);");
+    testScoped(
+        "var d = goog.dom;d.createElement(d.TagName.DIV);",
+        "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testSourceInfo() {
-    testScoped("var d = dom;\n" +
-               "var e = event;\n" +
-               "alert(e.EventType.MOUSEUP);\n" +
-               "alert(d.TagName.DIV);\n",
-               "alert(event.EventType.MOUSEUP); alert(dom.TagName.DIV);");
+    testScoped(
+        "var d = dom;\n"
+            + "var e = event;\n"
+            + "alert(e.EventType.MOUSEUP);\n"
+            + "alert(d.TagName.DIV);\n",
+        "alert(event.EventType.MOUSEUP); alert(dom.TagName.DIV);");
     Node root = getLastCompiler().getRoot();
     Node dom = findQualifiedNameNode("dom", root);
     Node event = findQualifiedNameNode("event", root);
@@ -136,35 +128,36 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testTransitive() {
-    testScoped("var d = goog.dom;var DIV = d.TagName.DIV;d.createElement(DIV);",
+    testScoped(
+        "var d = goog.dom;var DIV = d.TagName.DIV;d.createElement(DIV);",
         "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testTransitiveInSameVar() {
-    testScoped("var d = goog.dom, DIV = d.TagName.DIV;d.createElement(DIV);",
+    testScoped(
+        "var d = goog.dom, DIV = d.TagName.DIV;d.createElement(DIV);",
         "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testMultipleTransitive() {
     testScoped(
-        "var g=goog;var d=g.dom;var t=d.TagName;var DIV=t.DIV;" +
-            "d.createElement(DIV);",
+        "var g=goog;var d=g.dom;var t=d.TagName;var DIV=t.DIV;" + "d.createElement(DIV);",
         "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testFourLevel() {
-    testScoped("var DIV = goog.dom.TagName.DIV;goog.dom.createElement(DIV);",
+    testScoped(
+        "var DIV = goog.dom.TagName.DIV;goog.dom.createElement(DIV);",
         "goog.dom.createElement(goog.dom.TagName.DIV);");
   }
 
   @Test
   public void testWorksInClosures() {
     testScoped(
-        "var DIV = goog.dom.TagName.DIV;" +
-            "goog.x = function() {goog.dom.createElement(DIV);};",
+        "var DIV = goog.dom.TagName.DIV;" + "goog.x = function() {goog.dom.createElement(DIV);};",
         "goog.x = function() {goog.dom.createElement(goog.dom.TagName.DIV);};");
   }
 
@@ -172,70 +165,66 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testOverridden() {
     // Test that the alias doesn't get unaliased when it's overridden by a
     // parameter.
-    testScopedNoChanges(
-        "var g = goog;", "goog.x = function(g) {g.z()};");
+    testScopedNoChanges("var g = goog;", "goog.x = function(g) {g.z()};");
     // Same for a local.
-    testScopedNoChanges(
-        "var g = goog;", "goog.x = function() {var g = {}; g.z()};");
+    testScopedNoChanges("var g = goog;", "goog.x = function() {var g = {}; g.z()};");
   }
 
   @Test
   public void testTwoScopes() {
     test(
-        "goog.scope(function() {var g = goog;g.method()});" +
-        "goog.scope(function() {g.method();});",
+        "goog.scope(function() {var g = goog;g.method()});"
+            + "goog.scope(function() {g.method();});",
         "goog.method();g.method();");
   }
 
   @Test
   public void testTwoSymbolsInTwoScopes() {
     test(
-        "var goog = {};" +
-        "goog.scope(function() { var g = goog; g.Foo = function() {}; });" +
-        "goog.scope(function() { " +
-        "  var Foo = goog.Foo; goog.bar = function() { return new Foo(); };" +
-        "});",
-        "var goog = {};" +
-        "goog.Foo = function() {};" +
-        "goog.bar = function() { return new goog.Foo(); };");
+        "var goog = {};"
+            + "goog.scope(function() { var g = goog; g.Foo = function() {}; });"
+            + "goog.scope(function() { "
+            + "  var Foo = goog.Foo; goog.bar = function() { return new Foo(); };"
+            + "});",
+        "var goog = {};"
+            + "goog.Foo = function() {};"
+            + "goog.bar = function() { return new goog.Foo(); };");
   }
 
   @Test
   public void testAliasOfSymbolInGoogScope() {
     test(
-        "var goog = {};" +
-        "goog.scope(function() {" +
-        "  var g = goog;" +
-        "  g.Foo = function() {};" +
-        "  var Foo = g.Foo;" +
-        "  Foo.prototype.bar = function() {};" +
-        "});",
-        "var goog = {}; goog.Foo = function() {};" +
-        "goog.Foo.prototype.bar = function() {};");
+        "var goog = {};"
+            + "goog.scope(function() {"
+            + "  var g = goog;"
+            + "  g.Foo = function() {};"
+            + "  var Foo = g.Foo;"
+            + "  Foo.prototype.bar = function() {};"
+            + "});",
+        "var goog = {}; goog.Foo = function() {};" + "goog.Foo.prototype.bar = function() {};");
   }
 
   @Test
   public void testScopedFunctionReturnThis() {
-    test("goog.scope(function() { " +
-         "  var g = goog; g.f = function() { return this; };" +
-         "});",
-         "goog.f = function() { return this; };");
+    test(
+        "goog.scope(function() { " + "  var g = goog; g.f = function() { return this; };" + "});",
+        "goog.f = function() { return this; };");
   }
 
   @Test
   public void testScopedFunctionAssignsToVar() {
-    test("goog.scope(function() { " +
-         "  var g = goog; g.f = function(x) { x = 3; return x; };" +
-         "});",
-         "goog.f = function(x) { x = 3; return x; };");
+    test(
+        "goog.scope(function() { "
+            + "  var g = goog; g.f = function(x) { x = 3; return x; };"
+            + "});",
+        "goog.f = function(x) { x = 3; return x; };");
   }
 
   @Test
   public void testScopedFunctionThrows() {
-    test("goog.scope(function() { " +
-         "  var g = goog; g.f = function() { throw 'error'; };" +
-         "});",
-         "goog.f = function() { throw 'error'; };");
+    test(
+        "goog.scope(function() { " + "  var g = goog; g.f = function() { throw 'error'; };" + "});",
+        "goog.f = function() { throw 'error'; };");
   }
 
   @Test
@@ -245,150 +234,190 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testShadowedVar() {
-    test("var Popup = {};" +
-         "var OtherPopup = {};" +
-         "goog.scope(function() {" +
-         "  var Popup = OtherPopup;" +
-         "  Popup.newMethod = function() { return new Popup(); };" +
-         "});",
-         "var Popup = {};" +
-         "var OtherPopup = {};" +
-         "OtherPopup.newMethod = function() { return new OtherPopup(); };");
+    test(
+        "var Popup = {};"
+            + "var OtherPopup = {};"
+            + "goog.scope(function() {"
+            + "  var Popup = OtherPopup;"
+            + "  Popup.newMethod = function() { return new Popup(); };"
+            + "});",
+        "var Popup = {};"
+            + "var OtherPopup = {};"
+            + "OtherPopup.newMethod = function() { return new OtherPopup(); };");
   }
 
   @Test
   public void testShadowedScopedVar() {
-    test("var goog = {};" +
-         "goog.bar = {};" +
-         "goog.scope(function() {" +
-         "  var bar = goog.bar;" +
-         // This is bogus, because when the aliases are expanded, goog will
-         // shadow goog.bar.
-         "  bar.newMethod = function(goog) { return goog + bar; };" +
-         "});",
-         "var goog={};" +
-         "goog.bar={};" +
-         "goog.bar.newMethod=function(goog$jscomp$1){return goog$jscomp$1 + goog.bar}");
+    test(
+        "var goog = {};"
+            + "goog.bar = {};"
+            + "goog.scope(function() {"
+            + "  var bar = goog.bar;"
+            +
+            // This is bogus, because when the aliases are expanded, goog will
+            // shadow goog.bar.
+            "  bar.newMethod = function(goog) { return goog + bar; };"
+            + "});",
+        "var goog={};"
+            + "goog.bar={};"
+            + "goog.bar.newMethod=function(goog$jscomp$1){return goog$jscomp$1 + goog.bar}");
   }
 
   @Test
   public void testShadowedScopedVarTwoScopes() {
-    test("var goog = {};" +
-         "goog.bar = {};" +
-         "goog.scope(function() {" +
-         "  var bar = goog.bar;" +
-         "  bar.newMethod = function(goog, a) { return bar + a; };" +
-         "});" +
-         "goog.scope(function() {" +
-         "  var bar = goog.bar;" +
-         "  bar.newMethod2 = function(goog, b) { return bar + b; };" +
-         "});",
-         "var goog={};" +
-         "goog.bar={};" +
-         "goog.bar.newMethod=function(goog$jscomp$1, a){return goog.bar + a};" +
-         "goog.bar.newMethod2=function(goog$jscomp$1, b){return goog.bar + b};");
+    test(
+        "var goog = {};"
+            + "goog.bar = {};"
+            + "goog.scope(function() {"
+            + "  var bar = goog.bar;"
+            + "  bar.newMethod = function(goog, a) { return bar + a; };"
+            + "});"
+            + "goog.scope(function() {"
+            + "  var bar = goog.bar;"
+            + "  bar.newMethod2 = function(goog, b) { return bar + b; };"
+            + "});",
+        "var goog={};"
+            + "goog.bar={};"
+            + "goog.bar.newMethod=function(goog$jscomp$1, a){return goog.bar + a};"
+            + "goog.bar.newMethod2=function(goog$jscomp$1, b){return goog.bar + b};");
+  }
+
+  @Test
+  public void testIconImage2() {
+    testScoped(
+        lines(
+            "var getIconImage = (function(){",
+            " let _iconsImage;", //
+            " function getIconImage(){",
+            "   _iconsImage = 3;",
+            "   return _iconsImage;",
+            " }",
+            "})"),
+        lines(
+            "var $jscomp$scope$m1146332801$0$getIconImage = (function(){",
+            " let _iconsImage;", //
+            " function getIconImage(){",
+            "   _iconsImage = 3;",
+            "   return _iconsImage;",
+            " }",
+            "})"));
+  }
+
+  @Test
+  public void testIconImage() {
+    testScoped(
+        lines(
+            "let _iconsImage;", //
+            "function getIconImage(){",
+            "  _iconsImage = 3;",
+            "  return _iconsImage;",
+            "}"),
+        lines(
+            "var $jscomp$scope$m1146332801$1$getIconImage = function() {",
+            "  $jscomp$scope$m1146332801$0$_iconsImage = 3;",
+            "  return $jscomp$scope$m1146332801$0$_iconsImage;",
+            "};",
+            "var $jscomp$scope$m1146332801$0$_iconsImage;"));
   }
 
   @Test
   public void testFunctionDeclarationInScope() {
-    testScoped("var foo = function() {};", SCOPE_NAMESPACE + "$jscomp.scope.foo = function() {};");
+    testScoped("var foo = function() {};", "var $jscomp$scope$m1146332801$0$foo = function() {};");
   }
 
   @Test
   public void testFunctionDeclarationInScope_letConst() {
     testScoped(
         "var baz = goog.bar; let foo = function() {return baz;};",
-        SCOPE_NAMESPACE + "$jscomp.scope.foo = function() {return goog.bar;};");
+        "var $jscomp$scope$m1146332801$0$foo = function() {return goog.bar;};");
     testScoped(
         "var baz = goog.bar; const foo = function() {return baz;};",
-        SCOPE_NAMESPACE + "$jscomp.scope.foo = function() {return goog.bar;};");
+        "var $jscomp$scope$m1146332801$0$foo = function() {return goog.bar;};");
   }
 
   @Test
   public void testLetConstShadowing() {
     testScoped(
         "var foo = goog.bar; var f = function() {" + "let foo = baz; return foo;};",
-        SCOPE_NAMESPACE + "$jscomp.scope.f = function() {" + "let foo = baz; return foo;};");
+        "var $jscomp$scope$m1146332801$0$f = function() {" + "let foo = baz; return foo;};");
     testScoped(
         "var foo = goog.bar; var f = function() {" + "const foo = baz; return foo;};",
-        SCOPE_NAMESPACE + "$jscomp.scope.f = function() {" + "const foo = baz; return foo;};");
+        "var $jscomp$scope$m1146332801$0$f = function() {" + "const foo = baz; return foo;};");
   }
 
   @Test
   public void testYieldExpression() {
     testScoped(
         "var foo = goog.bar; var f = function*() {yield foo;};",
-        SCOPE_NAMESPACE + "$jscomp.scope.f = function*() {yield goog.bar;};");
+        "var $jscomp$scope$m1146332801$0$f = function*() {yield goog.bar;};");
   }
 
   @Test
   public void testDestructuringError() {
-    testScopedError("var [x] = [1];",
-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
+    testScopedError("var [x] = [1];", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
   }
 
   @Test
   public void testObjectDescructuringError1() {
-    testScopedError("var {x} = {x: 1};",
-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
+    testScopedError("var {x} = {x: 1};", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
   }
 
   @Test
   public void testObjectDescructuringError2() {
-    testScopedError("var {x: y} = {x: 1};",
-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
+    testScopedError("var {x: y} = {x: 1};", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);
   }
 
   @Test
   public void testNonTopLevelDestructuring() {
     testScoped(
         "var f = function() {var [x, y] = [1, 2];};",
-        SCOPE_NAMESPACE + "$jscomp.scope.f = function() {var [x, y] = [1, 2];};");
+        "var $jscomp$scope$m1146332801$0$f = function() {var [x, y] = [1, 2];};");
   }
 
   @Test
   public void testArrowFunction() {
     testScoped(
         "var foo = goog.bar; var v = (x => x + foo);",
-        SCOPE_NAMESPACE + "$jscomp.scope.v = (x => x + goog.bar)");
+        "var $jscomp$scope$m1146332801$0$v = (x => x + goog.bar)");
   }
 
   @Test
   public void testClassDefinition1() {
-    testScoped(
-        "class Foo {}",
-        SCOPE_NAMESPACE + "$jscomp.scope.Foo=class{}");
+    testScoped("class Foo {}", "var $jscomp$scope$m1146332801$0$Foo=class{}");
   }
 
   @Test
   public void testClassDefinition2() {
     testScoped(
         "var bar = goog.bar;" + "class Foo { constructor() { this.x = bar; }}",
-        SCOPE_NAMESPACE + "$jscomp.scope.Foo = class { constructor() { this.x = goog.bar; } }");
+        "var $jscomp$scope$m1146332801$0$Foo = class { constructor() { this.x = goog.bar; } }");
   }
 
   @Test
   public void testClassDefinition3() {
     testScoped(
         "var bar = {};" + "bar.Foo = class {};",
-        SCOPE_NAMESPACE + "$jscomp.scope.bar = {}; $jscomp.scope.bar.Foo = class {}");
+        "var $jscomp$scope$m1146332801$0$bar = {}; $jscomp$scope$m1146332801$0$bar.Foo = class"
+            + " {}");
   }
 
   @Test
   public void testClassDefinition_letConst() {
     testScoped(
         "let bar = {};" + "bar.Foo = class {};",
-        SCOPE_NAMESPACE + "$jscomp.scope.bar = {}; $jscomp.scope.bar.Foo = class {}");
+        "var $jscomp$scope$m1146332801$0$bar = {}; $jscomp$scope$m1146332801$0$bar.Foo = class"
+            + " {}");
     testScoped(
         "const bar = {};" + "bar.Foo = class {};",
-        SCOPE_NAMESPACE + "$jscomp.scope.bar = {}; $jscomp.scope.bar.Foo = class {}");
+        "var $jscomp$scope$m1146332801$0$bar = {}; $jscomp$scope$m1146332801$0$bar.Foo = class"
+            + " {}");
   }
 
   @Test
   public void testDefaultParameter() {
     testScoped(
         "var foo = goog.bar; var f = function(y=foo) {};",
-        SCOPE_NAMESPACE + "$jscomp.scope.f = function(y=goog.bar) {};");
+        "var $jscomp$scope$m1146332801$0$f = function(y=goog.bar) {};");
   }
 
   /**
@@ -405,11 +434,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  /** @param {Foo} foo */",
             "  y: function(foo) { }",
             "};"),
-        lines(
-            "goog.x = {",
-            "  /** @param {goog.Foo} foo */",
-            "  y: function(foo) {}",
-            "};"));
+        lines("goog.x = {", "  /** @param {goog.Foo} foo */", "  y: function(foo) {}", "};"));
 
     testScoped(
         lines(
@@ -417,10 +442,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "goog.x = {",
             "  y: /** @param {Foo} foo */ function(foo) {}",
             "};"),
-        lines(
-            "goog.x = {",
-            "  y: /** @param {goog.Foo} foo */ function(foo) {}",
-            "};"));
+        lines("goog.x = {", "  y: /** @param {goog.Foo} foo */ function(foo) {}", "};"));
 
     testScoped(
         lines(
@@ -428,34 +450,31 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "goog.x = {",
             "  y: /** @type {function(Foo)} */ (function(foo) {})",
             "};"),
-        lines(
-            "goog.x = {",
-            "  y: /** @type {function(goog.Foo)} */ (function(foo) {})",
-            "};"));
+        lines("goog.x = {", "  y: /** @type {function(goog.Foo)} */ (function(foo) {})", "};"));
   }
 
   @Test
   public void testObjectLiteralShorthand() {
     testScoped(
         "var bar = goog.bar; var Foo = {bar};",
-        SCOPE_NAMESPACE + "$jscomp.scope.Foo={bar: goog.bar};");
+        "var $jscomp$scope$m1146332801$0$Foo={bar: goog.bar};");
   }
 
   @Test
   public void testObjectLiteralMethods() {
     testScoped(
         "var foo = goog.bar; var obj = {toString() {return foo}};",
-        SCOPE_NAMESPACE + "$jscomp.scope.obj = {toString() {return goog.bar}};");
+        "var $jscomp$scope$m1146332801$0$obj = {toString() {return goog.bar}};");
   }
 
   @Test
   public void testObjectLiteralComputedPropertyNames() {
     testScoped(
         "var foo = goog.bar; var obj = {[(() => foo)()]: baz};",
-        SCOPE_NAMESPACE + "$jscomp.scope.obj = {[(() => goog.bar)()]:baz};");
+        "var $jscomp$scope$m1146332801$0$obj = {[(() => goog.bar)()]:baz};");
     testScoped(
         "var foo = goog.bar; var obj = {[x => x + foo]: baz};",
-        SCOPE_NAMESPACE + "$jscomp.scope.obj = {[x => x + goog.bar]:baz};");
+        "var $jscomp$scope$m1146332801$0$obj = {[x => x + goog.bar]:baz};");
   }
 
   @Test
@@ -482,10 +501,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  };",
             "  x.y('');",
             "});");
-    test(
-        externs(externs),
-        srcs(js),
-        warning(TypeValidator.TYPE_MISMATCH_WARNING));
+    test(externs(externs), srcs(js), warning(TypeValidator.TYPE_MISMATCH_WARNING));
 
     js =
         lines(
@@ -496,10 +512,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  };",
             "  x.y('');",
             "});");
-    test(
-        externs(externs),
-        srcs(js),
-        warning(TypeValidator.TYPE_MISMATCH_WARNING));
+    test(externs(externs), srcs(js), warning(TypeValidator.TYPE_MISMATCH_WARNING));
   }
 
   @Test
@@ -510,22 +523,22 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     // We only try to protect against accidental mis-use, not deliberate
     // mis-use.
     test(
-        "var goog = {};" +
-        "goog.bar = {};" +
-        "goog.scope(function() {" +
-        "  var bar = goog.bar;" +
-        "  var baz = goog.bar.baz;" +
-        "  goog.foo = function() {" +
-        "    goog.bar = {baz: 3};" +
-        "    return baz;" +
-        "  };" +
-        "});",
-        "var goog = {};" +
-        "goog.bar = {};" +
-        "goog.foo = function(){" +
-        "  goog.bar = {baz:3};" +
-        "  return goog.bar.baz;" +
-        "};");
+        "var goog = {};"
+            + "goog.bar = {};"
+            + "goog.scope(function() {"
+            + "  var bar = goog.bar;"
+            + "  var baz = goog.bar.baz;"
+            + "  goog.foo = function() {"
+            + "    goog.bar = {baz: 3};"
+            + "    return baz;"
+            + "  };"
+            + "});",
+        "var goog = {};"
+            + "goog.bar = {};"
+            + "goog.foo = function(){"
+            + "  goog.bar = {baz:3};"
+            + "  return goog.bar.baz;"
+            + "};");
   }
 
   private void testTypes(String aliases, String code) {
@@ -623,20 +636,16 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "/** @typedef {goog.Timer} */ types.expected;"));
 
     testScoped(
+        lines("/** @typedef {string} */ var s;", "/** @type {s} */ var t;"),
         lines(
-            "/** @typedef {string} */ var s;",
-            "/** @type {s} */ var t;"),
-        lines(
-            SCOPE_NAMESPACE,
-            "/** @typedef {string} */ $jscomp.scope.s;",
-            "/** @type {$jscomp.scope.s} */ $jscomp.scope.t;"));
+            "/** @typedef {string} */ var $jscomp$scope$m1146332801$0$s;",
+            "/** @type {$jscomp$scope$m1146332801$0$s} */ var $jscomp$scope$m1146332801$1$t;"));
 
     testScoped(
         lines("/** @typedef {string} */ let s;", "/** @type {s} */ var t;"),
         lines(
-            SCOPE_NAMESPACE,
-            "/** @typedef {string} */ $jscomp.scope.s;",
-            "/** @type {$jscomp.scope.s} */ $jscomp.scope.t;"));
+            "/** @typedef {string} */ var $jscomp$scope$m1146332801$0$s;",
+            "/** @type {$jscomp$scope$m1146332801$0$s} */ var $jscomp$scope$m1146332801$1$t;"));
   }
 
   @Test
@@ -650,8 +659,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  /** @type {{x: string}} */ ns.y = {'goog.Timer': 'x'};",
             "});"),
         lines(
-            "/** @const */ var ns = {};",
-            "/** @type {{x: string}} */ ns.y = {'goog.Timer': 'x'};"),
+            "/** @const */ var ns = {};", "/** @type {{x: string}} */ ns.y = {'goog.Timer': 'x'};"),
         warning(TypeValidator.TYPE_MISMATCH_WARNING));
   }
 
@@ -692,8 +700,8 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     testTypes(
         "var x = goog.Timer;",
         ""
-        + "/** @type {goog.Timer|Object} */ types.actual;"
-        + "/** @type {goog.Timer|Object} */ types.expected;");
+            + "/** @type {goog.Timer|Object} */ types.actual;"
+            + "/** @type {goog.Timer|Object} */ types.expected;");
   }
 
   @Test
@@ -701,13 +709,13 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     testTypes(
         "var x = goog.Timer;",
         ""
-        + "/** @type {function(goog.Timer) : void} */ types.actual;"
-        + "/** @type {function(goog.Timer) : void} */ types.expected;");
+            + "/** @type {function(goog.Timer) : void} */ types.actual;"
+            + "/** @type {function(goog.Timer) : void} */ types.expected;");
     testTypes(
         "var x = goog.Timer;",
         ""
-        + "/** @type {function() : goog.Timer} */ types.actual;"
-        + "/** @type {function() : goog.Timer} */ types.expected;");
+            + "/** @type {function() : goog.Timer} */ types.actual;"
+            + "/** @type {function() : goog.Timer} */ types.expected;");
   }
 
   @Test
@@ -739,8 +747,8 @@ public final class ScopedAliasesTest extends CompilerTestCase {
       testTypes(
           "var x = goog.Timer;",
           ""
-          + "/** @type {function() : x} */ types.actual;"
-          + "/** @type {function() : wrong.wrong} */ types.expected;");
+              + "/** @type {function() : x} */ types.actual;"
+              + "/** @type {function() : wrong.wrong} */ types.expected;");
       throw new Error("Test types should fail here.");
     } catch (AssertionError expected) {
     }
@@ -750,50 +758,48 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testNullType() {
     testTypes(
         "var x = goog.Timer;",
-        "/** @param draggable */ types.actual;"
-        + "/** @param draggable */ types.expected;");
+        "/** @param draggable */ types.actual;" + "/** @param draggable */ types.expected;");
   }
 
   @Test
   public void testJSDocCopiedForFunctions() {
     testScoped(
         "/** @export */ function Foo() {}",
-        SCOPE_NAMESPACE + "/** @export */ $jscomp.scope.Foo =/** @export */ function() {}");
+        "/** @export */ var $jscomp$scope$m1146332801$0$Foo =/** @export */ function() {}");
   }
 
   @Test
   public void testJSDocCopiedForClasses() {
     testScoped(
         "/** @export */ class Foo {}",
-        SCOPE_NAMESPACE + "/** @export */ $jscomp.scope.Foo = /** @export */ class {}");
+        "/** @export */ var $jscomp$scope$m1146332801$0$Foo = /** @export */ class {}");
   }
 
   @Test
   public void testIssue772() {
     testTypes(
-        "var b = a.b;" +
-        "var c = b.c;",
-        "/** @param {a.b.c.MyType} x */ types.actual;" +
-        "/** @param {a.b.c.MyType} x */ types.expected;");
+        "var b = a.b;" + "var c = b.c;",
+        "/** @param {a.b.c.MyType} x */ types.actual;"
+            + "/** @param {a.b.c.MyType} x */ types.expected;");
   }
 
   @Test
   public void testInlineJsDoc() {
     enableTypeCheck();
     test(
-        srcs(lines(
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            "goog.scope(function() {",
-            "  /** @const */ var A = ns.A;",
-            "  var /** ?A */ b = null;",
-            "});")),
-        expected(lines(
-            "/** @const */ var $jscomp = $jscomp || {};",
-            "/** @const */ $jscomp.scope = {};",
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            "/** @type {?ns.A} */ $jscomp.scope.b = null;")),
+        srcs(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                "goog.scope(function() {",
+                "  /** @const */ var A = ns.A;",
+                "  var /** @type {?A} */ b = null;",
+                "});")),
+        expected(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                "/** @type {?ns.A} */ var $jscomp$scope$m1146332801$0$b = null;")),
         VERIFY_TYPES);
   }
 
@@ -801,21 +807,21 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testInlineReturn() {
     enableTypeCheck();
     test(
-        srcs(lines(
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            "goog.scope(function() {",
-            "  /** @const */ var A = ns.A;",
-            "  function /** ?A */ b() { return null; }",
-            "});")),
-        expected(lines(
-            "/** @const */ var $jscomp = $jscomp || {};",
-            "/** @const */ $jscomp.scope = {};",
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            // TODO(moz): See if we can avoid generating duplicate @return's
-            "/** @return {?ns.A} */ $jscomp.scope.b = ",
-            "    /** @return {?ns.A} */ function() { return null; };")),
+        srcs(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                "goog.scope(function() {",
+                "  /** @const */ var A = ns.A;",
+                "  function /** ?A */ b() { return null; }",
+                "});")),
+        expected(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                // TODO(moz): See if we can avoid generating duplicate @return's
+                "/** @return {?ns.A} */ var $jscomp$scope$m1146332801$0$b = ",
+                "    /** @return {?ns.A} */ function() { return null; };")),
         VERIFY_TYPES);
   }
 
@@ -823,19 +829,19 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testInlineParam() {
     enableTypeCheck();
     test(
-        srcs(lines(
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            "goog.scope(function() {",
-            "  /** @const */ var A = ns.A;",
-            "  function b(/** ?A */ bee) {}",
-            "});")),
-        expected(lines(
-            "/** @const */ var $jscomp = $jscomp || {};",
-            "/** @const */ $jscomp.scope = {};",
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.A = function() {};",
-            "$jscomp.scope.b = function(/** ?ns.A */ bee) {};")),
+        srcs(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                "goog.scope(function() {",
+                "  /** @const */ var A = ns.A;",
+                "  function b(/** ?A */ bee) {}",
+                "});")),
+        expected(
+            lines(
+                "/** @const */ var ns = {};",
+                "/** @constructor */ ns.A = function() {};",
+                "var $jscomp$scope$m1146332801$0$b = function(/** ?ns.A */ bee) {};")),
         VERIFY_TYPES);
   }
 
@@ -861,34 +867,35 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testAliasNonRedefinition() {
-    test("var y = {}; goog.scope(function() { goog.dom = y; });",
-         "var y = {}; goog.dom = y;");
+    test("var y = {}; goog.scope(function() { goog.dom = y; });", "var y = {}; goog.dom = y;");
   }
 
   @Test
   public void testCtorAlias() {
-    test("var x = {y: {}};" +
-         "goog.scope(function() {" +
-         "  var y = x.y;" +
-         "  y.ClassA = function() { this.b = new ClassB(); };" +
-         "  y.ClassB = function() {};" +
-         "  var ClassB = y.ClassB;" +
-         "});",
-         "var x = {y: {}};" +
-         "x.y.ClassA = function() { this.b = new x.y.ClassB(); };" +
-         "x.y.ClassB = function() { };");
+    test(
+        "var x = {y: {}};"
+            + "goog.scope(function() {"
+            + "  var y = x.y;"
+            + "  y.ClassA = function() { this.b = new ClassB(); };"
+            + "  y.ClassB = function() {};"
+            + "  var ClassB = y.ClassB;"
+            + "});",
+        "var x = {y: {}};"
+            + "x.y.ClassA = function() { this.b = new x.y.ClassB(); };"
+            + "x.y.ClassB = function() { };");
   }
 
   @Test
   public void testAliasCycle() {
-    testError("var x = {y: {}};" +
-         "goog.scope(function() {" +
-         "  var y = z.x;" +
-         "  var z = y.x;" +
-         "  y.ClassA = function() {};" +
-         "  z.ClassB = function() {};" +
-         "});",
-         ScopedAliases.GOOG_SCOPE_ALIAS_CYCLE);
+    testError(
+        "var x = {y: {}};"
+            + "goog.scope(function() {"
+            + "  var y = z.x;"
+            + "  var z = y.x;"
+            + "  y.ClassA = function() {};"
+            + "  z.ClassB = function() {};"
+            + "});",
+        ScopedAliases.GOOG_SCOPE_ALIAS_CYCLE);
   }
 
   @Test
@@ -905,7 +912,8 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   @Test
   public void testUsedImproperly() {
     testError("var x = goog.scope(function() {});", ScopedAliases.GOOG_SCOPE_MUST_BE_ALONE);
-    testError("var f = function() { goog.scope(function() {}); }",
+    testError(
+        "var f = function() { goog.scope(function() {}); }",
         ScopedAliases.GOOG_SCOPE_MUST_BE_IN_GLOBAL_SCOPE);
   }
 
@@ -913,8 +921,9 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testScopeCallInIf() {
     test("if (true) { goog.scope(function() {});}", "if (true) {}");
     test("if (true) { goog.scope(function()  { var x = foo; });}", "if (true) { }");
-    test("if (true) { goog.scope(function()  { var x = foo; console.log(x); });}",
-         "if (true) { console.log(foo); }");
+    test(
+        "if (true) { goog.scope(function()  { var x = foo; console.log(x); });}",
+        "if (true) { console.log(foo); }");
   }
 
   @Test
@@ -942,14 +951,14 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   public void testWithCatch1() {
     testScoped(
         "var x = foo(); try { } catch (e) {}",
-        SCOPE_NAMESPACE + "$jscomp.scope.x = foo(); try { } catch (e) {}");
+        "var $jscomp$scope$m1146332801$0$x = foo(); try { } catch (e) {}");
   }
 
   @Test
   public void testWithCatch2() {
     testScoped(
         "try { } catch (e) {var x = foo();}",
-        SCOPE_NAMESPACE + "try { } catch (e) {$jscomp.scope.x = foo();}");
+        "try { } catch (e) {var $jscomp$scope$m1146332801$0$x = foo();}");
   }
 
   @Test
@@ -968,38 +977,35 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   @Test
   public void testHoistedAliases() {
     testScoped("if (true) { var x = foo;}", "if (true) {}");
-    testScoped("if (true) { var x = foo; console.log(x); }",
-                "if (true) { console.log(foo); }");
+    testScoped("if (true) { var x = foo; console.log(x); }", "if (true) { console.log(foo); }");
   }
 
   @Test
   public void testOkAliasLocal() {
-    testScoped("var x = 10;",
-               SCOPE_NAMESPACE + "$jscomp.scope.x = 10");
-    testScoped("var x = goog['dom'];",
-               SCOPE_NAMESPACE + "$jscomp.scope.x = goog['dom']");
-    testScoped("var x = 10, y = 9;",
-               SCOPE_NAMESPACE + "$jscomp.scope.x = 10; $jscomp.scope.y = 9;");
-    testScoped("var x = 10, y = 9; goog.getX = function () { return x + y; }",
-               SCOPE_NAMESPACE + "$jscomp.scope.x = 10; $jscomp.scope.y = 9;" +
-               "goog.getX = function () { " +
-               "    return $jscomp.scope.x + $jscomp.scope.y; }");
+    testScoped("var x = 10;", "var $jscomp$scope$m1146332801$0$x = 10");
+    testScoped("var x = goog['dom'];", "var $jscomp$scope$m1146332801$0$x = goog['dom']");
+    testScoped(
+        "var x = 10, y = 9;",
+        "var $jscomp$scope$m1146332801$0$x = 10; var $jscomp$scope$m1146332801$1$y = 9;");
+    testScoped(
+        "var x = 10, y = 9; goog.getX = function () { return x + y; }",
+        "var $jscomp$scope$m1146332801$0$x = 10; var $jscomp$scope$m1146332801$1$y = 9;"
+            + "goog.getX = function () { "
+            + "    return $jscomp$scope$m1146332801$0$x + $jscomp$scope$m1146332801$1$y; }");
   }
 
   @Test
   public void testOkAliasLocal_letConst() {
-    testScoped(
-        "let x = 10;", SCOPE_NAMESPACE + "$jscomp.scope.x = 10");
-    testScoped(
-        "const x = 10;", SCOPE_NAMESPACE + "$jscomp.scope.x = 10");
+    testScoped("let x = 10;", "var $jscomp$scope$m1146332801$0$x = 10");
+    testScoped("const x = 10;", "var $jscomp$scope$m1146332801$0$x = 10");
   }
 
   @Test
   public void testHoistedFunctionDeclaration() {
-    testScoped(" g(f); function f() {} ",
-               SCOPE_NAMESPACE +
-               " $jscomp.scope.f = function () {}; " +
-               "g($jscomp.scope.f); ");
+    testScoped(
+        " g(f); function f() {} ",
+        " var $jscomp$scope$m1146332801$0$f = function () {}; "
+            + "g($jscomp$scope$m1146332801$0$f); ");
   }
 
   @Test
@@ -1009,52 +1015,49 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testMultipleLocals() {
-    test("goog.scope(function () { var x = 3; });" +
-         "goog.scope(function () { var x = 4; });",
-         SCOPE_NAMESPACE + "$jscomp.scope.x = 3; $jscomp.scope.x$jscomp$1 = 4");
+    test(
+        "goog.scope(function () { var x = 3; });" + "goog.scope(function () { var x = 4; });",
+        "var $jscomp$scope$m1146332801$0$x = 3; var $jscomp$scope$m1146332801$1$x = 4");
   }
 
   @Test
   public void testIssue1103a() {
-    test("goog.scope(function () {" +
-         "  var a;" +
-         "  foo.bar = function () { a = 1; };" +
-         "});",
-         SCOPE_NAMESPACE + "foo.bar = function () { $jscomp.scope.a = 1; }");
+    test(
+        "goog.scope(function () {" + "  var a;" + "  foo.bar = function () { a = 1; };" + "});",
+        "var $jscomp$scope$m1146332801$0$a; foo.bar = function () { $jscomp$scope$m1146332801$0$a ="
+            + " 1; }");
   }
 
   @Test
   public void testIssue1103b() {
-    test("goog.scope(function () {" +
-         "  var a = foo, b, c = 1;" +
-         "});",
-         SCOPE_NAMESPACE + "$jscomp.scope.c=1");
+    test(
+        "goog.scope(function () {" + "  var a = foo, b, c = 1;" + "});",
+        "var $jscomp$scope$m1146332801$0$b; var $jscomp$scope$m1146332801$1$c=1");
   }
 
   @Test
   public void testIssue1103c() {
-    test("goog.scope(function () {" +
-         "  /** @type {number} */ var a;" +
-         "});",
-         SCOPE_NAMESPACE + "/** @type {number} */ $jscomp.scope.a;");
+    test(
+        "goog.scope(function () {" + "  /** @type {number} */ var a;" + "});",
+        "/** @type {number} */ var $jscomp$scope$m1146332801$0$a;");
   }
 
   @Test
   public void testIssue1144() {
-    test("var ns = {};" +
-         "ns.sub = {};" +
-         "/** @constructor */ ns.sub.C = function () {};" +
-         "goog.scope(function () {" +
-         "  var sub = ns.sub;" +
-         "  /** @type {sub.C} */" +
-         "  var x = null;" +
-         "});",
-         SCOPE_NAMESPACE +
-         "var ns = {};" +
-         "ns.sub = {};" +
-         "/** @constructor */ ns.sub.C = function () {};" +
-         "/** @type {ns.sub.C} */" +
-         "$jscomp.scope.x = null;");
+    test(
+        "var ns = {};"
+            + "ns.sub = {};"
+            + "/** @constructor */ ns.sub.C = function () {};"
+            + "goog.scope(function () {"
+            + "  var sub = ns.sub;"
+            + "  /** @type {sub.C} */"
+            + "  var x = null;"
+            + "});",
+        "var ns = {};"
+            + "ns.sub = {};"
+            + "/** @constructor */ ns.sub.C = function () {};"
+            + "/** @type {ns.sub.C} */"
+            + "var $jscomp$scope$m1146332801$0$x = null;");
   }
 
   // https://github.com/google/closure-compiler/issues/2211
@@ -1091,10 +1094,9 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  };",
             "});"),
         lines(
-            SCOPE_NAMESPACE,
             "var ns = {};",
             "var y = 1;",
-            "$jscomp.scope.x = function (y) {};",
+            "var $jscomp$scope$m1146332801$0$x = function (y) {};",
             "ns.fact = function y$jscomp$scopedAliases$0(n) {",
             "  return n == 1 ? 1 : n * y$jscomp$scopedAliases$0(n - 1);",
             "};"));
@@ -1104,12 +1106,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   @Test
   public void testIssue2211c() {
     testScoped(
-        lines(
-            "foo(() => {",
-            "  const y = function y() {",
-            "    use(y);",
-            "  };",
-            "});"),
+        lines("foo(() => {", "  const y = function y() {", "    use(y);", "  };", "});"),
         lines(
             "foo(() => {",
             "  const y = function y$jscomp$scopedAliases$0() {",
@@ -1337,10 +1334,12 @@ public final class ScopedAliasesTest extends CompilerTestCase {
             "  /** @return {F} */ function createFoo() { return 1; }",
             "});"),
         lines(
-            SCOPE_NAMESPACE,
-            "/** @return {$jscomp.scope.F} */",
-            "$jscomp.scope.createFoo = /** @return {$jscomp.scope.F} */ function() { return 1; };",
-            "/** @constructor */ $jscomp.scope.F = /** @constructor */ function() { };"),
+            "/** @return {$jscomp$scope$m1146332801$0$F} */",
+            "var $jscomp$scope$m1146332801$1$createFoo = ",
+            "/** @return {$jscomp$scope$m1146332801$0$F} */",
+            "function() { return 1; };",
+            "/** @constructor */ var $jscomp$scope$m1146332801$0$F =",
+            "/** @constructor */ function() { };"),
         warning(TypeValidator.TYPE_MISMATCH_WARNING));
   }
 
@@ -1348,8 +1347,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
   // TODO(tylerg) : update these to EasyMock style tests once available
   @Test
   public void testNoGoogScope() {
-    String fullJsCode =
-        "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);";
+    String fullJsCode = "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);";
     TransformationHandlerSpy spy = new TransformationHandlerSpy();
     transformationHandler = spy;
     testSame(fullJsCode);
@@ -1359,9 +1357,10 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testRecordOneAlias() {
-    String fullJsCode = GOOG_SCOPE_START_BLOCK
-        + "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n"
-        + GOOG_SCOPE_END_BLOCK;
+    String fullJsCode =
+        GOOG_SCOPE_START_BLOCK
+            + "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n"
+            + GOOG_SCOPE_END_BLOCK;
     String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n";
 
     TransformationHandlerSpy spy = new TransformationHandlerSpy();
@@ -1380,9 +1379,10 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testRecordOneAlias2() {
-    String fullJsCode = GOOG_SCOPE_START_BLOCK
-        + "var g$1 = goog;\n g$1.dom.createElement(g$1.dom.TagName.DIV);\n"
-        + GOOG_SCOPE_END_BLOCK;
+    String fullJsCode =
+        GOOG_SCOPE_START_BLOCK
+            + "var g$1 = goog;\n g$1.dom.createElement(g$1.dom.TagName.DIV);\n"
+            + GOOG_SCOPE_END_BLOCK;
     String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n";
 
     TransformationHandlerSpy spy = new TransformationHandlerSpy();
@@ -1401,12 +1401,12 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testRecordMultipleAliases() {
-    String fullJsCode = GOOG_SCOPE_START_BLOCK
-        + "var g = goog;\n var b= g.bar;\n var f = goog.something.foo;"
-        + "g.dom.createElement(g.dom.TagName.DIV);\n b.foo();"
-        + GOOG_SCOPE_END_BLOCK;
-    String expectedJsCode =
-        "goog.dom.createElement(goog.dom.TagName.DIV);\n goog.bar.foo();";
+    String fullJsCode =
+        GOOG_SCOPE_START_BLOCK
+            + "var g = goog;\n var b= g.bar;\n var f = goog.something.foo;"
+            + "g.dom.createElement(g.dom.TagName.DIV);\n b.foo();"
+            + GOOG_SCOPE_END_BLOCK;
+    String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n goog.bar.foo();";
     TransformationHandlerSpy spy = new TransformationHandlerSpy();
     transformationHandler = spy;
     test(fullJsCode, expectedJsCode);
@@ -1425,22 +1425,26 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   @Test
   public void testRecordAliasFromMultipleGoogScope() {
-    String firstGoogScopeBlock = GOOG_SCOPE_START_BLOCK
-        + "\n var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n"
-        + GOOG_SCOPE_END_BLOCK;
-    String fullJsCode = firstGoogScopeBlock + "\n\nvar l = abc.def;\n\n"
-        + GOOG_SCOPE_START_BLOCK
-        + "\n var z = namespace.Zoo;\n z.getAnimals(l);\n"
-        + GOOG_SCOPE_END_BLOCK;
+    String firstGoogScopeBlock =
+        GOOG_SCOPE_START_BLOCK
+            + "\n var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n"
+            + GOOG_SCOPE_END_BLOCK;
+    String fullJsCode =
+        firstGoogScopeBlock
+            + "\n\nvar l = abc.def;\n\n"
+            + GOOG_SCOPE_START_BLOCK
+            + "\n var z = namespace.Zoo;\n z.getAnimals(l);\n"
+            + GOOG_SCOPE_END_BLOCK;
 
-    String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n"
-        + "\n\nvar l = abc.def;\n\n" + "\n namespace.Zoo.getAnimals(l);\n";
+    String expectedJsCode =
+        "goog.dom.createElement(goog.dom.TagName.DIV);\n"
+            + "\n\nvar l = abc.def;\n\n"
+            + "\n namespace.Zoo.getAnimals(l);\n";
 
     TransformationHandlerSpy spy = new TransformationHandlerSpy();
     transformationHandler = spy;
     test(fullJsCode, expectedJsCode);
 
-
     assertThat(spy.observedPositions).containsKey("testcode");
     List<SourcePosition<AliasTransformation>> positions = spy.observedPositions.get("testcode");
     assertThat(positions).hasSize(2);
@@ -1457,8 +1461,12 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     assertThat(aliasSpy.observedDefinitions).containsEntry("z", "namespace.Zoo");
   }
 
-  private void verifyAliasTransformationPosition(int startLine, int startChar,
-      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {
+  private void verifyAliasTransformationPosition(
+      int startLine,
+      int startChar,
+      int endLine,
+      int endChar,
+      SourcePosition<AliasTransformation> pos) {
     assertThat(pos.getStartLine()).isEqualTo(startLine);
     assertThat(pos.getPositionOnStartLine()).isEqualTo(startChar);
     assertWithMessage("Endline smaller than expected.").that(pos.getEndLine()).isAtLeast(endLine);
@@ -1481,8 +1489,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     private final ListMultimap<String, SourcePosition<AliasTransformation>> observedPositions =
         MultimapBuilder.hashKeys().arrayListValues().build();
 
-    public final List<AliasTransformation> constructedAliases =
-         new ArrayList<>();
+    public final List<AliasTransformation> constructedAliases = new ArrayList<>();
 
     @Override
     public AliasTransformation logAliasTransformation(
@@ -1503,8 +1510,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     }
   }
 
-  private static class TypeVerifyingPass
-      implements CompilerPass, NodeTraversal.Callback {
+  private static class TypeVerifyingPass implements CompilerPass, NodeTraversal.Callback {
     private final Compiler compiler;
     private List<Node> actualTypes = null;
 
@@ -1518,8 +1524,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
     }
 
     @Override
-    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
-        Node parent) {
+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
       return true;
     }
 
diff --git a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
index 501a1e3..8f1d50c 100644
--- a/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java
@@ -33,7 +33,7 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class SemanticReverseAbstractInterpreterTest extends CompilerTypeTestCase {
-{ new GoogleCodingConvention(); }  private ReverseAbstractInterpreter interpreter;
+  private ReverseAbstractInterpreter interpreter;
   private TypedScope functionScope;
 
   @Override
diff --git a/test/com/google/javascript/jscomp/SourceFileTest.java b/test/com/google/javascript/jscomp/SourceFileTest.java
index 1223667..9e4ea14 100644
--- a/test/com/google/javascript/jscomp/SourceFileTest.java
+++ b/test/com/google/javascript/jscomp/SourceFileTest.java
@@ -85,25 +85,6 @@ public final class SourceFileTest {
         (code) -> serializeRoundTrip(SourceFile.fromCode("test.js", code, SourceKind.NON_CODE)));
   }
 
-  @Test
-  public void testLineOffset_serialization_noReloadingSource() {
-    testLineOffsetHelper(
-        (code) -> {
-          SourceFile inMemory = SourceFile.fromCode("test.js", code, SourceKind.NON_CODE);
-          assertThat(inMemory.getLineOfOffset(0)).isEqualTo(1); // Trigger line offset generation
-          SourceFile fakeOnDisk =
-              SourceFile.builder()
-                  .withPath("fake_on_disk.js")
-                  .withKind(SourceKind.NON_CODE)
-                  .build();
-
-          fakeOnDisk.restoreFrom(inMemory);
-          assertThat(fakeOnDisk.getLineOfOffset(0)).isEqualTo(1);
-
-          return serializeRoundTrip(fakeOnDisk);
-        });
-  }
-
   private void testLineOffsetHelper(Function<String, SourceFile> factory) {
     SourceFile f0 = factory.apply("");
     assertThat(f0.getLineOfOffset(0)).isEqualTo(1);
@@ -138,6 +119,11 @@ public final class SourceFileTest {
     // TODO(nickreid): This seems like a bug.
     assertThat(f3.getLineOfOffset(-1)).isEqualTo(0);
     assertThrows(Exception.class, () -> f3.getColumnOfOffset(-1));
+
+    SourceFile startsWithNewline = factory.apply("\n'a'\n'b'");
+    assertThat(startsWithNewline.getLineOffset(1)).isEqualTo(0);
+    assertThat(startsWithNewline.getLineOffset(2)).isEqualTo(1);
+    assertThat(startsWithNewline.getLineOffset(3)).isEqualTo(5);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/StrictModeCheckTest.java b/test/com/google/javascript/jscomp/StrictModeCheckTest.java
index 3cffc84..c9e9af2 100644
--- a/test/com/google/javascript/jscomp/StrictModeCheckTest.java
+++ b/test/com/google/javascript/jscomp/StrictModeCheckTest.java
@@ -33,7 +33,7 @@ public final class StrictModeCheckTest extends CompilerTestCase {
   @Before
   public void setUp() throws Exception {
     super.setUp();
-    enableTypeCheck();
+    disableTypeCheck();
   }
 
   @Override
@@ -164,11 +164,13 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testFunctionCallerProp() {
+    enableTypeCheck();
     testWarning("function foo() {foo.caller}", StrictModeCheck.FUNCTION_CALLER_FORBIDDEN);
   }
 
   @Test
   public void testFunctionArgumentsProp() {
+    enableTypeCheck();
     testWarning(
         "function foo() {foo.arguments}", StrictModeCheck.FUNCTION_ARGUMENTS_PROP_FORBIDDEN);
   }
@@ -204,7 +206,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
   public void testValidDelete() {
     testSame("var obj = { a: 0 }; delete obj.a;");
     testSame("var obj = { a: function() {} }; delete obj.a;");
-    disableTypeCheck();
     testSameEs6Strict("var obj = { a(){} }; delete obj.a;");
     testSameEs6Strict("var obj = { a }; delete obj.a;");
   }
@@ -238,8 +239,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
             "  set appData(data) { this.appData_ = data; }",
             "};"));
 
-    disableTypeCheck();
-
     testWarning("var x = {a: 2, a(){}}", StrictModeCheck.DUPLICATE_MEMBER);
     testWarning("var x = {a, a(){}}", StrictModeCheck.DUPLICATE_MEMBER);
     testWarning("var x = {a(){}, a(){}}", StrictModeCheck.DUPLICATE_MEMBER);
@@ -265,8 +264,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testClass() {
-    disableTypeCheck();
-
     testSame(
         lines(
             "class A {",
@@ -342,8 +339,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testComputedPropInClass() {
-    disableTypeCheck();
-
     testSame(
         lines(
             "class Example {",
@@ -354,8 +349,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testStaticAndNonstaticMethodWithSameName() {
-    disableTypeCheck();
-
     testSame(
         lines(
             "class Example {",
@@ -366,8 +359,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testStaticAndNonstaticGetterWithSameName() {
-    disableTypeCheck();
-
     testSame(
         lines(
             "class Example {",
@@ -378,8 +369,6 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testStaticAndNonstaticSetterWithSameName() {
-    disableTypeCheck();
-
     testSame(
         lines(
             "class Example {",
@@ -390,22 +379,38 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testClassWithEmptyMembers() {
-    disableTypeCheck();
-
     testWarning("class Foo { dup() {}; dup() {}; }", StrictModeCheck.DUPLICATE_MEMBER);
   }
 
   @Test
-  public void testClassField() {
-    disableTypeCheck();
+  public void testClassDuplicateFieldError() {
+    testWarning(
+        lines(
+            "class Example {", //
+            "  a;",
+            "  a;",
+            "}"),
+        StrictModeCheck.DUPLICATE_MEMBER);
+  }
 
+  @Test
+  public void testClassDuplicateStaticFieldError() {
+    testWarning(
+        lines(
+            "class Example {", //
+            "  static a;",
+            "  static a;",
+            "}"),
+        StrictModeCheck.DUPLICATE_MEMBER);
+  }
+
+  @Test
+  public void testClassFields_noError() {
     testSame(
         lines(
-            "class Example {",
-            "  a = 2;",
-            "  static b;",
-            "  ['a'] = 'hi';",
-            "  static ['b'];",
+            "class Example {", //
+            "  a;",
+            "  static a;",
             "}"));
   }
 
diff --git a/test/com/google/javascript/jscomp/SymbolTableTest.java b/test/com/google/javascript/jscomp/SymbolTableTest.java
index 046772b..b1c37ad 100644
--- a/test/com/google/javascript/jscomp/SymbolTableTest.java
+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java
@@ -619,10 +619,46 @@ public final class SymbolTableTest {
             lines("goog.module('baz');", "const {Color} = goog.require('foo');", "Color.RED;"));
     Symbol red =
         table.getAllSymbols().stream().filter((s) -> s.getName().equals("RED")).findFirst().get();
+    assertThat(table.getScope(red).getSymbolForScope().getSourceFileName()).isEqualTo("file1.js");
+    assertThat(table.getReferences(red)).hasSize(3);
+  }
+
+  @Test
+  public void testEnumsProvidedAsNamespace() {
+    SymbolTable table =
+        createSymbolTableFromManySources(
+            lines(
+                "goog.provide('foo.bar.Color');",
+                "/** @enum {number} */",
+                "foo.bar.Color = {RED: 1};",
+                "const /** !foo.bar.Color */ color = ",
+                "  foo.bar.Color.RED;"));
+    Symbol red =
+        table.getAllSymbols().stream().filter((s) -> s.getName().equals("RED")).findFirst().get();
+    assertThat(table.getScope(red).getSymbolForScope().getSourceFileName()).isEqualTo("file1.js");
+    assertThat(table.getReferences(red)).hasSize(2);
+    assertThat(table.getReferences(getGlobalVar(table, "foo.bar.Color"))).hasSize(3);
+  }
+
+  @Test
+  public void testEnumsProvidedAsMemberOfNamespace() {
+    SymbolTable table =
+        createSymbolTableFromManySources(
+            lines(
+                "goog.provide('foo.bar');",
+                "/** @enum {number} */",
+                "foo.bar.Color = {RED: 1};",
+                "const /** !foo.bar.Color */ color = ",
+                "  foo.bar.Color.RED;"));
+    Symbol red =
+        table.getAllSymbols().stream().filter((s) -> s.getName().equals("RED")).findFirst().get();
     // Make sure that RED belongs to the scope of Color that is defined in the first file and not
     // third. Because the third file also has "Color" enum that has the same type.
     assertThat(table.getScope(red).getSymbolForScope().getSourceFileName()).isEqualTo("file1.js");
-    assertThat(table.getReferences(red)).hasSize(3);
+    assertThat(table.getReferences(red)).hasSize(2);
+    Symbol colorEnum =
+        table.getAllSymbols().stream().filter((s) -> s.getName().equals("Color")).findFirst().get();
+    assertThat(table.getReferences(colorEnum)).hasSize(3);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index 87cb400..8b11904 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -4372,8 +4372,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
             "/** @constructor */ function F() {}"
                 + "/** jsdoc */ F.prototype.bar = function() {};"
                 + "/** jsdoc */ F.prototype.bar = function() {};")
-        .addDiagnostic(
-            "variable F.prototype.bar redefined, " + "original definition at [testcode]:1")
         .run();
   }
 
@@ -4384,8 +4382,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
             "/** @constructor */ function F() {}"
                 + "F.prototype.bar = function() {};"
                 + "/** jsdoc */ F.prototype.bar = function() {};")
-        .addDiagnostic(
-            "variable F.prototype.bar redefined, " + "original definition at [testcode]:1")
         .run();
   }
 
@@ -26760,7 +26756,7 @@ public final class TypeCheckTest extends TypeCheckTestCase {
     newTest().addSource("class A { static x=2; }").run();
     newTest().addSource("class B { static x; }").run();
     newTest().addSource("class C { static x }").run();
-    newTest().addSource("class D { static /** @type {string|undefined} */ x;}").run();
+    newTest().addSource("class D { /** @type {string|undefined} */ static x;}").run();
     newTest()
         .addSource("class E { /** @type {string} @suppress {checkTypes} */ static x = 2; }")
         .run();
@@ -26879,29 +26875,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testClassDuplicateFieldError() {
-    newTest()
-        .addSource("class C { /** @type {string} */ dog = ''; /** @type {number} */ dog = 0; }")
-        .addDiagnostic("Class field dog is duplicated")
-        .run();
-  }
-
-  @Test
-  public void testClassDuplicateStaticFieldError() {
-    newTest()
-        .addSource(
-            "class C { static /** @type {string} */ dog = ''; static /** @type {number} */ dog = 0;"
-                + " }")
-        .addDiagnostic("Class field dog is duplicated")
-        .run();
-  }
-
-  @Test
-  public void testClassDuplicateOneStaticFieldNoError() {
-    newTest().addSource("class C {dog = 2; static dog = 'hi';}").run();
-  }
-
-  @Test
   public void testClassInitializerTypeInitializer() {
     newTest()
         .addSource(
@@ -29288,6 +29261,16 @@ public final class TypeCheckTest extends TypeCheckTestCase {
         .run();
   }
 
+  @Test
+  @Ignore("b/221480261")
+  public void testSymbolIteratorMethod() {
+    newTest()
+        .includeDefaultExterns()
+        .addSource("const /** number */ num = [][Symbol.iterator];")
+        .addDiagnostic(TypeValidator.TYPE_MISMATCH_WARNING)
+        .run();
+  }
+
   private void testClosureTypes(String js, String description) {
     testClosureTypesMultipleWarnings(
         js, description == null ? null : ImmutableList.of(description));
diff --git a/test/com/google/javascript/jscomp/TypeValidatorTest.java b/test/com/google/javascript/jscomp/TypeValidatorTest.java
index 2ae60f1..b273e96 100644
--- a/test/com/google/javascript/jscomp/TypeValidatorTest.java
+++ b/test/com/google/javascript/jscomp/TypeValidatorTest.java
@@ -650,7 +650,6 @@ public final class TypeValidatorTest extends CompilerTestCase {
 
   @Test
   public void testDuplicateSuppression_class() {
-    enableTranspile();
     testWarning(
         lines(
             "class X { constructor() {} }", //
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index 99cd81b..102fc07 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -2066,6 +2066,12 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertThat(proto2.hasProperty("m1")).isFalse();
     assertThat(proto2.hasProperty("m2")).isFalse();
     assertThat(proto2.hasProperty("m3")).isFalse();
+
+    // Note: it's not necessary for correctness reasons to declare m1 and m2,  but it's trickier to
+    // avoid it without extra string maniuplation
+    assertScope(globalScope).declares("A.prototype.m1");
+    assertScope(globalScope).declares("A.prototype.m2");
+    assertScope(globalScope).doesNotDeclare("A.prototype.m3");
   }
 
   @Test
@@ -2184,10 +2190,11 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
             + "/** @type {number} */ I.prototype.bar;"
             + "/** @record */ I.prototype.baz = function() {};");
 
-    TypedVar baz = globalScope.getVar("I.prototype.baz");
-    assertThat(baz.getType().isInterface()).isTrue();
-    assertThat(baz.getType().isFunctionType()).isTrue();
-    assertThat(baz.getType().toMaybeFunctionType().isStructuralInterface()).isTrue();
+    TypedVar iPrototype = globalScope.getVar("I.prototype");
+    JSType baz = iPrototype.getType().findPropertyType("baz");
+    assertThat(baz.isInterface()).isTrue();
+    assertThat(baz.isFunctionType()).isTrue();
+    assertThat(baz.toMaybeFunctionType().isStructuralInterface()).isTrue();
   }
 
   @Test
@@ -2197,10 +2204,11 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
             + "/** @type {number} */ I.prototype.bar;"
             + "/** @interface */ I.prototype.baz = function() {};");
 
-    TypedVar baz = globalScope.getVar("I.prototype.baz");
-    assertThat(baz.getType().isInterface()).isTrue();
-    assertThat(baz.getType().isFunctionType()).isTrue();
-    assertThat(baz.getType().toMaybeFunctionType().isStructuralInterface()).isFalse();
+    TypedVar iPrototype = globalScope.getVar("I.prototype");
+    JSType baz = iPrototype.getType().findPropertyType("baz");
+    assertThat(baz.isInterface()).isTrue();
+    assertThat(baz.isFunctionType()).isTrue();
+    assertThat(baz.toMaybeFunctionType().isStructuralInterface()).isFalse();
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/UnusedLocalsCheckTest.java b/test/com/google/javascript/jscomp/UnusedLocalsCheckTest.java
index 423b8ac..8a12db3 100644
--- a/test/com/google/javascript/jscomp/UnusedLocalsCheckTest.java
+++ b/test/com/google/javascript/jscomp/UnusedLocalsCheckTest.java
@@ -256,13 +256,13 @@ public final class UnusedLocalsCheckTest extends CompilerTestCase {
         lines(
             "function f(elapsed) {",
             "  let fakeMs = 0;",
-            "  stubs.replace(goog, 'now', () => fakeMs += elapsed);",
+            "  stubs.replace(Date, 'now', () => fakeMs += elapsed);",
             "}"));
     assertNoWarning(
         lines(
             "function f(elapsed) {",
             "  let fakeMs = 0;",
-            "  stubs.replace(goog, 'now', () => fakeMs -= elapsed);",
+            "  stubs.replace(Date, 'now', () => fakeMs -= elapsed);",
             "}"));
   }
 
@@ -272,7 +272,7 @@ public final class UnusedLocalsCheckTest extends CompilerTestCase {
         lines(
             "export function f(elapsed) {",
             "  let fakeMs = 0;",
-            "  stubs.replace(goog, 'now', () => fakeMs -= elapsed);",
+            "  stubs.replace(Date, 'now', () => fakeMs -= elapsed);",
             "}"));
   }
 
diff --git a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
index 89c2695..ee803ff 100644
--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java
@@ -465,7 +465,7 @@ public final class VariableReferenceCheckTest extends CompilerTestCase {
         lines(
             "export function f(elapsed) {",
             "  let fakeMs = 0;",
-            "  stubs.replace(goog, 'now', () => fakeMs -= elapsed);",
+            "  stubs.replace(Date, 'now', () => fakeMs -= elapsed);",
             "}"));
   }
 
diff --git a/test/com/google/javascript/jscomp/deps/Es6SortedDependenciesTest.java b/test/com/google/javascript/jscomp/deps/Es6SortedDependenciesTest.java
deleted file mode 100644
index 8c26635..0000000
--- a/test/com/google/javascript/jscomp/deps/Es6SortedDependenciesTest.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright 2015 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp.deps;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableList;
-import com.google.javascript.jscomp.deps.DependencyInfo.Require;
-import java.util.List;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link Es6SortedDependencies} */
-@RunWith(JUnit4.class)
-public class Es6SortedDependenciesTest {
-  private static SortedDependencies<SimpleDependencyInfo> createSortedDependencies(
-      List<SimpleDependencyInfo> shuffled) {
-    return new Es6SortedDependencies<>(shuffled);
-  }
-
-  @Test
-  public void testSort() throws Exception {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a")
-            .setRequires(Require.googRequireSymbol("b"), Require.googRequireSymbol("c"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b")
-            .setProvides("b")
-            .setRequires(Require.googRequireSymbol("d"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("c", "c")
-            .setProvides("c")
-            .setRequires(Require.googRequireSymbol("d"))
-            .build();
-    SimpleDependencyInfo d = SimpleDependencyInfo.builder("d", "d").setProvides("d").build();
-
-    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(a, b, c, d));
-    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a));
-    assertSortedInputs(ImmutableList.of(d, c, b, a), ImmutableList.of(d, c, b, a));
-    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(d, a, b, c));
-
-    assertSortedDeps(
-        ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a), ImmutableList.of(a));
-    assertSortedDeps(ImmutableList.of(d, c), ImmutableList.of(d, c, b, a), ImmutableList.of(c));
-    assertSortedDeps(ImmutableList.of(d), ImmutableList.of(d, c, b, a), ImmutableList.of(d));
-  }
-
-  @Test
-  public void testSort2() throws Exception {
-    SimpleDependencyInfo ab =
-        SimpleDependencyInfo.builder("ab", "ab")
-            .setProvides("a", "b")
-            .setRequires(Require.googRequireSymbol("d"), Require.googRequireSymbol("f"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("c", "c")
-            .setProvides("c")
-            .setRequires(Require.googRequireSymbol("h"))
-            .build();
-    SimpleDependencyInfo d =
-        SimpleDependencyInfo.builder("d", "d")
-            .setProvides("d")
-            .setRequires(Require.googRequireSymbol("e"), Require.googRequireSymbol("f"))
-            .build();
-    SimpleDependencyInfo ef =
-        SimpleDependencyInfo.builder("ef", "ef")
-            .setProvides("e", "f")
-            .setRequires(Require.googRequireSymbol("g"), Require.googRequireSymbol("c"))
-            .build();
-    SimpleDependencyInfo g = SimpleDependencyInfo.builder("g", "g").setProvides("g").build();
-    SimpleDependencyInfo hi =
-        SimpleDependencyInfo.builder("hi", "hi").setProvides("h", "i").build();
-
-    assertSortedInputs(
-        ImmutableList.of(g, hi, c, ef, d, ab), ImmutableList.of(ab, c, d, ef, g, hi));
-
-    assertSortedDeps(
-        ImmutableList.of(g), ImmutableList.of(ab, c, d, ef, g, hi), ImmutableList.of(g));
-    assertSortedDeps(
-        ImmutableList.of(g, hi, c, ef, d),
-        ImmutableList.of(ab, c, d, ef, g, hi),
-        ImmutableList.of(d, hi));
-  }
-
-  @Test
-  public void testSort3() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a")
-            .setProvides("a")
-            .setRequires(Require.googRequireSymbol("c"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b")
-            .setProvides("b")
-            .setRequires(Require.googRequireSymbol("a"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("c", "c")
-            .setProvides("c")
-            .setRequires(Require.googRequireSymbol("b"))
-            .build();
-
-    assertOrder(ImmutableList.of(a, b, c), ImmutableList.of(b, c, a));
-  }
-
-  @Test
-  public void testSort4() throws Exception {
-    // Check the degenerate case.
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a")
-            .setProvides("a")
-            .setRequires(Require.googRequireSymbol("a"))
-            .build();
-    assertSortedDeps(ImmutableList.of(a), ImmutableList.of(a), ImmutableList.of(a));
-  }
-
-  @Test
-  public void testSort5() {
-    SimpleDependencyInfo a = SimpleDependencyInfo.builder("a", "a").setProvides("a").build();
-    SimpleDependencyInfo b = SimpleDependencyInfo.builder("b", "b").setProvides("b").build();
-    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
-
-    assertSortedInputs(ImmutableList.of(a, b, c), ImmutableList.of(a, b, c));
-    assertSortedInputs(ImmutableList.of(c, b, a), ImmutableList.of(c, b, a));
-  }
-
-  @Test
-  public void testSort6() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("gin", "gin")
-            .setProvides("gin")
-            .setRequires(Require.googRequireSymbol("tonic"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("tonic", "tonic")
-            .setProvides("tonic")
-            .setRequires(Require.googRequireSymbol("gin2"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("gin2", "gin2")
-            .setProvides("gin2")
-            .setRequires(Require.googRequireSymbol("gin"))
-            .build();
-    SimpleDependencyInfo d =
-        SimpleDependencyInfo.builder("gin3", "gin3")
-            .setProvides("gin3")
-            .setRequires(Require.googRequireSymbol("gin"))
-            .build();
-
-    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(c, b, a, d));
-  }
-
-  @Test
-  public void testSort7() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("gin", "gin")
-            .setProvides("gin")
-            .setRequires(Require.googRequireSymbol("tonic"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("tonic", "tonic")
-            .setProvides("tonic")
-            .setRequires(Require.googRequireSymbol("gin"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("gin2", "gin2")
-            .setProvides("gin2")
-            .setRequires(Require.googRequireSymbol("gin"))
-            .build();
-    SimpleDependencyInfo d =
-        SimpleDependencyInfo.builder("gin3", "gin3")
-            .setProvides("gin3")
-            .setRequires(Require.googRequireSymbol("gin"))
-            .build();
-
-    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(b, a, c, d));
-  }
-
-  @Test
-  public void testSort8() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("A", "A")
-            .setProvides("A")
-            .setRequires(Require.googRequireSymbol("B"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("B", "B")
-            .setProvides("B")
-            .setRequires(Require.googRequireSymbol("C"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("C", "C")
-            .setProvides("C")
-            .setRequires(Require.googRequireSymbol("D"))
-            .build();
-    SimpleDependencyInfo d =
-        SimpleDependencyInfo.builder("D", "D")
-            .setProvides("D")
-            .setRequires(Require.googRequireSymbol("A"))
-            .build();
-
-    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(d, c, b, a));
-  }
-
-  @Test
-  public void testSort9() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("A", "A")
-            .setProvides("A")
-            .setRequires(Require.googRequireSymbol("B"))
-            .build();
-    SimpleDependencyInfo a2 =
-        SimpleDependencyInfo.builder("A", "A")
-            .setProvides("A")
-            .setRequires(Require.googRequireSymbol("B1"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("B", "B")
-            .setProvides("B")
-            .setRequires(Require.googRequireSymbol("C"))
-            .build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("C", "C")
-            .setProvides("C")
-            .setRequires(Require.googRequireSymbol("E"))
-            .build();
-    SimpleDependencyInfo d =
-        SimpleDependencyInfo.builder("D", "D")
-            .setProvides("D")
-            .setRequires(Require.googRequireSymbol("A"))
-            .build();
-    SimpleDependencyInfo e =
-        SimpleDependencyInfo.builder("B1", "B1")
-            .setProvides("B1")
-            .setRequires(Require.googRequireSymbol("C1"))
-            .build();
-    SimpleDependencyInfo f =
-        SimpleDependencyInfo.builder("C1", "C1")
-            .setProvides("C1")
-            .setRequires(Require.googRequireSymbol("D1"))
-            .build();
-    SimpleDependencyInfo g =
-        SimpleDependencyInfo.builder("D1", "D1")
-            .setProvides("D1")
-            .setRequires(Require.googRequireSymbol("A"))
-            .build();
-
-    assertOrder(
-        ImmutableList.of(a, a2, b, c, d, e, f, g), ImmutableList.of(c, b, a, g, f, e, a2, d));
-  }
-
-  @Test
-  public void testSort10() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("A", "A")
-            .setProvides("A")
-            .setRequires(Require.googRequireSymbol("C"))
-            .build();
-    SimpleDependencyInfo b = SimpleDependencyInfo.builder("B", "B").setProvides("B").build();
-    SimpleDependencyInfo c = SimpleDependencyInfo.builder("C", "C").setProvides("C").build();
-
-    SortedDependencies<SimpleDependencyInfo> sorted =
-        createSortedDependencies(ImmutableList.of(a, b, c));
-
-    assertThat(sorted.getSortedList()).containsExactly(c, a, b).inOrder();
-  }
-
-  @Test
-  public void testWeakSort() throws Exception {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("c", "c").setProvides("c").setTypeRequires("d").build();
-    SimpleDependencyInfo d = SimpleDependencyInfo.builder("d", "d").setProvides("d").build();
-
-    // The order of weak edges is based on user input.
-    assertSortedWeakDeps(
-        ImmutableList.of(b, c, d), ImmutableList.of(a, b, c, d), ImmutableList.of(a));
-
-    assertSortedWeakDeps(
-        ImmutableList.of(c, b, d), ImmutableList.of(a, c, b, d), ImmutableList.of(a));
-
-    assertSortedWeakDeps(
-        ImmutableList.of(d, b, c), ImmutableList.of(d, b, c, a), ImmutableList.of(a));
-
-    assertSortedWeakDeps(
-        ImmutableList.of(c, d, b), ImmutableList.of(c, d, b, a), ImmutableList.of(a));
-  }
-
-  @Test
-  public void testWeakSortIncludesStrongEdgesFromWeakSources() throws Exception {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b")
-            .setProvides("b")
-            .setRequires(Require.googRequireSymbol("c"))
-            .build();
-    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
-
-    // Order is input order invariant due to the strong edge.
-    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(a, b, c), ImmutableList.of(a));
-
-    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(a, c, b), ImmutableList.of(a));
-  }
-
-  @Test
-  public void testWeakAndStrongIsStrong() throws Exception {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a")
-            .setProvides("a")
-            .setRequires(Require.googRequireSymbol("c"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
-    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
-
-    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(a, b, c), ImmutableList.of(a, b));
-
-    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(a, b, c), ImmutableList.of(b, a));
-
-    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(c, b, a), ImmutableList.of(a, b));
-
-    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(c, a, b), ImmutableList.of(b, a));
-  }
-
-  @Test
-  public void testSortCircularWeakStrongReference() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a")
-            .setProvides("a")
-            .setRequires(Require.googRequireSymbol("b"))
-            .build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("a").build();
-
-    assertSortedInputs(ImmutableList.of(b, a), ImmutableList.of(a, b));
-    assertSortedInputs(ImmutableList.of(b, a), ImmutableList.of(b, a));
-  }
-
-  @Test
-  public void testSortCircularWeakReference() {
-    SimpleDependencyInfo a =
-        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
-    SimpleDependencyInfo b =
-        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
-    SimpleDependencyInfo c =
-        SimpleDependencyInfo.builder("c", "c").setProvides("c").setTypeRequires("b").build();
-
-    assertSortedWeakDeps(ImmutableList.of(b, c), ImmutableList.of(b, c, a), ImmutableList.of(a));
-    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(c, b, a), ImmutableList.of(a));
-    assertSortedWeakDeps(ImmutableList.of(b, c), ImmutableList.of(a, b, c), ImmutableList.of(a));
-  }
-
-  private static void assertSortedInputs(
-      List<SimpleDependencyInfo> expected, List<SimpleDependencyInfo> shuffled) {
-    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
-    assertThat(sorted.getSortedList()).isEqualTo(expected);
-  }
-
-  private static void assertSortedDeps(
-      List<SimpleDependencyInfo> expected,
-      List<SimpleDependencyInfo> shuffled,
-      List<SimpleDependencyInfo> roots)
-      throws Exception {
-    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
-    assertThat(sorted.getSortedStrongDependenciesOf(roots)).isEqualTo(expected);
-  }
-
-  private static void assertSortedWeakDeps(
-      List<SimpleDependencyInfo> expected,
-      List<SimpleDependencyInfo> shuffled,
-      List<SimpleDependencyInfo> roots) {
-    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
-    assertThat(sorted.getSortedWeakDependenciesOf(roots)).isEqualTo(expected);
-  }
-
-  private static void assertOrder(
-      ImmutableList<SimpleDependencyInfo> shuffle, ImmutableList<SimpleDependencyInfo> expected) {
-    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffle);
-    assertThat(sorted.getSortedList()).isEqualTo(expected);
-  }
-}
diff --git a/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java b/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java
index b882028..32cb8e3 100644
--- a/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java
+++ b/test/com/google/javascript/jscomp/deps/JsFileLineParserTest.java
@@ -154,8 +154,8 @@ public final class JsFileLineParserTest {
   }
 
   private static class TestParser extends JsFileLineParser {
-    StringBuilder sb = new StringBuilder();
-    StringBuilder comments = new StringBuilder();
+    final StringBuilder sb = new StringBuilder();
+    final StringBuilder comments = new StringBuilder();
 
     TestParser(ErrorManager errorManager) {
       super(errorManager);
diff --git a/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java b/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java
new file mode 100644
index 0000000..661d321
--- /dev/null
+++ b/test/com/google/javascript/jscomp/deps/SortedDependenciesTest.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2015 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp.deps;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.deps.DependencyInfo.Require;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link SortedDependencies} */
+@RunWith(JUnit4.class)
+public class SortedDependenciesTest {
+  private static SortedDependencies<SimpleDependencyInfo> createSortedDependencies(
+      List<SimpleDependencyInfo> shuffled) {
+    return new SortedDependencies<>(shuffled);
+  }
+
+  @Test
+  public void testSort() throws Exception {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a")
+            .setRequires(Require.googRequireSymbol("b"), Require.googRequireSymbol("c"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b")
+            .setProvides("b")
+            .setRequires(Require.googRequireSymbol("d"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("c", "c")
+            .setProvides("c")
+            .setRequires(Require.googRequireSymbol("d"))
+            .build();
+    SimpleDependencyInfo d = SimpleDependencyInfo.builder("d", "d").setProvides("d").build();
+
+    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(a, b, c, d));
+    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a));
+    assertSortedInputs(ImmutableList.of(d, c, b, a), ImmutableList.of(d, c, b, a));
+    assertSortedInputs(ImmutableList.of(d, b, c, a), ImmutableList.of(d, a, b, c));
+
+    assertSortedDeps(
+        ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a), ImmutableList.of(a));
+    assertSortedDeps(ImmutableList.of(d, c), ImmutableList.of(d, c, b, a), ImmutableList.of(c));
+    assertSortedDeps(ImmutableList.of(d), ImmutableList.of(d, c, b, a), ImmutableList.of(d));
+  }
+
+  @Test
+  public void testSort2() throws Exception {
+    SimpleDependencyInfo ab =
+        SimpleDependencyInfo.builder("ab", "ab")
+            .setProvides("a", "b")
+            .setRequires(Require.googRequireSymbol("d"), Require.googRequireSymbol("f"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("c", "c")
+            .setProvides("c")
+            .setRequires(Require.googRequireSymbol("h"))
+            .build();
+    SimpleDependencyInfo d =
+        SimpleDependencyInfo.builder("d", "d")
+            .setProvides("d")
+            .setRequires(Require.googRequireSymbol("e"), Require.googRequireSymbol("f"))
+            .build();
+    SimpleDependencyInfo ef =
+        SimpleDependencyInfo.builder("ef", "ef")
+            .setProvides("e", "f")
+            .setRequires(Require.googRequireSymbol("g"), Require.googRequireSymbol("c"))
+            .build();
+    SimpleDependencyInfo g = SimpleDependencyInfo.builder("g", "g").setProvides("g").build();
+    SimpleDependencyInfo hi =
+        SimpleDependencyInfo.builder("hi", "hi").setProvides("h", "i").build();
+
+    assertSortedInputs(
+        ImmutableList.of(g, hi, c, ef, d, ab), ImmutableList.of(ab, c, d, ef, g, hi));
+
+    assertSortedDeps(
+        ImmutableList.of(g), ImmutableList.of(ab, c, d, ef, g, hi), ImmutableList.of(g));
+    assertSortedDeps(
+        ImmutableList.of(g, hi, c, ef, d),
+        ImmutableList.of(ab, c, d, ef, g, hi),
+        ImmutableList.of(d, hi));
+  }
+
+  @Test
+  public void testSort3() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a")
+            .setProvides("a")
+            .setRequires(Require.googRequireSymbol("c"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b")
+            .setProvides("b")
+            .setRequires(Require.googRequireSymbol("a"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("c", "c")
+            .setProvides("c")
+            .setRequires(Require.googRequireSymbol("b"))
+            .build();
+
+    assertOrder(ImmutableList.of(a, b, c), ImmutableList.of(b, c, a));
+  }
+
+  @Test
+  public void testSort4() throws Exception {
+    // Check the degenerate case.
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a")
+            .setProvides("a")
+            .setRequires(Require.googRequireSymbol("a"))
+            .build();
+    assertSortedDeps(ImmutableList.of(a), ImmutableList.of(a), ImmutableList.of(a));
+  }
+
+  @Test
+  public void testSort5() {
+    SimpleDependencyInfo a = SimpleDependencyInfo.builder("a", "a").setProvides("a").build();
+    SimpleDependencyInfo b = SimpleDependencyInfo.builder("b", "b").setProvides("b").build();
+    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
+
+    assertSortedInputs(ImmutableList.of(a, b, c), ImmutableList.of(a, b, c));
+    assertSortedInputs(ImmutableList.of(c, b, a), ImmutableList.of(c, b, a));
+  }
+
+  @Test
+  public void testSort6() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("gin", "gin")
+            .setProvides("gin")
+            .setRequires(Require.googRequireSymbol("tonic"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("tonic", "tonic")
+            .setProvides("tonic")
+            .setRequires(Require.googRequireSymbol("gin2"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("gin2", "gin2")
+            .setProvides("gin2")
+            .setRequires(Require.googRequireSymbol("gin"))
+            .build();
+    SimpleDependencyInfo d =
+        SimpleDependencyInfo.builder("gin3", "gin3")
+            .setProvides("gin3")
+            .setRequires(Require.googRequireSymbol("gin"))
+            .build();
+
+    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(c, b, a, d));
+  }
+
+  @Test
+  public void testSort7() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("gin", "gin")
+            .setProvides("gin")
+            .setRequires(Require.googRequireSymbol("tonic"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("tonic", "tonic")
+            .setProvides("tonic")
+            .setRequires(Require.googRequireSymbol("gin"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("gin2", "gin2")
+            .setProvides("gin2")
+            .setRequires(Require.googRequireSymbol("gin"))
+            .build();
+    SimpleDependencyInfo d =
+        SimpleDependencyInfo.builder("gin3", "gin3")
+            .setProvides("gin3")
+            .setRequires(Require.googRequireSymbol("gin"))
+            .build();
+
+    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(b, a, c, d));
+  }
+
+  @Test
+  public void testSort8() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("A", "A")
+            .setProvides("A")
+            .setRequires(Require.googRequireSymbol("B"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("B", "B")
+            .setProvides("B")
+            .setRequires(Require.googRequireSymbol("C"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("C", "C")
+            .setProvides("C")
+            .setRequires(Require.googRequireSymbol("D"))
+            .build();
+    SimpleDependencyInfo d =
+        SimpleDependencyInfo.builder("D", "D")
+            .setProvides("D")
+            .setRequires(Require.googRequireSymbol("A"))
+            .build();
+
+    assertOrder(ImmutableList.of(a, b, c, d), ImmutableList.of(d, c, b, a));
+  }
+
+  @Test
+  public void testSort9() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("A", "A")
+            .setProvides("A")
+            .setRequires(Require.googRequireSymbol("B"))
+            .build();
+    SimpleDependencyInfo a2 =
+        SimpleDependencyInfo.builder("A", "A")
+            .setProvides("A")
+            .setRequires(Require.googRequireSymbol("B1"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("B", "B")
+            .setProvides("B")
+            .setRequires(Require.googRequireSymbol("C"))
+            .build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("C", "C")
+            .setProvides("C")
+            .setRequires(Require.googRequireSymbol("E"))
+            .build();
+    SimpleDependencyInfo d =
+        SimpleDependencyInfo.builder("D", "D")
+            .setProvides("D")
+            .setRequires(Require.googRequireSymbol("A"))
+            .build();
+    SimpleDependencyInfo e =
+        SimpleDependencyInfo.builder("B1", "B1")
+            .setProvides("B1")
+            .setRequires(Require.googRequireSymbol("C1"))
+            .build();
+    SimpleDependencyInfo f =
+        SimpleDependencyInfo.builder("C1", "C1")
+            .setProvides("C1")
+            .setRequires(Require.googRequireSymbol("D1"))
+            .build();
+    SimpleDependencyInfo g =
+        SimpleDependencyInfo.builder("D1", "D1")
+            .setProvides("D1")
+            .setRequires(Require.googRequireSymbol("A"))
+            .build();
+
+    assertOrder(
+        ImmutableList.of(a, a2, b, c, d, e, f, g), ImmutableList.of(c, b, a, g, f, e, a2, d));
+  }
+
+  @Test
+  public void testSort10() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("A", "A")
+            .setProvides("A")
+            .setRequires(Require.googRequireSymbol("C"))
+            .build();
+    SimpleDependencyInfo b = SimpleDependencyInfo.builder("B", "B").setProvides("B").build();
+    SimpleDependencyInfo c = SimpleDependencyInfo.builder("C", "C").setProvides("C").build();
+
+    SortedDependencies<SimpleDependencyInfo> sorted =
+        createSortedDependencies(ImmutableList.of(a, b, c));
+
+    assertThat(sorted.getSortedList()).containsExactly(c, a, b).inOrder();
+  }
+
+  @Test
+  public void testWeakSort() throws Exception {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("c", "c").setProvides("c").setTypeRequires("d").build();
+    SimpleDependencyInfo d = SimpleDependencyInfo.builder("d", "d").setProvides("d").build();
+
+    // The order of weak edges is based on user input.
+    assertSortedWeakDeps(
+        ImmutableList.of(b, c, d), ImmutableList.of(a, b, c, d), ImmutableList.of(a));
+
+    assertSortedWeakDeps(
+        ImmutableList.of(c, b, d), ImmutableList.of(a, c, b, d), ImmutableList.of(a));
+
+    assertSortedWeakDeps(
+        ImmutableList.of(d, b, c), ImmutableList.of(d, b, c, a), ImmutableList.of(a));
+
+    assertSortedWeakDeps(
+        ImmutableList.of(c, d, b), ImmutableList.of(c, d, b, a), ImmutableList.of(a));
+  }
+
+  @Test
+  public void testWeakSortIncludesStrongEdgesFromWeakSources() throws Exception {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b")
+            .setProvides("b")
+            .setRequires(Require.googRequireSymbol("c"))
+            .build();
+    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
+
+    // Order is input order invariant due to the strong edge.
+    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(a, b, c), ImmutableList.of(a));
+
+    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(a, c, b), ImmutableList.of(a));
+  }
+
+  @Test
+  public void testWeakAndStrongIsStrong() throws Exception {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a")
+            .setProvides("a")
+            .setRequires(Require.googRequireSymbol("c"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
+    SimpleDependencyInfo c = SimpleDependencyInfo.builder("c", "c").setProvides("c").build();
+
+    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(a, b, c), ImmutableList.of(a, b));
+
+    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(a, b, c), ImmutableList.of(b, a));
+
+    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(c, b, a), ImmutableList.of(a, b));
+
+    assertSortedWeakDeps(ImmutableList.of(), ImmutableList.of(c, a, b), ImmutableList.of(b, a));
+  }
+
+  @Test
+  public void testSortCircularWeakStrongReference() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a")
+            .setProvides("a")
+            .setRequires(Require.googRequireSymbol("b"))
+            .build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("a").build();
+
+    assertSortedInputs(ImmutableList.of(b, a), ImmutableList.of(a, b));
+    assertSortedInputs(ImmutableList.of(b, a), ImmutableList.of(b, a));
+  }
+
+  @Test
+  public void testSortCircularWeakReference() {
+    SimpleDependencyInfo a =
+        SimpleDependencyInfo.builder("a", "a").setProvides("a").setTypeRequires("b").build();
+    SimpleDependencyInfo b =
+        SimpleDependencyInfo.builder("b", "b").setProvides("b").setTypeRequires("c").build();
+    SimpleDependencyInfo c =
+        SimpleDependencyInfo.builder("c", "c").setProvides("c").setTypeRequires("b").build();
+
+    assertSortedWeakDeps(ImmutableList.of(b, c), ImmutableList.of(b, c, a), ImmutableList.of(a));
+    assertSortedWeakDeps(ImmutableList.of(c, b), ImmutableList.of(c, b, a), ImmutableList.of(a));
+    assertSortedWeakDeps(ImmutableList.of(b, c), ImmutableList.of(a, b, c), ImmutableList.of(a));
+  }
+
+  private static void assertSortedInputs(
+      List<SimpleDependencyInfo> expected, List<SimpleDependencyInfo> shuffled) {
+    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
+    assertThat(sorted.getSortedList()).isEqualTo(expected);
+  }
+
+  private static void assertSortedDeps(
+      List<SimpleDependencyInfo> expected,
+      List<SimpleDependencyInfo> shuffled,
+      List<SimpleDependencyInfo> roots)
+      throws Exception {
+    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
+    assertThat(sorted.getSortedStrongDependenciesOf(roots)).isEqualTo(expected);
+  }
+
+  private static void assertSortedWeakDeps(
+      List<SimpleDependencyInfo> expected,
+      List<SimpleDependencyInfo> shuffled,
+      List<SimpleDependencyInfo> roots) {
+    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffled);
+    assertThat(sorted.getSortedWeakDependenciesOf(roots)).isEqualTo(expected);
+  }
+
+  private static void assertOrder(
+      ImmutableList<SimpleDependencyInfo> shuffle, ImmutableList<SimpleDependencyInfo> expected) {
+    SortedDependencies<SimpleDependencyInfo> sorted = createSortedDependencies(shuffle);
+    assertThat(sorted.getSortedList()).isEqualTo(expected);
+  }
+}
diff --git a/test/com/google/javascript/jscomp/graph/CheckPathsBetweenNodesTest.java b/test/com/google/javascript/jscomp/graph/CheckPathsBetweenNodesTest.java
index 0a2205a..f2a2414 100644
--- a/test/com/google/javascript/jscomp/graph/CheckPathsBetweenNodesTest.java
+++ b/test/com/google/javascript/jscomp/graph/CheckPathsBetweenNodesTest.java
@@ -36,7 +36,7 @@ public final class CheckPathsBetweenNodesTest {
    * Predicate satisfied by strings with a given prefix.
    */
   private static class PrefixPredicate implements Predicate<String> {
-    String prefix;
+    final String prefix;
 
     PrefixPredicate(String prefix) {
       this.prefix = prefix;
diff --git a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
index 855dd41..104901c 100644
--- a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
+++ b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
@@ -1194,11 +1194,11 @@ public final class ConvertToTypedInterfaceTest extends CompilerTestCase {
         "/** @enum {number} */ var E = { A: foo(), B: bar(), C: baz()};",
         "/** @enum {number} */ var E = { A: 0, B: 0, C: 0};");
 
-    // NOTE: This pattern typechecks when found in externs, but not for code.
-    // Since the goal of this pass is intended to be used as externs, this is acceptable.
+    // No corrosion into 0 for string enums. This allows conformance to emit fewer false positives.
+    // Values longer than 10 gets truncated.
     test(
-        "/** @enum {string} */ var E = { A: 'hello', B: 'world'};",
-        "/** @enum {string} */ var E = { A: 0, B: 0};");
+        "/** @enum {string} */ var E = { A: 'hello', B: 'world', C: 'some_string_longer_than_10'};",
+        "/** @enum {string} */ var E = { A: 'hello', B: 'world', C: 'some_str..'};");
 
     test(
         "/** @enum {Object} */ var E = { A: {b: 'c'}, D: {e: 'f'} };",
diff --git a/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java b/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
index 1e5982e..7f2bcf3 100644
--- a/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
@@ -2079,7 +2079,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceSimple() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     test(options, "var x = 0; var y = {}; alert(x ?? y)", "alert(0)");
@@ -2089,7 +2089,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceChain() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     test(options, "var x, y; alert(x ?? y ?? 'default string')", "alert('default string')");
@@ -2099,7 +2099,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceWithAnd() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     test(options, "var x, y, z; alert(x ?? (y && z))", "alert(void 0)");
@@ -2109,7 +2109,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceWithAssign() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     test(options, "var x, y; var z = 1; x ?? (y = z); alert(y)", "alert(1)");
@@ -2119,7 +2119,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceTranspiledOutput() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     externs =
@@ -2132,7 +2132,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   public void nullishCoalesceChainTranspiledOutput() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2019);
 
     externs =
@@ -2482,7 +2482,7 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
                 .addExtra("/** @fileoverview @suppress {externsValidation} */ foobar")
                 .buildExternsFile("externs.js"));
 
-    // with just variable renaming on, the code is unchanged becasue of the 'foobar' externs ref.
+    // with just variable renaming on, the code is unchanged because of the 'foobar' externs ref.
     options.setVariableRenaming(VariableRenamingPolicy.ALL);
     test(options, "foobar = {x: 1}; alert(foobar.x);", "foobar = {x:1}; alert(foobar.x);");
 
@@ -2490,4 +2490,180 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
     test(options, "foobar = {x: 1}; alert(foobar.x);", "foobar = {a: 1}; alert(foobar.a);");
   }
+
+  /**
+   * Validates that a private interface implemented by two classes will merge their disambiguation
+   * clusters even if it is DCE'd.
+   */
+  @Test
+  public void testHiddenInterfacesDisambiguateProperties() {
+
+    CompilerOptions options = createCompilerOptions();
+    options.setPropertyRenaming(PropertyRenamingPolicy.ALL_UNQUOTED);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2015);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setTypeBasedOptimizationOptions(options);
+
+    test(
+        options,
+        lines(
+            "/** @interface */",
+            "class Interface {",
+            "  /** @return {number} */",
+            "  getField() {}",
+            "}",
+            "/** @interface */",
+            "class Interface2 {",
+            "  /** @return {number} */",
+            "  getOtherField() {}",
+            "}",
+            "/** ",
+            " * @implements {Interface}",
+            " * @implements {Interface2}",
+            " */",
+            "class Foo {",
+            "  constructor(/** number */ bar) {",
+            "    this.bar = bar;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getOtherField() {",
+            "    return this.bar + this.bar;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getField() {",
+            "    return this.bar;",
+            "  }",
+            "}",
+            "/** @implements {Interface} */",
+            "class Bar {",
+            "  constructor(baz) {",
+            "    this.baz = baz;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getField() {",
+            "    return this.baz;",
+            "  }",
+            "}",
+            // Needed or jscomp will devirtualize getOtherField().
+            "window['Interface2'] = Interface2;",
+            "window['Foo'] = Foo;",
+            "window['Bar'] = Bar;",
+            "/**",
+            " * @param {!Foo} foo",
+            " * @param {!Bar} bar",
+            " */",
+            "window['foobar'] = function(foo, bar) {",
+            "  return foo.getField() + foo.getOtherField() + bar.getField();",
+            "};"),
+        lines(
+            "class b {",
+            "  c() {}",
+            "}",
+            "class c {",
+            "  constructor(a) {",
+            "    this.a = a;",
+            "  }",
+            "  c() {",
+            "    return this.a + this.a;",
+            "  }",
+            "  b() {",
+            "    return this.a;",
+            "  }",
+            "}",
+            "class d {",
+            "  constructor(a) {",
+            "    this.a = a;",
+            "  }",
+            "  b() {",
+            "    return this.a;",
+            "  }",
+            "}",
+            "window.Interface2 = b;",
+            "window.Foo = c;",
+            "window.Bar = d;",
+            "window.foobar = function(a, e) {",
+            // Property disambiguation renames both ".getField()" calls to .b().
+            "  return a.b() + a.c() + e.b();",
+            "};"));
+  }
+
+  /**
+   * Validates that a private interface implemented by two classes allows for devirtualization when
+   * the interface is DCE'd.
+   */
+  @Test
+  public void testHiddenInterfacesDoNotInhibitDevirtualization() {
+
+    CompilerOptions options = createCompilerOptions();
+    options.setPropertyRenaming(PropertyRenamingPolicy.ALL_UNQUOTED);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2015);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setTypeBasedOptimizationOptions(options);
+
+    test(
+        options,
+        lines(
+            "/** @interface */",
+            "class Interface {",
+            "  /** @return {number} */",
+            "  getField() {}",
+            "}",
+            "/** @interface */",
+            "class Interface2 {",
+            "  /** @return {number} */",
+            "  getOtherField() {}",
+            "}",
+            "/** ",
+            " * @implements {Interface}",
+            " * @implements {Interface2}",
+            " */",
+            "class Foo {",
+            "  constructor(/** number */ bar) {",
+            "    this.bar = bar;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getOtherField() {",
+            "    return this.bar + this.bar;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getField() {",
+            "    return this.bar;",
+            "  }",
+            "}",
+            "/** @implements {Interface} */",
+            "class Bar {",
+            "  constructor(baz) {",
+            "    this.baz = baz;",
+            "  }",
+            "  /** @override @noinline */",
+            "  getField() {",
+            "    return this.baz;",
+            "  }",
+            "}",
+            // Needed or jscomp will devirtualize getOtherField().
+            "window['Foo'] = Foo;",
+            "/**",
+            " * @param {!Foo} foo",
+            " * @param {!Bar} bar",
+            " */",
+            "window['foobar'] = function(foo, bar) {",
+            "  return foo.getField() + foo.getOtherField() + bar.getField();",
+            "};"),
+        lines(
+            "function b(a) {",
+            "  return a.a + a.a;",
+            "}",
+            "function c(a) {",
+            "  return a.a;",
+            "}",
+            "class d {",
+            "  constructor(a) {",
+            "    this.a = a;",
+            "  }",
+            "}",
+            "window.Foo = d;",
+            "window.foobar = function(a, e) {",
+            "  return c(a) + b(a) + c(e);",
+            "};"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/ClosureIntegrationTest.java b/test/com/google/javascript/jscomp/integration/ClosureIntegrationTest.java
index 195e5fa..9973938 100644
--- a/test/com/google/javascript/jscomp/integration/ClosureIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ClosureIntegrationTest.java
@@ -930,7 +930,7 @@ public final class ClosureIntegrationTest extends IntegrationTestCase {
           // input 0
           "goog.module('a.b');",
           // input 1
-          "goog.module.get('a.b');"
+          "var unsupportedAssignmentToGlobal = goog.module.get('a.b');"
         },
         DiagnosticGroups.CLOSURE_DEP_METHOD_USAGE_CHECKS);
 
@@ -941,7 +941,7 @@ public final class ClosureIntegrationTest extends IntegrationTestCase {
           // input 0
           "goog.module('a.b');",
           // input 1
-          "goog.provide('c'); goog.module.get('a.b');"
+          "goog.provide('c'); var unsupportedAssignmentToGlobal = goog.module.get('a.b');"
         },
         DiagnosticGroups.CLOSURE_DEP_METHOD_USAGE_CHECKS);
   }
@@ -1116,7 +1116,7 @@ public final class ClosureIntegrationTest extends IntegrationTestCase {
     // A bug in Es6RewriteClasses meant we were putting the wrong `originalName` on some nodes.
     CompilerOptions options = createCompilerOptions();
     // force SourceInformationAnnotator to run
-    options.setExternExports(true);
+    options.setExternExportsPath("exports.js");
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     options.setClosurePass(true);
 
diff --git a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
index 25eabac..9569f1b 100644
--- a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
@@ -39,7 +39,7 @@ public final class ES2022IntegrationTest extends IntegrationTestCase {
   /** Creates a CompilerOptions object with google coding conventions. */
   protected CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setDevMode(DevMode.EVERY_PASS);
     options.setCodingConvention(new GoogleCodingConvention());
     return options;
diff --git a/test/com/google/javascript/jscomp/integration/IntegrationTest.java b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
index d0c8088..e253be8 100644
--- a/test/com/google/javascript/jscomp/integration/IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
@@ -79,7 +79,7 @@ public final class IntegrationTest extends IntegrationTestCase {
   public void testSubstituteEs6Syntax() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
 
     externs =
@@ -100,7 +100,7 @@ public final class IntegrationTest extends IntegrationTestCase {
   public void testNewDotTargetTranspilation() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5_STRICT);
     test(
         options,
@@ -127,7 +127,7 @@ public final class IntegrationTest extends IntegrationTestCase {
   public void testNumericSeparator() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
     test(options, "1_000", "1000");
   }
@@ -3340,11 +3340,10 @@ public final class IntegrationTest extends IntegrationTestCase {
             "",
             "}); // goog.scope"),
         lines(
-            "var $jscomp = $jscomp || {};",
-            "$jscomp.scope = {};",
             "var foo = {};",
-            "/** @const */ $jscomp.scope.RESULT = 5;",
-            "/** @return {number} */ foo.baz = function() { return $jscomp.scope.RESULT; }"));
+            "/** @const */ var $jscomp$scope$98447280$0$RESULT = 5;",
+            "/** @return {number} */ foo.baz = function() { return $jscomp$scope$98447280$0$RESULT;"
+                + " }"));
   }
 
   @Test
@@ -3452,12 +3451,11 @@ public final class IntegrationTest extends IntegrationTestCase {
   @Test
   public void testWarnUnnecessaryBackslashInStringLiteral() {
     CompilerOptions options = createCompilerOptions();
-    options.setWarningLevel(DiagnosticGroups.UNNECESSARY_ESCAPE, CheckLevel.WARNING);
-    test(
-        options,
-        new String[] {"var str = '\\q';"},
-        new String[] {"var str = 'q';"},
-        DiagnosticGroups.UNNECESSARY_ESCAPE);
+    options.setWarningLevel(DiagnosticGroups.LINT_CHECKS, CheckLevel.WARNING);
+
+    compile(options, "const str = '\\q';");
+    assertThat(lastCompiler.getWarnings()).hasSize(1);
+    assertThat(lastCompiler.getWarnings().get(0).getDescription()).contains("Unnecessary escape");
   }
 
   // NOTE(dimvar): the jsdocs are ignored in the comparison of the before/after ASTs. It'd be nice
@@ -3639,7 +3637,7 @@ public final class IntegrationTest extends IntegrationTestCase {
 
     options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
     testSame(options, "async function* foo() {}");
-    testSame(options, "for await (a of b) {}");
+    testSame(options, "async () => { for await (a of b) {} }");
 
     options.setLanguageOut(LanguageMode.ECMASCRIPT_2017);
     test(
@@ -3837,7 +3835,7 @@ public final class IntegrationTest extends IntegrationTestCase {
     // A bug in Es6RewriteClasses meant we were putting the wrong `originalName` on some nodes.
     CompilerOptions options = createCompilerOptions();
     // force SourceInformationAnnotator to run
-    options.setExternExports(true);
+    options.setExternExportsPath("exports.js");
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     options.setClosurePass(true);
 
@@ -4269,7 +4267,7 @@ public final class IntegrationTest extends IntegrationTestCase {
     // Repro case for Github issue 3607.  Don't crash with a reference to new.target
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
     WarningLevel.QUIET.setOptionsForWarningLevel(options);
     test(
@@ -4300,7 +4298,7 @@ public final class IntegrationTest extends IntegrationTestCase {
 
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.WHITESPACE_ONLY.setOptionsForCompilationLevel(options);
-    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT_IN);
+    options.setLanguageIn(LanguageMode.UNSTABLE);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     test(
         options,
@@ -4319,4 +4317,19 @@ public final class IntegrationTest extends IntegrationTestCase {
             "}",
             ""));
   }
+
+  @Test
+  public void testGoogScopeWithAngular() {
+    CompilerOptions options = createCompilerOptions();
+    options.setClosurePass(true);
+    options.setCheckTypes(true);
+    options.setAngularPass(true);
+
+    test(
+        options,
+        lines("goog.scope(function() {", "/** @ngInject */", "function fn(a, b) {}", "});"),
+        lines(
+            "var $jscomp$scope$98447280$0$fn = function(a, b) {};",
+            "$jscomp$scope$98447280$0$fn[\"$inject\"] = [\"a\", \"b\"];"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
index 1eba770..16779e0 100644
--- a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
@@ -100,6 +100,29 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
   }
 
   @Test
+  public void disambiguatesGoogScopeAcrossLibraries() throws IOException {
+
+    SourceFile lib1 = code("goog.scope(function () { var x = 3; });");
+    SourceFile lib2 = code("goog.scope(function () { var x = 4; });");
+    SourceFile externs = extern(new TestExternsBuilder().addClosureExterns().build());
+
+    precompileLibrary(externs);
+    precompileLibrary(typeSummary(externs), lib1);
+    precompileLibrary(typeSummary(externs), lib2);
+
+    CompilerOptions options = new CompilerOptions();
+    options.setClosurePass(true);
+
+    Compiler compiler = compileTypedAstShards(options);
+    Node expectedRoot =
+        parseExpectedCode(
+            "var $jscomp$scope$1954846972$0$x=3;", "var $jscomp$scope$1954846973$0$x=4");
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
+  @Test
   public void disambiguatesAndDeletesMethodsAcrossLibraries() throws IOException {
     SourceFile lib1 = code("class Lib1 { m() { return 'lib1'; } n() { return 'delete me'; } }");
     SourceFile lib2 = code("class Lib2 { m() { return 'delete me'; } n() { return 'lib2'; } }");
@@ -332,6 +355,31 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
         .isEqualTo(expectedRoot);
   }
 
+  @Test
+  public void testAngularPass() throws IOException {
+    precompileLibrary(
+        extern(new TestExternsBuilder().build()),
+        code(
+            lines(
+                "/** @ngInject */ function f() {} ",
+                "/** @ngInject */ function g(a){} ",
+                "/** @ngInject */ var b = function f(a, b, c) {} ")));
+
+    CompilerOptions options = new CompilerOptions();
+
+    Compiler compiler = compileTypedAstShards(options);
+
+    Node expectedRoot =
+        parseExpectedCode(
+            lines(
+                "function f() {} ",
+                "function g(a) {} g['$inject']=['a'];",
+                "var b = function f(a, b, c) {}; b['$inject']=['a', 'b', 'c']"));
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
   // use over 'compileTypedAstShards' if you want to validate reported errors or warnings in your
   // @Test case.
   private Compiler compileTypedAstShardsWithoutErrorChecks(CompilerOptions options)
@@ -393,9 +441,11 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
 
     CompilerOptions options = new CompilerOptions();
     options.setChecksOnly(true);
+    options.setAngularPass(true);
     WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
     options.setProtectHiddenSideEffects(true);
     options.setTypedAstOutputFile(typedAstPath);
+    options.setClosurePass(true);
 
     ImmutableList.Builder<SourceFile> externs = ImmutableList.builder();
     ImmutableList.Builder<SourceFile> sources = ImmutableList.builder();
diff --git a/test/com/google/javascript/jscomp/lint/CheckUnusedPrivatePropertiesTest.java b/test/com/google/javascript/jscomp/lint/CheckUnusedPrivatePropertiesTest.java
index 3159fb2..bc8076e 100644
--- a/test/com/google/javascript/jscomp/lint/CheckUnusedPrivatePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/lint/CheckUnusedPrivatePropertiesTest.java
@@ -278,12 +278,13 @@ public final class CheckUnusedPrivatePropertiesTest extends CompilerTestCase {
 
   @Test
   public void testPrototypeProps2() {
-    // don't warn about properties that are exported by convention
-    used(lines(
-        "/** @constructor */ function A() {this._foo = 1;}",
-        "/** @private */ A.prototype._foo = 0;",
-        "A.prototype.method = function() {this._foo++};",
-        "new A().method()"));
+    // warn about all private properties
+    unused(
+        lines(
+            "/** @constructor */ function A() {this._foo = 1;}",
+            "/** @private */ A.prototype._foo = 0;",
+            "A.prototype.method = function() {this._foo++};",
+            "new A().method()"));
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index 9f7075b..433b55c 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -3148,14 +3148,12 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   public void testSingleTags() {
     JSDocInfo jsdoc =
         parse(
-            "@version Some old version"
-                + "\n* @deprecated In favor of the new one!"
+            "@deprecated In favor of the new one!"
                 + "\n* @return {SomeType} The most important object :-)*/",
             true);
 
     assertThat(jsdoc.isDeprecated()).isTrue();
     assertThat(jsdoc.getDeprecationReason()).isEqualTo("In favor of the new one!");
-    assertThat(jsdoc.getVersion()).isEqualTo("Some old version");
     assertThat(jsdoc.getReturnDescription()).isEqualTo("The most important object :-)");
   }
 
@@ -3171,30 +3169,15 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     JSDocInfo jsdoc =
         parse(
             "@deprecated In favor of the new one!"
-                + "\n * @return {SomeType} The most important object :-)"
-                + "\n * @version Some old version*/",
+                + "\n * @return {SomeType} The most important object :-)*/",
             true);
 
     assertThat(jsdoc.isDeprecated()).isTrue();
     assertThat(jsdoc.getDeprecationReason()).isEqualTo("In favor of the new one!");
-    assertThat(jsdoc.getVersion()).isEqualTo("Some old version");
     assertThat(jsdoc.getReturnDescription()).isEqualTo("The most important object :-)");
   }
 
   @Test
-  public void testVersionDuplication() {
-    parse(
-        "* @version Some old version" + "\n* @version Another version*/",
-        true,
-        "conflicting @version tag");
-  }
-
-  @Test
-  public void testVersionMissing() {
-    parse("* @version */", true, "@version tag missing version information");
-  }
-
-  @Test
   public void testAuthorMissing() {
     parse("* @author */", true, "@author tag missing author");
   }
@@ -5165,6 +5148,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             + "* @static \n"
             + "* @supported\n"
             + "* @wizaction \n"
+            + "* @wizcallback \n"
             + "*/");
   }
 
@@ -5272,6 +5256,27 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testParseProvideAlreadyProvided() {
+    assertThat(parse("@provideAlreadyProvided*/").isProvideAlreadyProvided()).isTrue();
+  }
+
+  @Test
+  public void testParseProvideAlreadyProvidedExtra() {
+    parse(
+        "@provideAlreadyProvided \n@provideAlreadyProvided*/", "extra @provideAlreadyProvided tag");
+  }
+
+  @Test
+  public void testParseWizcallback() {
+    assertThat(parse("@wizcallback*/").isWizcallback()).isTrue();
+  }
+
+  @Test
+  public void testParseWizcallbackExpectDuplicateError() {
+    parse("@wizcallback \n@wizcallback*/", "extra @wizcallback tag");
+  }
+
+  @Test
   public void testTextExtents() {
     parse(
         "@return {@code foo} bar \n *    baz. */",
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index 4554f56..9410083 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -420,7 +420,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
     parse("" + "for (var x of [1, 2, 3]) {\n" + "  if (x == 2) continue;\n" + "}");
   }
 
-  /** @bug 19100575 */
+  /**
+   * @bug 19100575
+   */
   @Test
   public void testVarSourceLocations() {
     isIdeMode = true;
@@ -1504,6 +1506,114 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testObjLitKeyNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node exprResult = parse("a = {\n// blah\n1n: 3};").getFirstChild();
+    Node assignNode = exprResult.getFirstChild();
+    Node objectLit = assignNode.getSecondChild();
+    Node stringKey = objectLit.getFirstChild();
+    assertThat(stringKey.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testLabelNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node label = parse("\n// blah\nlabel:\nfor(;;){ continue label; }").getFirstChild();
+    assertNode(label).hasType(Token.LABEL);
+    assertThat(label.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testFieldNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node field =
+        parse("class C{\n// blah\n field }").getFirstChild().getLastChild().getFirstChild();
+    assertNode(field).hasType(Token.MEMBER_FIELD_DEF);
+    assertThat(field.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testPropertyNameAssignmentNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node varName =
+        parse("let {key: \n// blah\nvarName} = someObject")
+            .getFirstChild()
+            .getFirstChild()
+            .getFirstChild()
+            .getFirstChild()
+            .getFirstChild();
+    assertNode(varName).hasType(Token.NAME);
+    assertThat(varName.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testGetPropCallNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node exprResult = parse("foo.\n// blah\nbaz(3);").getFirstChild();
+    Node call = exprResult.getFirstChild();
+    assertNode(call).hasType(Token.CALL);
+
+    Node bazAccess = call.getFirstChild();
+    assertThat(bazAccess.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testGetPropOptionalCallNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node exprResult = parse("foo?.\n// blah\nbaz(3);").getFirstChild();
+    Node callNode = exprResult.getFirstChild();
+    assertNode(callNode).hasType(Token.OPTCHAIN_CALL);
+
+    Node bazAccess = callNode.getFirstChild();
+    assertThat(bazAccess.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testGetPropAssignmentNonJSDocComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node exprResult = parse("foo.\n// blah\nbaz = 5;").getFirstChild();
+    Node assign = exprResult.getFirstChild();
+    assertNode(assign).hasType(Token.ASSIGN);
+
+    Node bazAccess = assign.getFirstChild();
+    assertThat(bazAccess.getNonJSDocCommentString()).contains("// blah");
+  }
+
+  @Test
+  public void testNonJSDocCommentsOnAdjacentNodes() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node root =
+        parse(
+            lines(
+                "// comment before GETPROP",
+                "a(",
+                "// comment on GETPROP",
+                ")",
+                ".b();",
+                "// comment after GETPROP",
+                "c();"));
+    Node exprResultA = root.getFirstChild();
+    assertNode(exprResultA).hasType(Token.EXPR_RESULT);
+    assertThat(exprResultA.getNonJSDocCommentString()).isEqualTo("// comment before GETPROP");
+
+    Node nodeB = exprResultA.getFirstChild().getFirstChild();
+    assertNode(nodeB).hasType(Token.GETPROP);
+    assertThat(nodeB.getNonJSDocCommentString()).isEqualTo("// comment on GETPROP");
+
+    Node exprResultC = root.getLastChild();
+    assertNode(exprResultC).hasType(Token.EXPR_RESULT);
+    assertThat(exprResultC.getNonJSDocCommentString()).isEqualTo("// comment after GETPROP");
+  }
+
+  @Test
   public void testInlineJSDocAttachmentToObjPatComputedPropKey() {
     Node letNode =
         parse("let { /** string */ ['computedProp']: computedProp } = {};").getFirstChild();
@@ -1976,6 +2086,101 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testEndOfFileNonJSDocComments_lineComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node scriptNode =
+        parse(
+            lines(
+                "function f1() {}", //
+                "// first",
+                "f1();",
+                "// second"));
+
+    assertNode(scriptNode).hasType(Token.SCRIPT);
+
+    Node exprNode = scriptNode.getLastChild();
+    assertNode(exprNode).hasType(Token.EXPR_RESULT);
+
+    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("// second");
+    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+  }
+
+  @Test
+  public void testEndOfFileNonJSDocComments_blockComment() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node scriptNode =
+        parse(
+            lines(
+                "function f1() {}", //
+                "// first",
+                "f1();",
+                "/* second */"));
+
+    assertNode(scriptNode).hasType(Token.SCRIPT);
+
+    Node exprNode = scriptNode.getLastChild();
+    assertNode(exprNode).hasType(Token.EXPR_RESULT);
+
+    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("/* second */");
+    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+  }
+
+  @Test
+  public void testEndOfFileNonJSDocComments_manyComments() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node scriptNode =
+        parse(
+            lines(
+                "function f1() {}", //
+                "// first",
+                "f1();",
+                "// second",
+                "/* third */",
+                "// fourth"));
+
+    assertNode(scriptNode).hasType(Token.SCRIPT);
+
+    Node exprNode = scriptNode.getLastChild();
+    assertNode(exprNode).hasType(Token.EXPR_RESULT);
+
+    assertThat(scriptNode.getNonJSDocCommentString())
+        .isEqualTo("// second\n/* third */\n// fourth");
+    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+  }
+
+  @Test
+  public void testEndOfFileNonJSDocComments() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node scriptNode =
+        parse(
+            lines(
+                "function f1() {}", //
+                "if (true) {",
+                "// first",
+                "f1(); // second ",
+                "}",
+                "// third"));
+
+    assertNode(scriptNode).hasType(Token.SCRIPT);
+
+    Node exprNode = scriptNode.getLastChild().getLastChild().getFirstChild();
+    assertNode(exprNode).hasType(Token.EXPR_RESULT);
+    // Ideally, exprNode contains "// first\n// second".
+    assertThat(exprNode.getNonJSDocCommentString()).isEqualTo("// first");
+    assertThat(exprNode.getNonJSDocComment().isTrailing()).isFalse();
+
+    // TODO(rishipal): the comments `// second` and `// third` do not have an AST node to attach to
+    // that "starts" after them (the `if(true) {..}` block starts before the comments).
+    // Hence both comments get attached to the SCRIPT node as a trailing comment.
+    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("// second\n\n// third");
+    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+  }
+
+  @Test
   public void testBoth_TrailingAndNonTrailing_NonJSDocCommentsGetAttachedToSameNode_SingleLine() {
     isIdeMode = true;
     parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
@@ -3722,7 +3927,6 @@ public final class ParserTest extends BaseJSTypeTestCase {
     expectFeatures(Feature.TEMPLATE_LITERALS);
     testTemplateLiteral("``");
     testTemplateLiteral("`\"`");
-    testTemplateLiteral("`\\\"`");
     testTemplateLiteral("`\\``");
     testTemplateLiteral("`hello world`;");
     testTemplateLiteral("`hello\nworld`;");
@@ -3809,6 +4013,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
     parseError("`hello\\5`", "Invalid escape sequence");
     parseError("`hello\\6`", "Invalid escape sequence");
     parseError("`hello\\7`", "Invalid escape sequence");
+    // TODO(b/223649306): \8 and \9 should cause "Invalid escape sequence" parse errors
+    parseWarning("`hello\\8`", "Unnecessary escape: '\\8' is equivalent to just '8'");
+    parseWarning("`hello\\9`", "Unnecessary escape: '\\9' is equivalent to just '9'");
     parseError("`hello\\01`", "Invalid escape sequence");
     parseError("`hello\\02`", "Invalid escape sequence");
     parseError("`hello\\03`", "Invalid escape sequence");
@@ -3819,6 +4026,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
     // newline before invalid escape sequence
     parseError("`\n\\1`", "Invalid escape sequence");
+    parseError("`\n\\1 ${0}`", "Invalid escape sequence");
   }
 
   @Test
@@ -4644,23 +4852,47 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
-  public void testUnnecessaryEscapeTemplateLiterals() {
-    expectFeatures(Feature.TEMPLATE_LITERALS);
-
-    // Don't warn for unnecessary escapes in template literals since tagged template literals
-    // can access the raw string value
-    parse("var str = `\\a`");
+  public void testUnnecessaryEscapeUntaggedTemplateLiterals() {
+    parseWarning("var str = `\\a`", "Unnecessary escape: '\\a' is equivalent to just 'a'");
     parse("var str = `\\b`");
-    parse("var str = `\\c`");
-    parse("var str = `\\d`");
-    parse("var str = `\\e`");
+    parseWarning("var str = `\\c`", "Unnecessary escape: '\\c' is equivalent to just 'c'");
+    parseWarning("var str = `\\d`", "Unnecessary escape: '\\d' is equivalent to just 'd'");
+    parseWarning("var str = `\\e`", "Unnecessary escape: '\\e' is equivalent to just 'e'");
     parse("var str = `\\f`");
-    parse("var str = `\\/`");
+    parseWarning("var str = `\\/`", "Unnecessary escape: '\\/' is equivalent to just '/'");
     parse("var str = `\\0`");
-    parse("var str = `\\8`");
-    parse("var str = `\\9`");
-    parse("var str = `\\%`");
+    parseWarning("var str = `\\%`", "Unnecessary escape: '\\%' is equivalent to just '%'");
+
+    // single and double quotes have no meaning in a template lit
+    parseWarning("var str = `\\\"`", "Unnecessary escape: '\\\"' is equivalent to just '\"'");
+    parseWarning("var str = `\\'`", "Unnecessary escape: \"\\'\" is equivalent to just \"'\"");
+
+    // $ needs to be escaped to distinguish it from use of ${}
     parse("var str = `\\$`");
+    // ` needs to be escaped to avoid ending the template lit
+    parse("var str = `\\``");
+  }
+
+  @Test
+  public void testUnnecessaryEscapeTaggedTemplateLiterals() {
+    expectFeatures(Feature.TEMPLATE_LITERALS);
+
+    // Don't warn for unnecessary escapes in tagged template literals since they may access the
+    // raw string value
+    parse("var str = String.raw`\\a`");
+    parse("var str = String.raw`\\b`");
+    parse("var str = String.raw`\\c`");
+    parse("var str = String.raw`\\d`");
+    parse("var str = String.raw`\\e`");
+    parse("var str = String.raw`\\f`");
+    parse("var str = String.raw`\\/`");
+    parse("var str = String.raw`\\0`");
+    parse("var str = String.raw`\\8`");
+    parse("var str = String.raw`\\9`");
+    parse("var str = String.raw`\\%`");
+
+    parse("var str = String.raw`\\$`");
+    parse("var str = String.raw`\\``");
   }
 
   @Test
@@ -4804,9 +5036,25 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
     parseError(
         "var unterm = 'forgot closing quote\n" + "alert(unterm);", "Unterminated string literal");
+
+    // test combo of a string continuation + useless escape warning + unterminated literal error
+    // create a TestErrorReporter so that we can expect both a warning and an error
+    String js = "var unterm = ' \\\n \\a \n";
+
+    TestErrorReporter testErrorReporter =
+        new TestErrorReporter()
+            .expectAllWarnings("Unnecessary escape: '\\a' is equivalent to just 'a'")
+            .expectAllErrors("Unterminated string literal");
+    StaticSourceFile file = new SimpleSourceFile("input", SourceKind.STRONG);
+    ParserRunner.parse(file, js, createConfig(), testErrorReporter);
+
+    // verify we reported both the warning and error
+    testErrorReporter.verifyHasEncounteredAllWarningsAndErrors();
   }
 
-  /** @bug 14231379 */
+  /**
+   * @bug 14231379
+   */
   @Test
   public void testUnterminatedRegExp() {
     parseError("var unterm = /forgot trailing slash", "Expected '/' in regular expression literal");
@@ -6058,49 +6306,61 @@ public final class ParserTest extends BaseJSTypeTestCase {
     strictMode = SLOPPY;
 
     expectFeatures(Feature.FOR_AWAIT_OF);
-    parse("for await(a of b) c;");
-    parse("for await(var a of b) c;");
-    parse("for await (a.x of b) c;");
-    parse("for await ([a1, a2, a3] of b) c;");
-    parse("for await (const {x, y, z} of b) c;");
+    parse("async () => { for await(a of b) c;}");
+    parse("async () => { for await(var a of b) c;}");
+    parse("async () => { for await (a.x of b) c;}");
+    parse("async () => { for await ([a1, a2, a3] of b) c;}");
+    parse("async () => { for await (const {x, y, z} of b) c;}");
     // default value inside a pattern isn't an initializer
-    parse("for await (const {x, y = 2, z} of b) c;");
+    parse("async () => { for await (const {x, y = 2, z} of b) c;}");
     expectFeatures(Feature.FOR_AWAIT_OF, Feature.LET_DECLARATIONS);
-    parse("for await(let a of b) c;");
+    parse("async () => { for await(let a of b) c;}");
     expectFeatures(Feature.FOR_AWAIT_OF, Feature.CONST_DECLARATIONS);
-    parse("for await(const a of b) c;");
+    parse("async () => { for await(const a of b) c;}");
   }
 
   @Test
   public void testInvalidForAwaitOfInitializers() {
     strictMode = SLOPPY;
 
-    parseError("for await (a=1 of b) c;", INVALID_ASSIGNMENT_TARGET);
-    parseError("for await (var a=1 of b) c;", "for-await-of statement may not have initializer");
-    parseError("for await (let a=1 of b) c;", "for-await-of statement may not have initializer");
-    parseError("for await (const a=1 of b) c;", "for-await-of statement may not have initializer");
+    parseError("async () => { for await (a=1 of b) c;}", INVALID_ASSIGNMENT_TARGET);
+    parseError(
+        "async () => { for await (var a=1 of b) c;}",
+        "for-await-of statement may not have initializer");
+    parseError(
+        "async () => { for await (let a=1 of b) c;}",
+        "for-await-of statement may not have initializer");
+    parseError(
+        "async () => { for await (const a=1 of b) c;}",
+        "for-await-of statement may not have initializer");
     parseError(
-        "for await (let {a} = {} of b) c;", "for-await-of statement may not have initializer");
+        "async () => { for await (let {a} = {} of b) c;}",
+        "for-await-of statement may not have initializer");
   }
 
   @Test
   public void testInvalidForAwaitOfMultipleInitializerTargets() {
     strictMode = SLOPPY;
 
-    parseError("for await (a, b of c) d;", INVALID_ASSIGNMENT_TARGET);
+    parseError("async () => { for await (a, b of c) d;}", INVALID_ASSIGNMENT_TARGET);
 
     parseError(
-        "for await (var a, b of c) d;",
+        "async () => { for await (var a, b of c) d;}",
         "for-await-of statement may not have more than one variable declaration");
     parseError(
-        "for await (let a, b of c) d;",
+        "async () => { for await (let a, b of c) d;}",
         "for-await-of statement may not have more than one variable declaration");
     parseError(
-        "for await (const a, b of c) d;",
+        "async () => { for await (const a, b of c) d;}",
         "for-await-of statement may not have more than one variable declaration");
   }
 
   @Test
+  public void testInvalidForAwaitOf() {
+    parseError("for await (a of b) foo();", "'for-await-of' used in a non-async function context");
+  }
+
+  @Test
   public void testDestructuringInForLoops() {
     strictMode = SLOPPY;
 
diff --git a/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java b/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
index 8f88978..b78576b 100644
--- a/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
+++ b/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
@@ -48,8 +48,8 @@ public final class FeatureSetTest {
   @Test
   public void testEsOrdering() {
     assertFS(FeatureSet.ALL).contains(FeatureSet.ES_UNSUPPORTED);
-    assertFS(FeatureSet.ES_UNSUPPORTED).contains(FeatureSet.ES_NEXT_IN);
-    assertFS(FeatureSet.ES_NEXT_IN).contains(FeatureSet.ES_NEXT);
+    assertFS(FeatureSet.ES_UNSUPPORTED).contains(FeatureSet.ES_UNSTABLE);
+    assertFS(FeatureSet.ES_UNSTABLE).contains(FeatureSet.ES_NEXT);
     assertFS(FeatureSet.ES_NEXT).contains(FeatureSet.ES2021);
     assertFS(FeatureSet.ES2021).contains(FeatureSet.ES2020);
     assertFS(FeatureSet.ES2020).contains(FeatureSet.ES2019);
@@ -97,13 +97,13 @@ public final class FeatureSetTest {
 
   @Test
   public void testEsNextAndNewer() {
-    // ES_NEXT, ES_NEXT_IN, and ES_UNSUPPORTED are moving targets that may or may not have any
+    // ES_NEXT, ES_UNSTABLE, and ES_UNSUPPORTED are moving targets that may or may not have any
     // unique features.  If any of these `FeatureSet`s are identical to a lower FeatureSet,
     // `version()` will return the lowest equivalent version that contains features.
     // This could be es_XXX, es_next, etc. and will change as new features are added and removed
     // from these `FeatureSet`s.
     assertThat(FeatureSet.ES_NEXT.version()).isEqualTo("es_next");
-    assertThat(FeatureSet.ES_NEXT_IN.version()).isEqualTo("es_next");
+    assertThat(FeatureSet.ES_UNSTABLE.version()).isEqualTo("es_next");
     assertThat(FeatureSet.ES_UNSUPPORTED.version()).isEqualTo("es_next");
   }
 
@@ -121,7 +121,7 @@ public final class FeatureSetTest {
     assertFS(FeatureSet.valueOf("es_2020")).equals(FeatureSet.ES2020);
     assertFS(FeatureSet.valueOf("es_2021")).equals(FeatureSet.ES2021);
     assertFS(FeatureSet.valueOf("es_next")).equals(FeatureSet.ES_NEXT);
-    assertFS(FeatureSet.valueOf("es_next_in")).equals(FeatureSet.ES_NEXT_IN);
+    assertFS(FeatureSet.valueOf("es_unstable")).equals(FeatureSet.ES_UNSTABLE);
     assertFS(FeatureSet.valueOf("es_unsupported")).equals(FeatureSet.ES_UNSUPPORTED);
     assertFS(FeatureSet.valueOf("all")).equals(FeatureSet.ALL);
     assertThrows(IllegalArgumentException.class, () -> FeatureSet.valueOf("bad"));
diff --git a/test/com/google/javascript/jscomp/runtime_tests/identifier_test.js b/test/com/google/javascript/jscomp/runtime_tests/identifier_test.js
index 25c873e..39bc200 100644
--- a/test/com/google/javascript/jscomp/runtime_tests/identifier_test.js
+++ b/test/com/google/javascript/jscomp/runtime_tests/identifier_test.js
@@ -20,11 +20,11 @@
  */
 goog.require('goog.testing.jsunit');
 
-// Test Scanner.java workaround to prevent GWT-compiled compiler from choking
+// Test Scanner.java workaround to prevent J2CL-compiled compiler from choking
 // on a special character used by Angular in some names.
-// Note that the non-GWT compiler allows all legal JS identifier names, but
-// due to GWT lack for Unicode support for Java's Character.is* methods, the
-// GWT-compiled compiler does not.
+// Note that the non-J2CL compiler allows all legal JS identifier names, but
+// due to J2CL lack for Unicode support for Java's Character.is* methods, the
+// J2CL-compiled compiler does not.
 function testUnicodeInVariableName() {
   var ɵ = true;
   // Note: a failure of this test actually manifests as
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/array_at_test.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/array_at_test.js
new file mode 100644
index 0000000..e4a57d1
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/array_at_test.js
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('jscomp.runtime_tests.polyfill_tests.array_at_test');
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+
+testSuite({
+  testAt() {
+    let arr = [1, 2, 3, 4, 5];
+    assertEquals(2, arr.at(1));
+    assertEquals(4, arr.at(-2));
+    assertEquals(1, arr.at(0));
+    assertUndefined(arr.at(5));
+  },
+});
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
index 3f4e937..08d495b 100644
--- a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
@@ -21,6 +21,7 @@
 
 delete Array.of;
 delete Array.from;
+delete Array.prototype.at;
 delete Array.prototype.entries;
 delete Array.prototype.keys;
 delete Array.prototype.values;
@@ -72,6 +73,7 @@ delete Reflect;
 delete Set;
 
 delete String.fromCodePoint;
+delete String.prototype.at;
 delete String.prototype.codePointAt;
 delete String.prototype.endsWith;
 delete String.prototype.includes;
@@ -84,6 +86,16 @@ delete String.prototype.trimStart;
 delete String.prototype.trimEnd;
 delete String.raw;
 
+delete Int8Array.prototype.at;
+delete Uint8Array.prototype.at;
+delete Uint8ClampedArray.prototype.at;
+delete Int16Array.prototype.at;
+delete Uint16Array.prototype.at;
+delete Int32Array.prototype.at;
+delete Uint32Array.prototype.at;
+delete Float32Array.prototype.at;
+delete Float64Array.prototype.at;
+
 delete Symbol;
 
 delete WeakMap;
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/string_at_test.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/string_at_test.js
new file mode 100644
index 0000000..248e57b
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/string_at_test.js
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('jscomp.runtime_tests.polyfill_tests.string_at_test');
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+
+testSuite({
+  testAt() {
+    assertEquals('123'.at(-1), '3');
+  }
+});
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/typed_array_fill_at_test.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/typed_array_fill_at_test.js
new file mode 100644
index 0000000..13e93d7
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/typed_array_fill_at_test.js
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('jscomp.runtime_tests.polyfill_tests.typedarray_at_test');
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+
+testSuite({
+  testAt_int8() {
+    assertEquals(new Int8Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_uint8() {
+    assertEquals(new Uint8Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_uint8Clamped() {
+    assertEquals(new Uint8ClampedArray([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_int16() {
+    assertEquals(new Int16Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_uint16() {
+    assertEquals(new Uint16Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_int32() {
+    assertEquals(new Int32Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_uint32() {
+    assertEquals(new Uint32Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_float32() {
+    assertEquals(new Float32Array([1, 2, 3]).at(-1), 3);
+  },
+
+  testAt_float64() {
+    assertEquals(new Float64Array([1, 2, 3]).at(-1), 3);
+  },
+});
diff --git a/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java b/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
index 885eeee..2726136 100644
--- a/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
+++ b/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
@@ -64,6 +64,7 @@ public class ColorPoolTest {
 
   @Test
   public void deserializesNativeObjectTableIntoNativeColor() {
+    StringPool.Builder stringPool = StringPool.builder();
     TypePool typePool =
         TypePool.newBuilder()
             .addType(
@@ -72,7 +73,8 @@ public class ColorPoolTest {
                         ObjectTypeProto.newBuilder()
                             .setUuid(StandardColors.NUMBER_OBJECT_ID.asByteString())
                             .setDebugInfo(
-                                ObjectTypeProto.DebugInfo.newBuilder().addTypename("Number"))
+                                ObjectTypeProto.DebugInfo.newBuilder()
+                                    .addTypenamePointer(stringPool.put("Number")))
                             .setIsInvalidating(true))
                     .build())
             .addType(
@@ -85,7 +87,7 @@ public class ColorPoolTest {
                 SubtypingEdge.newBuilder().setSubtype(poolPointer(0)).setSupertype(poolPointer(1)))
             .build();
 
-    ColorPool colorPool = ColorPool.fromOnlyShard(typePool, StringPool.empty());
+    ColorPool colorPool = ColorPool.fromOnlyShard(typePool, stringPool.build());
     ColorPool.ShardView view = colorPool.getOnlyShard();
 
     Color numberObject = colorPool.getColor(StandardColors.NUMBER_OBJECT_ID);
@@ -94,6 +96,7 @@ public class ColorPoolTest {
         .hasDisambiguationSupertypesThat(colorPool.getRegistry())
         .containsExactly(view.getColor(poolPointer(1)));
     assertThat(numberObject).isSameInstanceAs(view.getColor(poolPointer(0)));
+    assertThat(numberObject.getDebugInfo().getCompositeTypename()).isEqualTo("Number");
   }
 
   @Test
@@ -792,26 +795,32 @@ public class ColorPoolTest {
 
   @Test
   public void reconcile_debugNames() {
+    StringPool.Builder stringPool0 = StringPool.builder();
+    StringPool.Builder stringPool1 = StringPool.builder();
     // Given
     TypePool typePool0 =
         singleObjectPool(
             ObjectTypeProto.newBuilder()
                 .setUuid(TEST_ID.asByteString())
                 .setDebugInfo(
-                    ObjectTypeProto.DebugInfo.newBuilder().addTypename("A").addTypename("C")));
+                    ObjectTypeProto.DebugInfo.newBuilder()
+                        .addTypenamePointer(stringPool0.put("A"))
+                        .addTypenamePointer(stringPool0.put("C"))));
 
     TypePool typePool1 =
         singleObjectPool(
             ObjectTypeProto.newBuilder()
                 .setUuid(TEST_ID.asByteString())
                 .setDebugInfo(
-                    ObjectTypeProto.DebugInfo.newBuilder().addTypename("B").addTypename("A")));
+                    ObjectTypeProto.DebugInfo.newBuilder()
+                        .addTypenamePointer(stringPool1.put("B"))
+                        .addTypenamePointer(stringPool1.put("A"))));
 
     // When
     ColorPool colorPool =
         ColorPool.builder()
-            .addShardAnd(typePool0, StringPool.empty())
-            .addShardAnd(typePool1, StringPool.empty())
+            .addShardAnd(typePool0, stringPool0.build())
+            .addShardAnd(typePool1, stringPool1.build())
             .build();
 
     // Then
diff --git a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
index 9502c17..916fe28 100644
--- a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
@@ -21,6 +21,7 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.HashMultimap;
@@ -28,7 +29,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.truth.extensions.proto.ProtoSubject;
-import com.google.common.truth.extensions.proto.ProtoTruth;
 import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.ColorId;
 import com.google.javascript.jscomp.colors.DebugInfo;
@@ -174,6 +174,10 @@ public class ColorSerializerTest {
     // The colors for `Base.prototype` and the instances of `Base` will be added implicitly
     // in that order.
     final PooledString baseFieldPooledString = PooledString.create("baseField", 1);
+    final PooledString basePooledString = PooledString.create("Base", 2);
+    final PooledString typeofBasePrototypePooledString =
+        PooledString.create("typeof Base.prototype", 3);
+    final PooledString typeofBasePooledString = PooledString.create("typeof Base", 4);
     final TestColor baseClassInstanceTestColor =
         new TestObjectColorBuilder()
             .setColorId("Base.ins")
@@ -181,7 +185,7 @@ public class ColorSerializerTest {
             // 1 => explicitly added child class constructor
             // Then this instance color gets added implicitly
             .setTrimmedPoolOffset(2)
-            .setTypeName("Base")
+            .setTypeName(basePooledString)
             .addOwnProperty(baseFieldPooledString)
             .build();
     final TestColor baseClassPrototypeTestColor =
@@ -189,7 +193,7 @@ public class ColorSerializerTest {
             .setColorId("Base.pro")
             // This is implicitly added after the instance color above.
             .setTrimmedPoolOffset(3)
-            .setTypeName("typeof Base.prototype")
+            .setTypeName(typeofBasePrototypePooledString)
             .build();
     final PooledString baseStaticFieldPooledString = PooledString.create("baseStaticField", 0);
     final TestColor baseClassConstructorTestColor =
@@ -197,7 +201,7 @@ public class ColorSerializerTest {
             .setColorId("Base.con")
             // This is the first explicitly-added type.
             .setTrimmedPoolOffset(0)
-            .setTypeName("typeof Base")
+            .setTypeName(typeofBasePooledString)
             .setConstructor(true)
             .addPrototypeTestColor(baseClassPrototypeTestColor)
             .addInstanceTestColor(baseClassInstanceTestColor)
@@ -211,7 +215,11 @@ public class ColorSerializerTest {
     // We will explicitly add the color representing `typeof Child`.
     // The colors for `Child.prototype` and the instances of `Child` will be added implicitly
     // in that order.
-    final PooledString childFieldPooledString = PooledString.create("childField", 3);
+    final PooledString childFieldPooledString = PooledString.create("childField", 5);
+    final PooledString childPooledString = PooledString.create("Child", 6);
+    final PooledString typeofChildPrototypePooledString =
+        PooledString.create("typeof Child.prototype", 7);
+    final PooledString typeofChildPooledString = PooledString.create("typeof Child", 8);
     final TestColor childClassInstanceTestColor =
         new TestObjectColorBuilder()
             .setColorId("Child.in")
@@ -221,7 +229,7 @@ public class ColorSerializerTest {
             // 3 => implicitly added base class prototype color
             // Then this instance color gets added implicitly
             .setTrimmedPoolOffset(4)
-            .setTypeName("Child")
+            .setTypeName(childPooledString)
             .addOwnProperty(childFieldPooledString)
             .build();
     final TestColor childClassPrototypeTestColor =
@@ -229,7 +237,7 @@ public class ColorSerializerTest {
             .setColorId("Child.pr")
             // This is implicitly added after the instance color above.
             .setTrimmedPoolOffset(5)
-            .setTypeName("typeof Child.prototype")
+            .setTypeName(typeofChildPrototypePooledString)
             .build();
     final PooledString childStaticFieldPooledString = PooledString.create("childStaticField", 2);
     final TestColor childClassConstructorTestColor =
@@ -237,7 +245,7 @@ public class ColorSerializerTest {
             .setColorId("Child.co")
             // This is the second explicitly-added type
             .setTrimmedPoolOffset(1)
-            .setTypeName("typeof Child")
+            .setTypeName(typeofChildPooledString)
             .setConstructor(true)
             .addPrototypeTestColor(childClassPrototypeTestColor)
             .addInstanceTestColor(childClassInstanceTestColor)
@@ -277,6 +285,12 @@ public class ColorSerializerTest {
         .addPooledString(baseFieldPooledString)
         .addPooledString(childStaticFieldPooledString)
         .addPooledString(childFieldPooledString)
+        .addPooledString(basePooledString)
+        .addPooledString(typeofBasePrototypePooledString)
+        .addPooledString(typeofBasePooledString)
+        .addPooledString(childPooledString)
+        .addPooledString(typeofChildPrototypePooledString)
+        .addPooledString(typeofChildPooledString)
         // Only explicitly add the constructor types
         .addColor(baseClassConstructorTestColor)
         .addColor(childClassConstructorTestColor)
@@ -290,17 +304,21 @@ public class ColorSerializerTest {
 
   @Test
   public void includeMismatchesAndTypenames() {
+    PooledString typeName1 = PooledString.create("typeName1", 1);
+    PooledString typeName2 = PooledString.create("typeName2", 2);
+    PooledString typeName3 = PooledString.create("typeName3", 3);
+    PooledString typeName4 = PooledString.create("typeName4", 4);
     TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             .setTrimmedPoolOffset(0)
-            .setTypeName("typeName1")
+            .setTypeName(typeName1)
             .build();
     TestColor testColor2 =
         new TestObjectColorBuilder()
             .setColorId("color002")
             .setTrimmedPoolOffset(1)
-            .setTypeName("typeName2")
+            .setTypeName(typeName2)
             .build();
     TestMismatch testMismatch1 = TestMismatch.create("location1", testColor1, testColor2);
 
@@ -308,13 +326,13 @@ public class ColorSerializerTest {
         new TestObjectColorBuilder()
             .setColorId("color003")
             .setTrimmedPoolOffset(2)
-            .setTypeName("typeName3")
+            .setTypeName(typeName3)
             .build();
     TestColor testColor4 =
         new TestObjectColorBuilder()
             .setColorId("color004")
             .setTrimmedPoolOffset(3)
-            .setTypeName("typeName4")
+            .setTypeName(typeName4)
             .build();
     TestMismatch testMismatch2 = TestMismatch.create("location2", testColor3, testColor4);
 
@@ -336,6 +354,10 @@ public class ColorSerializerTest {
         .addColors(testColor1, testColor2, testColor3, testColor4)
         .addMismatch(testMismatch1)
         .addMismatch(testMismatch2)
+        .addPooledString(typeName1)
+        .addPooledString(typeName2)
+        .addPooledString(typeName3)
+        .addPooledString(typeName4)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
@@ -343,18 +365,22 @@ public class ColorSerializerTest {
 
   @Test
   public void skipMismatchesAndTypenames() {
+    PooledString typeName1 = PooledString.create("typeName1", 1);
+    PooledString typeName2 = PooledString.create("typeName2", 2);
+    PooledString typeName3 = PooledString.create("typeName3", 3);
+    PooledString typeName4 = PooledString.create("typeName4", 4);
     TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             .setTrimmedPoolOffset(0)
-            .setTypeName("typeName1")
+            .setTypeName(typeName1)
             .setIncludeDebugInfoInProto(false)
             .build();
     TestColor testColor2 =
         new TestObjectColorBuilder()
             .setColorId("color002")
             .setTrimmedPoolOffset(1)
-            .setTypeName("typeName2")
+            .setTypeName(typeName2)
             .setIncludeDebugInfoInProto(false)
             .build();
     TestMismatch testMismatch1 = TestMismatch.create("location1", testColor1, testColor2);
@@ -363,14 +389,14 @@ public class ColorSerializerTest {
         new TestObjectColorBuilder()
             .setColorId("color003")
             .setTrimmedPoolOffset(2)
-            .setTypeName("typeName3")
+            .setTypeName(typeName3)
             .setIncludeDebugInfoInProto(false)
             .build();
     TestColor testColor4 =
         new TestObjectColorBuilder()
             .setColorId("color004")
             .setTrimmedPoolOffset(3)
-            .setTypeName("typeName4")
+            .setTypeName(typeName4)
             .setIncludeDebugInfoInProto(false)
             .build();
     TestMismatch testMismatch2 = TestMismatch.create("location2", testColor3, testColor4);
@@ -429,18 +455,20 @@ public class ColorSerializerTest {
 
   @Test
   public void addUnionImplicitlyAddsMembers() {
+    PooledString testTypeName1 = PooledString.create("testColor1", 1);
+    PooledString testTypeName2 = PooledString.create("testColor2", 2);
     final TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             // We will explicitly add this color first
             .setTrimmedPoolOffset(1)
-            .setTypeName("testColor1")
+            .setTypeName(testTypeName1)
             .build();
     final TestColor testColor2 =
         new TestObjectColorBuilder()
             .setColorId("color002")
             .setTrimmedPoolOffset(2)
-            .setTypeName("testColor2")
+            .setTypeName(testTypeName2)
             .build();
     final TestColor unionTestColor =
         new TestUnionColorBuilder()
@@ -461,6 +489,8 @@ public class ColorSerializerTest {
     new Tester()
         .init()
         .addColor(unionTestColor)
+        .addPooledString(testTypeName1)
+        .addPooledString(testTypeName2)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
@@ -468,18 +498,20 @@ public class ColorSerializerTest {
 
   @Test
   public void avoidAddingDuplicateUnions() {
+    PooledString testTypeName1 = PooledString.create("testColor1", 1);
+    PooledString testTypeName2 = PooledString.create("testColor2", 2);
     final TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             // We will explicitly add this color first
             .setTrimmedPoolOffset(1)
-            .setTypeName("testColor1")
+            .setTypeName(testTypeName1)
             .build();
     final TestColor testColor2 =
         new TestObjectColorBuilder()
             .setColorId("color002")
             .setTrimmedPoolOffset(2)
-            .setTypeName("testColor2")
+            .setTypeName(testTypeName2)
             .build();
     final TestColor unionTestColor =
         new TestUnionColorBuilder()
@@ -511,6 +543,8 @@ public class ColorSerializerTest {
         .addColor(unionTestColor)
         // Try to add the duplicate union color. It should be ignored.
         .addColor(duplicateUnionTestColor)
+        .addPooledString(testTypeName1)
+        .addPooledString(testTypeName2)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
@@ -542,7 +576,7 @@ public class ColorSerializerTest {
     private ColorId colorId;
     private int trimmedPoolOffset = -1;
     // An empty string indicates that the type has no name.
-    private String typeName = "";
+    private PooledString typeName = PooledString.create("", 0);
     private boolean isConstructor = false;
     private boolean includeDebugInfoInProto = true;
 
@@ -567,7 +601,7 @@ public class ColorSerializerTest {
       return this;
     }
 
-    public TestObjectColorBuilder setTypeName(String typeName) {
+    public TestObjectColorBuilder setTypeName(PooledString typeName) {
       this.typeName = typeName;
       return this;
     }
@@ -631,10 +665,11 @@ public class ColorSerializerTest {
                   .collect(Collectors.toList()))
           .addAllOwnProperty(
               ownProperties.stream().map(PooledString::getPoolOffset).collect(Collectors.toList()));
-      if (!typeName.isEmpty()) {
-        colorBuilder.setDebugInfo(DebugInfo.builder().setCompositeTypename(typeName).build());
+      if (!typeName.getValue().isEmpty()) {
+        colorBuilder.setDebugInfo(
+            DebugInfo.builder().setCompositeTypename(typeName.getValue()).build());
         if (includeDebugInfoInProto) {
-          objectTypeProtoBuilder.getDebugInfoBuilder().addTypename(typeName);
+          objectTypeProtoBuilder.getDebugInfoBuilder().addTypenamePointer(typeName.getPoolOffset());
         }
       }
       return TestColor.create(colorBuilder.build(), typeProtoBuilder.build(), typePointer);
@@ -851,7 +886,7 @@ public class ColorSerializerTest {
     public abstract TypePool getTypePool();
 
     ProtoSubject assertThatTypePool() {
-      return ProtoTruth.assertThat(getTypePool());
+      return assertThat(getTypePool());
     }
 
     static GenerateTypePoolTestResult create(TypePool typePool) {
diff --git a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
index 9a49507..c5316bd 100644
--- a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
@@ -17,6 +17,7 @@
 package com.google.javascript.jscomp.serialization;
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 import static com.google.javascript.jscomp.serialization.TypePointers.isAxiomatic;
 import static com.google.javascript.jscomp.serialization.TypePointers.trimOffset;
@@ -58,11 +59,13 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
       ObjectTypeProto.getDescriptor().findFieldByName("uuid");
   private static final FieldDescriptor OBJECT_PROPERTIES =
       ObjectTypeProto.getDescriptor().findFieldByName("own_property");
+  private static final FieldDescriptor OBJECT_TYPENAME =
+      ObjectTypeProto.DebugInfo.getDescriptor().findFieldByName("typename_pointer");
   private static final FieldDescriptor IS_INVALIDATING =
       ObjectTypeProto.getDescriptor().findFieldByName("is_invalidating");
 
   private static final ImmutableList<FieldDescriptor> BRITTLE_TYPE_FIELDS =
-      ImmutableList.of(OBJECT_UUID, OBJECT_PROPERTIES);
+      ImmutableList.of(OBJECT_UUID, OBJECT_PROPERTIES, OBJECT_TYPENAME);
 
   @Override
   @Before
@@ -665,11 +668,15 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 .build());
   }
 
-  private ObjectTypeProto.Builder namedObjectBuilder(String... className) {
+  private ObjectTypeProto.Builder namedObjectBuilder(String... classNames) {
+    ImmutableList.Builder<Integer> typeNamePointers = ImmutableList.builder();
+    for (String className : classNames) {
+      typeNamePointers.add(this.stringPoolBuilder.put(className));
+    }
     return ObjectTypeProto.newBuilder()
         .setDebugInfo(
             ObjectTypeProto.DebugInfo.newBuilder()
-                .addAllTypename(ImmutableList.copyOf(className))
+                .addAllTypenamePointer(typeNamePointers.build())
                 .build());
   }
 
@@ -696,8 +703,13 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
 
   private int pointerForType(String className) {
     List<TypeProto> types = this.typePool.getTypeList();
+    StringPool stringPool = this.stringPoolBuilder.build();
     for (int i = 0; i < types.size(); i++) {
-      if (types.get(i).getObject().getDebugInfo().getTypenameList().contains(className)) {
+      ImmutableSet<String> typeNames =
+          types.get(i).getObject().getDebugInfo().getTypenamePointerList().stream()
+              .map(stringPool::get)
+              .collect(toImmutableSet());
+      if (typeNames.contains(className)) {
         return untrimOffset(i);
       }
     }
@@ -709,15 +721,20 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
     return ImmutableList.copyOf(compileToTypes(""));
   }
 
-  private static List<TypeProto> getNonPrimitiveSupertypesFor(TypePool typePool, String className) {
+  private List<TypeProto> getNonPrimitiveSupertypesFor(TypePool typePool, String className) {
     ArrayList<TypeProto> supertypes = new ArrayList<>();
+    StringPool stringPool = this.stringPoolBuilder.build();
     for (SubtypingEdge edge : typePool.getDisambiguationEdgesList()) {
       TypeProto subtype = typePool.getType(trimOffset(edge.getSubtype()));
       if (!subtype.hasObject()) {
         continue;
       }
       ObjectTypeProto objectSubtype = subtype.getObject();
-      if (!objectSubtype.getDebugInfo().getTypename(0).equals(className)) {
+      ImmutableList<String> typeNames =
+          objectSubtype.getDebugInfo().getTypenamePointerList().stream()
+              .map(stringPool::get)
+              .collect(toImmutableList());
+      if (!typeNames.get(0).equals(className)) {
         continue;
       }
       if (isAxiomatic(edge.getSupertype())) {
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java b/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
index 4d5d706..accdeaa 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
@@ -69,7 +69,10 @@ public final class SerializeTypesToPointersTest {
                 .getType(TypePointers.trimOffset(fooCtorPointer))
                 .getObject()
                 .getDebugInfo())
-        .isEqualTo(ObjectTypeProto.DebugInfo.newBuilder().addTypename("(typeof Foo)").build());
+        .isEqualTo(
+            ObjectTypeProto.DebugInfo.newBuilder()
+                .addTypenamePointer(stringPoolBuilder.put("(typeof Foo)"))
+                .build());
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
index dcf9e6d..c633739 100644
--- a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
@@ -174,7 +174,7 @@ public class TypedAstSerializerTest extends CompilerTestCase {
   }
 
   private class Tester {
-    Map<String, ImmutableSet<String>> expectedTypeNameToPropertyNamesMap = new HashMap<>();
+    final Map<String, ImmutableSet<String>> expectedTypeNameToPropertyNamesMap = new HashMap<>();
 
     Tester expectTypeNamed(String typeName) {
       expectedTypeNameToPropertyNamesMap.put(typeName, ImmutableSet.of());
@@ -196,7 +196,8 @@ public class TypedAstSerializerTest extends CompilerTestCase {
         final TypeProto typeProto = typeProtos.get(i);
         // none of our test cases use unions, so we know it's an object type
         final ObjectTypeProto typeProtoObject = typeProto.getObject();
-        final String typeName = typeProtoObject.getDebugInfo().getTypename(0);
+        final String typeName =
+            stringPool.get(typeProtoObject.getDebugInfo().getTypenamePointer(0));
         typeNameToTrimmedPoolOffset.put(typeName, i);
 
         // check actual property names against the expected ones
diff --git a/test/com/google/javascript/jscomp/testdata/SourceMapJsLangTest/control_structures.jsdata b/test/com/google/javascript/jscomp/testdata/SourceMapJsLangTest/control_structures.jsdata
index dc6e829..73aadfc 100644
--- a/test/com/google/javascript/jscomp/testdata/SourceMapJsLangTest/control_structures.jsdata
+++ b/test/com/google/javascript/jscomp/testdata/SourceMapJsLangTest/control_structures.jsdata
@@ -5,7 +5,7 @@ for (const __var2__ in __var3__) {}
 
 for (const __var4__ of __var5__) {}
 
-for await (const __var6__ of __var7__) {}
+async () => { for await (const __var6__ of __var7__) {} }
 
 while (__var8__) {}
 
diff --git a/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/entry.js b/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/entry.js
new file mode 100644
index 0000000..68c973f
--- /dev/null
+++ b/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/entry.js
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('entry');
+
+const {Foo} = goog.requireType('module.with.side.effects');
+
+/** @return {?Foo} */
+function f() {
+  console.log('entry');
+  return null;
+}
+
+f();
diff --git a/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/side_effects.js b/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/side_effects.js
new file mode 100644
index 0000000..aeb3f0d
--- /dev/null
+++ b/test/com/google/javascript/jscomp/typedast_integration/removeWeakSources/side_effects.js
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('module.with.side.effects');
+
+class Foo {}
+exports.Foo = Foo;
+
+console.log('In module with side effects');

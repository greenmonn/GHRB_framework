diff --git a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
index c9f4b2b..27d9878 100644
--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
@@ -47,7 +47,7 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
 
   @Override
   protected Format getSourceMapFormat() {
-    return SourceMap.Format.V3;
+    return Format.V3;
   }
 
   private static String getEncodedFileName() {
@@ -409,10 +409,11 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
   public void testWriteMetaMap() throws IOException {
     StringWriter out = new StringWriter();
     String name = "./app.js";
-    List<SourceMapSection> appSections = ImmutableList.of(
-        SourceMapSection.forURL("src1", 0, 0),
-        SourceMapSection.forURL("src2", 100, 10),
-        SourceMapSection.forURL("src3", 150, 5));
+    ImmutableList<SourceMapSection> appSections =
+        ImmutableList.of(
+            SourceMapSection.forURL("src1", 0, 0),
+            SourceMapSection.forURL("src2", 100, 10),
+            SourceMapSection.forURL("src3", 150, 5));
 
     SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();
     generator.appendIndexMapTo(out, name, appSections);
@@ -458,10 +459,11 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
   public void testWriteMetaMap2() throws IOException {
     StringWriter out = new StringWriter();
     String name = "./app.js";
-    List<SourceMapSection> appSections = ImmutableList.of(
-        // Map and URLs can be mixed.
-        SourceMapSection.forMap(getEmptyMapFor("./part.js"), 0, 0),
-        SourceMapSection.forURL("src2", 100, 10));
+    ImmutableList<SourceMapSection> appSections =
+        ImmutableList.of(
+            // Map and URLs can be mixed.
+            SourceMapSection.forMap(getEmptyMapFor("./part.js"), 0, 0),
+            SourceMapSection.forURL("src2", 100, 10));
 
     SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();
     generator.appendIndexMapTo(out, name, appSections);
diff --git a/test/com/google/debugging/sourcemap/SourceMapTestCase.java b/test/com/google/debugging/sourcemap/SourceMapTestCase.java
index de8465a..b464a9c 100644
--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java
+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java
@@ -35,7 +35,6 @@ import com.google.javascript.jscomp.SourceMap.DetailLevel;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import org.junit.Before;
@@ -57,7 +56,7 @@ public abstract class SourceMapTestCase {
   static final ImmutableList<SourceFile> EXTERNS =
       ImmutableList.of(SourceFile.fromCode("externs", ""));
 
-  protected DetailLevel detailLevel = SourceMap.DetailLevel.ALL;
+  protected DetailLevel detailLevel = DetailLevel.ALL;
   protected boolean sourceMapIncludeSourcesContent = false;
 
   private static final Joiner LINE_JOINER = Joiner.on('\n');
@@ -85,7 +84,7 @@ public abstract class SourceMapTestCase {
 
   @Before
   public void setUp() {
-    detailLevel = SourceMap.DetailLevel.ALL;
+    detailLevel = DetailLevel.ALL;
   }
 
   /**
@@ -290,7 +289,7 @@ public abstract class SourceMapTestCase {
 
     options.setChecksOnly(true);
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(fileName1, js1));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(fileName1, js1));
 
     if (js2 != null && fileName2 != null) {
       inputs =
diff --git a/test/com/google/javascript/jscomp/AstAnalyzerTest.java b/test/com/google/javascript/jscomp/AstAnalyzerTest.java
index f757d91..061b5ae 100644
--- a/test/com/google/javascript/jscomp/AstAnalyzerTest.java
+++ b/test/com/google/javascript/jscomp/AstAnalyzerTest.java
@@ -31,6 +31,7 @@ import static com.google.javascript.rhino.Token.ASSIGN_OR;
 import static com.google.javascript.rhino.Token.AWAIT;
 import static com.google.javascript.rhino.Token.BIGINT;
 import static com.google.javascript.rhino.Token.BITOR;
+import static com.google.javascript.rhino.Token.BLOCK;
 import static com.google.javascript.rhino.Token.CALL;
 import static com.google.javascript.rhino.Token.CLASS;
 import static com.google.javascript.rhino.Token.COALESCE;
@@ -88,6 +89,7 @@ import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import java.util.ArrayDeque;
 import java.util.Optional;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
@@ -150,7 +152,7 @@ public final class AstAnalyzerTest {
 
   /** Provides methods for parsing and accessing the compiler used for the parsing. */
   private static final class ParseHelper {
-    private Compiler compiler = null;
+    private @Nullable Compiler compiler = null;
 
     private void resetCompiler() {
       CompilerOptions options = new CompilerOptions();
@@ -230,7 +232,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           kase().js("i++").token(INC).expect(true),
           kase().js("[b, [a, i++]]").token(ARRAYLIT).expect(true),
@@ -357,7 +359,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           // Cases in need of differentiation.
           kase().expect(false).js("[1]"),
@@ -606,6 +608,17 @@ public final class AstAnalyzerTest {
           kase().expect(true).token(COMPUTED_FIELD_DEF).js("class C { static ['x'] = alert(1); }"),
           kase().expect(true).token(COMPUTED_FIELD_DEF).js("class C { static [alert(1)] = 2; }"),
 
+          // CLASS_STATIC_BLOCK
+          kase().expect(false).token(BLOCK).js("class C { static {} }"),
+          kase().expect(false).token(BLOCK).js("class C { static { [1]; } }"),
+          kase().expect(true).token(BLOCK).js("class C { static { let x; } }"),
+          kase().expect(true).token(BLOCK).js("class C { static { const x =1 ; } }"),
+          kase().expect(true).token(BLOCK).js("class C { static { var x; } }"),
+          kase().expect(true).token(BLOCK).js("class C { static { this.x = 1; } }"),
+          kase().expect(true).token(BLOCK).js("class C { static { function f() { } } }"),
+          kase().expect(false).token(BLOCK).js("class C { static { (function () {} )} }"),
+          kase().expect(false).token(BLOCK).js("class C { static { ()=>{} } }"),
+
           // SUPER calls
           kase().expect(false).token(SUPER).js("super()"),
           kase().expect(false).token(SUPER).js("super.foo()"),
@@ -671,7 +684,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           kase().js("x = y").token(ASSIGN).expect(true),
           kase().js("x += y").token(ASSIGN_ADD).expect(true),
@@ -950,7 +963,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static final Iterable<Object[]> cases() {
+    public static final ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             {"Array"}, {"Date"}, {"Error"}, {"Object"}, {"RegExp"}, {"XMLHttpRequest"}
diff --git a/test/com/google/javascript/jscomp/AstValidatorTest.java b/test/com/google/javascript/jscomp/AstValidatorTest.java
index e2a2fb4..1fe704b 100644
--- a/test/com/google/javascript/jscomp/AstValidatorTest.java
+++ b/test/com/google/javascript/jscomp/AstValidatorTest.java
@@ -46,13 +46,14 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** @author johnlenz@google.com (John Lenz) */
+/**
+ * @author johnlenz@google.com (John Lenz)
+ */
 @RunWith(JUnit4.class)
 public final class AstValidatorTest extends CompilerTestCase {
 
   private List<String> lastCheckViolationMessages;
-  private AstValidator.TypeInfoValidation typeInfoValidationMode =
-      AstValidator.TypeInfoValidation.JSTYPE;
+  private TypeInfoValidation typeInfoValidationMode = TypeInfoValidation.JSTYPE;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
@@ -94,7 +95,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testParenthesizedProperty() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.string("a");
     n.setIsParenthesized(true);
@@ -191,6 +192,52 @@ public final class AstValidatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassField_super() {
+    valid(
+        lines(
+            "class B { static x = 2}",
+            "class C extends B {", //
+            "  static y = super.x;",
+            "}"));
+    valid(
+        lines(
+            "class B { static x = 2}",
+            "class C extends B {", //
+            "  static y = super.x;",
+            "}"));
+    valid(
+        lines(
+            "class B { static x = 2}",
+            "class C extends B {", //
+            "  static y = super.x + 2;",
+            "}"));
+    valid(
+        lines(
+            "class B { static x = 2 }",
+            "class C extends B {", //
+            "   static y = super.x + 2 + 4 + 6 - 8;",
+            "}"));
+    valid(
+        lines(
+            "class B { static x = 2 }",
+            "/** @unrestricted */ class C extends B {", //
+            "   static ['y'] = super.x;",
+            "}"));
+    valid(
+        lines(
+            "class C { x=1;}", //
+            "class D extends C {",
+            "  y = () => super.x;",
+            "}"));
+    invalid(
+        lines(
+            "class C { x=1;}", //
+            "class D extends C {",
+            "  y = function() { super.x; }",
+            "}"));
+  }
+
+  @Test
   public void testClassComputedField() {
     valid("/** @dict */ class C { [x]; }");
     valid("/** @dict */ class C { ['x']=2; }");
@@ -246,6 +293,79 @@ public final class AstValidatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlock() {
+
+    valid(
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
+  public void testClassStaticBlock_this() {
+    // TODO (user): re-enable TypeInfoValidation and TypeCheck
+    typeInfoValidationMode = TypeInfoValidation.NONE;
+    disableTypeCheck();
+    valid(
+        lines(
+            "class C {", //
+            "  static {",
+            "    this.prop = 4;",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
+  public void testClassStaticBlock_superProperty() {
+    // TODO (user): re-enable TypeInfoValidation and TypeCheck
+    typeInfoValidationMode = TypeInfoValidation.NONE;
+    disableTypeCheck();
+    valid(
+        lines(
+            "class D {",
+            "  static field;",
+            "}",
+            "class C extends D {",
+            "  static {",
+            "    if (Foo) { super.field = 'hello'; }",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
+  public void testClassStaticBlock_invalidSuperConstructorCall() {
+    // TODO (user): re-enable TypeInfoValidation and TypeCheck
+    typeInfoValidationMode = TypeInfoValidation.NONE;
+    disableTypeCheck();
+    invalid(
+        lines(
+            "class D {}", //
+            "class C extends D {",
+            "  static {",
+            "    super();",
+            "  }",
+            "}",
+            ""));
+  }
+
+  @Test
+  public void testFeatureValidation_classStaticBlock() {
+    testFeatureValidation(
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}",
+            ""),
+        Feature.CLASS_STATIC_BLOCK);
+  }
+
+  @Test
   public void testFor() {
     valid("for(var a;;);");
     valid("for(let a;;);");
@@ -264,7 +384,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("for(a in {});");
 
     // Test that initializers are banned (except for simple vars - see testQuestionableForIn)
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_IN, IR.constNode(IR.name("a"), IR.number(1)), IR.name("b")),
         Check.STATEMENT);
@@ -288,7 +408,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("for (const {} of b);");
 
     // Test that initializers are banned
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_OF, IR.var(IR.name("a"), IR.number(1)), IR.name("b")), Check.STATEMENT);
     expectInvalid(
@@ -313,7 +433,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("async () => { for await(a of /** @type {!Iterable<?>} */ ({})); }");
 
     // Test that initializers are banned
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_AWAIT_OF, IR.var(IR.name("a"), IR.number(1)), IR.name("b")),
         Check.STATEMENT);
@@ -338,7 +458,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("a['b']++");
     valid("/** @type {number} */ (x)++;");
 
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(new Node(Token.INC, IR.name("x"), IR.name("x")), Check.EXPRESSION);
     expectInvalid(new Node(Token.INC, IR.arrayPattern()), Check.EXPRESSION);
     expectInvalid(new Node(Token.INC, IR.objectPattern()), Check.EXPRESSION);
@@ -351,7 +471,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("const a = {b: 0}; a.b += 1;");
     valid("const a = {b: '0'}; /** @type {?} */ (a.b) += 1;");
 
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(new Node(Token.ASSIGN_ADD, IR.arrayPattern(), IR.number(0)), Check.EXPRESSION);
     expectInvalid(new Node(Token.ASSIGN_ADD, IR.objectPattern(), IR.number(0)), Check.EXPRESSION);
   }
@@ -371,7 +491,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidScript() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.SCRIPT);
     expectInvalid(n, Check.SCRIPT);
@@ -385,7 +505,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidStatement1() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.RETURN);
     setTestSourceLocationForTree(n);
@@ -397,7 +517,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidExpression1() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.ARRAYLIT, new Node(Token.EMPTY));
     setTestSourceLocationForTree(n);
@@ -409,7 +529,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidExpression2() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.NOT, new Node(Token.TRUE));
     setTestSourceLocationForTree(n);
@@ -446,7 +566,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidConstLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.constNode(IR.name("x"), IR.number(3));
     setTestSourceLocationForTree(n);
@@ -461,7 +581,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidLetLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.let(IR.name("x"), IR.number(3));
     setTestSourceLocationForTree(n);
@@ -476,7 +596,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testNewTargetIsValidExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.NEW_TARGET);
     setTestSourceLocationForTree(n);
@@ -486,7 +606,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testImportMetaIsValidExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.IMPORT_META);
     setTestSourceLocationForTree(n);
@@ -496,7 +616,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testCastOnLeftSideOfAssign() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     JSDocInfo.Builder jsdoc = JSDocInfo.builder();
     jsdoc.recordType(new JSTypeExpression(IR.string("number"), "<AstValidatorTest>"));
@@ -518,7 +638,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidNumberStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.number(1);
     setTestSourceLocationForTree(n);
@@ -531,7 +651,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidBigIntStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.bigint(BigInteger.ONE);
     setTestSourceLocationForTree(n);
@@ -557,7 +677,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testAwaitExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node awaitNode = new Node(Token.AWAIT);
@@ -573,7 +693,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   public void testNoAwaitExpressionInDefaultParams() {
     // We're inserting our own Nodes below, and we won't be bothering to put valid type
     // information on them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     Node scriptNode =
         parseValidScript(
             lines(
@@ -601,7 +721,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   public void testNoYieldExpressionInDefaultParams() {
     // We're inserting our own Nodes below, and we won't be bothering to put valid type
     // information on them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     Node scriptNode =
         parseValidScript(
             lines(
@@ -649,7 +769,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testAwaitExpressionNoFunction() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node n = new Node(Token.AWAIT);
@@ -660,7 +780,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testYieldExpressionNoFunction() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node n = new Node(Token.YIELD);
@@ -671,7 +791,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidArrayPattern0() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -764,7 +884,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidObjectRestForLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.assign(IR.objectPattern(IR.objectRest(IR.name("x"))), IR.objectlit());
     setTestSourceLocationForTree(n);
@@ -779,7 +899,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidArrayRestForLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.assign(IR.arrayPattern(IR.iterRest(IR.name("x"))), IR.arraylit());
     setTestSourceLocationForTree(n);
@@ -794,7 +914,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidDestructuringDeclaration() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -822,7 +942,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidDestructuringAssignment() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -857,7 +977,7 @@ public final class AstValidatorTest extends CompilerTestCase {
             ""));
 
     // Since we're modifying the AST by hand below, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node c = new Node(Token.CLASS, IR.name("C"), IR.empty());
     Node members = new Node(Token.CLASS_MEMBERS);
@@ -1112,7 +1232,7 @@ public final class AstValidatorTest extends CompilerTestCase {
 
     // Since we're modifying the AST by hand below, there won't be types on some nodes that need
     // them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node c = new Node(Token.CLASS, IR.name("C"), IR.empty());
     Node members = new Node(Token.CLASS_MEMBERS);
@@ -1335,7 +1455,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testFeatureValidation_logicalAssignmentOp() {
     // TODO (user): re-enable TypeInfoValidation and TypeCheck
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     disableTypeCheck();
     testFeatureValidation("x ||= y", Feature.LOGICAL_ASSIGNMENT);
     testFeatureValidation("x &&= y", Feature.LOGICAL_ASSIGNMENT);
@@ -1380,7 +1500,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidFeatureInScript() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -1445,7 +1565,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testSwitchStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     String switchStatement =
         lines(
diff --git a/test/com/google/javascript/jscomp/ChangeVerifierTest.java b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
index 87502f4..86e312e 100644
--- a/test/com/google/javascript/jscomp/ChangeVerifierTest.java
+++ b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,7 +47,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class ChangeVerifierTest {
-  private Compiler compiler;
+  private @Nullable Compiler compiler;
 
   @Before
   public void setup() {
diff --git a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
index b7d47f2..a7fe75e 100644
--- a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
+++ b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
@@ -267,6 +267,41 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testNoWarningOnClassField_deprecated1() {
+    // TODO(b/239747805): Should throw deprecatedProp warning
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /**",
+                "   * @type {number}",
+                "   * @deprecated No.",
+                "   */",
+                "  static x=1;",
+                "}",
+                "Foo.x;")));
+  }
+
+  @Test
+  public void testNoWarningOnClassField_deprecated2() {
+    // TODO(b/239747805): Should say "Property x of type number" not "super"
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /**",
+                "   * @type {number}",
+                "   * @deprecated No.",
+                "   */",
+                "  static x = 1;",
+                "}",
+                "class Bar extends Foo {",
+                "  static y = super.x;",
+                "}")),
+        deprecatedProp("Property x of type super has been deprecated: No."));
+  }
+
+  @Test
   public void testNoWarningInDeprecatedClass() {
     test(
         srcs(
@@ -339,6 +374,81 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testWarningInClassStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "/** @deprecated Oh No! */",
+                "function f() {}",
+                "",
+                "class Foo {",
+                "  static { f(); }",
+                "}")),
+        deprecatedName("Variable f has been deprecated: Oh No!"));
+  }
+
+  @Test
+  public void testWarningInClassStaticBlock1() {
+    test(
+        srcs(
+            lines(
+                "/** @deprecated Woah! */", //
+                "var x;",
+                "",
+                "class Foo {",
+                "  static { x; }",
+                "}")),
+        deprecatedName("Variable x has been deprecated: Woah!"));
+  }
+
+  @Test
+  public void testWarningInClassStaticBlock2() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  /** @deprecated Bad :D */",
+                "   static x = 1;",
+                "   static {",
+                "      var y = this.x;",
+                "   }",
+                "}")),
+        deprecatedProp("Property x of type this has been deprecated: Bad :D"));
+  }
+
+  @Test
+  public void testNoWarningInClassStaticBlock() {
+    // TODO(b/235871861): Compiler should throw warning as it doesn't make sense to deprecate a
+    // static block
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @deprecated D: */",
+                "  static {",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoWarningInClassStaticBlock1() {
+    // TODO(b/239747805): Should say "Property x of type number" not "super"
+    test(
+        srcs(
+            lines(
+                "class A {",
+                "  /** @deprecated Meow! */",
+                "  static x = 1;",
+                "}",
+                "class B extends A {",
+                "  static {",
+                "    this.y = super.x;",
+                "  }",
+                "}")),
+        deprecatedProp("Property x of type super has been deprecated: Meow!"));
+  }
+
+  @Test
   public void testWarningForSubclassMethod() {
     test(
         srcs(
@@ -948,6 +1058,38 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testPrivateAccessForStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @private */",
+                "  static bar = 2",
+                "  static {",
+                "    this.bar = 4;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoPrivateAccessForStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @private */",
+                "  static bar = 2;",
+                "}"),
+            lines(
+                "class Bar extends Foo{", //
+                "  static {",
+                "    this.bar = 4;",
+                "  }",
+                "}")),
+        error(BAD_PRIVATE_PROPERTY_ACCESS));
+  }
+
+  @Test
   public void testProtectedAccessForProperties1() {
     test(
         srcs(
@@ -1719,6 +1861,87 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testProtectedAccessForStaticBlocks() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStaticBlocks_sameFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}",
+                "class SubFoo extends Foo {",
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStaticBlocks_sameFile1() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}",
+                "class Bar {",
+                "  static {",
+                "    Foo.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStatic_differentFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}"),
+            lines(
+                "class SubFoo extends Foo {", //
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoProtectedAccessForStaticBlocks_differentFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}"),
+            lines(
+                "class Bar {", //
+                "  static {",
+                "    Foo.bar;",
+                "  }",
+                "}")),
+        error(BAD_PROTECTED_PROPERTY_ACCESS));
+  }
+
+  @Test
   public void testPackagePrivateAccessForProperties1() {
     test(
         srcs(
@@ -3356,6 +3579,21 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testConstantPropertyReassignmentInClassStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "/** @const */",
+                "  static x = 2;",
+                "  static {",
+                "    this.x = 3;",
+                "  }",
+                "}")),
+        error(CONST_PROPERTY_REASSIGNED_VALUE));
+  }
+
+  @Test
   public void testFinalClassCannotBeSubclassed() {
     test(
         srcs(
diff --git a/test/com/google/javascript/jscomp/CheckConformanceTest.java b/test/com/google/javascript/jscomp/CheckConformanceTest.java
index 5343886..a236415 100644
--- a/test/com/google/javascript/jscomp/CheckConformanceTest.java
+++ b/test/com/google/javascript/jscomp/CheckConformanceTest.java
@@ -3285,6 +3285,18 @@ public final class CheckConformanceTest extends CompilerTestCase {
 
     testWarning(
         externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS(null, 'SRc', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSetAttribute Message");
+
+    testWarning(
+        externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS('ns', 'data-random', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSetAttribute Message");
+
+    testWarning(
+        externs(externs),
         srcs("var attr = 'unknown'; (new HTMLScriptElement).setAttributeNS(null, attr, 'xxx')"),
         CheckConformance.CONFORMANCE_VIOLATION,
         "Violation: BanSetAttribute Message");
@@ -3292,6 +3304,10 @@ public final class CheckConformanceTest extends CompilerTestCase {
     testNoWarning(
         externs(externs), srcs("(new HTMLScriptElement).setAttribute('data-random', 'xxx')"));
 
+    testNoWarning(
+        externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS(null, 'data-random', 'xxx')"));
+
     testWarning(
         externs(externs),
         srcs("(new HTMLScriptElement)['SRc'] = 'xxx';"),
@@ -3374,6 +3390,98 @@ public final class CheckConformanceTest extends CompilerTestCase {
   }
 
   @Test
+  public void testBanSettingAttributes() {
+    configuration =
+        lines(
+            "requirement: {\n",
+            "  type: CUSTOM\n",
+            "  value: 'Element.prototype.attr'\n",
+            "  value: 'Foo.prototype.attrib'\n",
+            "  java_class: 'com.google.javascript.jscomp.ConformanceRules$BanSettingAttributes'\n",
+            "  error_message: 'BanSettingAttributes Message'\n",
+            "}");
+
+    String externs =
+        lines(
+            DEFAULT_EXTERNS,
+            "/** @constructor */ function Foo() {}\n",
+            "/** @constructor */ function Bar() {}\n",
+            "/** @constructor */ function Element() {}\n",
+            "/** @constructor @extends {Element} */ function HTMLScriptElement() {}\n");
+
+    testWarning(
+        externs(externs),
+        srcs("(new Foo).attrib('SRc', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSettingAttributes Message");
+
+    testWarning(
+        externs(externs),
+        srcs("(new HTMLScriptElement).attr('href', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSettingAttributes Message");
+
+    testNoWarning(externs(externs), srcs("(new Bar).attr('src', 'xxx')"));
+
+    testNoWarning(externs(externs), srcs("(new Foo).attrib('src')"));
+
+    testNoWarning(externs(externs), srcs("(new HTMLScriptElement).attrib('src', 'xxx')"));
+
+    testNoWarning(externs(externs), srcs("(new HTMLScriptElement).attr('data-random', 'xxx')"));
+
+    testWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "const foo = 'safe';",
+                "var bar = foo;",
+                "(new HTMLScriptElement).attr(bar, 'xxx');")),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSettingAttributes Message");
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "const foo = 'safe';",
+                "const bar = foo;",
+                "(new HTMLScriptElement).attr(bar, 'xxx');")));
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            new String[] {
+              lines(
+                  "goog.provide('test.Attribute');",
+                  "",
+                  "/** @enum {string} */",
+                  "test.Attribute = {SRC: 'src', HREF: 'href', SAFE: 'safe'};"),
+              lines(
+                  "goog.module('test.attr');",
+                  "",
+                  "const Attribute = goog.require('test.Attribute');",
+                  "",
+                  "const attr = Attribute.SAFE;",
+                  "(new HTMLScriptElement).attr(attr, 'xxx');")
+            }));
+
+    testNoWarning(
+        externs(externs),
+        srcs(
+            lines(
+                "goog.provide('xid');",
+                "goog.provide('xid.String');",
+                "/** @enum {string} */ xid.String = {DO_NOT_USE: ''};",
+                "/**",
+                " * @param {string} id",
+                " * @return {xid.String}",
+                " */",
+                "xid = function(id) {return /** @type {xid.String} */ (id);};",
+                "const attr = xid('src');",
+                "(new HTMLScriptElement).attr(attr, 'xxx');")));
+  }
+
+  @Test
   public void testBanExecCommand() {
     configuration =
         lines(
diff --git a/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java b/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
index 6631bc6..ca70392 100644
--- a/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
+++ b/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,7 +28,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class CheckDebuggerStatementTest extends CompilerTestCase {
 
-  private CheckLevel checkLevel;
+  private @Nullable CheckLevel checkLevel;
 
   @Override
   @After
diff --git a/test/com/google/javascript/jscomp/CheckGlobalThisTest.java b/test/com/google/javascript/jscomp/CheckGlobalThisTest.java
index ddac8f0..3f132a3 100644
--- a/test/com/google/javascript/jscomp/CheckGlobalThisTest.java
+++ b/test/com/google/javascript/jscomp/CheckGlobalThisTest.java
@@ -34,8 +34,7 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new CombinedCompilerPass(
-        compiler, new CheckGlobalThis(compiler));
+    return new CombinedCompilerPass(compiler, new CheckGlobalThis(compiler));
   }
 
   private void testFailure(String js) {
@@ -134,14 +133,14 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testInterface1() {
-    testSame(
-        "/** @interface */function A() { /** @type {string} */ this.m2; }");
+    testSame("/** @interface */function A() { /** @type {string} */ this.m2; }");
   }
 
   @Test
   public void testOverride1() {
-    testSame("/** @constructor */function A() { } var a = new A();" +
-             "/** @override */ a.foo = function() { this.bar = 5; };");
+    testSame(
+        "/** @constructor */function A() { } var a = new A();"
+            + "/** @override */ a.foo = function() { this.bar = 5; };");
   }
 
   @Test
@@ -191,8 +190,7 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testPropertyOfMethod() {
-    testFailure("a.protoype.b = {}; " +
-        "a.prototype.b.c = function() { this.foo = 3; };");
+    testFailure("a.protoype.b = {}; " + "a.prototype.b.c = function() { this.foo = 3; };");
   }
 
   @Test
@@ -222,10 +220,11 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testStaticFunctionInMethod2() {
-    testSame("A.prototype.m1 = function() {" +
-        "  function me() {" +
-        "    function myself() {" +
-        "      function andI() { this.m2 = 5; } } } }");
+    testSame(
+        "A.prototype.m1 = function() {"
+            + "  function me() {"
+            + "    function myself() {"
+            + "      function andI() { this.m2 = 5; } } } }");
   }
 
   @Test
@@ -240,14 +239,12 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testInnerFunction3() {
-    testFailure(
-        "function f() { var x = {}; x.y = function() { return this.x; } }");
+    testFailure("function f() { var x = {}; x.y = function() { return this.x; } }");
   }
 
   @Test
   public void testInnerFunction4() {
-    testSame(
-        "function f() { var x = {}; x.y(function() { return this.x; }); }");
+    testSame("function f() { var x = {}; x.y(function() { return this.x; }); }");
   }
 
   @Test
@@ -267,28 +264,30 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testIssue182d() {
-    testSame("function Foo() {} " +
-        "Foo.prototype = {write: function() { this.foo = 3; }};");
+    testSame("function Foo() {} " + "Foo.prototype = {write: function() { this.foo = 3; }};");
   }
 
   @Test
   public void testLendsAnnotation1() {
-    testFailure("/** @constructor */ function F() {}" +
-        "dojo.declare(F, {foo: function() { return this.foo; }});");
+    testFailure(
+        "/** @constructor */ function F() {}"
+            + "dojo.declare(F, {foo: function() { return this.foo; }});");
   }
 
   @Test
   public void testLendsAnnotation2() {
-    testFailure("/** @constructor */ function F() {}" +
-        "dojo.declare(F, /** @lends {F.bar} */ (" +
-        "    {foo: function() { return this.foo; }}));");
+    testFailure(
+        "/** @constructor */ function F() {}"
+            + "dojo.declare(F, /** @lends {F.bar} */ ("
+            + "    {foo: function() { return this.foo; }}));");
   }
 
   @Test
   public void testLendsAnnotation3() {
-    testSame("/** @constructor */ function F() {}" +
-        "dojo.declare(F, /** @lends {F.prototype} */ (" +
-        "    {foo: function() { return this.foo; }}));");
+    testSame(
+        "/** @constructor */ function F() {}"
+            + "dojo.declare(F, /** @lends {F.prototype} */ ("
+            + "    {foo: function() { return this.foo; }}));");
   }
 
   @Test
@@ -308,54 +307,111 @@ public final class CheckGlobalThisTest extends CompilerTestCase {
 
   @Test
   public void testArrowFunction3() {
-    testFailure("function Foo() {} " +
-        "Foo.prototype.getFoo = () => this.foo;");
+    testFailure("function Foo() {} " + "Foo.prototype.getFoo = () => this.foo;");
   }
 
   @Test
   public void testArrowFunction4() {
-    testFailure("function Foo() {} " +
-        "Foo.prototype.setFoo = (f) => { this.foo = f; };");
+    testFailure("function Foo() {} " + "Foo.prototype.setFoo = (f) => { this.foo = f; };");
   }
 
   @Test
   public void testInnerFunctionInClassMethod1() {
     // TODO(user): It would be nice to warn for using 'this' here
-    testSame(lines(
-        "function Foo() {}",
-        "Foo.prototype.init = function() {",
-        "  button.addEventListener('click', function () {",
-        "    this.click();",
-        "  });",
-        "}",
-        "Foo.prototype.click = function() {}"));
+    testSame(
+        lines(
+            "function Foo() {}",
+            "Foo.prototype.init = function() {",
+            "  button.addEventListener('click', function () {",
+            "    this.click();",
+            "  });",
+            "}",
+            "Foo.prototype.click = function() {}"));
   }
 
   @Test
   public void testInnerFunctionInClassMethod2() {
     // TODO(user): It would be nice to warn for using 'this' here
-    testSame(lines(
-        "function Foo() {",
-        "  var x = function() {",
-        "    button.addEventListener('click', function () {",
-        "      this.click();",
-        "    });",
-        "  }",
-        "}"));
+    testSame(
+        lines(
+            "function Foo() {",
+            "  var x = function() {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "}"));
   }
 
   @Test
   public void testInnerFunctionInEs6ClassMethod() {
     // TODO(user): It would be nice to warn for using 'this' here
-    testSame(lines(
-        "class Foo {",
-        "  constructor() {",
-        "    button.addEventListener('click', function () {",
-        "      this.click();",
-        "    });",
-        "  }",
-        "  click() {}",
-        "}"));
+    testSame(
+        lines(
+            "class Foo {",
+            "  constructor() {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "  click() {}",
+            "}"));
+  }
+
+  @Test
+  public void testStaticBlockThis() {
+    testSame("class Foo { static {var x = this.y;} }");
+    testSame("class Foo {static {this.x = 2; }}");
+    testSame("class Foo {static {this[this.x] = 3;}}");
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    function g() {",
+            "      return this.f() + 1;",
+            "    }",
+            "    var y = g() + 1;",
+            "  }",
+            "  static f() {return 1;}",
+            "}"));
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "  static click() {}",
+            "}"));
+  }
+
+  @Test
+  public void testES6ClassStaticMethodThis() {
+    testSame("class Foo { static h() {var x = this.y;} }");
+    testSame("class Foo {static h() {this.x = 2; }}");
+    testSame("class Foo {static h() {this[this.x] = 3;}}");
+    testSame(
+        lines(
+            "class Foo {",
+            "  static h() {",
+            "    function g() {",
+            "      return this.f() + 1;",
+            "    }",
+            "    var y = g() + 1;",
+            "  }",
+            "  static f() {return 1;}",
+            "}"));
+    testSame(
+        lines(
+            "class Foo {",
+            "  static h() {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "  static click() {}",
+            "}"));
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/CheckRegExpTest.java b/test/com/google/javascript/jscomp/CheckRegExpTest.java
index 6dc7171..3aae955 100644
--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java
+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java
@@ -18,6 +18,7 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,7 +27,7 @@ import org.junit.runners.JUnit4;
 /** @author johnlenz@google.com (John Lenz) */
 @RunWith(JUnit4.class)
 public final class CheckRegExpTest extends CompilerTestCase {
-  CheckRegExp last = null;
+  @Nullable CheckRegExp last = null;
   boolean reportErrors;
 
   public CheckRegExpTest() {
diff --git a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
index daa743f..fc78921 100644
--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java
@@ -201,6 +201,68 @@ public final class CheckSideEffectsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testUslessCodeInClassStaticBlock() {
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    function f(x) { if(x) return; }",
+            "  }",
+            "}"));
+    testWarning(
+        lines(
+            "class C {", //
+            "  static {",
+            "    function f(x) { if(x); }",
+            "  }",
+            "}"),
+        e);
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    var f = x=>x;",
+            "  }",
+            "}"));
+    testWarning(
+        lines(
+            "class C {", //
+            "  static {",
+            "    var f = (x)=>{ if(x); }",
+            "  }",
+            "}"),
+        e);
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    x = 3;",
+            "  }",
+            "}"));
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    x == 3;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  static {",
+            "    JSCOMPILER_PRESERVE(x == 3);",
+            "  }",
+            "}"),
+        warning(e));
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "     foo();;;;bar();;;;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testTypeAnnotations() {
     test("x;", "JSCOMPILER_PRESERVE(x);", warning(e));
     test("a.b.c.d;", "JSCOMPILER_PRESERVE(a.b.c.d);", warning(e));
diff --git a/test/com/google/javascript/jscomp/CheckSuperTest.java b/test/com/google/javascript/jscomp/CheckSuperTest.java
index dfe7bac..d7762e5 100644
--- a/test/com/google/javascript/jscomp/CheckSuperTest.java
+++ b/test/com/google/javascript/jscomp/CheckSuperTest.java
@@ -65,12 +65,13 @@ public final class CheckSuperTest extends CompilerTestCase {
   @Test
   public void testMissingSuper_nestedClass() {
     // Note that super is only called for anonymous class "E", not C.
-    testError(lines(
-        "class C extends D {",
-        "  constructor() { ",
-        "    const E = class extends D { constructor() { super(); } };",
-        "  }",
-        "}"),
+    testError(
+        lines(
+            "class C extends D {",
+            "  constructor() { ",
+            "    const E = class extends D { constructor() { super(); } };",
+            "  }",
+            "}"),
         MISSING_CALL_TO_SUPER);
   }
 
@@ -107,6 +108,14 @@ public final class CheckSuperTest extends CompilerTestCase {
         error(THIS_BEFORE_SUPER));
   }
 
+  @Test
+  public void testThisAndSuperPropAccessBeforeSuperCall_inSuperConstructorArgs() {
+    test(
+        srcs("class C extends D { constructor() { super(this.foo(), super.foo()); } }"),
+        error(SUPER_ACCESS_BEFORE_SUPER_CONSTRUCTOR),
+        error(THIS_BEFORE_SUPER));
+  }
+
   // We could require that the super() call is the first statement in the constructor, except that
   // doing so breaks J2CL-compiled code, which needs to do the static initialization for the class
   // before anything else.
@@ -352,9 +361,38 @@ public final class CheckSuperTest extends CompilerTestCase {
         srcs("class C extends D { foo() { super(1); }}"),
         error(INVALID_SUPER_CALL_WITH_SUGGESTION)
             .withMessage("super() not allowed here. Did you mean super.foo?"));
+    test(
+        srcs("class C extends D { static foo() { super(1); }}"),
+        error(INVALID_SUPER_CALL_WITH_SUGGESTION)
+            .withMessage("super() not allowed here. Did you mean super.foo?"));
     testError("class C { static foo() { super(); }}", INVALID_SUPER_CALL_WITH_SUGGESTION);
     testError(
         "class C extends D { foo() { (()=>{ super(); })(); }}", INVALID_SUPER_CALL_WITH_SUGGESTION);
+    testError(
+        "class C extends D { static foo() { (()=>{ super(); })(); }}",
+        INVALID_SUPER_CALL_WITH_SUGGESTION);
+  }
+
+  @Test
+  public void testSuperCallInStaticBlock() {
+    testError("class C extends D {static {super();}}", INVALID_SUPER_CALL);
+    testError("class C extends D {static {super(1);}}", INVALID_SUPER_CALL);
+    testError("class C extends D { static { (()=>{ super(); })(); }}", INVALID_SUPER_CALL);
+  }
+
+  @Test
+  public void testPropertyInStaticBlock() {
+    testSame("class C extends D { static { super.foo(); }}");
+    testSame("class C extends D { static { super.foo(1); }}");
+
+    // TODO(tbreisacher): Consider warning for this. It's valid but likely indicates a mistake.
+    testSame("class C extends D { static { var x = super.bar; }}");
+    testSame("class C extends D { static { var x = super[y]; }}");
+    testSame("class C extends D { static { var x = super.bar(); }}");
+
+    testSame("class C extends D { static { this[super.x] = super.bar; }}");
+    testSame("class C extends D { static { this[super.x] = super[y]; }}");
+    testSame("class C extends D { static { this[super.x] = super.bar(); }}");
   }
 
   @Test
@@ -365,7 +403,26 @@ public final class CheckSuperTest extends CompilerTestCase {
     // TODO(tbreisacher): Consider warning for this. It's valid but likely indicates a mistake.
     testSame("class C extends D { foo() { var x = super.bar; }}");
     testSame("class C extends D { foo() { var x = super[y]; }}");
-    testSame("class C extends D { foo() { super.bar(); }}");
+    testSame("class C extends D { foo() { var x = super.bar(); }}");
+
+    testSame("class C extends D { foo() { this[super.x] = super.bar; }}");
+    testSame("class C extends D { foo() { this[super.x] = super[y]; }}");
+    testSame("class C extends D { foo() { this[super.x] = super.bar(); }}");
+  }
+
+  @Test
+  public void testPropertyInStaticMethod() {
+    testSame("class C extends D { static foo() { super.foo(); }}");
+    testSame("class C extends D { static foo() { super.foo(1); }}");
+
+    // TODO(tbreisacher): Consider warning for this. It's valid but likely indicates a mistake.
+    testSame("class C extends D { static foo() { var x = super.bar; }}");
+    testSame("class C extends D { static foo() { var x = super[y]; }}");
+    testSame("class C extends D { static foo() { var x = super.bar(); }}");
+
+    testSame("class C extends D { static foo() { this[super.x] = super.bar; }}");
+    testSame("class C extends D { static foo() { this[super.x] = super[y]; }}");
+    testSame("class C extends D { static foo() { this[super.x] = super.bar(); }}");
   }
 
   @Test
@@ -413,6 +470,8 @@ public final class CheckSuperTest extends CompilerTestCase {
   public void testNestedProperty() {
     testSame("class C extends D { constructor() { super(); (()=>{ super.foo(); })(); }}");
     testSame("class C extends D { foo() { (()=>{ super.foo(); })(); }}");
+    testSame("class C extends D { static foo() { (()=>{ super.foo(); })(); }}");
+    testSame("class C extends D { static { (()=>{ super.foo(); })(); }}");
   }
 
   @Test
@@ -424,6 +483,4 @@ public final class CheckSuperTest extends CompilerTestCase {
     testSame("class C { foo() { super.baz; }}");
     testSame("class C { foo() { super[x](); }}");
   }
-
-  // TODO(sdh): test super.prop access from static methods - this will need runtime tests, too!
 }
diff --git a/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java b/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java
index be2cea0..7b90b52 100644
--- a/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java
+++ b/test/com/google/javascript/jscomp/CheckUnreachableCodeTest.java
@@ -167,6 +167,23 @@ public final class CheckUnreachableCodeTest extends CompilerTestCase {
   }
 
   @Test
+  public void testUnreachableStaticBlocks() {
+    assertUnreachable("class C{ static { function f(){ return; let x; } } }");
+    assertUnreachable("class C{ static{ if(false) { var x; } } }");
+    assertUnreachable("class C{ static{ while(false){ let x; } } }");
+  }
+
+  @Test
+  public void testReachableStaticBlocks() {
+    testSame("class C{ static { let x; } }");
+    testSame("class C{ static { function a(){} } }");
+    testSame("class C{ static {} a(){} }");
+    testSame("class C{ static {} static {} }");
+    testSame("class C{ static{} static x; static{} static y;}");
+    testSame("class C{ static [l('l1')] = l('r1'); static{ l('s2');} static[l('l3')] = l('r3');}");
+  }
+
+  @Test
   public void testSuppression() {
     assertUnreachable("if(false) { }");
 
diff --git a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
index 54247dd..f7a529f 100644
--- a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
@@ -26,6 +26,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Outcome;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSType;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -98,8 +99,8 @@ public final class ClosureReverseAbstractInterpreterTest extends CompilerTypeTes
         getNativeCheckedUnknownType());
   }
 
-  private void testClosureFunction(String function, JSType type,
-      JSType trueType, JSType falseType) {
+  private void testClosureFunction(
+      String function, @Nullable JSType type, JSType trueType, @Nullable JSType falseType) {
     // function(a) where a : type
     Node n = compiler.parseTestCode("var a; " + function + "(a)");
     Node call = n.getLastChild().getLastChild();
diff --git a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
index acf7651..806faf8 100644
--- a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
+++ b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
@@ -17,6 +17,7 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.javascript.jscomp.ClosurePrimitiveErrors.DUPLICATE_MODULE;
+import static com.google.javascript.jscomp.ClosurePrimitiveErrors.DUPLICATE_NAMESPACE_AND_MODULE;
 import static com.google.javascript.jscomp.ClosurePrimitiveErrors.INVALID_FORWARD_DECLARE_NAMESPACE;
 import static com.google.javascript.jscomp.ClosurePrimitiveErrors.INVALID_GET_NAMESPACE;
 import static com.google.javascript.jscomp.ClosureRewriteModule.ILLEGAL_MODULE_RENAMING_CONFLICT;
@@ -1753,6 +1754,52 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   }
 
   @Test
+  public void testExport_initializedWithVar() {
+    test(
+        // TODO(lharker): should `var exports = ...` be banned?
+        lines(
+            "goog.module('ns.a');", //
+            "/** @suppress {checkTypes} */",
+            // this statement causes a "type mismatch" error
+            "var exports = {};"),
+        lines(
+            "/** @const */ var module$exports$ns$a = {};",
+            "/** @suppress {checkTypes} */",
+            "var module$contents$ns$a_exports = {};"));
+  }
+
+  @Test
+  public void testExport_dontMangleLocalVariableNamedExports() {
+    test(
+        lines(
+            "goog.module('ns.a');",
+            "",
+            "function f(exports, a) {",
+            // test the various syntactic froms of doing goog.module exports
+            "  exports.prop = 0;",
+            "  exports = {a};",
+            "  exports = function() {};",
+            "  if (true) {",
+            "    const exports = {};",
+            "  }",
+            "  return exports;",
+            "}"),
+        lines(
+            "/** @const */",
+            "var module$exports$ns$a = {};",
+            "",
+            "function module$contents$ns$a_f(exports, a) {",
+            "  exports.prop = 0;",
+            "  exports = {a};",
+            "  exports = function() {};",
+            "  if (true) {",
+            "    const exports = {};",
+            "  }",
+            "  return exports;",
+            "}"));
+  }
+
+  @Test
   public void testExportEnhancedObjectLiteral() {
     test(
         lines("goog.module('ns.a');", "class Something {}", "exports = { Something };"),
@@ -2021,7 +2068,8 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   @Test
   public void testDuplicateNamespaceDoesntCrash() {
     // The compiler emits a warning elsewhere for this code
-    testError(srcs("goog.module('ns.a');", "goog.provide('ns.a');"), DUPLICATE_MODULE);
+    testError(
+        srcs("goog.module('ns.a');", "goog.provide('ns.a');"), DUPLICATE_NAMESPACE_AND_MODULE);
   }
 
   @Test
@@ -2559,8 +2607,7 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
             "class module$contents$client_Foo {}",
             "{",
             "  class Foo {}",
-            // TODO(b/135536377): this should remain `Foo`.
-            "  let /** !module$contents$client_Foo */ x;",
+            "  let /** !Foo */ x;",
             "}"));
   }
 
@@ -2954,7 +3001,7 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   }
 
   @Test
-  public void testTypeOfGoogRequireFromModule() {
+  public void testTypeAndSourceInfoOfGoogRequireFromModule() {
     test(
         srcs(
             lines(
@@ -2984,6 +3031,13 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
             Predicates.alwaysTrue());
 
     assertNode(moduleExportsDotBar).hasJSTypeThat().getReferenceNameIsEqualTo("mod.one.Bar");
+    // The source info for the rewritten name must match the source info for `Bar` in `new Bar();`
+    assertNode(moduleExportsDotBar)
+        .hasSourceFileName(secondScript.getSourceFileName())
+        .hasLineno(3)
+        .hasCharno(4)
+        .hasLength(3);
+    assertNode(moduleExportsDotBar.getOnlyChild()).hasEqualSourceInfoTo(moduleExportsDotBar);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
index c15f042..3f772d6 100644
--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
@@ -372,6 +372,53 @@ public final class CoalesceVariableNamesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testCoalesceVarinStaticBlock() {
+    test(
+        lines(
+            "function foo() {",
+            "   var x = 0;",
+            "   var y = 2;",
+            "   const C = class{",
+            "      static{",
+            "       print(x);",
+            "      }",
+            "   }",
+            "}"),
+        lines(
+            "function foo() {",
+            "   var x = 0;",
+            "   var y = 2;",
+            "   y = class{",
+            "     static{",
+            "      print(x);",
+            "     }",
+            "   }",
+            "}"));
+
+    test(
+        lines(
+            "function foo() {",
+            "   var x = 0;",
+            "   var y = 2;",
+            "   const C = class {",
+            "      function(){",
+            "       print(x);",
+            "      }",
+            "   }",
+            "}"),
+        lines(
+            "function foo() {",
+            "   var x = 0;",
+            "   var y = 2;",
+            "   y = class {",
+            "     function(){",
+            "      print(x);",
+            "     }",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testBug65688660() {
     test(
         lines(
@@ -996,8 +1043,9 @@ public final class CoalesceVariableNamesTest extends CompilerTestCase {
   @Test
   public void testUsePseudoNames() {
     usePseudoName = true;
-    inFunction("var x   = 0; print(x  ); var   y = 1; print(  y)",
-               "var x_y = 0; print(x_y);     x_y = 1; print(x_y)");
+    inFunction(
+        "var x   = 0; print(x  ); var   y = 1; print(  y)",
+        "var x_y = 0; print(x_y);     x_y = 1; print(x_y)");
 
     inFunction(
         "var x_y = 1; var x    = 0; print(x   ); var     y = 1; print(   y); print(x_y);",
diff --git a/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java b/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
index 84b3a9d..801da0e 100644
--- a/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
@@ -21,8 +21,6 @@ import static com.google.javascript.rhino.TypeDeclarationsIR.namedType;
 import static com.google.javascript.rhino.TypeDeclarationsIR.parameterizedType;
 
 import com.google.common.collect.ImmutableList;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -50,8 +48,7 @@ public final class CodePrinterEs6TypedTest extends CodePrinterTestBase {
                         options.setPrettyPrint(true);
                         options.setPreferLineBreakAtEndOfFile(false);
                         options.setPreferSingleQuotes(true);
-                        options.setOutputFeatureSet(
-                            FeatureSet.ES_NEXT.with(Feature.TYPE_ANNOTATION));
+                        options.setGentsMode(true);
                       }
                     }))
             .build();
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 1838479..9fa54d3 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -1977,7 +1977,7 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   }
 
   @Test
-  public void testNonJSDocCommentsPrinted_endOfFile_blockComment() {
+  public void testNonJSDocCommentsPrinted_endOfBlockComment() {
     preserveNonJSDocComments = true;
     assertPrettyPrint(
         lines(
@@ -1991,17 +1991,13 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "function f1() {\n}", //
             "if (true) {",
             "  // first",
-            "  f1();",
-            "}",
-            // The comment `/* second */` does not have an AST node to attach to
-            // that "starts" after it (the `if(true) {..}` block starts before the comment).
-            // Hence the comment gets attached to the SCRIPT node as a trailing comment and gets
-            // printed at the end.
-            " /* second */\n"));
+            "  f1(); ",
+            "  /* second */",
+            "}\n"));
   }
 
   @Test
-  public void testNonJSDocCommentsPrinted_endOfFile_manyMixedComments() {
+  public void testNonJSDocCommentsPrinted_endOfBlock_manyMixedComments() {
     preserveNonJSDocComments = true;
     assertPrettyPrint(
         lines(
@@ -2017,11 +2013,11 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "function f1() {\n}", //
             "if (true) {",
             "  // first",
-            "  f1();",
-            "}",
-            " // second",
-            "/* third */",
-            "// fourth\n"));
+            "  f1(); ",
+            "  // second",
+            "  /* third */",
+            "  // fourth",
+            "}\n"));
   }
 
   @Test
@@ -2038,11 +2034,8 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "function f1() {\n}", //
             "if (true) {",
             "  // first",
-            "  f1();",
-            "}",
-            // This is not ideal. Ideally the last comment `// second` attaches as a trailing
-            // comment of the `f1()` call.
-            " // second\n"));
+            "  f1(); // second",
+            "}\n"));
   }
 
   @Test
@@ -3222,6 +3215,8 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("function*f(){yield(a=0)}");
     assertPrintSame("function*f(){a=yield 0}");
     assertPrintSame("function*f(){(yield 1)+(yield 1)}");
+    // Parens required for evaluating arrow function expression i.e. `yield (() => expr)`
+    assertPrintSame("function*f(){yield(()=>({}))}");
   }
 
   @Test
@@ -3343,6 +3338,20 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("pwait=async promise=>await promise");
   }
 
+  /** Regression test for b/235871063 - necessary parens dropped around awaited arrow function. */
+  @Test
+  public void testParansAroudAwaitArrowFunction() {
+    // Parens required for evaluating arrow function expression i.e. `await (() => expr)`
+    assertPrint(
+        "async function f(){return await (()=>new Promise((resolve)=>setTimeout(resolve,0)));}",
+        "async function f(){return await (()=>new Promise(resolve=>setTimeout(resolve,0)))}");
+    System.out.println("--------------");
+    // Parens not required for evaluating new
+    assertPrint(
+        "async function f(){return await new Promise((resolve)=>setTimeout(resolve,0));}",
+        "async function f(){return await new Promise(resolve=>setTimeout(resolve,0))}");
+  }
+
   /**
    * Regression test for b/28633247 - necessary parens dropped around arrow functions.
    *
@@ -3488,6 +3497,113 @@ public final class CodePrinterTest extends CodePrinterTestBase {
   }
 
   @Test
+  public void testEmptyClassStaticBlock() {
+    assertPrettyPrintSame("class C {\n  static {\n  }\n}\n");
+    assertPrint("class C {\n  static {\n  }\n}\n", "class C{static{}}");
+    assertPrettyPrintSame("let a = class {\n  static {\n  }\n};\n");
+  }
+
+  @Test
+  public void testClassStaticBlock() {
+    assertPrettyPrintSame(
+        lines(
+            "class C {",
+            "  static field1=1;",
+            "  static field2=2;",
+            "  static {",
+            "    let x = this.field1;",
+            "    let y = this.field2;",
+            "  }",
+            "}",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    this.field1 = 1;",
+            "    this.field2 = 2;",
+            "  }",
+            "}",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "let a = class {",
+            "  static field1=1;",
+            "  static field2=2;",
+            "  static {",
+            "    let x = this.field1;",
+            "    let y = this.field2;",
+            "  }",
+            "};",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "let a = class {",
+            "  static {",
+            "    this.field1 = 1;",
+            "    this.field2 = 2;",
+            "  }",
+            "};",
+            ""));
+  }
+
+  @Test
+  public void testMultipleClassStaticBlocks() {
+    // empty
+    assertPrettyPrintSame("class C {\n  static {\n  }\n  static {\n  }\n}\n");
+    assertPrettyPrintSame("let a = class {\n  static {\n  }\n  static {\n  }\n};\n");
+    // multiple fields
+    assertPrettyPrintSame(
+        lines(
+            "class C {",
+            "  static field1=1;",
+            "  static field2=2;",
+            "  static {",
+            "    let x = this.field1;",
+            "  }",
+            "  static {",
+            "    let y = this.field2;",
+            "  }",
+            "}",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    this.field1 = 1;",
+            "  }",
+            "  static {",
+            "    this.field2 = 2;",
+            "  }",
+            "}",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "let a = class {",
+            "  static field1=1;",
+            "  static field2=2;",
+            "  static {",
+            "    let x = this.field1;",
+            "  }",
+            "  static {",
+            "    let y = this.field2;",
+            "  }",
+            "};",
+            ""));
+    assertPrettyPrintSame(
+        lines(
+            "let a = class {",
+            "  static {",
+            "    this.field1 = 1;",
+            "  }",
+            "  static {",
+            "    this.field2 = 2;",
+            "  }",
+            "};",
+            ""));
+  }
+
+  @Test
   public void testDeclarations() {
     assertPrintSame("let x");
     assertPrintSame("let x,y");
diff --git a/test/com/google/javascript/jscomp/CodePrinterTestBase.java b/test/com/google/javascript/jscomp/CodePrinterTestBase.java
index fe3ed27..c162321 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTestBase.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTestBase.java
@@ -24,6 +24,7 @@ import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.parsing.Config;
 import com.google.javascript.rhino.Node;
 import java.nio.charset.Charset;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /** Base class for tests that exercise {@link CodePrinter}. */
@@ -35,8 +36,8 @@ public abstract class CodePrinterTestBase {
   protected boolean preserveTypeAnnotations = false;
   protected boolean preserveNonJSDocComments = false;
   protected LanguageMode languageMode = LanguageMode.ECMASCRIPT5;
-  protected Compiler lastCompiler = null;
-  protected Charset outputCharset = null;
+  protected @Nullable Compiler lastCompiler = null;
+  protected @Nullable Charset outputCharset = null;
 
   @Before
   public void setUp() throws Exception {
diff --git a/test/com/google/javascript/jscomp/CollapsePropertiesAndModuleRewritingTest.java b/test/com/google/javascript/jscomp/CollapsePropertiesAndModuleRewritingTest.java
index 9f10fa4..8543a51 100644
--- a/test/com/google/javascript/jscomp/CollapsePropertiesAndModuleRewritingTest.java
+++ b/test/com/google/javascript/jscomp/CollapsePropertiesAndModuleRewritingTest.java
@@ -23,7 +23,6 @@ import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.modules.ModuleMapCreator;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
-import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -44,34 +43,31 @@ public class CollapsePropertiesAndModuleRewritingTest extends CompilerTestCase {
 
       @Override
       public void process(Node externs, Node root) {
-        List<PassFactory> factories = new ArrayList<>();
+        PassListBuilder factories = new PassListBuilder(options);
         GatherModuleMetadata gatherModuleMetadata =
             new GatherModuleMetadata(compiler, false, options.getModuleResolutionMode());
-        factories.add(
+        factories.maybeAdd(
             PassFactory.builder()
                 .setName(PassNames.GATHER_MODULE_METADATA)
                 .setRunInFixedPointLoop(true)
                 .setInternalFactory((x) -> gatherModuleMetadata)
-                .setFeatureSetForChecks()
                 .build());
-        factories.add(
+        factories.maybeAdd(
             PassFactory.builder()
                 .setName(PassNames.CREATE_MODULE_MAP)
                 .setRunInFixedPointLoop(true)
                 .setInternalFactory(
                     (x) -> new ModuleMapCreator(compiler, compiler.getModuleMetadataMap()))
-                .setFeatureSetForChecks()
                 .build());
         TranspilationPasses.addEs6ModulePass(
             factories, new PreprocessorSymbolTable.CachedInstanceFactory());
-        factories.add(
+        factories.maybeAdd(
             PassFactory.builder()
                 .setName("REWRITE_DYNAMIC_IMPORT")
-                .setFeatureSetForChecks()
                 .setInternalFactory(
                     (x) -> new RewriteDynamicImports(compiler, null, ChunkOutputType.ES_MODULES))
                 .build());
-        factories.add(
+        factories.maybeAdd(
             PassFactory.builder()
                 .setName(PassNames.COLLAPSE_PROPERTIES)
                 .setRunInFixedPointLoop(true)
@@ -83,10 +79,9 @@ public class CollapsePropertiesAndModuleRewritingTest extends CompilerTestCase {
                             .setHaveModulesBeenRewritten(true)
                             .setModuleResolutionMode(options.getModuleResolutionMode())
                             .build())
-                .setFeatureSetForChecks()
                 .build());
 
-        for (PassFactory factory : factories) {
+        for (PassFactory factory : factories.build()) {
           factory.create(compiler).process(externs, root);
         }
       }
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index ca66449..605cf7d 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -30,9 +30,13 @@ import com.google.common.base.Joiner;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.io.Files;
+import com.google.gson.Gson;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
 import com.google.javascript.jscomp.AbstractCommandLineRunner.FlagEntry;
 import com.google.javascript.jscomp.AbstractCommandLineRunner.JsSourceType;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
@@ -57,6 +61,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -68,18 +73,19 @@ import org.junit.runners.JUnit4;
 /** Tests for {@link CommandLineRunner}. */
 @RunWith(JUnit4.class)
 public final class CommandLineRunnerTest {
+  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
   private static final Joiner LINE_JOINER = Joiner.on('\n');
 
-  private Compiler lastCompiler = null;
-  private CommandLineRunner lastCommandLineRunner = null;
-  private List<Integer> exitCodes = null;
-  private ByteArrayOutputStream outReader = null;
-  private ByteArrayOutputStream errReader = null;
+  private @Nullable Compiler lastCompiler = null;
+  private @Nullable CommandLineRunner lastCommandLineRunner = null;
+  private @Nullable List<Integer> exitCodes = null;
+  private @Nullable ByteArrayOutputStream outReader = null;
+  private @Nullable ByteArrayOutputStream errReader = null;
   private Map<Integer, String> filenames;
 
   // If set, this will be appended to the end of the args list.
   // For testing args parsing.
-  private String lastArg = null;
+  private @Nullable String lastArg = null;
 
   // If set to true, uses comparison by string instead of by AST.
   private boolean useStringComparison = false;
@@ -136,7 +142,7 @@ public final class CommandLineRunnerTest {
                       "/** @param {...*} x */ function alert(x) {}",
                       "function Symbol() {}")));
 
-  private List<SourceFile> externs;
+  private ImmutableList<SourceFile> externs;
 
   @Before
   public void setUp() throws Exception {
@@ -153,12 +159,38 @@ public final class CommandLineRunnerTest {
   }
 
   @Test
+  public void testStage1ErrorExitStatus() throws Exception {
+    // Create an input file
+    File srcFile = temporaryFolder.newFile("input.js");
+    writeLinesToFile(
+        srcFile,
+        // Intentionally incorrect type to generate a compiler error
+        "/** @type {undefined} */",
+        "const x = 1;");
+
+    // Create a path for the stage 1 output
+    File stage1Save = temporaryFolder.newFile("stage1.save");
+
+    ImmutableList<String> commonFlags =
+        ImmutableList.of("--jscomp_error=checkTypes", "--js", srcFile.toString());
+
+    // Run the compiler to generate the stage 1 save file
+    final ImmutableList<String> stage1Flags =
+        createStringList(
+            commonFlags, new String[] {"--save_stage1_to_file", stage1Save.toString()});
+    CommandLineRunner runner =
+        new CommandLineRunner(
+            stringListToArray(stage1Flags), new PrintStream(outReader), new PrintStream(errReader));
+    // Expect an exit status of 1 because there is one error.
+    assertThat(runner.doRun()).isEqualTo(1);
+    assertThat(new String(outReader.toByteArray(), UTF_8)).isEmpty();
+  }
+
+  @Test
   public void test3StageCompile() throws Exception {
-    // Create a temporary directory to hold inputs and outputs
-    final File testDir = java.nio.file.Files.createTempDirectory("testDir").toFile();
 
     // Create a message bundle to use
-    File msgBundle = new File(testDir, "messages.xtb");
+    File msgBundle = temporaryFolder.newFile("messages.xtb");
     final ImmutableList<String> lines =
         ImmutableList.of(
             "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
@@ -170,7 +202,7 @@ public final class CommandLineRunnerTest {
     writeLinesToFile(msgBundle, lines);
 
     // Create test externs with a definition for goog.getMsg().
-    final File externsFile = new File(testDir, "externs.js");
+    final File externsFile = temporaryFolder.newFile("externs.js");
     writeLinesToFile(
         externsFile,
         "/**",
@@ -188,7 +220,7 @@ public final class CommandLineRunnerTest {
         "goog.getMsg = function(msg, placeholderReplacements, options) {};");
 
     // Create an input file
-    File srcFile = new File(testDir, "input.js");
+    File srcFile = temporaryFolder.newFile("input.js");
     writeLinesToFile(
         srcFile,
         "/** @desc greeting */",
@@ -196,11 +228,12 @@ public final class CommandLineRunnerTest {
         "console.log(MSG_HELLO);");
 
     // Create a path for the stage 1 output
-    File stage1Save = new File(testDir, "stage1.save");
+    File stage1Save = temporaryFolder.newFile("stage1.save");
 
     ImmutableList<String> commonFlags =
         ImmutableList.of(
             "--compilation_level=ADVANCED_OPTIMIZATIONS",
+            "--source_map_include_content",
             "--translations_file",
             msgBundle.toString(),
             "--js",
@@ -213,14 +246,17 @@ public final class CommandLineRunnerTest {
         createStringList(
             commonFlags, new String[] {"--save_stage1_to_file", stage1Save.toString()});
     verifyFlagsAreIncompatibleWithChecksOnly(stage1Flags);
-    CommandLineRunner runner = new CommandLineRunner(stringListToArray(stage1Flags));
+    CommandLineRunner runner =
+        new CommandLineRunner(
+            stringListToArray(stage1Flags), new PrintStream(outReader), new PrintStream(errReader));
     assertThat(runner.doRun()).isEqualTo(0);
+    assertThat(new String(outReader.toByteArray(), UTF_8)).isEmpty();
 
     assertThat(runner.getCompiler().toSource())
         .isEqualTo("const MSG_HELLO=goog.getMsg(\"hello\");console.log(MSG_HELLO);");
 
     // Create a path for the stage 2 output
-    File stage2Save = new File(testDir, "stage2.save");
+    File stage2Save = temporaryFolder.newFile("stage2.save");
     // run the compiler to generate the stage 2 save file
     final ImmutableList<String> stage2Flags =
         createStringList(
@@ -245,7 +281,9 @@ public final class CommandLineRunnerTest {
                 ");"));
 
     // Create a path for the final output
-    File compiledFile = new File(testDir, "compiled.js");
+    File compiledFile = temporaryFolder.newFile("compiled.js");
+    // Create a path for the output source map
+    File sourceMapFile = temporaryFolder.newFile("compiled.sourcemap");
 
     // run the compiler to generate the final output
     final ImmutableList<String> stage3Flags =
@@ -255,7 +293,9 @@ public final class CommandLineRunnerTest {
               "--restore_stage2_from_file",
               stage2Save.toString(),
               "--js_output_file",
-              compiledFile.toString()
+              compiledFile.toString(),
+              "--create_source_map",
+              sourceMapFile.toString()
             });
     verifyFlagsAreIncompatibleWithChecksOnly(stage3Flags);
     runner = new CommandLineRunner(stringListToArray(stage3Flags));
@@ -263,9 +303,32 @@ public final class CommandLineRunnerTest {
 
     // During stage 3 the message is actually replaced and the output written to the compiled
     // output file.
-    final String compiledJs =
-        new String(java.nio.file.Files.readAllBytes(compiledFile.toPath()), UTF_8);
+    final String compiledJs = java.nio.file.Files.readString(compiledFile.toPath());
     assertThat(compiledJs).isEqualTo("console.log(\"hola\");\n");
+
+    final JsonObject expectedSourceMap = new JsonObject();
+    expectedSourceMap.addProperty("version", 3);
+    expectedSourceMap.addProperty("file", compiledFile.getAbsolutePath());
+    expectedSourceMap.addProperty("lineCount", 1);
+    expectedSourceMap.addProperty("mappings", "AAEAA,OAAQC,CAAAA,GAAR,CADkBC,MAClB;");
+    expectedSourceMap.add("sources", newJsonArrayOfStrings(srcFile.getAbsolutePath()));
+    expectedSourceMap.add(
+        "sourcesContent", newJsonArrayOfStrings(java.nio.file.Files.readString(srcFile.toPath())));
+    expectedSourceMap.add("names", newJsonArrayOfStrings("console", "log", "MSG_HELLO"));
+
+    final String sourceMapText = java.nio.file.Files.readString(sourceMapFile.toPath());
+    JsonObject actualSourceMap = getJsonObjectFromJson(sourceMapText);
+    assertThat(actualSourceMap).isEqualTo(expectedSourceMap);
+  }
+
+  private static final Gson GSON = new Gson();
+
+  private JsonArray newJsonArrayOfStrings(String... strings) {
+    return GSON.toJsonTree(strings).getAsJsonArray();
+  }
+
+  private JsonObject getJsonObjectFromJson(String json) {
+    return GSON.fromJson(json, JsonObject.class);
   }
 
   /** The given flags should be incompatible with `--checks_only`. */
@@ -278,7 +341,7 @@ public final class CommandLineRunnerTest {
     final ImmutableList<String> combinedFlags =
         ImmutableList.<String>builder().addAll(flags).add(additionalFlag).build();
     CommandLineRunner checksOnlyRunner = new CommandLineRunner(stringListToArray(combinedFlags));
-    assertThrows(FlagUsageException.class, () -> checksOnlyRunner.doRun());
+    assertThrows(FlagUsageException.class, checksOnlyRunner::doRun);
   }
 
   private String[] stringListToArray(ImmutableList<String> stringList) {
@@ -1650,7 +1713,7 @@ public final class CommandLineRunnerTest {
     args.add("--source_map_input=input2|input2.sourcemap");
     testSame("var x = 3;");
 
-    Map<String, SourceMapInput> inputMaps = lastCompiler.getOptions().inputSourceMaps;
+    ImmutableMap<String, SourceMapInput> inputMaps = lastCompiler.getOptions().inputSourceMaps;
     assertThat(inputMaps).hasSize(2);
     assertThat(inputMaps.get("input1").getOriginalPath()).isEqualTo("input1.sourcemap");
     assertThat(inputMaps.get("input2").getOriginalPath()).isEqualTo("input2.sourcemap");
@@ -2995,6 +3058,15 @@ public final class CommandLineRunnerTest {
     assertThat(lastCompiler.getOptions().getIsolatePolyfills()).isTrue();
   }
 
+  @Test
+  public void testCrossChunkCodeMotionNoStubMethods() {
+    testSame("");
+    assertThat(lastCompiler.getOptions().crossChunkCodeMotionNoStubMethods).isFalse();
+    args.add("--assume_no_prototype_method_enumeration=true");
+    testSame("");
+    assertThat(lastCompiler.getOptions().crossChunkCodeMotionNoStubMethods).isTrue();
+  }
+
   /* Helper functions */
 
   private void testSame(String original) {
@@ -3022,7 +3094,7 @@ public final class CommandLineRunnerTest {
    * into {@code compiled}. If {@code warning} is non-null, we will also check if the given warning
    * type was emitted.
    */
-  private void test(String[] original, String[] compiled, DiagnosticType warning) {
+  private void test(String[] original, String[] compiled, @Nullable DiagnosticType warning) {
     exitCodes.clear();
     Compiler compiler = compile(original);
 
@@ -3181,7 +3253,7 @@ public final class CommandLineRunnerTest {
     compileArgs(expectedOutput, null);
   }
 
-  private void compileArgs(String expectedOutput, DiagnosticType expectedError) {
+  private void compileArgs(String expectedOutput, @Nullable DiagnosticType expectedError) {
     String[] argStrings = args.toArray(new String[] {});
 
     CommandLineRunner runner =
@@ -3234,22 +3306,24 @@ public final class CommandLineRunnerTest {
     Supplier<List<SourceFile>> inputsSupplier = null;
     Supplier<List<JSChunk>> modulesSupplier = null;
 
-    if (useModules == ModulePattern.NONE) {
-      List<SourceFile> inputs = new ArrayList<>();
-      for (int i = 0; i < original.length; i++) {
-        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));
-      }
-      inputsSupplier = Suppliers.ofInstance(inputs);
-    } else if (useModules == ModulePattern.STAR) {
-      modulesSupplier =
-          Suppliers.<List<JSChunk>>ofInstance(
-              ImmutableList.copyOf(JSChunkGraphBuilder.forStar().addChunks(original).build()));
-    } else if (useModules == ModulePattern.CHAIN) {
-      modulesSupplier =
-          Suppliers.<List<JSChunk>>ofInstance(
-              ImmutableList.copyOf(JSChunkGraphBuilder.forChain().addChunks(original).build()));
-    } else {
-      throw new IllegalArgumentException("Unknown module type: " + useModules);
+    switch (useModules) {
+      case NONE:
+        List<SourceFile> inputs = new ArrayList<>();
+        for (int i = 0; i < original.length; i++) {
+          inputs.add(SourceFile.fromCode(getFilename(i), original[i]));
+        }
+        inputsSupplier = Suppliers.ofInstance(inputs);
+        break;
+      case STAR:
+        modulesSupplier =
+            Suppliers.<List<JSChunk>>ofInstance(
+                ImmutableList.copyOf(JSChunkGraphBuilder.forStar().addChunks(original).build()));
+        break;
+      case CHAIN:
+        modulesSupplier =
+            Suppliers.<List<JSChunk>>ofInstance(
+                ImmutableList.copyOf(JSChunkGraphBuilder.forChain().addChunks(original).build()));
+        break;
     }
 
     runner.enableTestMode(
diff --git a/test/com/google/javascript/jscomp/CompilerOptionsTest.java b/test/com/google/javascript/jscomp/CompilerOptionsTest.java
index e03d67c..026b97b 100644
--- a/test/com/google/javascript/jscomp/CompilerOptionsTest.java
+++ b/test/com/google/javascript/jscomp/CompilerOptionsTest.java
@@ -19,13 +19,13 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
+import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.util.Map;
 import java.util.regex.Pattern;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -64,7 +64,7 @@ public final class CompilerOptionsTest {
     options.setDefineToNumberLiteral("threeVar", 3);
     options.setDefineToStringLiteral("strVar", "str");
 
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
     assertEquivalent(new Node(Token.TRUE), actual.get("trueVar"));
     assertEquivalent(new Node(Token.FALSE), actual.get("falseVar"));
     assertEquivalent(Node.newNumber(3), actual.get("threeVar"));
@@ -117,7 +117,7 @@ public final class CompilerOptionsTest {
     options =
         CompilerOptions.deserialize(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));
 
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
     assertEquivalent(new Node(Token.TRUE), actual.get("trueVar"));
     assertEquivalent(new Node(Token.FALSE), actual.get("falseVar"));
     assertEquivalent(Node.newNumber(3), actual.get("threeVar"));
diff --git a/test/com/google/javascript/jscomp/CompilerTest.java b/test/com/google/javascript/jscomp/CompilerTest.java
index 6777982..ff42ed0 100644
--- a/test/com/google/javascript/jscomp/CompilerTest.java
+++ b/test/com/google/javascript/jscomp/CompilerTest.java
@@ -66,6 +66,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -111,7 +112,7 @@ public final class CompilerTest {
 
   @Test
   public void testCyclicalDependencyInInputs() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("gin", "goog.provide('gin'); goog.require('tonic'); var gin = {};"),
             SourceFile.fromCode(
@@ -134,7 +135,7 @@ public final class CompilerTest {
 
   @Test
   public void testPrintExterns() {
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(SourceFile.fromCode("extern", "/** @externs */ function alert(x) {}"));
     CompilerOptions options = new CompilerOptions();
     options.setPreserveTypeAnnotations(true);
@@ -180,7 +181,7 @@ public final class CompilerTest {
                 normalize("../original/source.html"),
                 originalSourcePosition));
     String origSourceName = normalize("original/source.html");
-    List<SourceFile> originalSources =
+    ImmutableList<SourceFile> originalSources =
         ImmutableList.of(SourceFile.fromCode(origSourceName, "<div ng-show='foo()'>"));
 
     CompilerOptions options = new CompilerOptions();
@@ -373,7 +374,7 @@ public final class CompilerTest {
 
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT3);
-    options.sourceMapOutputPath = "fake/source_map_path.js.map";
+    options.setSourceMapOutputPath("fake/source_map_path.js.map");
     options.inputSourceMaps = inputSourceMaps;
     options.applyInputSourceMaps = true;
     Compiler compiler = new Compiler();
@@ -402,7 +403,7 @@ public final class CompilerTest {
   public void testKeepInputSourceMapsSourcesContent() throws Exception {
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT3);
-    options.sourceMapOutputPath = "fake/source_map_path.js.map";
+    options.setSourceMapOutputPath("fake/source_map_path.js.map");
     options.applyInputSourceMaps = true;
     options.sourceMapIncludeSourcesContent = true;
     String code =
@@ -450,7 +451,7 @@ public final class CompilerTest {
     options.setPrintInputDelimiter(true);
 
     String fileOverview = "/** @fileoverview Foo */";
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(SourceFile.fromCode("i1", ""), SourceFile.fromCode("i2", fileOverview));
 
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -515,7 +516,7 @@ public final class CompilerTest {
   public void testNormalInputs() {
     CompilerOptions options = new CompilerOptions();
     Compiler compiler = new Compiler();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(SourceFile.fromCode("in1", ""), SourceFile.fromCode("in2", ""));
     compiler.compile(EMPTY_EXTERNS, inputs, options);
 
@@ -526,7 +527,7 @@ public final class CompilerTest {
 
   @Test
   public void testRebuildInputsFromModule() {
-    List<JSChunk> modules = ImmutableList.of(new JSChunk("m1"), new JSChunk("m2"));
+    ImmutableList<JSChunk> modules = ImmutableList.of(new JSChunk("m1"), new JSChunk("m2"));
     modules.get(0).add(SourceFile.fromCode("in1", ""));
     modules.get(1).add(SourceFile.fromCode("in2", ""));
 
@@ -564,7 +565,7 @@ public final class CompilerTest {
 
   @Test
   public void testFileoverviewTwice() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode("foo", "/** @fileoverview */ var x; /** @fileoverview */ var y;"));
     assertThat(new Compiler().compile(EMPTY_EXTERNS, input, new CompilerOptions()).success)
@@ -583,7 +584,7 @@ public final class CompilerTest {
   // Make sure we output license text even if followed by @fileoverview.
   @Test
   public void testImportantCommentAndOverviewDirectiveWarning() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode(
                 "foo",
@@ -683,7 +684,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -700,7 +701,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -721,7 +722,7 @@ public final class CompilerTest {
   // Make sure we output license text even if followed by @fileoverview.
   @Test
   public void testLicenseAndOverviewDirectiveWarning() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode(
                 "foo",
@@ -820,7 +821,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -841,7 +842,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1),
             SourceFile.fromCode("testcode2", js2),
@@ -860,7 +861,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -878,10 +879,10 @@ public final class CompilerTest {
 
   @Test
   public void testDefineOverriding1() {
-    List<String> defines =
+    ImmutableList<String> defines =
         ImmutableList.of(
             "COMPILED", "DEF_TRUE=true", "DEF_FALSE=false", "DEF_NUMBER=5.5", "DEF_STRING='bye'");
-    Map<String, Node> expected =
+    ImmutableMap<String, Node> expected =
         ImmutableMap.of(
             "COMPILED", new Node(Token.TRUE),
             "DEF_TRUE", new Node(Token.TRUE),
@@ -893,33 +894,33 @@ public final class CompilerTest {
 
   @Test
   public void testDefineOverriding2() {
-    List<String> defines = ImmutableList.of("DEF_STRING='='");
-    Map<String, Node> expected = ImmutableMap.of("DEF_STRING", Node.newString("="));
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING='='");
+    ImmutableMap<String, Node> expected = ImmutableMap.of("DEF_STRING", Node.newString("="));
     assertDefineOverrides(expected, defines);
   }
 
   @Test
   public void testDefineOverriding3() {
-    List<String> defines = ImmutableList.of("a.DEBUG");
-    Map<String, Node> expected = ImmutableMap.of("a.DEBUG", new Node(Token.TRUE));
+    ImmutableList<String> defines = ImmutableList.of("a.DEBUG");
+    ImmutableMap<String, Node> expected = ImmutableMap.of("a.DEBUG", new Node(Token.TRUE));
     assertDefineOverrides(expected, defines);
   }
 
   @Test
   public void testBadDefineOverriding1() {
-    List<String> defines = ImmutableList.of("DEF_STRING=");
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING=");
     assertCreateDefinesThrowsException(defines);
   }
 
   @Test
   public void testBadDefineOverriding2() {
-    List<String> defines = ImmutableList.of("=true");
+    ImmutableList<String> defines = ImmutableList.of("=true");
     assertCreateDefinesThrowsException(defines);
   }
 
   @Test
   public void testBadDefineOverriding3() {
-    List<String> defines = ImmutableList.of("DEF_STRING='''");
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING='''");
     assertCreateDefinesThrowsException(defines);
   }
 
@@ -937,7 +938,7 @@ public final class CompilerTest {
   static void assertDefineOverrides(Map<String, Node> expected, List<String> defines) {
     CompilerOptions options = new CompilerOptions();
     AbstractCommandLineRunner.createDefineReplacements(defines, options);
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
 
     // equality of nodes compares by reference, so instead,
     // compare the maps manually using Node.checkTreeEqualsSilent
@@ -952,10 +953,10 @@ public final class CompilerTest {
     }
   }
 
-  static Result test(String js, String expected, DiagnosticType error) {
+  static Result test(String js, String expected, @Nullable DiagnosticType error) {
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     if (error == null) {
@@ -996,24 +997,6 @@ public final class CompilerTest {
   }
 
   @Test
-  public void testErrorLeveling_forFeaturesNotSupportedByPass_controlledByOptions() {
-    JSError error = JSError.make(PhaseOptimizer.FEATURES_NOT_SUPPORTED_BY_PASS, "");
-    CompilerOptions options = new CompilerOptions();
-    Compiler compiler = new Compiler();
-
-    compiler.initOptions(options);
-    assertThat(compiler.getErrorLevel(error)).isNull();
-
-    options.setSkipUnsupportedPasses(false);
-    compiler.initOptions(options);
-    assertThat(compiler.getErrorLevel(error)).isNull();
-
-    options.setSkipUnsupportedPasses(true);
-    compiler.initOptions(options);
-    assertThat(compiler.getErrorLevel(error)).isEqualTo(CheckLevel.WARNING);
-  }
-
-  @Test
   public void testExportSymbolReservesNamesForRenameVars() {
     Compiler compiler = new Compiler();
     CompilerOptions options = new CompilerOptions();
@@ -1022,7 +1005,7 @@ public final class CompilerTest {
     options.setVariableRenaming(VariableRenamingPolicy.ALL);
 
     String js = "var goog, x; goog.exportSymbol('a', x);";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(result.success).isTrue();
@@ -1039,7 +1022,7 @@ public final class CompilerTest {
     options.setGenerateExports(true);
 
     String js = "var goog; /** @export */ var a={};";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(result.success).isTrue();
@@ -1098,7 +1081,7 @@ public final class CompilerTest {
     }
   }
 
-  private boolean hasOutput(String showWarningsOnlyFor, String path, CheckLevel level) {
+  private boolean hasOutput(@Nullable String showWarningsOnlyFor, String path, CheckLevel level) {
     TestErrorManager errorManager = new TestErrorManager();
     Compiler compiler = new Compiler(errorManager);
     CompilerOptions options = createNewFlagBasedOptions();
@@ -1140,7 +1123,7 @@ public final class CompilerTest {
         });
 
     String js = "var x = 1;";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(before[0]).isTrue(); // should run these custom passes
@@ -1161,7 +1144,7 @@ public final class CompilerTest {
 
   @Test
   public void testExternsDependencySorting() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("leaf", "/** @fileoverview @typeSummary */ goog.require('beer');"),
             SourceFile.fromCode(
@@ -1172,7 +1155,7 @@ public final class CompilerTest {
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.sortOnly());
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
 
@@ -1311,6 +1294,216 @@ public final class CompilerTest {
     assertThat(source).isEqualTo("console.log(Error(\"a\"),\"hello\");");
   }
 
+  private static final String RESULT_SOURCE_MAP_WITH_CONTENT =
+      lines(
+          "{",
+          "\"version\":3,",
+          "\"file\":\"output.js\",",
+          "\"lineCount\":1,",
+          "\"mappings\":\"AAQAA,OAAQC,CAAAA,GAAR,CAAY,IALVC,QAAA,EAAyB,EAKf,CAAM,CAAN,CAAZ;\",",
+          "\"sources\":[\"../test/foo.ts\"],",
+          "\"sourcesContent\":[\"var A = (function () {\\n"
+              + "    function A(input) {\\n"
+              + "        this.a = input;\\n"
+              + "    }\\n"
+              + "    return A;\\n"
+              + "}());\\n"
+              + "console.log(new A(1));\"],",
+          "\"names\":[\"console\",\"log\",\"X\"]",
+          "}\n");
+
+  @Test
+  public void testCheckSaveRestore3StagesSourceMaps() throws Exception {
+    Compiler compiler = new Compiler(new TestErrorManager());
+
+    CompilerOptions options = new CompilerOptions();
+    options.setAssumeForwardDeclaredForMissingTypes(true);
+    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
+    options.setCheckTypes(true);
+    options.setStrictModeInput(true);
+    options.setEmitUseStrict(false);
+    options.setPreserveDetailedSourceInfo(true);
+    // 3-stage builds require late localization
+    options.setDoLateLocalization(true);
+    // For stages 1 and 2 we generally expect no source map output path to be set,
+    // since it won't actually be generated until compilation is completed in
+    // stage 3.
+    options.setSourceMapOutputPath(null);
+    // The code that is running the compiler is expected to set this option
+    // when executing a partial compilation and it expects to request source
+    // maps when running the final stage later.
+    options.setAlwaysGatherSourceMapInfo(true);
+    options.applyInputSourceMaps = true;
+    options.setSourceMapIncludeSourcesContent(true);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    List<SourceFile> externs =
+        Collections.singletonList(
+            SourceFile.fromCode(
+                "externs.js",
+                lines(
+                    "var console = {};", //
+                    " console.log = function() {};",
+                    "")));
+    List<SourceFile> srcs =
+        Collections.singletonList(
+            SourceFile.fromCode(
+                "input.js",
+                SOURCE_MAP_TEST_CODE
+                    + "\n//# sourceMappingURL="
+                    + BASE64_ENCODED_SOURCE_MAP_WITH_CONTENT));
+
+    // Stage 1
+    compiler.init(externs, srcs, options);
+    compiler.parse();
+    compiler.check();
+    final byte[] stateAfterChecks = getSavedCompilerState(compiler);
+
+    // Stage 2
+    compiler = new Compiler(new TestErrorManager());
+    compiler.init(externs, srcs, options);
+    restoreCompilerState(compiler, stateAfterChecks);
+    compiler.performTranspilationAndOptimizations();
+
+    String source = compiler.toSource();
+    assertThat(source).isEqualTo("console.log(new function(){}(1));");
+
+    final byte[] stateAfterOptimizations = getSavedCompilerState(compiler);
+
+    // Stage 3
+    compiler = new Compiler(new TestErrorManager());
+    // In general the options passed to the compiler should be the same for all
+    // 3 stages. The source map output path is an exception.
+    // It only makes sense to specify it for the final stage when the output
+    // file will actually be generated.
+    // The name passed here doesn't matter, because the compiler itself only stores it and enables
+    // tracking of source map information when it is non-null.
+    // In real usage AbstractCommandLineRunner is responsible for actually writing the file whose
+    // path is stored in this field.
+    options.setSourceMapOutputPath("dummy");
+    // The code that is running the compiler is expected to set this option
+    // to false when executing the final stage, so no time and space will
+    // be wasted on generating source maps if the source map output path is null.
+    options.setAlwaysGatherSourceMapInfo(false);
+    compiler.init(externs, srcs, options);
+    restoreCompilerState(compiler, stateAfterOptimizations);
+    compiler.performFinalizations();
+    final Result result = compiler.getResult();
+
+    source = compiler.toSource();
+    assertThat(source).isEqualTo("console.log(new function(){}(1));");
+
+    final SourceMap sourceMap = result.sourceMap;
+    assertThat(sourceMap).isNotNull();
+
+    // Check sourcemap output
+    final StringBuilder sourceMapStringBuilder = new StringBuilder();
+    final String outputJSFile = "output.js";
+    sourceMap.appendTo(sourceMapStringBuilder, outputJSFile);
+    final String sourceMapString = sourceMapStringBuilder.toString();
+    assertThat(sourceMapString).isEqualTo(RESULT_SOURCE_MAP_WITH_CONTENT);
+  }
+
+  @Test
+  public void testSingleStageCompileSourceMaps() throws Exception {
+    Compiler compiler = new Compiler(new TestErrorManager());
+
+    CompilerOptions options = new CompilerOptions();
+    options.setAssumeForwardDeclaredForMissingTypes(true);
+    options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
+    options.setCheckTypes(true);
+    options.setStrictModeInput(true);
+    options.setEmitUseStrict(false);
+    options.setPreserveDetailedSourceInfo(true);
+    // The name passed here doesn't matter, because the compiler itself only stores it and enables
+    // tracking of source map information when it is non-null.
+    // In real usage AbstractCommandLineRunner is responsible for actually writing the file whose
+    // path is stored in this field.
+    options.setSourceMapOutputPath("dummy");
+    options.applyInputSourceMaps = true;
+    options.setSourceMapIncludeSourcesContent(true);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    List<SourceFile> externs =
+        Collections.singletonList(
+            SourceFile.fromCode(
+                "externs.js",
+                lines(
+                    "var console = {};", //
+                    " console.log = function() {};",
+                    "")));
+    List<SourceFile> srcs =
+        Collections.singletonList(
+            SourceFile.fromCode(
+                "input.js",
+                SOURCE_MAP_TEST_CODE
+                    + "\n//# sourceMappingURL="
+                    + BASE64_ENCODED_SOURCE_MAP_WITH_CONTENT));
+    compiler.init(externs, srcs, options);
+
+    compiler.parse();
+    compiler.check();
+    compiler.performTranspilationAndOptimizations();
+    compiler.performFinalizations();
+
+    final Result result = compiler.getResult();
+
+    String source = compiler.toSource();
+    assertThat(source).isEqualTo("console.log(new function(){}(1));");
+
+    final SourceMap sourceMap = result.sourceMap;
+    assertThat(sourceMap).isNotNull();
+
+    // Check sourcemap output
+    final StringBuilder sourceMapStringBuilder = new StringBuilder();
+    final String outputJSFile = "output.js";
+    sourceMap.appendTo(sourceMapStringBuilder, outputJSFile);
+    final String sourceMapString = sourceMapStringBuilder.toString();
+    assertThat(sourceMapString).isEqualTo(RESULT_SOURCE_MAP_WITH_CONTENT);
+  }
+
+  @Test
+  public void testCheckSaveRestore3StagesNoInputFiles() throws Exception {
+    // There's an edge case where a chunk may be empty.
+    // The compiler covers this weird case by adding a special "fillFile" into empty chunks.
+    // This makes the logic in passes like CrossChunkCodeMotion easier.
+    // However, we also need to drop the phony "fillFiles" in several cases.
+    // One of those cases is serialization.
+    // This can lead to an odd situation where deserialization doesn't see a SourceFile
+    // for one of these "fillFiles".
+    // This led to a NullPointerException in the past.
+    // This test case exists to test the fix for that.
+    Compiler compiler = new Compiler(new TestErrorManager());
+
+    CompilerOptions options = new CompilerOptions();
+    // Late localization happens in stage 3, so this forces stage 3 to actually have some
+    // effect on the AST.
+    options.setDoLateLocalization(true);
+
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    ImmutableList<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> srcs = ImmutableList.of();
+    compiler.init(externs, srcs, options);
+
+    compiler.parse();
+    compiler.check();
+    final CompilerInput onlyInputBeforeSave =
+        getOnlyElement(compiler.getModuleGraph().getAllInputs());
+    // this is the special name used for a single fill file when there are no inputs
+    assertThat(onlyInputBeforeSave.getName()).isEqualTo("$strong$$fillFile");
+
+    final byte[] stateAfterChecks = getSavedCompilerState(compiler);
+
+    compiler = new Compiler(new TestErrorManager());
+    compiler.init(externs, srcs, options);
+    restoreCompilerState(compiler, stateAfterChecks);
+
+    // The fillFile is still listed as the only input
+    final CompilerInput onlyInputAfterRestore =
+        getOnlyElement(compiler.getModuleGraph().getAllInputs());
+    assertThat(onlyInputAfterRestore.getName()).isEqualTo("$strong$$fillFile");
+  }
+
   private String concatStrings(String... strings) {
     return stream(strings).collect(joining());
   }
@@ -1499,7 +1692,7 @@ public final class CompilerTest {
 
   @Test
   public void testExternsDependencyPruning() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "unused", "/** @fileoverview @typeSummary */ goog.provide('unused');"),
@@ -1511,7 +1704,7 @@ public final class CompilerTest {
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(ImmutableList.of()));
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
 
@@ -1529,7 +1722,7 @@ public final class CompilerTest {
   // https://github.com/google/closure-compiler/issues/2692
   @Test
   public void testGoogNamespaceEntryPoint() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/index.js",
@@ -1541,15 +1734,15 @@ public final class CompilerTest {
                     "foo('hello');")),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(ModuleIdentifier.forClosure("goog:foobar"));
 
     CompilerOptions options = createNewFlagBasedOptions();
-    options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT_2017);
-    options.setLanguageOut(CompilerOptions.LanguageMode.ECMASCRIPT5);
+    options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(entryPoints));
     options.setProcessCommonJSModules(true);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addAlert().buildExternsFile("default_externs.js"));
 
@@ -1565,16 +1758,17 @@ public final class CompilerTest {
   public void testEs6ModulePathWithOddCharacters() throws Exception {
     // Note that this is not yet compatible with transpilation, since the generated goog.provide
     // statements are not valid identifiers.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index[0].js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(entryPoints));
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addAlert().buildExternsFile("default_externs.js"));
 
@@ -1590,18 +1784,19 @@ public final class CompilerTest {
     // Test that you can specify externs as entry points.
     // This allows all inputs to be passed to the compiler under the --js flag,
     // relying on dependency management to sort out which ones are externs or weak files
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(0);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1617,18 +1812,19 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint2() throws Exception {
     // Test code reference to an extern that doesn't exist,
     // but the extern is still the sole entry point.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(nonexistentExtern);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1644,20 +1840,20 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint3() throws Exception {
     // Test code reference to an extern that doesn't exist,
     // but the extern and source files are both entry points
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(nonexistentExtern);"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(
             ModuleIdentifier.forFile("/externs.js"), ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1673,20 +1869,20 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint4() throws Exception {
     // Test that has a code reference to an extern that does exist,
     // and the extern and source files are both entry points
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(bar);"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(
             ModuleIdentifier.forFile("/externs.js"), ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1702,18 +1898,19 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint5() throws Exception {
     // Test that has a code reference to an extern that does exist,
     // and only the source source file is an entry point
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(bar);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/foo.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1728,19 +1925,20 @@ public final class CompilerTest {
   @Test
   public void testWeakExternsFileAsEntryPointNoError() throws Exception {
     // Test that if a weak extern file is passed in as entry point, there is no error thrown.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js",
                 "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;",
                 SourceKind.WEAK));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
@@ -2013,7 +2211,7 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, ImmutableList.copyOf(sources), options);
@@ -2057,7 +2255,7 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, sources.build(), options);
@@ -2102,10 +2300,10 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneLegacyForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     for (int iterationCount = 0; iterationCount < 10; iterationCount++) {
-      java.util.Collections.shuffle(sources);
+      Collections.shuffle(sources);
       Compiler compiler = new Compiler();
       Result result = compiler.compile(externs, ImmutableList.copyOf(sources), options);
       assertThat(result.success).isTrue();
@@ -2150,7 +2348,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2195,7 +2393,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2239,7 +2437,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2257,9 +2455,9 @@ public final class CompilerTest {
 
   @Test
   public void testCodeReferenceToTypeImport() throws Exception {
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(SourceFile.fromCode("extern.js", "/** @externs */ function alert(x) {}"));
-    List<SourceFile> sources =
+    ImmutableList<SourceFile> sources =
         ImmutableList.of(
             SourceFile.fromCode(
                 "type.js",
@@ -2293,7 +2491,7 @@ public final class CompilerTest {
 
   @Test
   public void testWeakSources() throws Exception {
-    List<SourceFile> sources =
+    ImmutableList<SourceFile> sources =
         ImmutableList.of(
             SourceFile.fromCode("weak1.js", "goog.provide('a');", SourceKind.WEAK),
             SourceFile.fromCode("strong1.js", "goog.provide('a.b');", SourceKind.STRONG),
@@ -2739,7 +2937,7 @@ public final class CompilerTest {
     options.setCheckTypes(false);
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
@@ -2766,7 +2964,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
@@ -2796,7 +2994,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 1b150a7..c2e00ff 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -29,6 +29,7 @@ import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.truth.Correspondence;
 import com.google.errorprone.annotations.ForOverride;
@@ -36,7 +37,6 @@ import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import com.google.javascript.jscomp.AccessorSummary.PropertyAccessKind;
 import com.google.javascript.jscomp.AstValidator.TypeInfoValidation;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.modules.ModuleMapCreator;
 import com.google.javascript.jscomp.parsing.Config.JsDocParsing;
@@ -59,7 +59,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Function;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /**
@@ -170,7 +170,7 @@ public abstract class CompilerTestCase {
   private boolean expectParseWarningsInThisTest;
 
   /** An expected symbol table error. Only useful for testing the symbol table error-handling. */
-  private DiagnosticType expectedSymbolTableError;
+  private @Nullable DiagnosticType expectedSymbolTableError;
 
   /** Whether the PureFunctionIdentifier pass runs before the pass being tested */
   private boolean computeSideEffects;
@@ -193,10 +193,10 @@ public abstract class CompilerTestCase {
 
   private LanguageMode languageOut;
 
-  private Integer browserFeaturesetYear;
+  private @Nullable Integer browserFeaturesetYear;
 
   /** How to interpret ES6 module imports */
-  private ModuleLoader.ResolutionMode moduleResolutionMode;
+  private ResolutionMode moduleResolutionMode;
 
   /** How to parse JS Documentation. */
   private JsDocParsing parseJsDocDocumentation;
@@ -621,7 +621,7 @@ public abstract class CompilerTestCase {
     // TODO(sdh): Initialize *all* the options here, but first we must ensure no subclass
     // is changing them in the constructor, rather than in their own setUp method.
     this.acceptedLanguage = LanguageMode.UNSUPPORTED;
-    this.moduleResolutionMode = ModuleLoader.ResolutionMode.BROWSER;
+    this.moduleResolutionMode = ResolutionMode.BROWSER;
     this.parseJsDocDocumentation = JsDocParsing.TYPES_ONLY;
     this.allowExternsChanges = false;
     this.allowSourcelessWarnings = false;
@@ -790,7 +790,7 @@ public abstract class CompilerTestCase {
     this.browserFeaturesetYear = year;
   }
 
-  protected final void setModuleResolutionMode(ModuleLoader.ResolutionMode moduleResolutionMode) {
+  protected final void setModuleResolutionMode(ResolutionMode moduleResolutionMode) {
     checkState(this.setUpRan, "Attempted to configure before running setUp().");
     this.moduleResolutionMode = moduleResolutionMode;
   }
@@ -1009,7 +1009,7 @@ public abstract class CompilerTestCase {
     gatherExternPropertiesEnabled = true;
   }
 
-  protected final Set<String> getGatheredExternProperties() {
+  protected final ImmutableSet<String> getGatheredExternProperties() {
     checkState(this.gatherExternPropertiesEnabled, "Must enable gatherExternProperties");
     return lastCompiler.getExternProperties();
   }
@@ -1270,21 +1270,22 @@ public abstract class CompilerTestCase {
     return compiler;
   }
 
-  private static ImmutableList<SourceFile> maybeCreateSources(String name, String srcText) {
+  private static @Nullable ImmutableList<SourceFile> maybeCreateSources(
+      String name, String srcText) {
     if (srcText != null) {
       return ImmutableList.of(SourceFile.fromCode(name, srcText));
     }
     return null;
   }
 
-  protected static List<SourceFile> createSources(String name, String... sources) {
+  protected static @Nullable List<SourceFile> createSources(String name, String... sources) {
     if (sources == null) {
       return null;
     }
     return createSources(name, ImmutableList.copyOf(sources));
   }
 
-  private static List<SourceFile> createSources(String name, List<String> sources) {
+  private static @Nullable List<SourceFile> createSources(String name, List<String> sources) {
     if (sources == null) {
       return null;
     }
@@ -1335,9 +1336,9 @@ public abstract class CompilerTestCase {
     List<SourceFile> inputs =
         (inputsObj instanceof FlatSources) ? ((FlatSources) inputsObj).sources : null;
     List<SourceFile> expected = expectedObj != null ? expectedObj.expected : null;
-    List<Diagnostic> expectedErrors =
+    ImmutableList<Diagnostic> expectedErrors =
         diagnostics.stream().filter(d -> d.level == CheckLevel.ERROR).collect(toImmutableList());
-    List<Diagnostic> expectedWarnings =
+    ImmutableList<Diagnostic> expectedWarnings =
         diagnostics.stream().filter(d -> d.level == CheckLevel.WARNING).collect(toImmutableList());
     checkState(
         expectedErrors.isEmpty() || expectedWarnings.isEmpty(),
@@ -1555,7 +1556,7 @@ public abstract class CompilerTestCase {
         // Transpilation passes are allowed to leave the AST in a bad state when there is a halting
         // error.
         if (astValidationEnabled && !compiler.hasHaltingErrors()) {
-          AstValidator.TypeInfoValidation typeValidationMode =
+          TypeInfoValidation typeValidationMode =
               typeInfoValidationEnabled
                   ? compiler.hasOptimizationColors()
                       ? TypeInfoValidation.COLOR
@@ -1624,10 +1625,15 @@ public abstract class CompilerTestCase {
         }
       }
 
-      // If we ran normalize on the AST, we must also run normalize on the
-      // clone before checking for changes.
+      // If we ran normalize on the AST, we must also run normalize on th clone before checking for
+      // changes.
       if (normalizeEnabled) {
+        boolean hasTypecheckingRun = compiler.hasTypeCheckingRun();
+        // we don't run type inference over the clone of the AST, so need to mark that in the
+        // compiler or Normalize will crash due to lack of inferred types on the clone AST nodes.
+        compiler.setTypeCheckingHasRun(false);
         normalizeActualCode(compiler, externsRootClone, mainRootClone);
+        compiler.setTypeCheckingHasRun(hasTypecheckingRun);
       }
 
       boolean codeChange = !mainRootClone.isEquivalentWithSideEffectsTo(mainRoot);
@@ -1731,30 +1737,28 @@ public abstract class CompilerTestCase {
   }
 
   private static void rewriteEsModules(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
-    List<PassFactory> factories = new ArrayList<>();
     CompilerOptions options = compiler.getOptions();
+    PassListBuilder factories = new PassListBuilder(options);
 
     GatherModuleMetadata gatherModuleMetadata =
         new GatherModuleMetadata(
             compiler, options.getProcessCommonJSModules(), options.moduleResolutionMode);
-    factories.add(
+    factories.maybeAdd(
         PassFactory.builder()
             .setName(PassNames.GATHER_MODULE_METADATA)
             .setRunInFixedPointLoop(true)
-            .setInternalFactory((x) -> gatherModuleMetadata)
-            .setFeatureSetForChecks()
+            .setInternalFactory((x1) -> gatherModuleMetadata)
             .build());
-    factories.add(
+    factories.maybeAdd(
         PassFactory.builder()
             .setName(PassNames.CREATE_MODULE_MAP)
             .setRunInFixedPointLoop(true)
             .setInternalFactory(
                 (x) -> new ModuleMapCreator(compiler, compiler.getModuleMetadataMap()))
-            .setFeatureSetForChecks()
             .build());
     TranspilationPasses.addEs6ModulePass(
         factories, new PreprocessorSymbolTable.CachedInstanceFactory());
-    for (PassFactory factory : factories) {
+    for (PassFactory factory : factories.build()) {
       factory.create(compiler).process(externsRoot, codeRoot);
     }
   }
@@ -1762,15 +1766,15 @@ public abstract class CompilerTestCase {
   private static void transpileToEs5(AbstractCompiler compiler, Node externsRoot, Node codeRoot) {
     rewriteEsModules(compiler, externsRoot, codeRoot);
 
-    List<PassFactory> factories = new ArrayList<>();
     CompilerOptions options = compiler.getOptions();
+    PassListBuilder factories = new PassListBuilder(options);
 
     options.setLanguageIn(LanguageMode.UNSUPPORTED);
     options.setLanguageOut(LanguageMode.ECMASCRIPT5);
-    TranspilationPasses.addTranspilationRuntimeLibraries(factories, options);
+    TranspilationPasses.addTranspilationRuntimeLibraries(factories);
     TranspilationPasses.addRewritePolyfillPass(factories);
     TranspilationPasses.addEarlyOptimizationTranspilationPasses(factories, options);
-    for (PassFactory factory : factories) {
+    for (PassFactory factory : factories.build()) {
       factory.create(compiler).process(externsRoot, codeRoot);
     }
   }
@@ -2196,7 +2200,7 @@ public abstract class CompilerTestCase {
   protected static final class Expected implements TestPart {
     final List<SourceFile> expected;
 
-    Expected(List<SourceFile> files) {
+    Expected(@Nullable List<SourceFile> files) {
       this.expected = files;
     }
   }
@@ -2241,7 +2245,9 @@ public abstract class CompilerTestCase {
     final NamedPredicate<String> messagePredicate;
 
     Diagnostic(
-        CheckLevel level, DiagnosticType diagnostic, NamedPredicate<String> messagePredicate) {
+        CheckLevel level,
+        DiagnosticType diagnostic,
+        @Nullable NamedPredicate<String> messagePredicate) {
       this.level = level;
       this.diagnostic = diagnostic;
       this.messagePredicate = messagePredicate;
diff --git a/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java b/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
index 4c47968..fe8def1 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
@@ -21,7 +21,7 @@ import java.io.ByteArrayOutputStream;
 import java.util.List;
 
 /** CompilerTestCase utilities that can be super sourced out for GWT/J2CL implementation. */
-public class CompilerTestCaseUtils {
+public final class CompilerTestCaseUtils {
   @GwtIncompatible
   public static Compiler multistageSerializeAndDeserialize(
       CompilerTestCase testCase,
@@ -53,4 +53,6 @@ public class CompilerTestCaseUtils {
   @GwtIncompatible
   public static void setDebugLogDirectoryOn(CompilerOptions options) {
   }
+
+  private CompilerTestCaseUtils() {}
 }
diff --git a/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java b/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
index 276baa5..5fd4abe 100644
--- a/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
+++ b/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
@@ -23,7 +23,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.javascript.rhino.Node;
 import java.io.IOException;
-import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -155,7 +154,7 @@ public class ConformanceAllowlisterTest {
     options.setCheckTypes(true);
     // TODO(bangert): Support banned property on OBJECT even if types are not checked.
     options.setChecksOnly(true);
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, sources, options);
     assertThat(result.success).isTrue();
diff --git a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java
index d2b406a..bcb21ea 100644
--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java
@@ -25,6 +25,7 @@ import com.google.common.collect.Ordering;
 import com.google.javascript.jscomp.ControlFlowGraph.Branch;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;
+import com.google.javascript.jscomp.testing.CodeSubTree;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.io.IOException;
@@ -36,17 +37,13 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests {@link ControlFlowAnalysis}.
- *
- */
+/** Tests {@link ControlFlowAnalysis}. */
 @RunWith(JUnit4.class)
 public final class ControlFlowAnalysisTest {
 
   /**
-   * Given an input in JavaScript, test if the control flow analysis
-   * creates the proper control flow graph by comparing the expected
-   * Dot file output.
+   * Given an input in JavaScript, test if the control flow analysis creates the proper control flow
+   * graph by comparing the expected Dot file output.
    *
    * @param input Input JavaScript.
    * @param expected Expected Graphviz Dot file.
@@ -61,25 +58,28 @@ public final class ControlFlowAnalysisTest {
    *
    * @param input Input JavaScript.
    * @param expected Expected Graphviz Dot file.
-   * @param shouldTraverseFunctions Whether to traverse functions when constructing the CFG (true by
-   *     default). Passed in to the constructor of {@link ControlFlowAnalysis}.
+   * @param shouldTraverseFunctions Whether to traverse functions when constructing the CFG. Passed
+   *     in to the builder for {@link ControlFlowAnalysis}. Defaults to true for the two-arg {@link
+   *     #testCfg(String, String)}
    */
   private void testCfg(String input, String expected, boolean shouldTraverseFunctions)
       throws IOException {
     Compiler compiler = new Compiler();
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, shouldTraverseFunctions, true);
-
     Node root = compiler.parseSyntheticCode("cfgtest", input);
-    cfa.process(null, root);
-    ControlFlowGraph<Node> cfg = cfa.getCfg();
+
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder()
+            .setCompiler(compiler)
+            .setCfgRoot(root)
+            .setTraverseFunctions(shouldTraverseFunctions)
+            .setIncludeEdgeAnnotations(true)
+            .computeCfg();
+
     assertThat(DotFormatter.toDot(root, cfg)).isEqualTo(expected);
   }
 
-  /**
-   * Gets all the edges of the graph.
-   */
-  private static List<DiGraphEdge<Node, Branch>> getAllEdges(
-      ControlFlowGraph<Node> cfg) {
+  /** Gets all the edges of the graph. */
+  private static List<DiGraphEdge<Node, Branch>> getAllEdges(ControlFlowGraph<Node> cfg) {
     List<DiGraphEdge<Node, Branch>> edges = new ArrayList<>();
     for (DiGraphNode<Node, Branch> n : cfg.getNodes()) {
       edges.addAll(cfg.getOutEdges(n.getValue()));
@@ -88,8 +88,8 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Gets all the control flow edges from some node with the first token to
-   * some node with the second token.
+   * Gets all the control flow edges from some node with the first token to some node with the
+   * second token.
    */
   private static List<DiGraphEdge<Node, Branch>> getAllEdges(
       ControlFlowGraph<Node> cfg, Token startToken, Token endToken) {
@@ -110,20 +110,18 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Gets all the control flow edges of the given type from some node with the
-   * first token to some node with the second token.
+   * Gets all the control flow edges of the given type from some node with the first token to some
+   * node with the second token.
    */
   private static List<DiGraphEdge<Node, Branch>> getAllEdges(
       ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
-    List<DiGraphEdge<Node, Branch>> edges =
-        getAllEdges(cfg, startToken, endToken);
+    List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken);
     edges.removeIf(elem -> type != elem.getValue());
     return edges;
   }
 
   private static boolean isAncestor(Node n, Node maybeDescendant) {
-    for (Node current = n.getFirstChild(); current != null;
-         current = current.getNext()) {
+    for (Node current = n.getFirstChild(); current != null; current = current.getNext()) {
       if (current == maybeDescendant || isAncestor(current, maybeDescendant)) {
         return true;
       }
@@ -133,14 +131,12 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Gets all the control flow edges of the given type from some node with
-   * the first token to some node with the second token.
-   * This edge must flow from a parent to one of its descendants.
+   * Gets all the control flow edges of the given type from some node with the first token to some
+   * node with the second token. This edge must flow from a parent to one of its descendants.
    */
   private static List<DiGraphEdge<Node, Branch>> getAllDownEdges(
       ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
-    List<DiGraphEdge<Node, Branch>> edges =
-        getAllEdges(cfg, startToken, endToken, type);
+    List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken, type);
     Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator();
     while (it.hasNext()) {
       DiGraphEdge<Node, Branch> edge = it.next();
@@ -163,36 +159,47 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Assert that there exists a control flow edge of the given type
-   * from some node with the first token to some node with the second token.
-   * This edge must flow from a parent to one of its descendants.
+   * Assert that there exists a control flow edge of the given type from some node with the first
+   * token to some node with the second token. This edge must flow from a parent to one of its
+   * descendants.
    */
-  private static void assertDownEdge(ControlFlowGraph<Node> cfg,
-      Token startToken, Token endToken, Branch type) {
+  private static void assertDownEdge(
+      ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
     assertWithMessage("No down edge found")
         .that(getAllDownEdges(cfg, startToken, endToken, type))
         .isNotEmpty();
   }
 
   /**
-   * Assert that there exists a control flow edge of the given type
-   * from some node with the first token to some node with the second token.
-   * This edge must flow from a node to one of its ancestors.
+   * Assert that there exists a control flow edge of the given type from some node with the first
+   * token to some node with the second token.
+   */
+  private static void assertEdge(
+      ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
+    assertWithMessage("No up edge found.")
+        .that(getAllEdges(cfg, /*startToken=*/ startToken, /*endToken=*/ endToken, type))
+        .isNotEmpty();
+  }
+
+  /**
+   * Assert that there exists a control flow edge of the given type from some node with the first
+   * token to some node with the second token. This edge must flow from a node to one of its
+   * ancestors.
    */
-  private static void assertUpEdge(ControlFlowGraph<Node> cfg,
-      Token startToken, Token endToken, Branch type) {
+  private static void assertUpEdge(
+      ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
     assertWithMessage("No up edge found.")
         .that(getAllDownEdges(cfg, /*startToken=*/ endToken, /*endToken=*/ startToken, type))
         .isNotEmpty();
   }
 
   /**
-   * Assert that there exists a control flow edge of the given type
-   * from some node with the first token to some node with the second token.
-   * This edge must flow between two nodes that are not in the same subtree.
+   * Assert that there exists a control flow edge of the given type from some node with the first
+   * token to some node with the second token. This edge must flow between two nodes that are not in
+   * the same subtree.
    */
-  private static void assertCrossEdge(ControlFlowGraph<Node> cfg,
-      Token startToken, Token endToken, Branch type) {
+  private static void assertCrossEdge(
+      ControlFlowGraph<Node> cfg, Token startToken, Token endToken, Branch type) {
     int numDownEdges = getAllDownEdges(cfg, startToken, endToken, type).size();
     int numUpEdges = getAllDownEdges(cfg, endToken, startToken, type).size();
     int numEdges = getAllEdges(cfg, startToken, endToken, type).size();
@@ -200,11 +207,10 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Assert that there exists a control flow edge of the given type
-   * from some node with the first token to the return node.
+   * Assert that there exists a control flow edge of the given type from some node with the first
+   * token to the return node.
    */
-  private static void assertReturnEdge(ControlFlowGraph<Node> cfg,
-      Token startToken) {
+  private static void assertReturnEdge(ControlFlowGraph<Node> cfg, Token startToken) {
     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg);
     for (DiGraphEdge<Node, Branch> edge : edges) {
       Node source = edge.getSource().getValue();
@@ -218,11 +224,10 @@ public final class ControlFlowAnalysisTest {
   }
 
   /**
-   * Assert that there exists no control flow edge of the given type
-   * from some node with the first token to the return node.
+   * Assert that there exists no control flow edge of the given type from some node with the first
+   * token to the return node.
    */
-  private static void assertNoReturnEdge(ControlFlowGraph<Node> cfg,
-      Token startToken) {
+  private static void assertNoReturnEdge(ControlFlowGraph<Node> cfg, Token startToken) {
     List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg);
     for (DiGraphEdge<Node, Branch> edge : edges) {
       Node source = edge.getSource().getValue();
@@ -245,19 +250,19 @@ public final class ControlFlowAnalysisTest {
    *
    * @param input Input JavaScript.
    */
-  private ControlFlowGraph<Node> createCfg(String input,
-      boolean runSynBlockPass) {
+  private ControlFlowGraph<Node> createCfg(String input, boolean runSynBlockPass) {
     Compiler compiler = new Compiler();
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true);
-
     Node root = compiler.parseSyntheticCode("cfgtest", input);
     if (runSynBlockPass) {
-      CreateSyntheticBlocks pass = new CreateSyntheticBlocks(
-          compiler, "START", "END");
+      CreateSyntheticBlocks pass = new CreateSyntheticBlocks(compiler, "START", "END");
       pass.process(null, root);
     }
-    cfa.process(null, root);
-    return cfa.getCfg();
+    return ControlFlowAnalysis.builder()
+        .setCompiler(compiler)
+        .setCfgRoot(root)
+        .setTraverseFunctions(true)
+        .setIncludeEdgeAnnotations(true)
+        .computeCfg();
   }
 
   private ControlFlowGraph<Node> createCfg(String input) {
@@ -455,8 +460,7 @@ public final class ControlFlowAnalysisTest {
 
   @Test
   public void testSimpleSwitch() throws IOException {
-    String src = "var x; switch(x){ case(1): x(); case('x'): x(); break" +
-        "; default: x();}";
+    String src = "var x; switch(x){ case(1): x(); case('x'): x(); break" + "; default: x();}";
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertCrossEdge(cfg, Token.VAR, Token.SWITCH, Branch.UNCOND);
     assertNoEdge(cfg, Token.SWITCH, Token.NAME);
@@ -490,8 +494,7 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testSwitchDefaultInMiddle() throws IOException {
     // DEFAULT appears in the middle. But it is should evaluated last.
-    String src = "var x; switch(x){ case 1: break; default: break; " +
-        "case 2: break; }";
+    String src = "var x; switch(x){ case 1: break; default: break; " + "case 2: break; }";
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND);
     assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE);
@@ -645,8 +648,7 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testNestedFor() throws IOException {
     // This is tricky as the inner FOR branches to "x++" ON_FALSE.
-    String src = "var a,b;a();for(var x=0;x<100;x++){for(var y=0;y<100;y++){" +
-      "continue;b();}}";
+    String src = "var a,b;a();for(var x=0;x<100;x++){for(var y=0;y<100;y++){" + "continue;b();}}";
     String expected =
         "digraph AST {\n"
             + "  node [color=lightblue2, style=filled];\n"
@@ -973,9 +975,54 @@ public final class ControlFlowAnalysisTest {
   }
 
   @Test
+  public void testClass_withPublicFieldsAndMethod() throws IOException {
+    String src = "class C{ x; y; foo() {}}";
+    ControlFlowGraph<Node> cfg = createCfg(src);
+    assertEdge(cfg, Token.FUNCTION, Token.BLOCK, Branch.UNCOND);
+    assertReturnEdge(cfg, Token.BLOCK);
+  }
+
+  @Test
   public void testClassWithMemberFunctions() throws IOException {
     String src = "class C{ f(){} g(){} }";
-    String expected =
+    String expectedWithoutShouldTraverseFunctions =
+        "digraph AST {\n"
+            + "  node [color=lightblue2, style=filled];\n"
+            + "  node0 [label=\"SCRIPT\"];\n"
+            + "  node1 [label=\"CLASS\"];\n"
+            + "  node0 -> node1 [weight=1];\n"
+            + "  node2 [label=\"NAME(C)\"];\n"
+            + "  node1 -> node2 [weight=1];\n"
+            + "  node3 [label=\"EMPTY\"];\n"
+            + "  node1 -> node3 [weight=1];\n"
+            + "  node4 [label=\"CLASS_MEMBERS\"];\n"
+            + "  node1 -> node4 [weight=1];\n"
+            + "  node5 [label=\"MEMBER_FUNCTION_DEF\"];\n"
+            + "  node4 -> node5 [weight=1];\n"
+            + "  node6 [label=\"FUNCTION\"];\n"
+            + "  node5 -> node6 [weight=1];\n"
+            + "  node7 [label=\"NAME\"];\n"
+            + "  node6 -> node7 [weight=1];\n"
+            + "  node8 [label=\"PARAM_LIST\"];\n"
+            + "  node6 -> node8 [weight=1];\n"
+            + "  node9 [label=\"BLOCK\"];\n"
+            + "  node6 -> node9 [weight=1];\n"
+            + "  node10 [label=\"MEMBER_FUNCTION_DEF\"];\n"
+            + "  node4 -> node10 [weight=1];\n"
+            + "  node11 [label=\"FUNCTION\"];\n"
+            + "  node10 -> node11 [weight=1];\n"
+            + "  node12 [label=\"NAME\"];\n"
+            + "  node11 -> node12 [weight=1];\n"
+            + "  node13 [label=\"PARAM_LIST\"];\n"
+            + "  node11 -> node13 [weight=1];\n"
+            + "  node14 [label=\"BLOCK\"];\n"
+            + "  node11 -> node14 [weight=1];\n"
+            + "  node1 -> RETURN "
+            + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
+            + "  node0 -> node1 "
+            + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
+            + "}\n";
+    String expectedWithShouldTraverseFunctions =
         "digraph AST {\n"
             + "  node [color=lightblue2, style=filled];\n"
             + "  node0 [label=\"SCRIPT\"];\n"
@@ -1020,7 +1067,8 @@ public final class ControlFlowAnalysisTest {
             + "  node0 -> node1 "
             + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n"
             + "}\n";
-    testCfg(src, expected);
+    testCfg(src, expectedWithShouldTraverseFunctions);
+    testCfg(src, expectedWithoutShouldTraverseFunctions, /* shouldTraverseFunctions= */ false);
   }
 
   @Test
@@ -1331,9 +1379,10 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testComplicatedFinally2() throws IOException {
     // Now the most nasty case.....
-    String src = "while(1){try{" +
-      "if(a){a;continue;}else if(b){b;break;} else if(c) throw 1; else a}" +
-      "catch(e){}finally{c()}bar}foo";
+    String src =
+        "while(1){try{"
+            + "if(a){a;continue;}else if(b){b;break;} else if(c) throw 1; else a}"
+            + "catch(e){}finally{c()}bar}foo";
 
     ControlFlowGraph<Node> cfg = createCfg(src);
     // Focus only on the ON_EX edges.
@@ -1344,8 +1393,7 @@ public final class ControlFlowAnalysisTest {
 
   @Test
   public void testDeepNestedBreakwithFinally() throws IOException {
-    String src = "X:while(1){try{while(2){try{var a;break X;}" +
-        "finally{}}}finally{}}";
+    String src = "X:while(1){try{while(2){try{var a;break X;}" + "finally{}}}finally{}}";
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE);
     assertDownEdge(cfg, Token.BLOCK, Token.TRY, Branch.UNCOND);
@@ -1360,8 +1408,7 @@ public final class ControlFlowAnalysisTest {
 
   @Test
   public void testDeepNestedFinally() throws IOException {
-    String src = "try{try{try{throw 1}" +
-        "finally{1;var a}}finally{2;if(a);}}finally{3;a()}";
+    String src = "try{try{try{throw 1}" + "finally{1;var a}}finally{2;if(a);}}finally{3;a()}";
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX);
     assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND);
@@ -1384,8 +1431,7 @@ public final class ControlFlowAnalysisTest {
 
   @Test
   public void testReturnInFinally2() throws IOException {
-    String src = "function f(x){" +
-      " try{ try{}finally{var dummy; return x;} } finally {} }";
+    String src = "function f(x){" + " try{ try{}finally{var dummy; return x;} } finally {} }";
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertCrossEdge(cfg, Token.VAR, Token.RETURN, Branch.UNCOND);
     assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.UNCOND);
@@ -1497,15 +1543,19 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testPartialTraversalOfScope() throws IOException {
     Compiler compiler = new Compiler();
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true);
 
     Node script1 = compiler.parseSyntheticCode("cfgtest", "var foo;");
     Node script2 = compiler.parseSyntheticCode("cfgtest2", "var bar;");
     // Create a parent node for the scripts
     new Node(Token.BLOCK, script1, script2);
 
-    cfa.process(null, script1);
-    ControlFlowGraph<Node> cfg = cfa.getCfg();
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder()
+            .setCompiler(compiler)
+            .setCfgRoot(script1)
+            .setTraverseFunctions(true)
+            .setIncludeEdgeAnnotations(true)
+            .computeCfg();
 
     assertThat(cfg.getNode(script1)).isNotNull();
     assertThat(cfg.getNode(script2)).isNull();
@@ -1516,9 +1566,14 @@ public final class ControlFlowAnalysisTest {
     assertNodeOrder(
         createCfg("for (var i = 0; i < 5; i++) { var x = 3; } if (true) {}"),
         ImmutableList.of(
-            Token.SCRIPT, Token.VAR, Token.FOR, Token.BLOCK, Token.VAR,
+            Token.SCRIPT,
+            Token.VAR,
+            Token.FOR,
+            Token.BLOCK,
+            Token.VAR,
             Token.INC /* i++ */,
-            Token.IF, Token.BLOCK));
+            Token.IF,
+            Token.BLOCK));
   }
 
   @Test
@@ -1561,23 +1616,24 @@ public final class ControlFlowAnalysisTest {
 
   @Test
   public void testLocalFunctionOrder() throws IOException {
-    ControlFlowGraph<Node> cfg =
-        createCfg("function f() { while (x) { x++; } } var x = 3;");
+    ControlFlowGraph<Node> cfg = createCfg("function f() { while (x) { x++; } } var x = 3;");
     assertNodeOrder(
         cfg,
         ImmutableList.of(
-            Token.SCRIPT, Token.VAR,
-
-            Token.FUNCTION, Token.BLOCK,
-            Token.WHILE, Token.BLOCK, Token.EXPR_RESULT));
+            Token.SCRIPT,
+            Token.VAR,
+            Token.FUNCTION,
+            Token.BLOCK,
+            Token.WHILE,
+            Token.BLOCK,
+            Token.EXPR_RESULT));
   }
 
   @Test
   public void testDoWhileOrder() throws IOException {
     assertNodeOrder(
         createCfg("do { var x = 3; } while (true); void x;"),
-        ImmutableList.of(
-            Token.SCRIPT, Token.BLOCK, Token.VAR, Token.DO, Token.EXPR_RESULT));
+        ImmutableList.of(Token.SCRIPT, Token.BLOCK, Token.VAR, Token.DO, Token.EXPR_RESULT));
   }
 
   @Test
@@ -1679,19 +1735,21 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testBreakInFinally1() throws IOException {
     String src =
-        "f = function() {\n" +
-        "  var action;\n" +
-        "  a: {\n" +
-        "    var proto = null;\n" +
-        "    try {\n" +
-        "      proto = new Proto\n" +
-        "    } finally {\n" +
-        "      action = proto;\n" +
-        "      break a\n" +  // Remove this...
-        "    }\n" +
-        "  }\n" +
-        "  alert(action)\n" + // but not this.
-        "};";
+        "f = function() {\n"
+            + "  var action;\n"
+            + "  a: {\n"
+            + "    var proto = null;\n"
+            + "    try {\n"
+            + "      proto = new Proto\n"
+            + "    } finally {\n"
+            + "      action = proto;\n"
+            + "      break a\n"
+            + // Remove this...
+            "    }\n"
+            + "  }\n"
+            + "  alert(action)\n"
+            + // but not this.
+            "};";
     String expected =
         "digraph AST {\n"
             + "  node [color=lightblue2, style=filled];\n"
@@ -1775,36 +1833,129 @@ public final class ControlFlowAnalysisTest {
   @Test
   public void testBreakInFinally2() throws IOException {
     String src =
-      "var action;\n" +
-      "a: {\n" +
-      "  var proto = null;\n" +
-      "  try {\n" +
-      "    proto = new Proto\n" +
-      "  } finally {\n" +
-      "    action = proto;\n" +
-      "    break a\n" +
-      "  }\n" +
-      "}\n" +
-      "alert(action)\n";
+        "var action;\n"
+            + "a: {\n"
+            + "  var proto = null;\n"
+            + "  try {\n"
+            + "    proto = new Proto\n"
+            + "  } finally {\n"
+            + "    action = proto;\n"
+            + "    break a\n"
+            + "  }\n"
+            + "}\n"
+            + "alert(action)\n";
 
     ControlFlowGraph<Node> cfg = createCfg(src);
     assertCrossEdge(cfg, Token.BREAK, Token.EXPR_RESULT, Branch.UNCOND);
     assertNoEdge(cfg, Token.BREAK, Token.BLOCK);
   }
 
+  @Test
+  public void testCfgRootedAtEmptyFunctionDeclaration() {
+    String src = "function fn() {}";
+    Compiler compiler = new Compiler();
+    Node globalRoot = compiler.parseSyntheticCode("cfgtest", src);
+    Node fnRoot = CodeSubTree.findFirstNode(globalRoot, Node::isFunction);
+
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(fnRoot).computeCfg();
+
+    assertDownEdge(cfg, Token.FUNCTION, Token.BLOCK, Branch.UNCOND);
+    assertReturnEdge(cfg, Token.BLOCK);
+  }
+
+  @Test
+  public void testCfgRootedAtFunctionDeclarationWithSingleStatement() {
+    String src = "function fn() {  alert(3); }";
+    Compiler compiler = new Compiler();
+    Node globalRoot = compiler.parseSyntheticCode("cfgtest", src);
+    Node fnRoot = CodeSubTree.findFirstNode(globalRoot, Node::isFunction);
+
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(fnRoot).computeCfg();
+
+    assertDownEdge(cfg, Token.FUNCTION, Token.BLOCK, Branch.UNCOND);
+    assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND);
+    assertReturnEdge(cfg, Token.EXPR_RESULT);
+  }
+
+  @Test
+  public void testCfgRootedAtEmptyClassStaticBlock() {
+    String src = "class C { static {} }";
+    Compiler compiler = new Compiler();
+    Node globalRoot = compiler.parseSyntheticCode("cfgtest", src);
+    Node staticBlock = CodeSubTree.findFirstNode(globalRoot, Node::isBlock);
+
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(staticBlock).computeCfg();
+
+    assertReturnEdge(cfg, Token.BLOCK);
+  }
+
+  @Test
+  public void testCfgRootedAtClassStaticBlockSingleStatementAndSubsequentMembers() {
+    String src = "class C { static { alert(0); } x = 0; fn() {} }";
+    Compiler compiler = new Compiler();
+    Node globalRoot = compiler.parseSyntheticCode("cfgtest", src);
+    Node staticBlock = CodeSubTree.findFirstNode(globalRoot, Node::isBlock);
+
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(staticBlock).computeCfg();
+
+    assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND);
+    // Double check edge removal from EXPR_RESULT to next child of CLASS_MEMBER
+    assertNoEdge(cfg, Token.EXPR_RESULT, Token.MEMBER_FIELD_DEF);
+    assertReturnEdge(cfg, Token.EXPR_RESULT);
+  }
+
+  @Test
+  public void testCfgRootedAtClassStaticBlockMultipleStatementAndSubsequentMembers() {
+    String src =
+        lines(
+            "class C {",
+            "  static { alert(0); }",
+            "  x = 0;",
+            "  [0+1]() {}",
+            "  static { alert(1); }",
+            "  fn(){}",
+            "}");
+    Compiler compiler = new Compiler();
+    Node globalRoot = compiler.parseSyntheticCode("cfgtest", src);
+    ImmutableList<Node> staticBlocks =
+        CodeSubTree.findNodesNonEmpty(globalRoot, NodeUtil::isClassStaticBlock);
+    assertThat(staticBlocks).hasSize(2);
+    Node staticBlock1 = staticBlocks.get(0);
+    Node staticBlock2 = staticBlocks.get(1);
+
+    // First Static Block
+    ControlFlowGraph<Node> cfg1 =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(staticBlock1).computeCfg();
+
+    assertDownEdge(cfg1, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND);
+    assertNoEdge(cfg1, Token.EXPR_RESULT, Token.MEMBER_FIELD_DEF);
+    assertReturnEdge(cfg1, Token.EXPR_RESULT);
+
+    assertNoEdge(cfg1, Token.COMPUTED_PROP, Token.BLOCK);
+
+    // Second Static Block
+    ControlFlowGraph<Node> cfg2 =
+        ControlFlowAnalysis.builder().setCompiler(compiler).setCfgRoot(staticBlock2).computeCfg();
+
+    assertDownEdge(cfg2, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND);
+    assertNoEdge(cfg2, Token.EXPR_RESULT, Token.MEMBER_FIELD_DEF);
+    assertReturnEdge(cfg2, Token.EXPR_RESULT);
+  }
 
   /**
    * Asserts the priority order of CFG nodes.
    *
-   * Checks that the node type of the highest-priority node matches the
-   * first element of the list, the type of the second node matches the
-   * second element of the list, and so on.
+   * <p>Checks that the node type of the highest-priority node matches the first element of the
+   * list, the type of the second node matches the second element of the list, and so on.
    *
    * @param cfg The control flow graph.
    * @param nodeTypes The expected node types, in order.
    */
-  private void assertNodeOrder(ControlFlowGraph<Node> cfg,
-      List<Token> nodeTypes) {
+  private void assertNodeOrder(ControlFlowGraph<Node> cfg, List<Token> nodeTypes) {
     List<? extends DiGraphNode<Node, Branch>> cfgNodes =
         Ordering.from(cfg.getOptionalNodeComparator(true)).sortedCopy(cfg.getNodes());
 
diff --git a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
index 307ad10..d6b6855 100644
--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
@@ -50,7 +50,7 @@ public final class CreateSyntheticBlocksTest extends CompilerTestCase {
                 getName(),
                 new MinimizeExitPoints(),
                 new PeepholeRemoveDeadCode(),
-                new PeepholeMinimizeConditions(true /* late */),
+                new PeepholeMinimizeConditions(/* late= */ true),
                 new PeepholeFoldConstants(true, false /* useTypes */))
             .process(externs, js);
         new Denormalize(compiler, FeatureSet.BARE_MINIMUM).process(externs, js);
diff --git a/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java b/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
index e197ad6..6e72c5a 100644
--- a/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
+++ b/test/com/google/javascript/jscomp/CrossChunkCodeMotionTest.java
@@ -22,9 +22,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link CrossChunkCodeMotion}.
- */
+/** Tests for {@link CrossChunkCodeMotion}. */
 @RunWith(JUnit4.class)
 public final class CrossChunkCodeMotionTest extends CompilerTestCase {
 
@@ -754,6 +752,90 @@ public final class CrossChunkCodeMotionTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassMovement_classStaticBlock1() {
+    // TODO(bradfordcsmith):Ideally the class would move
+    test(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk("class Foo { static { } }")
+                .addChunk("new Foo();")
+                .build()),
+        expected("class Foo { static { } }", "new Foo();"));
+  }
+
+  @Test
+  public void testClassMovement_classStaticBlock2() {
+    test(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk("var x = 1;")
+                .addChunk("class Foo { static { x; } } new Foo();")
+                .build()),
+        expected("", "var x = 1; class Foo { static { x; } } new Foo();"));
+  }
+
+  @Test
+  public void testClassMovement_classStaticBlock3() {
+    // TODO(bradfordcsmith):Ideally the class and var would move to m3
+    JSChunk[] modules =
+        JSChunkGraphBuilder.forChain()
+            // m1
+            .addChunk("const x = 1; var y = 2;")
+            // m2
+            .addChunk("class Foo { static { y = 3; } }")
+            // m3
+            .addChunk("new Foo();")
+            .build();
+
+    test(
+        srcs(modules),
+        expected(
+            // m1
+            "const x = 1;",
+            // m2
+            "var y =2; class Foo { static { y = 3; } } ",
+            // m3
+            "new Foo();"));
+  }
+
+  @Test
+  public void testClassMovement_classStaticBlock4() {
+    JSChunk[] modules =
+        JSChunkGraphBuilder.forChain()
+            // m1
+            .addChunk("var x =1;")
+            // m2
+            .addChunk(
+                lines(
+                    "class Foo {", //
+                    "  static {",
+                    "    x = 2;",
+                    "  }",
+                    "}",
+                    "use(x);"))
+            // m3
+            .addChunk("new Foo();")
+            .build();
+
+    test(
+        srcs(modules),
+        expected(
+            // m1
+            "",
+            // m2
+            lines(
+                "var x =1;", //
+                "class Foo {",
+                "  static {",
+                "    x = 2",
+                "  }",
+                "}",
+                "use(x);"),
+            // m3
+            "new Foo();"));
+  }
+
+  @Test
   public void testClassMovement_mixins() {
     test(
         srcs(
diff --git a/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java b/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
index b648147..d8358bb 100644
--- a/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
+++ b/test/com/google/javascript/jscomp/CrossChunkMethodMotionTest.java
@@ -1647,6 +1647,133 @@ public final class CrossChunkMethodMotionTest extends CompilerTestCase {
   }
 
   @Test
+  public void staticBlockWithoutMethodReference() {
+    test(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk(
+                    lines(
+                        "class Bar {", //
+                        "  method() {",
+                        "  }",
+                        "  static {",
+                        "  }",
+                        "}",
+                        "class Foo extends Bar {",
+                        "  method2() {",
+                        "    return () => super.method();",
+                        "  }",
+                        "}"))
+                .addChunk("(new Foo).method2()")
+                .build()),
+        expected(
+            lines(
+                STUB_DECLARATIONS, //
+                "class Bar {",
+                "  static {",
+                "  }",
+                "}",
+                "Bar.prototype.method = JSCompiler_stubMethod(0);",
+                "class Foo extends Bar {",
+                "  method2() {",
+                "    return () => super.method();",
+                "  }",
+                "}"),
+            // Chunk 2
+            lines(
+                "Bar.prototype.method = JSCompiler_unstubMethod(0, function() {});",
+                "(new Foo).method2()")));
+  }
+
+  @Test
+  public void referenceToMethodInOwnStaticBlock() {
+    testSame(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk(
+                    lines(
+                        "class Bar {", //
+                        "  method() {",
+                        "  }",
+                        "  static {",
+                        "    this.prototype.method;",
+                        "  }",
+                        "}",
+                        "class Foo extends Bar {",
+                        "  method2() {",
+                        "    return () => super.method();",
+                        "  }",
+                        "}"))
+                .addChunk("(new Foo).method2()")
+                .build()));
+  }
+
+  @Test
+  public void staticBlockReferenceToMethodInDifferentClassNoMovement() {
+    testSame(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk(
+                    lines(
+                        "class Bar {", //
+                        "  method() {}",
+                        "}",
+                        "class Foo extends Bar {",
+                        "  static {",
+                        "    (new Bar).method();",
+                        "  }",
+                        "  method2() {",
+                        "    return () => super.method();",
+                        "  }",
+                        "}"))
+                .addChunk("(new Foo).method2()")
+                .build()));
+  }
+
+  @Test
+  public void staticBlockReferenceToMethodInDifferentClassWithMovement() {
+    test(
+        srcs(
+            JSChunkGraphBuilder.forChain()
+                .addChunk(
+                    lines(
+                        "class Bar {", //
+                        "  method() {}",
+                        "}"))
+                .addChunk(
+                    lines(
+                        "class Foo extends Bar {",
+                        "  static {",
+                        "    (new Bar()).method();",
+                        "  }",
+                        "  method2() {",
+                        "    return () => { return super.method(); };",
+                        "  }",
+                        "}"))
+                .addChunk("(new Foo).method2()")
+                .build()),
+        expected(
+            lines(
+                STUB_DECLARATIONS, //
+                "class Bar {",
+                "}",
+                "Bar.prototype.method = JSCompiler_stubMethod(0);"),
+            // Chunk 2
+            lines(
+                "Bar.prototype.method = JSCompiler_unstubMethod(0, function() {});",
+                "class Foo extends Bar {",
+                "  static {",
+                "    (new Bar()).method();",
+                "  }",
+                "  method2() {",
+                "    return () => { return super.method(); };",
+                "  }",
+                "}"),
+            // Chunk 3
+            lines("(new Foo()).method2();")));
+  }
+
+  @Test
   public void testIssue600() {
     testSame(
         srcs(
diff --git a/test/com/google/javascript/jscomp/CrossChunkReferenceCollectorTest.java b/test/com/google/javascript/jscomp/CrossChunkReferenceCollectorTest.java
index b23c973..7c58f5b 100644
--- a/test/com/google/javascript/jscomp/CrossChunkReferenceCollectorTest.java
+++ b/test/com/google/javascript/jscomp/CrossChunkReferenceCollectorTest.java
@@ -59,8 +59,9 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
 
   @Test
   public void testVarInBlock() {
-    testSame(lines(
-            "  if (true) {",
+    testSame(
+        lines(
+            "  if (true) {", //
             "    var y = x;",
             "    y;",
             "    y;",
@@ -140,8 +141,9 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
 
   @Test
   public void testBasicBlocks() {
-    testSame(lines(
-            "var x = 0;",
+    testSame(
+        lines(
+            "var x = 0;", //
             "switch (x) {",
             "  case 0:",
             "    x;",
@@ -157,6 +159,29 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlock() {
+    testSame(
+        lines(
+            "var x=1;", //
+            "class C {",
+            "  static {",
+            "    x;",
+            "    x=2;",
+            "  }",
+            "}"));
+
+    ImmutableMap<String, Var> globalVariableNamesMap = testedCollector.getGlobalVariableNamesMap();
+    assertThat(globalVariableNamesMap).containsKey("x");
+    Var xVar = globalVariableNamesMap.get("x");
+    ReferenceCollection xRefs = testedCollector.getReferences(xVar);
+    assertThat(xRefs.isAssignedOnceInLifetime()).isFalse();
+    assertThat(xRefs.references).hasSize(3);
+    assertNode(xRefs.references.get(0).getBasicBlock().getRoot()).hasType(Token.ROOT);
+    assertNode(xRefs.references.get(1).getBasicBlock().getRoot()).hasType(Token.CLASS_MEMBERS);
+    assertNode(xRefs.references.get(2).getBasicBlock().getRoot()).hasType(Token.CLASS_MEMBERS);
+  }
+
+  @Test
   public void nullishCoalesce() {
     testSame("var x = 0; var y = x ?? (x = 1)");
     ImmutableMap<String, Var> globalVariableNamesMap = testedCollector.getGlobalVariableNamesMap();
@@ -171,13 +196,14 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
 
   @Test
   public void testTopLevelStatements() {
-    testSame(lines(
-        "var x = 1;",
-        "const y = x;",
-        "let z = x - y;",
-        "function f(x, y) {",   // only f and z globals referenced
-        "  return x + y + z;",
-        "}"));
+    testSame(
+        lines(
+            "var x = 1;",
+            "const y = x;",
+            "let z = x - y;",
+            "function f(x, y) {", // only f and z globals referenced
+            "  return x + y + z;",
+            "}"));
 
     // Pull out all the references for comparison.
     ImmutableMap<String, Var> globalVariableNamesMap = testedCollector.getGlobalVariableNamesMap();
@@ -201,8 +227,7 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
     // const y = x;
     TopLevelStatement yEqualsX = topLevelStatements.get(1);
     assertThat(yEqualsX.getOriginalOrder()).isEqualTo(1);
-    assertThat(yEqualsX.getNonDeclarationReferences())
-        .containsExactly(xReferences.get(1));
+    assertThat(yEqualsX.getNonDeclarationReferences()).containsExactly(xReferences.get(1));
     // let z = x - y;
     TopLevelStatement zEqualsXMinusY = topLevelStatements.get(2);
     assertThat(zEqualsXMinusY.getOriginalOrder()).isEqualTo(2);
@@ -350,18 +375,18 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
 
   @Test
   public void testFunctionCallsAreNotMovableExceptForMethodStubs() {
-    testSame(lines(
-        "function Foo() {}",
-        "Foo.prototype.stub = JSCompiler_stubMethod(x);",
-        "Foo.prototype.unstub = JSCompiler_unstubMethod(x);",
-        "Foo.prototype.other = other();"));
+    testSame(
+        lines(
+            "function Foo() {}",
+            "Foo.prototype.stub = JSCompiler_stubMethod(x);",
+            "Foo.prototype.unstub = JSCompiler_unstubMethod(x);",
+            "Foo.prototype.other = other();"));
     List<TopLevelStatement> statements = testedCollector.getTopLevelStatements();
     assertThat(statements.get(1).isMovableDeclaration()).isTrue();
     assertThat(statements.get(2).isMovableDeclaration()).isFalse();
     assertThat(statements.get(3).isMovableDeclaration()).isFalse();
   }
 
-
   @Test
   public void testUnknownNameValueIsImmovable() {
     assertStatementIsImmovable("var a = unknownName;");
@@ -465,9 +490,7 @@ public final class CrossChunkReferenceCollectorTest extends CompilerTestCase {
 
   @Test
   public void testTemplateLiteralIsMovableIfSubstitutionsAreMovable() {
-    testSame(lines(
-        "var wellDefinedName = 1;",
-        "var t = `${wellDefinedName}`;"));
+    testSame(lines("var wellDefinedName = 1;", "var t = `${wellDefinedName}`;"));
     assertThat(testedCollector.getTopLevelStatements().get(1).isMovableDeclaration()).isTrue();
   }
 
diff --git a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
index 3df19c3..f815827 100644
--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.rhino.Token;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -744,9 +745,12 @@ public final class DataFlowAnalysisTest {
     }
 
     // Control flow graph
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
-    cfa.process(null, script);
-    ControlFlowGraph<Node> cfg = cfa.getCfg();
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder()
+            .setCompiler(compiler)
+            .setCfgRoot(script)
+            .setIncludeEdgeAnnotations(true)
+            .computeCfg();
 
     // All variables declared in function
     AllVarsDeclaredInFunction allVarsDeclaredInFunction =
@@ -950,14 +954,14 @@ public final class DataFlowAnalysisTest {
     assertThat(e).hasMessageThat().startsWith("Dataflow analysis appears to diverge around: ");
   }
 
-  static void verifyInHas(GraphNode<Instruction, Branch> node, Variable var,
-      Integer constant) {
+  static void verifyInHas(
+      GraphNode<Instruction, Branch> node, Variable var, @Nullable Integer constant) {
     LinearFlowState<ConstPropLatticeElement> fState = node.getAnnotation();
     veritfyLatticeElementHas(fState.getIn(), var, constant);
   }
 
-  static void verifyOutHas(GraphNode<Instruction, Branch> node, Variable var,
-      Integer constant) {
+  static void verifyOutHas(
+      GraphNode<Instruction, Branch> node, Variable var, @Nullable Integer constant) {
     LinearFlowState<ConstPropLatticeElement> fState = node.getAnnotation();
     veritfyLatticeElementHas(fState.getOut(), var, constant);
   }
diff --git a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
index 6ae8928..cd41891 100644
--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
@@ -698,6 +698,31 @@ public final class DeadAssignmentsEliminationTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlocks() {
+    // TODO(b/240443227): Improve ClassStaticBlock optimization, dead code is not removed in
+    // expression.
+    testSame(
+        lines(
+            "class C{", //
+            "  static{",
+            "    var x;",
+            "    x = 1;",
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            " var x = 0;",
+            " print(x);",
+            "  x = 1;",
+            "  class C {",
+            "   static {",
+            "    print(x);",
+            "    }",
+            "  }"));
+  }
+
+  @Test
   public void testGenerators() {
     test(
         lines(
@@ -1054,7 +1079,7 @@ public final class DeadAssignmentsEliminationTest extends CompilerTestCase {
   }
 
   @Test
-  public void testClassField() {
+  public void testComputedClassField() {
     inFunction(
         lines(
             "let x;", //
@@ -1077,6 +1102,53 @@ public final class DeadAssignmentsEliminationTest extends CompilerTestCase {
             "  [x = 'field2'] = 7;",
             "}",
             "use(x);"));
+
+    inFunction(
+        lines(
+            "let x;", //
+            "class C {",
+            "  static field1 = x;",
+            "  [x = 'field2'] = 7;",
+            "}",
+            "use(C.field1);"),
+        lines(
+            "let x;", //
+            "class C {",
+            "  static field1 = x;",
+            // TODO(b/189993301): don't remove 'x = field2' because it's read by 'field1 = x'
+            "  ['field2'] = 7;",
+            "}",
+            "use(C.field1);"));
+  }
+
+  @Test
+  public void testComputedClassMethod() {
+    inFunction(
+        lines(
+            "let x;", //
+            "class C {",
+            // NOTE: it would be correct to eliminate the following two assignments
+            "  static [x = 'field1']() {}",
+            "  [x = 'field2']() {}",
+            "}"));
+
+    inFunction(
+        lines(
+            "let x;", //
+            "class C {",
+            "  static [x = 'field1']() {};",
+            "  [x = 'field2']() {}",
+            "}",
+            "use(x);"));
+
+    inFunction(
+        lines(
+            "let x;", //
+            "class C {",
+            "  static field1 = x;",
+            "  [x = 'field2']() {}",
+            "}",
+            "use(C.field1);"));
   }
 
   private void inFunction(String src) {
diff --git a/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java b/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
index c486d8d..c043019 100644
--- a/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
+++ b/test/com/google/javascript/jscomp/DeadPropertyAssignmentEliminationTest.java
@@ -33,26 +33,27 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
   @Test
   public void testBasic() {
-    testSame(lines(
-        "var foo = function() {",
-        "  this.a = 20;",
-        "}"));
+    testSame(
+        lines(
+            "var foo = function() {", //
+            "  this.a = 20;",
+            "}"));
 
     test(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = 10;",
             "  this.a = 20;",
             "}"),
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  10;",
             "  this.a = 20;",
             "}"));
 
     testSame(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = 20;",
             "  this.a = this.a + 20;",
             "}"));
@@ -62,13 +63,13 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testMultipleProperties() {
     test(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = 10;",
             "  this.b = 15;",
             "  this.a = 20;",
             "}"),
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  10;",
             "  this.b = 15;",
             "  this.a = 20;",
@@ -79,13 +80,13 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testNonStandardAssign() {
     test(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = 10;",
             "  this.a += 15;",
             "  this.a = 20;",
             "}"),
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = 10;",
             "  this.a + 15;",
             "  this.a = 20;",
@@ -96,12 +97,12 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testChainingPropertiesAssignments() {
     test(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = this.b = this.c = 10;",
             "  this.b = 15;",
             "}"),
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  this.a = this.c = 10;",
             "  this.b = 15;",
             "}"));
@@ -163,7 +164,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testQualifiedNamePrefixAssignment() {
     testSame(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  a.b.c = 20;",
             "  a.b = other;",
             "  a.b.c = 30;",
@@ -171,7 +172,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  a.b = 20;",
             "  a = other;",
             "  a.b = 30;",
@@ -182,7 +183,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testCall() {
     testSame(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  a.b.c = 20;",
             "  doSomething();",
             "  a.b.c = 30;",
@@ -257,7 +258,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
     // Assume that properties may be read during a yield
     testSame(
         lines(
-            "var foo = function*() {",
+            "var foo = function*() {", //
             "  a.b.c = 20;",
             "  yield;",
             "  a.b.c = 30;",
@@ -290,7 +291,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  a.b.c = 30;",
             "}"),
         lines(
-            "var foo = function*() {",
+            "var foo = function*() {", //
             "  20;",
             "  yield a.b.c = 25;",
             "  a.b.c = 30;",
@@ -302,7 +303,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
     // Assume that properties may be read during a constructor call
     testSame(
         lines(
-            "var foo = function() {",
+            "var foo = function() {", //
             "  a.b.c = 20;",
             "  new C;",
             "  a.b.c = 30;",
@@ -326,7 +327,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
     // Assume that properties may be read while waiting for "await"
     testSame(
         lines(
-            "async function foo() {",
+            "async function foo() {", //
             "  a.b.c = 20;",
             "  await bar;",
             "  a.b.c = 30;",
@@ -478,7 +479,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testBrackets() {
     testSame(
         lines(
-            "function f(x, p) {",
+            "function f(x, p) {", //
             "  x.prop = 123;",
             "  x[p] = 234;",
             "  return x.prop;",
@@ -491,7 +492,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testFor() {
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  for(;x;) {}",
             "  x.p = 2;",
@@ -499,7 +500,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  for(;x;) {",
             "    x.p = 1;",
             "  }",
@@ -508,7 +509,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  for(;;) {",
             "    x.p = 2;",
@@ -517,7 +518,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  for(x.p = 2;;) {",
             "  }",
@@ -534,7 +535,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  for(;;) {",
             "    x.p = 1;",
             "    x.p = 2;",
@@ -543,7 +544,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  for(;;) {",
             "  }",
@@ -557,7 +558,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testWhile() {
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  while(x);",
             "  x.p = 2;",
@@ -565,7 +566,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  while(1) {",
             "    x.p = 2;",
@@ -594,13 +595,13 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     test(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  while(x.p = 2) {",
             "  }",
             "}"),
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  1;",
             "  while(x.p = 2) {",
             "  }",
@@ -608,14 +609,14 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     test(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  while(true) {",
             "    x.p = 1;",
             "    x.p = 2;",
             "  }",
             "}"),
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  while(true) {",
             "    1;",
             "    x.p = 2;",
@@ -624,13 +625,13 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     test(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  while(1) {}",
             "  x.p = 2;",
             "}"),
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  1;",
             "  while(1) {}",
             "  x.p = 2;",
@@ -641,7 +642,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testTry() {
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 1;",
             "  try {",
             "    x.p = 2;",
@@ -678,7 +679,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  }",
             "}"),
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  try {",
             "    1;",
             "    x.p = 2;",
@@ -725,7 +726,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testThrow() {
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 10",
             "  if (random) throw err;",
             "  x.p = 20;",
@@ -733,7 +734,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  x.p = 10",
             "  throw err;",
             "  x.p = 20;",
@@ -820,7 +821,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  return x.p;",
             "}"),
         lines(
-            "function f(x, pred) {",
+            "function f(x, pred) {", //
             "  1;",
             "  if (pred) {}",
             "  x.p = 2;",
@@ -829,7 +830,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
     testSame(
         lines(
-            "function f(x, pred) {",
+            "function f(x, pred) {", //
             "  if (pred) {",
             "    x.p = 1;",
             "  }",
@@ -841,7 +842,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testCircularPropChain() {
     testSame(
         lines(
-            "function f(x, y) {",
+            "function f(x, y) {", //
             "  x.p = {};",
             "  x.p.y.p.z = 10;",
             "  x.p = {};",
@@ -852,7 +853,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testDifferentQualifiedNames() {
     testSame(
         lines(
-            "function f(x, y) {",
+            "function f(x, y) {", //
             "  x.p = 10;",
             "  y.p = 11;",
             "}"));
@@ -862,14 +863,14 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
   public void testGetPropContainsNonQualifiedNames() {
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  foo(x).p = 10;",
             "  foo(x).p = 11;",
             "}"));
 
     testSame(
         lines(
-            "function f(x) {",
+            "function f(x) {", //
             "  (x = 10).p = 10;",
             "  (x = 10).p = 11;",
             "}"));
@@ -906,7 +907,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  }",
             "}"),
         lines(
-            "class Foo {",
+            "class Foo {", //
             "  constructor() {",
             "    123;",
             "    this.p = 234;",
@@ -928,9 +929,64 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "    super();",
             "    this.x = 40;",
             "  }",
-            "}"
-        )
-    );
+            "}"));
+  }
+
+  @Test
+  public void testStaticBlock() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    this.p = 123;",
+            "    var z = this.p;",
+            "    this.p = 234;",
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    this.x = 20;",
+            "  }",
+            "}",
+            "class D extends C {",
+            "  static {",
+            "    this.x = 40;",
+            "  }",
+            "}"));
+
+    // TODO(b/235871861): Ideally the first assignment would be removed
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    this.p = 123;", // should get removed
+            "    this.p = 234;",
+            "  }",
+            "}"));
+
+    // TODO(b/235871861): Ideally the first assignment would be removed
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    let o = { prop : 2};",
+            "    o.prop = 123;", // should get removed
+            "    o.prop = 234;",
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            "let o = { prop : 2};",
+            "class C {",
+            "  static {",
+            "    o.prop = 20;", // should not get removed
+            "  }",
+            "}",
+            "o.prop;"));
   }
 
   @Test
@@ -1016,8 +1072,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  var ret = bar.baz;",
             "  bar.enabled = false;",
             "  return ret;",
-            "};")
-    );
+            "};"));
   }
 
   @Test
@@ -1064,8 +1119,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  var ret = bar.baz;",
             "  bar.enabled = false;",
             "  return ret;",
-            "};")
-    );
+            "};"));
 
     testSame(
         lines(
@@ -1128,8 +1182,7 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
             "  bar.enabled = true;",
             "  bar.baz = 10;",
             "  bar.enabled = false;",
-            "};")
-    );
+            "};"));
   }
 
   @Test
@@ -1504,13 +1557,13 @@ public class DeadPropertyAssignmentEliminationTest extends CompilerTestCase {
 
   @Test
   public void testPropertyDefinedInExterns() {
-    String externs = lines(
-        "var window = {};",
-        "/** @type {number} */ window.innerWidth",
-        "/** @constructor */",
-        "var Image = function() {};",
-        "/** @type {string} */ Image.prototype.src;"
-    );
+    String externs =
+        lines(
+            "var window = {};",
+            "/** @type {number} */ window.innerWidth",
+            "/** @constructor */",
+            "var Image = function() {};",
+            "/** @type {string} */ Image.prototype.src;");
 
     testSame(
         externs(externs),
diff --git a/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java b/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
index 2d144a3..3ca62a1 100644
--- a/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
+++ b/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
@@ -27,16 +27,13 @@ import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import com.google.javascript.rhino.Node;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link DevirtualizeMethods}
- *
- */
+/** Tests for {@link DevirtualizeMethods} */
 @RunWith(JUnit4.class)
 public final class DevirtualizeMethodsTest extends CompilerTestCase {
   private static final String EXTERNAL_SYMBOLS =
@@ -60,10 +57,8 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     disableTypeCheck();
   }
 
-  /**
-   * Combine source strings using ';' as the separator.
-   */
-  private static String semicolonJoin(String ... parts) {
+  /** Combine source strings using ';' as the separator. */
+  private static String semicolonJoin(String... parts) {
     return Joiner.on(";").join(parts);
   }
 
@@ -138,8 +133,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
         label);
   }
 
-  @Nullable
-  private static Node getLabelledExpressionIfPresent(String label, Node root) {
+  private static @Nullable Node getLabelledExpressionIfPresent(String label, Node root) {
     if (root.isLabel() && root.getFirstChild().getString().equals(label)) {
       Node labelledBlock = root.getSecondChild();
       checkState(labelledBlock.isBlock(), labelledBlock);
@@ -179,9 +173,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     test(source, expected);
   }
 
-  /**
-   * Inputs for declaration used as an r-value tests.
-   */
+  /** Inputs for declaration used as an r-value tests. */
   private static class NoRewriteDeclarationUsedAsRValue {
     static final String DECL = "a.prototype.foo = function() {}";
     static final String CALL = "o.foo()";
@@ -191,23 +183,27 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
 
   @Test
   public void testRewriteDeclIsExpressionStatement() {
-    test(semicolonJoin(NoRewriteDeclarationUsedAsRValue.DECL,
-                       NoRewriteDeclarationUsedAsRValue.CALL),
-         "var JSCompiler_StaticMethods_foo =" +
-         "function(JSCompiler_StaticMethods_foo$self) {};" +
-         "JSCompiler_StaticMethods_foo(o)");
+    test(
+        semicolonJoin(NoRewriteDeclarationUsedAsRValue.DECL, NoRewriteDeclarationUsedAsRValue.CALL),
+        "var JSCompiler_StaticMethods_foo ="
+            + "function(JSCompiler_StaticMethods_foo$self) {};"
+            + "JSCompiler_StaticMethods_foo(o)");
   }
 
   @Test
   public void testNoRewriteDeclUsedAsAssignmentRhs() {
-    testSame(semicolonJoin("var c = " + NoRewriteDeclarationUsedAsRValue.DECL,
-                           NoRewriteDeclarationUsedAsRValue.CALL));
+    testSame(
+        semicolonJoin(
+            "var c = " + NoRewriteDeclarationUsedAsRValue.DECL,
+            NoRewriteDeclarationUsedAsRValue.CALL));
   }
 
   @Test
   public void testNoRewriteDeclUsedAsCallArgument() {
-    testSame(semicolonJoin("f(" + NoRewriteDeclarationUsedAsRValue.DECL + ")",
-                           NoRewriteDeclarationUsedAsRValue.CALL));
+    testSame(
+        semicolonJoin(
+            "f(" + NoRewriteDeclarationUsedAsRValue.DECL + ")",
+            NoRewriteDeclarationUsedAsRValue.CALL));
   }
 
   @Test
@@ -228,6 +224,28 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "JSCompiler_StaticMethods_foo(o);"));
   }
 
+  @Test
+  public void noRewrite_forPropertyNamesAccessedReflectively() {
+    test(
+        externs("function use() {}"),
+        srcs(
+            lines(
+                "class C { m() {} n() {} }",
+                "const c = new C();",
+                "c.m();",
+                "c.n();",
+                // this call should prevent devirtualizing m() but not n()
+                "use(C.prototype, $jscomp.reflectProperty('m', C.prototype));")),
+        expected(
+            lines(
+                "var JSCompiler_StaticMethods_n = function(JSCompiler_StaticMethods_n$self) {};",
+                "class C { m() {} }",
+                "const c = new C();",
+                "c.m();",
+                "JSCompiler_StaticMethods_n(c);",
+                "use(C.prototype, $jscomp.reflectProperty('m', C.prototype));")));
+  }
+
   private void testNoRewriteIfDefinitionSiteBetween(String prefix, String suffix) {
     testSame(
         lines(
@@ -521,9 +539,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "alert(x.getFoo());"));
   }
 
-  /**
-   * Inputs for object literal tests.
-   */
+  /** Inputs for object literal tests. */
   private static class NoRewritePrototypeObjectLiteralsTestInput {
     static final String REGULAR = "b.prototype.foo = function() { return 1; }";
     static final String OBJ_LIT = "a.prototype = {foo : function() { return 2; }}";
@@ -561,9 +577,11 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
 
   @Test
   public void testNoRewrite_multipleDefinitions_definedUsingProtoObjectLit_definedUsingGetProp() {
-    testSame(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,
-                           NoRewritePrototypeObjectLiteralsTestInput.REGULAR,
-                           NoRewritePrototypeObjectLiteralsTestInput.CALL));
+    testSame(
+        semicolonJoin(
+            NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,
+            NoRewritePrototypeObjectLiteralsTestInput.REGULAR,
+            NoRewritePrototypeObjectLiteralsTestInput.CALL));
   }
 
   @Test
@@ -669,9 +687,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     testSame(source);
   }
 
-  /**
-   * Inputs for invalidating reference tests.
-   */
+  /** Inputs for invalidating reference tests. */
   private static class NoRewriteNonCallReferenceTestInput {
     static final String BASE =
         lines(
@@ -778,34 +794,30 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "new o.foo();"));
   }
 
-  /**
-   * Inputs for nested definition tests.
-   */
+  /** Inputs for nested definition tests. */
   private static class NoRewriteNestedFunctionTestInput {
     static final String PREFIX = "a.prototype.foo = function() {";
     static final String SUFFIX = "o.foo()";
     static final String INNER = "a.prototype.bar = function() {}; o.bar()";
     static final String EXPECTED_PREFIX =
-        "var JSCompiler_StaticMethods_foo=" +
-        "function(JSCompiler_StaticMethods_foo$self){";
-    static final String EXPECTED_SUFFIX =
-        "JSCompiler_StaticMethods_foo(o)";
+        "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self){";
+    static final String EXPECTED_SUFFIX = "JSCompiler_StaticMethods_foo(o)";
 
     private NoRewriteNestedFunctionTestInput() {}
   }
 
   @Test
   public void testRewriteNoNestedFunction() {
-    test(semicolonJoin(
-             NoRewriteNestedFunctionTestInput.PREFIX + "}",
-             NoRewriteNestedFunctionTestInput.SUFFIX,
-             NoRewriteNestedFunctionTestInput.INNER),
-         semicolonJoin(
-             NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + "}",
-             NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX,
-             "var JSCompiler_StaticMethods_bar=" +
-             "function(JSCompiler_StaticMethods_bar$self){}",
-             "JSCompiler_StaticMethods_bar(o)"));
+    test(
+        semicolonJoin(
+            NoRewriteNestedFunctionTestInput.PREFIX + "}",
+            NoRewriteNestedFunctionTestInput.SUFFIX,
+            NoRewriteNestedFunctionTestInput.INNER),
+        semicolonJoin(
+            NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + "}",
+            NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX,
+            "var JSCompiler_StaticMethods_bar=" + "function(JSCompiler_StaticMethods_bar$self){}",
+            "JSCompiler_StaticMethods_bar(o)"));
   }
 
   @Test
@@ -1350,6 +1362,36 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "console.log(new Foo().a);"));
   }
 
+  @Test
+  public void testStaticClassFieldNoRHS() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a;",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
+  @Test
+  public void testStaticClassFieldNonFunction() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a = 2;",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
+  @Test
+  public void testStaticClassFieldFunction() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a = function x() { return 5; };",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
   private static class ModuleTestInput {
     static final String DEFINITION = "a.prototype.foo = function() {}";
     static final String USE = "x.foo()";
diff --git a/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java b/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
index 91cdd67..1b66bf4 100644
--- a/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
+++ b/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
@@ -37,9 +37,14 @@ public final class DiagnosticGroupsTest {
   public void lintChecksGroupIsDisjointFromEveryOtherGroup() throws Exception {
     DiagnosticGroup lintChecks = DiagnosticGroups.LINT_CHECKS;
     for (DiagnosticGroup group : DiagnosticGroups.getRegisteredGroups().values()) {
-      // TODO(lharker): stop ignoring USE_OF_GOOG_PROVIDE after migrating rules_closure
-      // code to suppress useOfGoogProvide instead of lintChecks.
-      if (group.equals(lintChecks) || group.equals(DiagnosticGroups.USE_OF_GOOG_PROVIDE)) {
+      if (group.equals(lintChecks)
+          // TODO(lharker): stop ignoring USE_OF_GOOG_PROVIDE after migrating rules_closure
+          // code to suppress useOfGoogProvide instead of lintChecks.
+          || group.equals(DiagnosticGroups.USE_OF_GOOG_PROVIDE)
+          // We need a separate group for "lintVarDeclarations" so code that really cannot be
+          // updated to use only `let` and `const` can suppress the warnings about `var` without
+          // suppressing all lint checks.
+          || group.equals(DiagnosticGroups.LINT_VAR_DECLARATIONS)) {
         continue;
       }
       assertWithMessage(
diff --git a/test/com/google/javascript/jscomp/Es6CheckModuleTest.java b/test/com/google/javascript/jscomp/Es6CheckModuleTest.java
index 1e27636..bccfddb 100644
--- a/test/com/google/javascript/jscomp/Es6CheckModuleTest.java
+++ b/test/com/google/javascript/jscomp/Es6CheckModuleTest.java
@@ -62,6 +62,66 @@ public final class Es6CheckModuleTest extends CompilerTestCase {
             "exports = Foo;"));
   }
 
+  @Test
+  public void testThisWithStaticMethod() {
+    testSame("class Foo { static h() {var x = this.y;} }; exports = Foo;");
+    testSame("class Foo {static h() {this.x = 2; }}; exports = Foo;");
+    testSame("class Foo {static h() {this[this.x] = 3;}}; exports = Foo;");
+    testSame(
+        lines(
+            "class Foo {",
+            "  static h() {",
+            "    function g() {",
+            "      return this.f() + 1;",
+            "    }",
+            "    var y = g() + 1;",
+            "  }",
+            "  static f() {return 1;}",
+            "}",
+            "exports = Foo;"));
+    testSame(
+        lines(
+            "class Foo {",
+            "  static h() {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "  static click() {}",
+            "};",
+            "exports = Foo;"));
+  }
+
+  @Test
+  public void testThisWithStaticBlock() {
+    testSame("class Foo { static {var x = this.y;} }; exports = Foo;");
+    testSame("class Foo {static {this.x = 2; }}; exports = Foo;");
+    testSame("class Foo {static {this[this.x] = 3;}}; exports = Foo;");
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    function g() {",
+            "      return this.f() + 1;",
+            "    }",
+            "    var y = g() + 1;",
+            "  }",
+            "  static f() {return 1;}",
+            "}",
+            "exports = Foo;"));
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    button.addEventListener('click', function () {",
+            "      this.click();",
+            "    });",
+            "  }",
+            "  static click() {}",
+            "};",
+            "exports = Foo;"));
+  }
+
   // just here to make sure import.meta doesn't break anything
   @Test
   public void testImportMeta() {
diff --git a/test/com/google/javascript/jscomp/Es6ConvertSuperTest.java b/test/com/google/javascript/jscomp/Es6ConvertSuperTest.java
index 4a45d30..06bc6e6 100644
--- a/test/com/google/javascript/jscomp/Es6ConvertSuperTest.java
+++ b/test/com/google/javascript/jscomp/Es6ConvertSuperTest.java
@@ -15,7 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
 import static com.google.javascript.jscomp.testing.CodeSubTree.findClassDefinition;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
diff --git a/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java b/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
index b6a219d..76c4136 100644
--- a/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
+++ b/test/com/google/javascript/jscomp/Es6ExtractClassesTest.java
@@ -16,7 +16,7 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import org.junit.Before;
diff --git a/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java b/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
index b7b3f6e..4dd60cb 100644
--- a/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
+++ b/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
@@ -22,7 +22,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +32,7 @@ public class Es6RelativizeImportPathsTest extends CompilerTestCase {
 
   private ImmutableMap<String, String> prefixReplacements;
   private ResolutionMode moduleResolutionMode;
-  private List<String> moduleRoots;
+  private ImmutableList<String> moduleRoots;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclarationTest.java b/test/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclarationTest.java
index 381fabb..cdf833a 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclarationTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteBlockScopedDeclarationTest.java
@@ -48,6 +48,35 @@ public final class Es6RewriteBlockScopedDeclarationTest extends CompilerTestCase
   }
 
   @Test
+  public void testVarNameCollisionWithExterns() {
+    test(
+        externs("var url;"),
+        srcs("export {}; { const url = ''; alert(url);}"),
+        expected("export {}; { /** @const */ var url$0 = ''; alert(url$0); }"));
+
+    test(
+        externs("var url;" + DEFAULT_EXTERNS),
+        srcs("goog.module('main'); { const url = ''; alert(url);}"),
+        expected("goog.module('main'); { /** @const */ var url$0 = ''; alert(url$0); }"));
+
+    test(
+        externs("var url;"),
+        srcs("export {}; function foo() { const url = ''; alert(url);}"),
+        expected("export {}; function foo() { /** @const */ var url = ''; alert(url); }"));
+
+    test(
+        externs("var url;" + DEFAULT_EXTERNS),
+        srcs("goog.module('main'); function foo() { const url = ''; alert(url);}"),
+        expected(
+            "goog.module('main'); function foo() { /** @const */ var url = ''; alert(url); }"));
+
+    test(
+        externs("var url;" + DEFAULT_EXTERNS),
+        srcs("function foo() { const url = ''; alert(url);}"),
+        expected("function foo() { /** @const */ var url = ''; alert(url); }"));
+  }
+
+  @Test
   public void testSimple() {
     test("let x = 3;", "var x = 3;");
     test("const x = 3;", "/** @const */ var x = 3;");
diff --git a/test/com/google/javascript/jscomp/Es6RewriteClassTest.java b/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
index 439e34d..a6a0a43 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteClassTest.java
@@ -16,9 +16,8 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
 import static com.google.javascript.jscomp.TypedScopeCreator.DYNAMIC_EXTENDS_WITHOUT_JSDOC;
-import static com.google.javascript.jscomp.parsing.parser.FeatureSet.ES2015_MODULES;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
@@ -68,11 +67,7 @@ public final class Es6RewriteClassTest extends CompilerTestCase {
 
   private static PassFactory makePassFactory(
       String name, Function<AbstractCompiler, CompilerPass> pass) {
-    return PassFactory.builder()
-        .setName(name)
-        .setInternalFactory(pass)
-        .setFeatureSet(ES2015_MODULES)
-        .build();
+    return PassFactory.builder().setName(name).setInternalFactory(pass).build();
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
index 3e60386..f8e049a 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteGeneratorsTest.java
@@ -554,8 +554,9 @@ public final class Es6RewriteGeneratorsTest extends CompilerTestCase {
 
   @Test
   public void testGeneratorCannotConvertYet() {
-    testError("function *f(b, i) {switch (i) { case yield: return b; }}",
-        Es6ToEs3Util.CANNOT_CONVERT_YET);
+    testError(
+        "function *f(b, i) {switch (i) { case yield: return b; }}",
+        TranspilationUtil.CANNOT_CONVERT_YET);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
index 875bd34..54e2628 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
@@ -20,6 +20,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.modules.ModuleMapCreator;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesBeforeTypeCheckingTest extends CompilerTestCase {
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
 
   private static final SourceFile other =
       SourceFile.fromCode(
@@ -287,7 +288,7 @@ public final class Es6RewriteModulesBeforeTypeCheckingTest extends CompilerTestC
                     "/** @fileoverview @externs */",
                     "export let /** !number */ externalName;",
                     ""))),
-        error(Es6ToEs3Util.CANNOT_CONVERT_YET));
+        error(TranspilationUtil.CANNOT_CONVERT_YET));
   }
 
   @Test
@@ -1258,6 +1259,6 @@ public final class Es6RewriteModulesBeforeTypeCheckingTest extends CompilerTestC
   @Test
   public void testImportMeta() {
 
-    testError("import.meta", Es6ToEs3Util.CANNOT_CONVERT);
+    testError("import.meta", TranspilationUtil.CANNOT_CONVERT);
   }
 }
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
index f2036b7..26cf064 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
@@ -23,6 +23,7 @@ import com.google.javascript.jscomp.CompilerOptions.ChunkOutputType;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,7 +40,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesTest extends CompilerTestCase {
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
   private ChunkOutputType chunkOutputType = ChunkOutputType.GLOBAL_NAMESPACE;
 
   private static final SourceFile other =
@@ -300,7 +301,7 @@ public final class Es6RewriteModulesTest extends CompilerTestCase {
                     "/** @fileoverview @externs */",
                     "export let /** !number */ externalName;",
                     ""))),
-        error(Es6ToEs3Util.CANNOT_CONVERT_YET));
+        error(TranspilationUtil.CANNOT_CONVERT_YET));
   }
 
   @Test
@@ -1266,7 +1267,7 @@ public final class Es6RewriteModulesTest extends CompilerTestCase {
 
   @Test
   public void testImportMeta() {
-    testError("import.meta", Es6ToEs3Util.CANNOT_CONVERT);
+    testError("import.meta", TranspilationUtil.CANNOT_CONVERT);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
index c980857..01298d5 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,7 +27,7 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesToCommonJsModulesTest extends CompilerTestCase {
-  private List<String> moduleRoots;
+  private ImmutableList<String> moduleRoots;
   private ModuleLoader.ResolutionMode resolutionMode;
   private ImmutableMap<String, String> prefixReplacements;
   private PathEscaper pathEscaper;
@@ -496,7 +495,7 @@ public final class Es6RewriteModulesToCommonJsModulesTest extends CompilerTestCa
 
   @Test
   public void testProtocolInImportPathIsError() {
-    testError("import * as foo from 'file://imported.js';", Es6ToEs3Util.CANNOT_CONVERT);
+    testError("import * as foo from 'file://imported.js';", TranspilationUtil.CANNOT_CONVERT);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
index 262f83d..b999e9f 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
@@ -28,7 +28,6 @@ import static com.google.javascript.jscomp.RhinoErrorReporter.UNRECOGNIZED_TYPE_
 import static com.google.javascript.jscomp.TypeCheck.INEXISTENT_PROPERTY;
 import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY;
 import static com.google.javascript.jscomp.modules.EsModuleProcessor.NAMESPACE_IMPORT_CANNOT_USE_STAR;
-import static com.google.javascript.jscomp.modules.ModuleMapCreator.MISSING_NAMESPACE_IMPORT;
 
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
@@ -1099,8 +1098,7 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
 
   @Test
   public void testMissingRequireAssumesGoogProvide() {
-    ignoreWarnings(
-        MISSING_MODULE_OR_PROVIDE, MISSING_NAMESPACE_IMPORT, POSSIBLE_INEXISTENT_PROPERTY);
+    ignoreWarnings(MISSING_MODULE_OR_PROVIDE, POSSIBLE_INEXISTENT_PROPERTY);
 
     test(
         srcs(
diff --git a/test/com/google/javascript/jscomp/Es6SplitVariableDeclarationsTest.java b/test/com/google/javascript/jscomp/Es6SplitVariableDeclarationsTest.java
index c7381e2..e571579 100644
--- a/test/com/google/javascript/jscomp/Es6SplitVariableDeclarationsTest.java
+++ b/test/com/google/javascript/jscomp/Es6SplitVariableDeclarationsTest.java
@@ -79,7 +79,7 @@ public final class Es6SplitVariableDeclarationsTest extends CompilerTestCase {
 
   @Test
   public void testCannotSplitLabeledDeclaration() {
-    testError("label: var   [a] = [], b = 3;", Es6ToEs3Util.CANNOT_CONVERT_YET);
+    testError("label: var   [a] = [], b = 3;", TranspilationUtil.CANNOT_CONVERT_YET);
     // `label: let   [a] = [], b = 3;` and `label: const [a] = [], b = 3;` are syntax errors
   }
 
diff --git a/test/com/google/javascript/jscomp/Es6TranspilationIntegrationTest.java b/test/com/google/javascript/jscomp/Es6TranspilationIntegrationTest.java
index 276e74e..9e49ce7 100644
--- a/test/com/google/javascript/jscomp/Es6TranspilationIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/Es6TranspilationIntegrationTest.java
@@ -16,17 +16,15 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT;
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
 import static com.google.javascript.jscomp.TypeCheck.INSTANTIATE_ABSTRACT_CLASS;
-import static com.google.javascript.jscomp.parsing.parser.FeatureSet.ES2016_MODULES;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.serialization.ConvertTypesToColors;
 import com.google.javascript.jscomp.serialization.SerializationOptions;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
-import java.util.ArrayList;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -66,25 +64,23 @@ public final class Es6TranspilationIntegrationTest extends CompilerTestCase {
   protected CompilerPass getProcessor(final Compiler compiler) {
     PhaseOptimizer optimizer = new PhaseOptimizer(compiler, null);
 
-    ArrayList<PassFactory> passes = new ArrayList<>();
+    PassListBuilder passes = new PassListBuilder(compiler.getOptions());
 
-    passes.add(
+    passes.maybeAdd(
         PassFactory.builder()
             .setName("es6InjectRuntimeLibraries")
             .setInternalFactory(InjectTranspilationRuntimeLibraries::new)
-            .setFeatureSet(ES2016_MODULES)
             .build());
 
-    passes.add(
+    passes.maybeAdd(
         PassFactory.builder()
             .setName("convertTypesToColors")
             .setInternalFactory(
                 (c) -> new ConvertTypesToColors(c, SerializationOptions.INCLUDE_DEBUG_INFO))
-            .setFeatureSet(ES2016_MODULES)
             .build());
 
     TranspilationPasses.addEarlyOptimizationTranspilationPasses(passes, compiler.getOptions());
-    optimizer.consume(passes);
+    optimizer.consume(passes.build());
 
     return optimizer;
   }
@@ -1819,8 +1815,8 @@ public final class Es6TranspilationIntegrationTest extends CompilerTestCase {
         lines(
             "function f() {",
             "  if (true) {",
-            "    var Symbol = function() {};",
-            "    alert(Symbol.ism)",
+            "    var Symbol$0 = function() {};",
+            "    alert(Symbol$0.ism)",
             "  }",
             "}"));
     // No $jscomp.initSymbol in externs
diff --git a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
index de65d04..6ede713 100644
--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
@@ -36,7 +36,7 @@ import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.function.Function;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,7 +49,7 @@ public final class ExpressionDecomposerTest {
   private final Set<String> knownConstants = new HashSet<>();
 
   /** The language out to set in the compiler options. If null, use the default. */
-  @Nullable private LanguageMode languageOut;
+  private @Nullable LanguageMode languageOut;
   // Whether we should run type checking and test the type information in the output expression
   private boolean shouldTestTypes;
 
@@ -479,6 +479,42 @@ public final class ExpressionDecomposerTest {
         DecompositionType.UNDECOMPOSABLE,
         "[{ [foo()]: a } = goo()] = arr;",
         exprMatchesStr("foo()"));
+
+    helperExposeExpression(
+        lines(
+            "var Di = I(() => {",
+            "  function zv() {",
+            "    JSCOMPILER_PRESERVE(e), [getObj().propName] = CN();",
+            "  }",
+            "  function CN() {",
+            "    let t;",
+            "  }",
+            "});"),
+        exprMatchesStr("CN()"),
+        lines(
+            "var Di = I(() => {",
+            "  function zv() {",
+            "    var temp_const$jscomp$1 = JSCOMPILER_PRESERVE(e);",
+            "    var temp_const$jscomp$0 = getObj().propName;",
+            "    temp_const$jscomp$1, [temp_const$jscomp$0] = CN();",
+            "  }",
+            "  function CN() {",
+            "    let t;",
+            "  }",
+            "});"));
+
+    helperCanExposeExpression(
+        DecompositionType.DECOMPOSABLE,
+        lines(
+            "var Di = I(() => {",
+            "  function zv() {",
+            "    JSCOMPILER_PRESERVE(e), [f] = CN();",
+            "  }",
+            "  function CN() {",
+            "    let t;",
+            "  }",
+            "});"),
+        exprMatchesStr("CN()"));
   }
 
   @Test
@@ -1382,6 +1418,25 @@ public final class ExpressionDecomposerTest {
   }
 
   @Test
+  public void testExposeTemplateLiteralFreeCall() {
+    helperExposeExpression(
+        "foo`${x()}${y()}`",
+        exprMatchesStr("y()"),
+        lines(
+            "var temp_const$jscomp$1 = foo;",
+            "var temp_const$jscomp$0 = x();",
+            "temp_const$jscomp$1`${temp_const$jscomp$0}${y()}`;"));
+  }
+
+  @Test
+  public void testCanExposeTaggedTemplateLiteralInterpolation() {
+    helperCanExposeExpression(DecompositionType.DECOMPOSABLE, "x`${y()}`", exprMatchesStr("y()"));
+    // TODO(b/251958225): Implement decomposition for this case.
+    helperCanExposeExpression(
+        DecompositionType.UNDECOMPOSABLE, "x.foo`${y()}`", exprMatchesStr("y()"));
+  }
+
+  @Test
   public void testExposeExpression18() {
     helperExposeExpression(
         lines("const {a, b, c} = condition ?", "  y() :", "  {a: 0, b: 0, c: 1};"),
@@ -1667,10 +1722,10 @@ public final class ExpressionDecomposerTest {
         exprMatchesStr("foo()"),
         lines(
             "let x = {};", //
-            "let $jscomp$logical$assign$tmpm1879438141$0;",
-            "if (($jscomp$logical$assign$tmpm1879438141$0 = x).a) {",
+            "let $jscomp$logical$assign$tmpm1146332801$0;",
+            "if (($jscomp$logical$assign$tmpm1146332801$0 = x).a) {",
             "} else {",
-            "   var temp_const$jscomp$1 = $jscomp$logical$assign$tmpm1879438141$0;",
+            "   var temp_const$jscomp$1 = $jscomp$logical$assign$tmpm1146332801$0;",
             "   temp_const$jscomp$1.a = foo() + 1;",
             "}"));
     helperExposeExpression(
@@ -1678,12 +1733,12 @@ public final class ExpressionDecomposerTest {
         exprMatchesStr("foo()"),
         lines(
             "let x = {};", //
-            "let $jscomp$logical$assign$tmpm1879438141$0;",
-            "let $jscomp$logical$assign$tmpindexm1879438141$0;",
-            "if (($jscomp$logical$assign$tmpm1879438141$0 = x)",
-            "    [$jscomp$logical$assign$tmpindexm1879438141$0 = a]) {",
-            "    var temp_const$jscomp$2 = $jscomp$logical$assign$tmpm1879438141$0;",
-            "    var temp_const$jscomp$1 = $jscomp$logical$assign$tmpindexm1879438141$0;",
+            "let $jscomp$logical$assign$tmpm1146332801$0;",
+            "let $jscomp$logical$assign$tmpindexm1146332801$0;",
+            "if (($jscomp$logical$assign$tmpm1146332801$0 = x)",
+            "    [$jscomp$logical$assign$tmpindexm1146332801$0 = a]) {",
+            "    var temp_const$jscomp$2 = $jscomp$logical$assign$tmpm1146332801$0;",
+            "    var temp_const$jscomp$1 = $jscomp$logical$assign$tmpindexm1146332801$0;",
             "    temp_const$jscomp$2[temp_const$jscomp$1] = foo() + 1;",
             "}"));
   }
@@ -2154,8 +2209,7 @@ public final class ExpressionDecomposerTest {
     compiler.setTypeCheckingHasRun(true);
   }
 
-  @Nullable
-  private static Node findClass(Node n) {
+  private static @Nullable Node findClass(Node n) {
     if (n.isClass()) {
       return n;
     }
diff --git a/test/com/google/javascript/jscomp/ExternExportsPassTest.java b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
index 9dcebcf..494912a 100644
--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java
+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
@@ -19,6 +19,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import java.util.function.Consumer;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -1723,14 +1724,15 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   }
 
   /**
-   * Compiles the passed in JavaScript with the passed in externs and returns
-   * the new externs exported by the this pass.
+   * Compiles the passed in JavaScript with the passed in externs and returns the new externs
+   * exported by the this pass.
    *
    * @param js the source to be compiled
    * @param externs the externs the {@code js} source needs
    * @param consumer consumer for the externs generated from {@code js}
    */
-  private void compileAndExportExterns(String js, String externs, final Consumer<String> consumer) {
+  private void compileAndExportExterns(
+      String js, String externs, final @Nullable Consumer<String> consumer) {
     js = lines(
         "/** @const */ var goog = {};",
         "goog.exportSymbol = function(a, b) {};",
diff --git a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
index f90072a..b1cdaf9 100644
--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.jscomp.deps.ModuleLoader.LOAD_WARNING;
 import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;
 import com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormat;
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -362,7 +363,7 @@ public final class ExtractPrototypeMemberDeclarationsTest extends CompilerTestCa
     return generateExtractedDeclarations(num, null);
   }
 
-  private String generateExtractedDeclarations(int num, Integer fileIndex) {
+  private String generateExtractedDeclarations(int num, @Nullable Integer fileIndex) {
     StringBuilder builder = new StringBuilder();
 
     String alias = TMP;
diff --git a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
index f9bbe22..da4bf36 100644
--- a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
+++ b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
@@ -54,7 +54,11 @@ public final class FixedPointGraphTraversalTest {
 
   private DiGraph<Counter, String> graph;
 
-  private Counter A, B, C, D, E;
+  private Counter A;
+  private Counter B;
+  private Counter C;
+  private Counter D;
+  private Counter E;
   private final CounterIncrementer callback = new CounterIncrementer();
   private FixedPointGraphTraversal<Counter, String> traversal =
       FixedPointGraphTraversal.newTraversal(callback);
diff --git a/test/com/google/javascript/jscomp/FunctionInjectorTest.java b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
index 4b9ebcd..a35675c 100644
--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
@@ -30,7 +30,6 @@ import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;
 import com.google.javascript.jscomp.FunctionInjector.InliningMode;
 import com.google.javascript.jscomp.FunctionInjector.Reference;
 import com.google.javascript.rhino.Node;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -46,7 +45,7 @@ public final class FunctionInjectorTest {
   static final InliningMode INLINE_DIRECT = InliningMode.DIRECT;
   static final InliningMode INLINE_BLOCK = InliningMode.BLOCK;
   private boolean assumeStrictThis = false;
-  private final boolean assumeMinimumCapture = false;
+  private static final boolean ASSUME_MINIMUM_CAPTURE = false;
   private boolean allowDecomposition;
 
   @Before
@@ -1855,7 +1854,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .functionArgumentInjector(functionArgumentInjector)
             .build();
     final Node tree = parse(compiler, code);
@@ -1904,8 +1903,7 @@ public final class FunctionInjectorTest {
       String code, final String expectedResult,
       final String fnName, final InliningMode mode) {
     final Compiler compiler = new Compiler();
-    List<SourceFile> externsInputs = ImmutableList.of(
-        SourceFile.fromCode("externs", ""));
+    ImmutableList<SourceFile> externsInputs = ImmutableList.of(SourceFile.fromCode("externs", ""));
 
     CompilerOptions options = new CompilerOptions();
     options.setCodingConvention(new GoogleCodingConvention());
@@ -1918,7 +1916,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .functionArgumentInjector(functionArgumentInjector)
             .build();
 
@@ -2006,7 +2004,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .build();
     final Node tree = parse(compiler, code);
 
diff --git a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
index 025df58..e957d6b 100644
--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -273,7 +274,8 @@ public final class FunctionToBlockMutatorTest {
     helperMutate(code, expectedResult, fnName, "result");
   }
 
-  public void helperMutate(String code, String expectedResult, String fnName, String resultName) {
+  public void helperMutate(
+      String code, String expectedResult, String fnName, @Nullable String resultName) {
     final Compiler compiler = new Compiler();
     compiler.initCompilerOptionsIfTesting();
     final FunctionToBlockMutator mutator = new FunctionToBlockMutator(
diff --git a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
index 54d13a4..7e32195 100644
--- a/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
+++ b/test/com/google/javascript/jscomp/GatherModuleMetadataTest.java
@@ -463,7 +463,7 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
         ClosurePrimitiveErrors.DUPLICATE_NAMESPACE_AND_MODULE);
     testError(
         srcs("goog.module('duplciated');", "goog.provide('duplciated');"),
-        ClosurePrimitiveErrors.DUPLICATE_MODULE);
+        ClosurePrimitiveErrors.DUPLICATE_NAMESPACE_AND_MODULE);
   }
 
   @Test
@@ -473,7 +473,7 @@ public final class GatherModuleMetadataTest extends CompilerTestCase {
         ClosurePrimitiveErrors.DUPLICATE_NAMESPACE_AND_MODULE);
     testError(
         srcs("export {}; goog.declareModuleId('duplciated');", "goog.provide('duplciated');"),
-        ClosurePrimitiveErrors.DUPLICATE_MODULE);
+        ClosurePrimitiveErrors.DUPLICATE_NAMESPACE_AND_MODULE);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/GatherRawExportsTest.java b/test/com/google/javascript/jscomp/GatherRawExportsTest.java
index 09fb38e..8c6e5f3 100644
--- a/test/com/google/javascript/jscomp/GatherRawExportsTest.java
+++ b/test/com/google/javascript/jscomp/GatherRawExportsTest.java
@@ -19,7 +19,6 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -234,7 +233,7 @@ public final class GatherRawExportsTest extends CompilerTestCase {
   }
 
   private void assertExported(String js, String ... names) {
-    Set<String> setNames = ImmutableSet.copyOf(names);
+    ImmutableSet<String> setNames = ImmutableSet.copyOf(names);
     testSame(js);
     assertThat(last.getExportedVariableNames()).isEqualTo(setNames);
   }
diff --git a/test/com/google/javascript/jscomp/GenerateExportsTest.java b/test/com/google/javascript/jscomp/GenerateExportsTest.java
index 0e96765..81f6c1c 100644
--- a/test/com/google/javascript/jscomp/GenerateExportsTest.java
+++ b/test/com/google/javascript/jscomp/GenerateExportsTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,8 +36,8 @@ public final class GenerateExportsTest extends CompilerTestCase {
           "goog.exportProperty = function(a, b, c) {};");
 
   private boolean allowNonGlobalExports = true;
-  private String exportSymbolFunction;
-  private String exportPropertyFunction;
+  private @Nullable String exportSymbolFunction;
+  private @Nullable String exportPropertyFunction;
 
   public GenerateExportsTest() {
     super(EXTERNS);
@@ -371,6 +372,61 @@ public final class GenerateExportsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testCannotExportEs6StaticBlockInClassExpressionInReturnExpression() {
+    testError(
+        lines(
+            "function f() {", //
+            "  return class {",
+            "    /** @export */ static {}",
+            "  }",
+            "};"),
+        FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);
+  }
+
+  @Test
+  public void testCannotExportStaticBlock() {
+    testError(
+        lines(
+            "class G {", //
+            "/** @export */ static {}",
+            "}"),
+        FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);
+  }
+
+  @Test
+  public void testExportClassMemberInStaticBlock() {
+    allowExternsChanges();
+    String code = "class G { static { /** @export */ this.foo = 1;} }";
+    testSame(code);
+    testExternChanges(srcs(code), expected("Object.prototype.foo;"));
+  }
+
+  @Test
+  public void testClassMemberExportDoesntConflictInStaticBlock() {
+    allowExternsChanges();
+    String code =
+        lines(
+            "/** @export */", //
+            "class G {",
+            "  static {",
+            // TODO(b/235871861): Either generate an export for this property or report an error for
+            // it.
+            "    /** @export */ this.foo=1;",
+            "  }",
+            "}");
+    String result =
+        lines(
+            "/** @export */", //
+            "class G {",
+            "  static {",
+            "    /** @export */ this.foo=1;}",
+            "  }",
+            "goog.exportSymbol('G', G);");
+    test(code, result);
+    testExternChanges(srcs(code), expected("Object.prototype.foo;var goog;"));
+  }
+
+  @Test
   public void testGoogScopeFunctionOutput() {
     test(
         "/** @export */ $jscomp.scope.foo = /** @export */ function() {}",
@@ -524,4 +580,3 @@ public final class GenerateExportsTest extends CompilerTestCase {
     testSame(srcs("function Foo() {}"));
   }
 }
-
diff --git a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
index cb2305a..f209d2f 100644
--- a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
+++ b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
@@ -26,6 +26,7 @@ import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.GlobalNamespace.AstChange;
 import com.google.javascript.jscomp.GlobalNamespace.Inlinability;
@@ -39,8 +40,7 @@ import com.google.javascript.rhino.JSTypeExpression;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSType;
-import java.util.Collection;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -49,7 +49,8 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class GlobalNamespaceTest {
 
-  @Nullable private Compiler lastCompiler = null;
+  private @Nullable Compiler lastCompiler = null;
+  private boolean assumeStaticInheritanceIsNotUsed = true;
 
   @Test
   public void detectsPropertySetsInAssignmentOperators() {
@@ -529,9 +530,9 @@ public final class GlobalNamespaceTest {
     Name foo = namespace.getOwnSlot("Foo");
     Name bar = namespace.getOwnSlot("Bar");
     Name baz = namespace.getOwnSlot("Baz");
-    Collection<Ref> originalFooRefs = ImmutableList.copyOf(foo.getRefs());
-    Collection<Ref> originalBarRefs = ImmutableList.copyOf(bar.getRefs());
-    Collection<Ref> originalBazRefs = ImmutableList.copyOf(baz.getRefs());
+    ImmutableList<Ref> originalFooRefs = ImmutableList.copyOf(foo.getRefs());
+    ImmutableList<Ref> originalBarRefs = ImmutableList.copyOf(bar.getRefs());
+    ImmutableList<Ref> originalBazRefs = ImmutableList.copyOf(baz.getRefs());
 
     // Rescan all of the nodes for which we got refs as if they were newly added
     Node root = lastCompiler.getJsRoot();
@@ -740,6 +741,28 @@ public final class GlobalNamespaceTest {
   }
 
   @Test
+  public void testLocalVarsDefinedinStaticBlocks() {
+    GlobalNamespace namespace = parse("class C{ static{ var x; }}");
+    assertThat(namespace.getSlot("x")).isNull();
+  }
+
+  @Test
+  public void testAddPropertytoGlobalObjectinClassStaticBlock() {
+    GlobalNamespace namespace = parse("const a = {}; class C{ static { a.b = 1;}}");
+
+    Name a = namespace.getSlot("a");
+
+    assertThat(a.getGlobalSets()).isEqualTo(1);
+    assertThat(a.getTotalSets()).isEqualTo(1);
+
+    Name ab = namespace.getSlot("a.b");
+
+    assertThat(ab.getParent()).isEqualTo(a);
+    assertThat(ab.getGlobalSets()).isEqualTo(0);
+    assertThat(ab.getLocalSets()).isEqualTo(1);
+  }
+
+  @Test
   public void testDirectGets() {
     // None of the symbol uses here should be considered aliasing gets.
     GlobalNamespace namespace =
@@ -1215,6 +1238,19 @@ public final class GlobalNamespaceTest {
   }
 
   @Test
+  public void testCannotCollapseOrInlineDeletedProperty() {
+    GlobalNamespace namespace =
+        parse(
+            lines(
+                "const global = window;", //
+                "delete global.HTMLElement;",
+                "global.HTMLElement = (class {});"));
+
+    Name deletedProp = namespace.getSlot("global.HTMLElement");
+    assertThat(deletedProp.canCollapseOrInline()).isEqualTo(Inlinability.DO_NOT_INLINE);
+  }
+
+  @Test
   public void testCanCollapse_objectLitProperty_declaredBeforeASpread() {
     GlobalNamespace namespace = parse("var foo = {prop: 0, ...bar}; use(foo.prop);");
 
@@ -1447,20 +1483,11 @@ public final class GlobalNamespaceTest {
     assertThat(x.getDeclaration()).isNotNull();
   }
 
-  private boolean assumeStaticInheritanceIsNotUsed = true;
-
   // This method exists for testing module metadata lookups.
   private GlobalNamespace parseAndGatherModuleData(String js) {
-    Compiler compiler = new Compiler();
-    CompilerOptions options = new CompilerOptions();
-    // Don't optimize, because we want to know how GlobalNamespace responds to the original code
-    // in `js`.
-    options.setSkipNonTranspilationPasses(true);
-    options.setWrapGoogModulesForWhitespaceOnly(false);
-    // Test the latest features supported for input and don't transpile, because we want to test how
-    // GlobalNamespace deals with the language features actually present in `js`.
-    options.setAssumeStaticInheritanceIsNotUsed(assumeStaticInheritanceIsNotUsed);
-    compiler.compile(SourceFile.fromCode("ex.js", ""), SourceFile.fromCode("test.js", js), options);
+    CompilerOptions options = getDefaultOptions();
+    Compiler compiler = compile(js, options);
+
     // Disabling transpilation also disables these passes that we need to have run when
     // testing behavior related to module metadata.
     new GatherModuleMetadata(
@@ -1470,24 +1497,34 @@ public final class GlobalNamespaceTest {
         .process(compiler.getExternsRoot(), compiler.getJsRoot());
     assertThat(compiler.getErrors()).isEmpty();
     this.lastCompiler = compiler;
-
     return new GlobalNamespace(compiler, compiler.getRoot());
   }
 
   private GlobalNamespace parse(String js) {
-    Compiler compiler = new Compiler();
+    CompilerOptions options = getDefaultOptions();
+    compile(js, options);
+    return new GlobalNamespace(this.lastCompiler, this.lastCompiler.getRoot());
+  }
+
+  private CompilerOptions getDefaultOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguage(LanguageMode.UNSUPPORTED);
     // Don't optimize, because we want to know how GlobalNamespace responds to the original code
     // in `js`.
     options.setSkipNonTranspilationPasses(true);
+    options.setWrapGoogModulesForWhitespaceOnly(false);
     // Test the latest features supported for input and don't transpile, because we want to test how
     // GlobalNamespace deals with the language features actually present in `js`.
     options.setAssumeStaticInheritanceIsNotUsed(assumeStaticInheritanceIsNotUsed);
+    return options;
+  }
+
+  @CanIgnoreReturnValue
+  private Compiler compile(String js, CompilerOptions options) {
+    Compiler compiler = new Compiler();
     compiler.compile(SourceFile.fromCode("ex.js", ""), SourceFile.fromCode("test.js", js), options);
     assertThat(compiler.getErrors()).isEmpty();
     this.lastCompiler = compiler;
-
-    return new GlobalNamespace(compiler, compiler.getRoot());
+    return compiler;
   }
 }
diff --git a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
index bf17238..1e9089a 100644
--- a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
@@ -56,7 +56,7 @@ public final class GoogleCodingConventionTest {
   }
 
   @Test
-  public void testInlineName() {
+  public void testIsConstant() {
     assertThat(conv.isConstant("a")).isFalse();
     assertThat(conv.isConstant("XYZ123_")).isTrue();
     assertThat(conv.isConstant("ABC")).isTrue();
@@ -72,6 +72,21 @@ public final class GoogleCodingConventionTest {
     assertThat(conv.isConstant("a$b$aBC")).isFalse();
     assertThat(conv.isConstant("a$b$")).isFalse();
     assertThat(conv.isConstant("$")).isFalse();
+    assertThat(conv.isConstant("$A")).isTrue();
+    assertThat(conv.isConstant("$a")).isFalse();
+  }
+
+  @Test
+  public void testIsConstantKey() {
+    assertThat(conv.isConstantKey("a")).isFalse();
+    assertThat(conv.isConstantKey("XYZ123_")).isTrue();
+    assertThat(conv.isConstantKey("ABC")).isTrue();
+    assertThat(conv.isConstantKey("ABCdef")).isFalse();
+    assertThat(conv.isConstantKey("aBC")).isFalse();
+    assertThat(conv.isConstantKey("A")).isTrue();
+    assertThat(conv.isConstantKey("_XYZ123")).isFalse();
+    assertThat(conv.isConstantKey("a$b$ABC")).isFalse();
+    assertThat(conv.isConstantKey("$")).isFalse();
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/GuardedCallbackTest.java b/test/com/google/javascript/jscomp/GuardedCallbackTest.java
index aadb2d0..81fa1fd 100644
--- a/test/com/google/javascript/jscomp/GuardedCallbackTest.java
+++ b/test/com/google/javascript/jscomp/GuardedCallbackTest.java
@@ -40,7 +40,7 @@ public final class GuardedCallbackTest extends CompilerTestCase {
    * Replaces all guarded name and property references with "GUARDED_NAME" and "GUARDED_PROP",
    * respectively.
    */
-  private class GuardSwitchingCallback extends GuardedCallback<String> {
+  private static class GuardSwitchingCallback extends GuardedCallback<String> {
 
     GuardSwitchingCallback(AbstractCompiler compiler) {
       super(compiler);
diff --git a/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java b/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
index 5bd8eba..1315969 100644
--- a/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
+++ b/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
@@ -16,11 +16,14 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.javascript.jscomp.base.JSCompStrings.lines;
+import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DIAGNOSTIC_EQUALITY;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
-import java.util.Set;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,16 +31,24 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public class InjectTranspilationRuntimeLibrariesTest {
 
+  private NoninjectingCompiler compiler;
+  private LanguageMode languageOut;
+
+  @Before
+  public void setup() {
+    compiler = new NoninjectingCompiler();
+    languageOut = LanguageMode.ECMASCRIPT5;
+  }
+
   /**
    * Parses the given code and runs the {@link InjectTranspilationRuntimeLibraries} pass over the
    * resulting AST
    *
    * @return the set of paths to all the injected libraries
    */
-  private Set<String> parseAndRunInjectionPass(String js) {
-    NoninjectingCompiler compiler = new NoninjectingCompiler();
+  private ImmutableSet<String> parseAndRunInjectionPass(String js) {
     CompilerOptions options = new CompilerOptions();
-    options.setLanguageOut(LanguageMode.ECMASCRIPT5);
+    options.setLanguageOut(this.languageOut);
 
     compiler.init(
         ImmutableList.of(SourceFile.fromCode("externs", "")),
@@ -52,62 +63,96 @@ public class InjectTranspilationRuntimeLibrariesTest {
 
   @Test
   public void testEmptyInjected() {
-    Set<String> injected = parseAndRunInjectionPass("");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("");
 
     assertThat(injected).isEmpty();
   }
 
   @Test
   public void testMakeIteratorAndObjectAssignInjectedForObjectPatternRest() {
-    Set<String> injected = parseAndRunInjectionPass("const {a, ...rest} = something();");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("const {a, ...rest} = something();");
     assertThat(injected).containsExactly("es6/util/makeiterator", "es6/object/assign");
   }
 
   @Test
   public void testObjectAssignInjectedForObjectSpread() {
-    Set<String> injected = parseAndRunInjectionPass("const obj = {a, ...rest};");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("const obj = {a, ...rest};");
     assertThat(injected).containsExactly("es6/object/assign");
   }
 
   @Test
   public void testForOf_injectsMakeIterator() {
-    Set<String> injected = parseAndRunInjectionPass("for (x of []) {}");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("for (x of []) {}");
 
     assertThat(injected).containsExactly("es6/util/makeiterator");
   }
 
   @Test
   public void testArrayPattern_injectsMakeIterator() {
-    Set<String> injected = parseAndRunInjectionPass("var [a] = [];");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var [a] = [];");
 
     assertThat(injected).containsExactly("es6/util/makeiterator");
   }
 
   @Test
   public void testObjectPattern_injectsNothing() {
-    Set<String> injected = parseAndRunInjectionPass("var {a} = {};");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var {a} = {};");
 
     assertThat(injected).isEmpty();
   }
 
   @Test
   public void testArrayPatternRest_injectsArrayFromIterator() {
-    Set<String> injected = parseAndRunInjectionPass("var [...a] = [];");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var [...a] = [];");
 
     assertThat(injected).containsExactly("es6/util/makeiterator", "es6/util/arrayfromiterator");
   }
 
   @Test
   public void testArrayPatternRest_injectsExecuteAsyncFunctionSupport() {
-    Set<String> injected = parseAndRunInjectionPass("async function foo() {}");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("async function foo() {}");
 
     assertThat(injected).containsExactly("es6/execute_async_generator");
   }
 
   @Test
   public void testTaggedTemplateFirstArgCreaterInjected() {
-    Set<String> injected = parseAndRunInjectionPass("function tag(...a) {}; tag`hello`;");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("function tag(...a) {}; tag`hello`;");
     assertThat(injected)
         .containsExactly("es6/util/createtemplatetagfirstarg", "es6/util/restarguments");
   }
+
+  @Test
+  public void testAllowsEs5GetterSetterWithEs5Out() {
+    this.languageOut = LanguageMode.ECMASCRIPT5;
+    parseAndRunInjectionPass(
+        lines(
+            "var o = {", //
+            "  get x() {},",
+            "  set x(val) {}",
+            "};"));
+
+    assertThat(compiler.getErrors()).isEmpty();
+    assertThat(compiler.getInjected()).isEmpty();
+  }
+
+  @Test
+  public void testCannotConvertEs5GetterToEs3() {
+    this.languageOut = LanguageMode.ECMASCRIPT3;
+    parseAndRunInjectionPass("var o = {get x() {}};");
+
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
+        .containsExactly(TranspilationUtil.CANNOT_CONVERT);
+  }
+
+  @Test
+  public void testCannotConvertEs5SetterToEs3() {
+    this.languageOut = LanguageMode.ECMASCRIPT3;
+    parseAndRunInjectionPass("var o = {set x(val) {}};");
+
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
+        .containsExactly(TranspilationUtil.CANNOT_CONVERT);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
index ef5014d..e1e8785 100644
--- a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
@@ -18,10 +18,13 @@ package com.google.javascript.jscomp;
 
 import static com.google.javascript.jscomp.InlineAndCollapseProperties.PARTIAL_NAMESPACE_WARNING;
 import static com.google.javascript.jscomp.InlineAndCollapseProperties.RECEIVER_AFFECTED_BY_COLLAPSE;
+import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.javascript.jscomp.CompilerOptions.ChunkOutputType;
 import com.google.javascript.jscomp.CompilerOptions.PropertyCollapseLevel;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.testing.NodeSubject;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,6 +42,8 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
           "/** @constructor */ function String() {};",
           "var arguments");
 
+  private boolean assumeStaticInheritanceIsNotUsed = true;
+
   public InlineAndCollapsePropertiesTest() {
     super(EXTERNS);
   }
@@ -50,6 +55,7 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
         .setChunkOutputType(ChunkOutputType.GLOBAL_NAMESPACE)
         .setHaveModulesBeenRewritten(false)
         .setModuleResolutionMode(ResolutionMode.BROWSER)
+        .setAssumeStaticInheritanceIsNotUsed(this.assumeStaticInheritanceIsNotUsed)
         .build();
   }
 
@@ -62,6 +68,16 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDoNotCollapseDeletedProperty() {
+    testSame(
+        srcs(
+            lines(
+                "const global = window;", //
+                "delete global.HTMLElement;",
+                "global.HTMLElement = (class {});")));
+  }
+
+  @Test
   public void testConstObjRefInTemplateLiteralComputedPropKey() {
     test(
         srcs(
@@ -264,6 +280,121 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testCollapseKeepsSourceInfoForAliases() {
+    test(
+        lines(
+            "var a = {};",
+            "a.use = function(arg) {};",
+            "a.b = {};",
+            "var c = a.b;",
+            "a.use(c);",
+            ""),
+        lines(
+            "var a$use = function (arg) { };", //
+            "var a$b = {};",
+            "var c = null;",
+            "a$use(a$b);",
+            ""));
+
+    final Node scriptNode =
+        getLastCompiler()
+            .getRoot()
+            .getLastChild() // sources root
+            .getOnlyChild(); // only one source file
+    assertNode(scriptNode).isScript().hasXChildren(4);
+    final Node statement1 = scriptNode.getFirstChild();
+    final Node statement2 = statement1.getNext();
+    final Node statement3 = statement2.getNext();
+    final Node statement4 = statement3.getNext();
+    final String scriptName = scriptNode.getSourceFileName();
+
+    // Original line 2: `a.use = function(arg) {};`
+    // Compiled line 1: `var a$use = function(arg) {};`
+    assertNode(statement1)
+        .isVar()
+        .hasSourceFileName(scriptName)
+        .hasLineno(2)
+        .hasCharno(0)
+        .hasOneChildThat() // `a$use = function(arg) {};
+        .isName("a$use")
+        .hasSourceFileName(scriptName)
+        .hasLineno(2)
+        .hasCharno(0) // `a.use = ` was the beginning of the line
+        .hasOneChildThat() // `function(arg) {}`
+        .isFunction()
+        .hasSourceFileName(scriptName)
+        .hasLineno(2)
+        .hasCharno(8); // `a.use = ` 8 chars
+
+    // Original line 3: `a.b = {};`
+    // Compiled line 2: `var a$b = {};`
+    assertNode(statement2)
+        .isVar()
+        .hasSourceFileName(scriptName)
+        .hasLineno(3)
+        .hasCharno(0)
+        .hasOneChildThat() // a$b = {}
+        .isName("a$b")
+        .hasSourceFileName(scriptName)
+        .hasLineno(3)
+        .hasCharno(0)
+        .hasOneChildThat() // {}
+        .isObjectLit()
+        .hasSourceFileName(scriptName)
+        .hasLineno(3)
+        .hasCharno(6);
+
+    // Original line 4: `var c = a.b;`
+    // Compiled line 3: `var c = null;`
+    assertNode(statement3)
+        .isVar()
+        .hasSourceFileName(scriptName)
+        .hasLineno(4)
+        .hasCharno(0)
+        .hasOneChildThat() // c = a.b
+        .isName("c")
+        .hasSourceFileName(scriptName)
+        .hasLineno(4)
+        .hasCharno(4)
+        .hasOneChildThat() // null
+        .isNullNode()
+        .hasSourceFileName(scriptName)
+        .hasLineno(4)
+        .hasCharno(10);
+
+    // Original line 5: `a.use(c);`
+    // Compiled line 4: `a$use(a$b);`
+    final NodeSubject callNodeSubject =
+        assertNode(statement4)
+            .isExprResult()
+            .hasSourceFileName(scriptName)
+            .hasLineno(5)
+            .hasCharno(0)
+            .hasOneChildThat() // a.use(c)
+            .isCall()
+            .hasSourceFileName(scriptName)
+            .hasLineno(5)
+            .hasCharno(0);
+
+    // `a$use` from `a.use(c);`
+    callNodeSubject
+        .hasFirstChildThat()
+        .isName("a$use")
+        .hasSourceFileName(scriptName)
+        .hasLineno(5)
+        .hasCharno(2); // source info points to the `use` part of `a.use`
+
+    // Original line 5: `c` in `a.use(c)`
+    // Compiled line 4: `a$b` in `a$use(a$b)`
+    callNodeSubject
+        .hasSecondChildThat()
+        .isName("a$b")
+        .hasSourceFileName(scriptName)
+        .hasLineno(5)
+        .hasCharno(6); // `a.use(` is 6 chars
+  }
+
+  @Test
   public void testOptChainPreventsInlineAndCollapse() {
     testSame(
         lines(
@@ -2606,6 +2737,69 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticMemberAccessedWithSuperAndThis() {
+    assumeStaticInheritanceIsNotUsed = false;
+    testSame(
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${super.classname} - is a subclass`;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticMemberAccessedWithSuperAndThis2() {
+    assumeStaticInheritanceIsNotUsed = true;
+    test(
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${super.classname} - is a subclass`;",
+            "  }",
+            "}"),
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${Bar.classname} - is a subclass`;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testCommaCallAliasing1() {
     test(
         lines(
diff --git a/test/com/google/javascript/jscomp/InlineFunctionsTest.java b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
index 8cd6376..4673401 100644
--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java
+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java
@@ -887,6 +887,21 @@ public class InlineFunctionsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDestructuringAssignInFunction_withArrayPattern_doesNotCrash() {
+    test(
+        lines(
+            "var Di = I(() => {",
+            "  function zv() {",
+            "    JSCOMPILER_PRESERVE(e), [f] = CN();",
+            "  }",
+            "  function CN() {",
+            "    let t;",
+            "  }",
+            "});"),
+        "var Di = I(() => {});");
+  }
+
+  @Test
   public void testNoInlineIfParametersModified1() {
     // Assignment
     test(
diff --git a/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
index eb7423e..71b8871 100644
--- a/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
+++ b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
@@ -32,6 +32,7 @@ public final class InlineSimpleMethodsTest extends CompilerTestCase {
   @Before
   public void setUp() throws Exception {
     super.setUp();
+    enableGatherExternProperties();
     enableNormalize();
   }
 
@@ -44,6 +45,38 @@ public final class InlineSimpleMethodsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDoesNotInlineMethodOnBaseClass() {
+    String baseClassJS =
+        lines(
+            "class Base {",
+            "  constructor() {",
+            "    /** @const */",
+            "    this.prop_ =",
+            "        Math.random() > .5;",
+            "  }",
+            "  method() {",
+            "    return this.prop_;",
+            "  }",
+            "}");
+
+    String derivedClassJS =
+        lines(
+            "class Derived extends Base {",
+            "  constructor() {",
+            "    super();",
+            "  }",
+            "  derivedMethod() {",
+            "    super.method();",
+            "  }",
+            "}",
+            "",
+            "(new Derived()).derivedMethod();");
+
+    String source = baseClassJS + derivedClassJS;
+    testSame(source);
+  }
+
+  @Test
   public void testSimpleInline1() {
     testWithPrefix("function Foo(){}" +
         "Foo.prototype.bar=function(){return this.baz};",
diff --git a/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java b/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
index 805e01a..02cd934 100644
--- a/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
+++ b/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
@@ -27,6 +27,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,7 +47,7 @@ public final class IsolatePolyfillsTest extends CompilerTestCase {
 
   private boolean enablePropertyFlattening = false;
 
-  private void addLibrary(String name, String from, String to, String library) {
+  private void addLibrary(String name, String from, String to, @Nullable String library) {
     polyfillTable.add(String.format("%s %s %s %s", name, from, to, nullToEmpty(library)));
     polyfillsToInject.add(name);
   }
diff --git a/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java b/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
index d9c86f9..bcd3fb2 100644
--- a/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
+++ b/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
@@ -24,7 +24,9 @@ import org.junit.runners.JUnit4;
 public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
   private static final String EXTERN =
       "Equality.$same = function(opt_a, opt_b) {};\n"
-          + "String.m_equals__java_lang_String__java_lang_Object = function(opt_a, opt_b) {};";
+          + "String.m_equals__java_lang_String__java_lang_Object__boolean = function(opt_a,"
+          + " opt_b) {};";
+  ;
 
   private static boolean useTypes;
 
@@ -213,9 +215,9 @@ public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
   public void testRewriteStringEquals() {
     test(
         LINE_JOINER.join(
-            "String.m_equals__java_lang_String__java_lang_Object('', 0);",
+            "String.m_equals__java_lang_String__java_lang_Object__boolean('', 0);",
             "var a = 'ABC';",
-            "String.m_equals__java_lang_String__java_lang_Object('ABC', a);"),
+            "String.m_equals__java_lang_String__java_lang_Object__boolean('ABC', a);"),
         LINE_JOINER.join(
             "'' === 0;", //
             "var a = 'ABC';",
@@ -228,8 +230,8 @@ public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
         LINE_JOINER.join(
             "/** @type {?string} */",
             "var b = null;",
-            "String.m_equals__java_lang_String__java_lang_Object(b, null);",
-            "String.m_equals__java_lang_String__java_lang_Object(null, b);",
-            "String.m_equals__java_lang_String__java_lang_Object(c, d);"));
+            "String.m_equals__java_lang_String__java_lang_Object__boolean(b, null);",
+            "String.m_equals__java_lang_String__java_lang_Object__boolean(null, b);",
+            "String.m_equals__java_lang_String__java_lang_Object__boolean(c, d);"));
   }
 }
diff --git a/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java b/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
index 77cf15d..fc7cfcd 100644
--- a/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
+++ b/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
@@ -36,27 +36,56 @@ public final class J2clStringValueOfRewriterPassTest extends CompilerTestCase {
 
   @Test
   public void testRemoveStringValueOf() {
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('')", "String('')");
     test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(null)", "String(null)");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(undefined)", "'null'");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(void 0)", "'null'");
+        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object__java_lang_String('')",
+        "String('')");
     test(
+        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object__java_lang_String(null)",
+        "String(null)");
+    test(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "    .m_valueOf__java_lang_Object__java_lang_String(undefined)"),
+        "'null'");
+    test(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "    .m_valueOf__java_lang_Object__java_lang_String(void 0)"),
+        "'null'");
+    test(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "   .m_valueOf__java_lang_Object__java_lang_String('foo' +",
+            "       module$exports$java$lang$String$impl",
+            "           .m_valueOf__java_lang_Object__java_lang_String(bar))"),
         lines(
-            "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('foo' +",
-            "    module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(bar))"),
-        "String('foo' + module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(bar))");
+            "String('foo' + module$exports$java$lang$String$impl",
+            "   .m_valueOf__java_lang_Object__java_lang_String(bar))"));
     test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(foo + 'bar' + baz)",
+        lines(
+            "module$exports$java$lang$String$impl",
+            "   .m_valueOf__java_lang_Object__java_lang_String(foo + 'bar' + baz)"),
         "String(foo + 'bar' + baz)");
     test(
-        "foo + module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('bar' + baz)",
+        lines(
+            "foo + module$exports$java$lang$String$impl",
+            "   .m_valueOf__java_lang_Object__java_lang_String('bar' + baz)"),
         "foo + String('bar' + baz)");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(1)", "String(1)");
     test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(null + foo)",
+        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object__java_lang_String(1)",
+        "String(1)");
+    test(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "    .m_valueOf__java_lang_Object__java_lang_String(null + foo)"),
         "String(null + foo)");
-    testSame("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(window)");
-    testSame("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object([])");
+    testSame(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "   .m_valueOf__java_lang_Object__java_lang_String(window)"));
+    testSame(
+        lines(
+            "module$exports$java$lang$String$impl",
+            "    .m_valueOf__java_lang_Object__java_lang_String([])"));
   }
 }
diff --git a/test/com/google/javascript/jscomp/JSChunkGraphTest.java b/test/com/google/javascript/jscomp/JSChunkGraphTest.java
index 8f745d6..bf895bc 100644
--- a/test/com/google/javascript/jscomp/JSChunkGraphTest.java
+++ b/test/com/google/javascript/jscomp/JSChunkGraphTest.java
@@ -34,6 +34,7 @@ import java.util.BitSet;
 import java.util.HashMap;
 import java.util.List;
 import java.util.stream.Collectors;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,7 +50,7 @@ public final class JSChunkGraphTest {
   private JSChunk moduleD;
   private JSChunk moduleE;
   private JSChunk moduleF;
-  private JSChunkGraph graph = null;
+  private @Nullable JSChunkGraph graph = null;
 
   // For resolving dependencies only.
   private Compiler compiler;
@@ -337,7 +338,7 @@ public final class JSChunkGraphTest {
     makeGraph();
     setUpManageDependenciesTest();
     DependencyOptions depOptions = DependencyOptions.pruneLegacyForEntryPoints(ImmutableList.of());
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     assertInputs(moduleA, "a1", "a3");
     assertInputs(moduleB, "a2", "b2");
@@ -356,7 +357,7 @@ public final class JSChunkGraphTest {
     DependencyOptions depOptions =
         DependencyOptions.pruneLegacyForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forClosure("c2")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     assertInputs(moduleA, "a1", "a3");
     assertInputs(moduleB, "a2", "b2");
@@ -374,7 +375,7 @@ public final class JSChunkGraphTest {
     setUpManageDependenciesTest();
     DependencyOptions depOptions =
         DependencyOptions.pruneForEntryPoints(ImmutableList.of(ModuleIdentifier.forClosure("c2")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     // Everything gets pushed up into module c, because that's
     // the only one that has entry points.
@@ -403,7 +404,7 @@ public final class JSChunkGraphTest {
 
     DependencyOptions depOptions =
         DependencyOptions.pruneForEntryPoints(ImmutableList.of(ModuleIdentifier.forClosure("a1")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     // Everything gets pushed up into module c, because that's
     // the only one that has entry points.
@@ -417,7 +418,8 @@ public final class JSChunkGraphTest {
     makeDeps();
     makeGraph();
     setUpManageDependenciesTest();
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
 
     assertInputs(moduleA, "a1", "a2", "a3");
     assertInputs(moduleB, "b1", "b2");
@@ -444,7 +446,8 @@ public final class JSChunkGraphTest {
       input.setCompiler(compiler);
     }
 
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
 
     assertInputs(moduleA, "base.js", "a1", "a2");
 
@@ -455,7 +458,8 @@ public final class JSChunkGraphTest {
   public void testNoFiles() throws Exception {
     makeDeps();
     makeGraph();
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
     assertThat(results).isEmpty();
   }
 
@@ -536,7 +540,7 @@ public final class JSChunkGraphTest {
         input.setCompiler(compiler);
       }
 
-      List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+      ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
       assertInputs(moduleA, "base.js", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a1");
 
@@ -594,7 +598,7 @@ public final class JSChunkGraphTest {
         input.setHasFullParseDependencyInfo(true);
       }
 
-      List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+      ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
       assertInputs(
           moduleA,
@@ -929,7 +933,7 @@ public final class JSChunkGraphTest {
     assertDeepestCommonDepOneWay(expected, m2, m1, true);
   }
 
-  private void assertDeepestCommonDep(JSChunk expected, JSChunk m1, JSChunk m2) {
+  private void assertDeepestCommonDep(@Nullable JSChunk expected, JSChunk m1, JSChunk m2) {
     assertDeepestCommonDepOneWay(expected, m1, m2, false);
     assertDeepestCommonDepOneWay(expected, m2, m1, false);
   }
diff --git a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
index 3aa39ea..a8bdb7c 100644
--- a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
@@ -17,17 +17,14 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -36,22 +33,10 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class JsMessageExtractorTest {
 
-  private JsMessage.Style mode;
-
-  @Before
-  public void setUp() throws Exception {
-    mode = JsMessage.Style.LEGACY;
-  }
-
   private Collection<JsMessage> extractMessages(String... js) {
-    try {
-      String sourceCode = Joiner.on("\n").join(js);
-      return new JsMessageExtractor(null, mode)
-          .extractMessages(SourceFile.fromCode("testcode", sourceCode));
-    } catch (IOException e) {
-      assertWithMessage(e.getMessage()).fail();
-      return null;
-    }
+    String sourceCode = Joiner.on("\n").join(js);
+    return new JsMessageExtractor(null)
+        .extractMessages(SourceFile.fromCode("testcode", sourceCode));
   }
 
   private JsMessage extractMessage(String... js) {
@@ -84,7 +69,11 @@ public final class JsMessageExtractorTest {
   public void testExtractNewStyleMessage1() {
     // A simple message with no description.
     assertEquals(
-        new JsMessage.Builder("MSG_SILLY").appendStringPart("silly test message").build(),
+        new JsMessage.Builder()
+            .setKey("MSG_SILLY")
+            .setId("MSG_SILLY")
+            .appendStringPart("silly test message")
+            .build(),
         extractMessage("var MSG_SILLY = goog.getMsg('silly test message');"));
   }
 
@@ -92,11 +81,13 @@ public final class JsMessageExtractorTest {
   public void testOriginalCodeAndExampleMaps() {
     // A message with placeholders and original code annotations.
     assertEquals(
-        new JsMessage.Builder("MSG_WELCOME")
+        new JsMessage.Builder()
+            .setKey("MSG_WELCOME")
+            .setId("MSG_WELCOME")
             .appendStringPart("Hi ")
-            .appendPlaceholderReference("interpolation_0")
+            .appendJsPlaceholderReference("interpolation_0")
             .appendStringPart("! Welcome to ")
-            .appendPlaceholderReference("interpolation_1")
+            .appendJsPlaceholderReference("interpolation_1")
             .appendStringPart(".")
             .setPlaceholderNameToOriginalCodeMap(
                 ImmutableMap.of(
@@ -133,21 +124,20 @@ public final class JsMessageExtractorTest {
   public void testExtractNewStyleMessage2() {
     // A message with placeholders and meta data.
     assertEquals(
-        new JsMessage.Builder("MSG_WELCOME")
+        new JsMessage.Builder()
+            .setKey("MSG_WELCOME")
+            .setId("MSG_WELCOME")
             .appendStringPart("Hi ")
-            .appendPlaceholderReference("userName")
+            .appendJsPlaceholderReference("userName")
             .appendStringPart("! Welcome to ")
-            .appendPlaceholderReference("product")
+            .appendJsPlaceholderReference("product")
             .appendStringPart(".")
             .setDesc("The welcome message.")
-            .setIsHidden(true)
             .build(),
         extractMessage(
             "/**",
             " * @desc The welcome",
             " *   message.",
-            " *",
-            " * @hidden",
             " */",
             "var MSG_WELCOME = goog.getMsg(",
             "    'Hi {$userName}! Welcome to {$product}.',",
@@ -155,84 +145,6 @@ public final class JsMessageExtractorTest {
   }
 
   @Test
-  public void testExtractOldStyleMessage1() {
-    // Description before the message.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendStringPart("silly test message")
-            .setDesc("Description.")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY_HELP = 'Description.';", "var MSG_SILLY = 'silly test message';"));
-  }
-
-  @Test
-  public void testExtractOldStyleMessage2() {
-    // Description after the message, broken into parts.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendStringPart("silly test message")
-            .setDesc("Description.")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY = 'silly test message';", "var MSG_SILLY_HELP = 'Descrip' + 'tion.';"));
-  }
-
-  @Test
-  public void testExtractOldStyleMessage3() {
-    // Function-style message with two placeholders and no description.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendPlaceholderReference("one")
-            .appendStringPart(", ")
-            .appendPlaceholderReference("two")
-            .appendStringPart(", buckle my shoe")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY = function(one, two) {",
-            "  return one + ', ' + two + ', buckle my shoe';",
-            "};"));
-  }
-
-  @Test
-  public void testExtractMixedMessages() {
-    // Several mixed-style messages in succession, one containing newlines.
-    Iterator<JsMessage> msgs =
-        extractMessages(
-                "var MSG_MONEY = function(amount) {",
-                "  return 'You owe $' + amount +",
-                "         ' to the credit card company.';",
-                "};",
-                "var MSG_TIME = goog.getMsg('You need to finish your work in ' +",
-                "                           '{$duration} hours.', {'duration': d});",
-                "var MSG_NAG = 'Clean your room.\\n\\nWash your clothes.';",
-                "var MSG_NAG_HELP = 'Just some ' +",
-                "                   'nags.';")
-            .iterator();
-
-    assertEquals(
-        new JsMessage.Builder("MSG_MONEY")
-            .appendStringPart("You owe $")
-            .appendPlaceholderReference("amount")
-            .appendStringPart(" to the credit card company.")
-            .build(),
-        msgs.next());
-    assertEquals(
-        new JsMessage.Builder("MSG_TIME")
-            .appendStringPart("You need to finish your work in ")
-            .appendPlaceholderReference("duration")
-            .appendStringPart(" hours.")
-            .build(),
-        msgs.next());
-    assertEquals(
-        new JsMessage.Builder("MSG_NAG")
-            .appendStringPart("Clean your room.\n\nWash your clothes.")
-            .setDesc("Just some nags.")
-            .build(),
-        msgs.next());
-  }
-
-  @Test
   public void testDuplicateUnnamedVariables() {
     // Make sure that duplicate unnamed variables don't get swallowed when using
     // a Google-specific ID generator.
@@ -247,8 +159,8 @@ public final class JsMessageExtractorTest {
 
     assertThat(msgs).hasSize(2);
     final Iterator<JsMessage> iter = msgs.iterator();
-    assertThat(iter.next().toString()).isEqualTo("foo");
-    assertThat(iter.next().toString()).isEqualTo("bar");
+    assertThat(iter.next().asJsMessageString()).isEqualTo("foo");
+    assertThat(iter.next().asJsMessageString()).isEqualTo("bar");
   }
 
   @Test
@@ -274,10 +186,9 @@ public final class JsMessageExtractorTest {
   private void assertEquals(JsMessage expected, JsMessage actual) {
     assertThat(actual.getId()).isEqualTo(expected.getId());
     assertThat(actual.getKey()).isEqualTo(expected.getKey());
-    assertThat(actual.parts()).isEqualTo(expected.parts());
-    assertThat(actual.placeholders()).isEqualTo(expected.placeholders());
+    assertThat(actual.getParts()).isEqualTo(expected.getParts());
+    assertThat(actual.jsPlaceholderNames()).isEqualTo(expected.jsPlaceholderNames());
     assertThat(actual.getDesc()).isEqualTo(expected.getDesc());
-    assertThat(actual.isHidden()).isEqualTo(expected.isHidden());
     assertThat(actual.getMeaning()).isEqualTo(expected.getMeaning());
   }
 }
diff --git a/test/com/google/javascript/jscomp/JsMessageTest.java b/test/com/google/javascript/jscomp/JsMessageTest.java
index d828ff2..b9c8487 100644
--- a/test/com/google/javascript/jscomp/JsMessageTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageTest.java
@@ -22,28 +22,59 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * @author anatol@google.com (Anatol Pomazau)
- */
 @RunWith(JUnit4.class)
 public final class JsMessageTest {
 
   @Test
+  public void testIsLowerCamelCaseWithNumericSuffixes() {
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("name")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("NAME")).isFalse();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("Name")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("a4Letter")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("startSpan_1_23")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("startSpan_1_23b")).isFalse();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("")).isFalse();
+  }
+
+  @Test
+  public void testToLowerCamelCaseWithNumericSuffixes() {
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("NAME")).isEqualTo("name");
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isEqualTo("a4Letter");
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23"))
+        .isEqualTo("startSpan_1_23");
+  }
+
+  @Test
   public void testIsEmpty() {
-    assertThat(new JsMessage.Builder().build().isEmpty()).isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("").build().isEmpty()).isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("").appendStringPart("").build().isEmpty())
+    assertThat(newTestMessageBuilder("MSG_KEY").build().isEmpty()).isTrue();
+    assertThat(newTestMessageBuilder("MSG_KEY").appendStringPart("").build().isEmpty()).isTrue();
+    assertThat(
+            newTestMessageBuilder("MSG_KEY")
+                .appendStringPart("")
+                .appendStringPart("")
+                .build()
+                .isEmpty())
         .isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("s").appendStringPart("").build().isEmpty())
+    assertThat(
+            newTestMessageBuilder("MSG_KEY")
+                .appendStringPart("s")
+                .appendStringPart("")
+                .build()
+                .isEmpty())
+        .isFalse();
+    assertThat(
+            newTestMessageBuilder("MSG_KEY").appendJsPlaceholderReference("ph").build().isEmpty())
         .isFalse();
-    assertThat(new JsMessage.Builder().appendPlaceholderReference("3").build().isEmpty()).isFalse();
   }
 
-  @Test
-  public void testMeaningChangesId() {
-    String id1 = new JsMessage.Builder().appendStringPart("foo").build().getId();
-    String id2 = new JsMessage.Builder().appendStringPart("foo").setMeaning("bar").build().getId();
-    assertThat(id1.equals(id2)).isFalse();
+  /** Return a new message builder that uses the given string as both its key and its ID. */
+  private JsMessage.Builder newTestMessageBuilder(String keyAndId) {
+    return new JsMessage.Builder().setKey(keyAndId).setId(keyAndId);
   }
 
   @Test
@@ -57,43 +88,35 @@ public final class JsMessageTest {
 
   @Test
   public void testNoAlternateId() {
-    JsMessage msg = new JsMessage.Builder().setDesc("Hello.").build();
+    JsMessage msg = newTestMessageBuilder("MSG_SOME_KEY").setDesc("Hello.").build();
     assertThat(msg.getDesc()).isEqualTo("Hello.");
-    assertThat(msg.getId()).isEqualTo("MSG_12MI20AMYO9T6");
+    assertThat(msg.getId()).isEqualTo("MSG_SOME_KEY");
     assertThat(msg.getAlternateId()).isNull();
   }
 
   @Test
   public void testSelfReferentialAlternateId() {
     JsMessage msg =
-        new JsMessage.Builder().setDesc("Hello.").setAlternateId("MSG_12MI20AMYO9T6").build();
+        newTestMessageBuilder("MSG_SOME_NAME")
+            .setDesc("Hello.")
+            .setAlternateId("MSG_SOME_NAME")
+            .build();
     assertThat(msg.getDesc()).isEqualTo("Hello.");
-    assertThat(msg.getId()).isEqualTo("MSG_12MI20AMYO9T6");
+    assertThat(msg.getId()).isEqualTo("MSG_SOME_NAME");
     assertThat(msg.getAlternateId()).isNull();
   }
 
   @Test
-  public void testGenerateIdWithGoogScope() {
-    JsMessage msg1 =
-        new JsMessage.Builder().setDesc("Hello.").setKey("$jscomp$scope$12345$0$MSG_HELLO").build();
-    assertThat(msg1.getDesc()).isEqualTo("Hello.");
-    assertThat(msg1.getId()).isEqualTo("MSG_HELLO");
-
-    JsMessage msg2 =
-        new JsMessage.Builder().setDesc("Test.").setKey("$jscomp$scope$m12345$0$MSG_TEST").build();
-    assertThat(msg2.getDesc()).isEqualTo("Test.");
-    assertThat(msg2.getId()).isEqualTo("MSG_TEST");
-  }
-
-  @Test
   public void testAlternateId() {
     JsMessage msg =
         new JsMessage.Builder()
+            .setKey("MSG_KEY")
             .setDesc("Hello.")
             .setAlternateId("foo")
             .setMeaning("meaning")
-            .appendPlaceholderReference("placeholder0")
-            .appendPlaceholderReference("placeholder1")
+            .setId("meaning")
+            .appendJsPlaceholderReference("placeholder0")
+            .appendJsPlaceholderReference("placeholder1")
             .appendStringPart("part0")
             .appendStringPart("part1")
             .appendStringPart("part2")
diff --git a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
index 1a1a839..498e011 100644
--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
@@ -17,26 +17,24 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE;
-import static com.google.javascript.jscomp.JsMessage.Style.LEGACY;
-import static com.google.javascript.jscomp.JsMessage.Style.RELAX;
+import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY;
 import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED;
-import static com.google.javascript.jscomp.JsMessageVisitor.isLowerCamelCaseWithNumericSuffixes;
-import static com.google.javascript.jscomp.JsMessageVisitor.toLowerCamelCaseWithNumericSuffixes;
 import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DESCRIPTION_EQUALITY;
 import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DIAGNOSTIC_EQUALITY;
 import static com.google.javascript.jscomp.testing.JSErrorSubject.assertError;
+import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.debugging.sourcemap.FilePosition;
 import com.google.debugging.sourcemap.SourceMapGeneratorV3;
-import com.google.javascript.jscomp.JsMessage.Style;
+import com.google.javascript.jscomp.JsMessage.Part;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -67,16 +65,16 @@ public final class JsMessageVisitorTest {
     }
   }
 
-  private CompilerOptions compilerOptions;
+  private @Nullable CompilerOptions compilerOptions;
   private Compiler compiler;
   private List<JsMessage> messages;
-  private JsMessage.Style mode;
+  private List<JsMessageDefinition> messageDefinitions;
   private boolean renameMessages = false;
 
   @Before
   public void setUp() throws Exception {
     messages = new ArrayList<>();
-    mode = JsMessage.Style.LEGACY;
+    messageDefinitions = new ArrayList<>();
     compilerOptions = null;
     renameMessages = false;
   }
@@ -90,7 +88,8 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
     assertThat(msg.getDesc()).isEqualTo("Hello");
-    assertThat(msg.getSourceName()).isEqualTo("[testcode]:1");
+    // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+    assertThat(msg.getSourceName()).isEqualTo("testcode:1");
   }
 
   @Test
@@ -103,7 +102,8 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
     assertThat(msg.getDesc()).isEqualTo("Hello");
-    assertThat(msg.getSourceName()).isEqualTo("[testcode]:1");
+    // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+    assertThat(msg.getSourceName()).isEqualTo("testcode:1");
   }
 
   @Test
@@ -116,7 +116,8 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
     assertThat(msg.getDesc()).isEqualTo("Hello");
-    assertThat(msg.getSourceName()).isEqualTo("[testcode]:1");
+    // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+    assertThat(msg.getSourceName()).isEqualTo("testcode:1");
   }
 
   @Test
@@ -138,9 +139,10 @@ public final class JsMessageVisitorTest {
     sourceMap.appendTo(output, "unused.js");
 
     compilerOptions = new CompilerOptions();
+    // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
     compilerOptions.inputSourceMaps =
         ImmutableMap.of(
-            "[testcode]",
+            "testcode",
             new SourceMapInput(SourceFile.fromCode("example.srcmap", output.toString())));
 
     extractMessagesSafely(
@@ -196,8 +198,8 @@ public final class JsMessageVisitorTest {
     extractMessages(
         LINE_JOINER.join(
             "/**", " * @enum {number}", " */", "var MyEnum = {", "  MSG_ONE: 0", "};"));
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -233,8 +235,8 @@ public final class JsMessageVisitorTest {
   public void testInvalidJsMessageOnObjLit() {
     extractMessages(
         "" + "pint.sub = {" + "  /** @desc a */ MSG_MENU_MARK_AS_UNREAD: undefined" + "}");
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -267,8 +269,8 @@ public final class JsMessageVisitorTest {
   @Test
   public void testMessageAliasedToObject_nonMSGNameIsNotAllowed() {
     extractMessages("a.b.MSG_FOO_ALIAS = someVarName;");
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -319,10 +321,10 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testOrphanedJsMessage() {
-    extractMessagesSafely("goog.getMsg('a')");
+    extractMessages("goog.getMsg('a')");
     assertThat(messages).isEmpty();
 
-    assertThat(compiler.getWarnings())
+    assertThat(compiler.getErrors())
         .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
         .containsExactly(JsMessageVisitor.MESSAGE_NODE_IS_ORPHANED);
   }
@@ -348,9 +350,9 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
 
     JSError malformedTreeError = compiler.getErrors().get(0);
-    assertError(malformedTreeError).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertError(malformedTreeError).hasType(MESSAGE_TREE_MALFORMED);
     assertThat(malformedTreeError.getDescription())
-        .isEqualTo("Message parse tree malformed. " + "STRING or ADD node expected; found: POS");
+        .isEqualTo("Message parse tree malformed. literal string or concatenation expected");
   }
 
   @Test
@@ -364,7 +366,7 @@ public final class JsMessageVisitorTest {
 
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
-    assertThat(msg.toString()).isEqualTo("hello");
+    assertThat(msg.asJsMessageString()).isEqualTo("hello");
   }
 
   @Test
@@ -377,7 +379,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
 
     JSError malformedTreeError = compiler.getErrors().get(0);
-    assertError(malformedTreeError).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertError(malformedTreeError).hasType(MESSAGE_TREE_MALFORMED);
     assertThat(malformedTreeError.getDescription())
         .isEqualTo(
             "Message parse tree malformed."
@@ -385,85 +387,6 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testEmptyMessage() {
-    // This is an edge case. Empty messages are useless, but shouldn't fail
-    extractMessagesSafely("var MSG_EMPTY = '';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_EMPTY");
-    assertThat(msg.toString()).isEmpty();
-  }
-
-  @Test
-  public void testConcatOfStrings() {
-    extractMessagesSafely("var MSG_NOTEMPTY = 'aa' + 'bbb' \n + ' ccc';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_NOTEMPTY");
-    assertThat(msg.toString()).isEqualTo("aabbb ccc");
-  }
-
-  @Test
-  public void testLegacyFormatDescription() {
-    extractMessagesSafely(
-        "var MSG_SILLY = 'silly test message';\n" + "var MSG_SILLY_HELP = 'help text';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("silly test message");
-  }
-
-  @Test
-  public void testLegacyFormatParametizedFunction() {
-    extractMessagesSafely(
-        "var MSG_SILLY = function(one, two) {"
-            + "  return one + ', ' + two + ', buckle my shoe';"
-            + "};");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.getDesc()).isNull();
-    assertThat(msg.toString()).isEqualTo("{$one}, {$two}, buckle my shoe");
-  }
-
-  @Test
-  public void testLegacyMessageWithDescAnnotation() {
-    // Well, is was better do not allow legacy messages with @desc annotations,
-    // but people love to mix styles so we need to check @desc also.
-    extractMessagesSafely("/** @desc The description */ var MSG_A = 'The Message';");
-
-    assertThat(messages).hasSize(1);
-    assertThat(compiler.getWarnings()).isEmpty();
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_A");
-    assertThat(msg.toString()).isEqualTo("The Message");
-    assertThat(msg.getDesc()).isEqualTo("The description");
-  }
-
-  @Test
-  public void testLegacyMessageWithDescAnnotationAndHelpVar() {
-    mode = RELAX;
-
-    // Well, is was better do not allow legacy messages with @desc annotations,
-    // but people love to mix styles so we need to check @desc also.
-    extractMessagesSafely(
-        "var MSG_A_HELP = 'This is a help var';\n"
-            + "/** @desc The description in @desc*/ var MSG_A = 'The Message';");
-
-    assertThat(messages).hasSize(1);
-    assertThat(compiler.getWarnings()).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_A");
-    assertThat(msg.toString()).isEqualTo("The Message");
-    assertThat(msg.getDesc()).isEqualTo("The description in @desc");
-  }
-
-  @Test
   public void testClosureMessageWithHelpPostfix() {
     extractMessagesSafely("/** @desc help text */\n" + "var MSG_FOO_HELP = goog.getMsg('Help!');");
 
@@ -471,24 +394,22 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_FOO_HELP");
     assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("Help!");
+    assertThat(msg.asJsMessageString()).isEqualTo("Help!");
   }
 
   @Test
   public void testClosureMessageWithoutGoogGetmsg() {
-    mode = CLOSURE;
 
     extractMessages("var MSG_FOO_HELP = 'I am a bad message';");
 
     assertThat(messages).isEmpty();
     assertThat(compiler.getWarnings()).hasSize(1);
     assertError(compiler.getWarnings().get(0))
-        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testAllowOneMSGtoAliasAnotherMSG() {
-    mode = CLOSURE;
 
     // NOTE: tsickle code generation can end up creating new MSG_* variables that are temporary
     // aliases of existing ones that were defined correctly using goog.getMsg(). Don't complain
@@ -503,13 +424,12 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_FOO");
-    assertThat(msg.toString()).isEqualTo("Foo message");
+    assertThat(msg.asJsMessageString()).isEqualTo("Foo message");
     assertThat(compiler.getWarnings()).isEmpty();
   }
 
   @Test
   public void testDisallowOneMSGtoAliasNONMSG() {
-    mode = CLOSURE;
 
     // NOTE: tsickle code generation can end up creating new MSG_* variables that are temporary
     // aliases of existing ones that were defined correctly using goog.getMsg(). Don't complain
@@ -524,7 +444,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
     assertThat(compiler.getWarnings()).hasSize(1);
     assertError(compiler.getWarnings().get(0))
-        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -538,7 +458,7 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
     assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("{$adjective} message");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} message");
   }
 
   @Test
@@ -546,7 +466,6 @@ public final class JsMessageVisitorTest {
     extractMessagesSafely(
         "/**"
             + " * @desc A message with lots of stuff.\n"
-            + " * @hidden\n"
             + " */"
             + "var MSG_HUGE = goog.getMsg("
             + "    '{$startLink_1}Google{$endLink}' +"
@@ -569,8 +488,7 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HUGE");
     assertThat(msg.getDesc()).isEqualTo("A message with lots of stuff.");
-    assertThat(msg.isHidden()).isTrue();
-    assertThat(msg.toString())
+    assertThat(msg.asJsMessageString())
         .isEqualTo(
             "{$startLink_1}Google{$endLink}{$startLink_2}blah{$endLink}"
                 + "{$boo}{$foo_001}{$boo}{$foo_002}{$xxx_001}{$image}"
@@ -589,6 +507,24 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
+  public void testMeaningGetsUsedAsIdIfTheresNoGenerator() {
+    extractMessagesSafely(
+        lines(
+            "/**", //
+            " * @desc some description",
+            " * @meaning some meaning",
+            " */",
+            "var MSG_HULLO = goog.getMsg('Hullo');"));
+
+    assertThat(messages).hasSize(1);
+    JsMessage msg = messages.get(0);
+    assertThat(msg.getDesc()).isEqualTo("some description");
+    assertThat(msg.getKey()).isEqualTo("MSG_HULLO");
+    assertThat(msg.getMeaning()).isEqualTo("some meaning");
+    assertThat(msg.getId()).isEqualTo("some meaning");
+  }
+
+  @Test
   public void testEmptyTextMessage() {
     extractMessagesSafely("/** @desc text */ var MSG_FOO = goog.getMsg('');");
 
@@ -641,10 +577,9 @@ public final class JsMessageVisitorTest {
   public void testMsgVarWithIncorrectRightSide() {
     extractMessages("var MSG_SILLY = 0;");
 
-    assertThat(compiler.getErrors())
+    assertThat(compiler.getWarnings())
         .comparingElementsUsing(DESCRIPTION_EQUALITY)
-        .containsExactly(
-            "Message parse tree malformed. Cannot parse value of " + "message MSG_SILLY");
+        .containsExactly("message not initialized using goog.getMsg");
   }
 
   @Test
@@ -652,16 +587,13 @@ public final class JsMessageVisitorTest {
     extractMessages("DP_DatePicker.MSG_DATE_SELECTION = {};");
 
     assertThat(messages).isEmpty();
-    assertThat(compiler.getErrors())
+    assertThat(compiler.getWarnings())
         .comparingElementsUsing(DESCRIPTION_EQUALITY)
-        .containsExactly(
-            "Message parse tree malformed."
-                + " Message must be initialized using goog.getMsg function.");
+        .containsExactly("message not initialized using goog.getMsg");
   }
 
   @Test
   public void testUnrecognizedFunction() {
-    mode = CLOSURE;
     extractMessages("DP_DatePicker.MSG_DATE_SELECTION = somefunc('a')");
 
     assertThat(messages).isEmpty();
@@ -677,7 +609,6 @@ public final class JsMessageVisitorTest {
     extractMessagesSafely(
         "/**"
             + " * @desc A message that demonstrates placeholders\n"
-            + " * @hidden\n"
             + " */"
             + "a.b.MSG_SILLY = goog.getMsg(\n"
             + "    '{$adjective} ' + '{$someNoun}',\n"
@@ -686,9 +617,8 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.toString()).isEqualTo("{$adjective} {$someNoun}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} {$someNoun}");
     assertThat(msg.getDesc()).isEqualTo("A message that demonstrates placeholders");
-    assertThat(msg.isHidden()).isTrue();
   }
 
   @Test
@@ -708,9 +638,8 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.toString()).isEqualTo("{$adjective} {$someNoun}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} {$someNoun}");
     assertThat(msg.getDesc()).isEqualTo("A message that demonstrates placeholders");
-    assertThat(msg.isHidden()).isTrue();
   }
 
   @Test
@@ -742,39 +671,15 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testIsValidMessageNameStrict() {
-    JsMessageVisitor visitor = new DummyJsVisitor(CLOSURE);
+    JsMessageVisitor visitor = new DummyJsVisitor();
 
-    assertThat(visitor.isMessageName("MSG_HELLO", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_HELP", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", true)).isTrue();
+    assertThat(visitor.isMessageName("MSG_HELLO")).isTrue();
+    assertThat(visitor.isMessageName("MSG_")).isTrue();
+    assertThat(visitor.isMessageName("MSG_HELP")).isTrue();
+    assertThat(visitor.isMessageName("MSG_FOO_HELP")).isTrue();
 
-    assertThat(visitor.isMessageName("_FOO_HELP", true)).isFalse();
-    assertThat(visitor.isMessageName("MSGFOOP", true)).isFalse();
-  }
-
-  @Test
-  public void testIsValidMessageNameRelax() {
-    JsMessageVisitor visitor = new DummyJsVisitor(RELAX);
-
-    assertThat(visitor.isMessageName("MSG_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", false)).isFalse();
-  }
-
-  @Test
-  public void testIsValidMessageNameLegacy() {
-    theseAreLegacyMessageNames(new DummyJsVisitor(RELAX));
-    theseAreLegacyMessageNames(new DummyJsVisitor(LEGACY));
-  }
-
-  private void theseAreLegacyMessageNames(JsMessageVisitor visitor) {
-    assertThat(visitor.isMessageName("MSG_HELLO", false)).isTrue();
-    assertThat(visitor.isMessageName("MSG_", false)).isTrue();
-
-    assertThat(visitor.isMessageName("MSG_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("_FOO_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSGFOOP", false)).isFalse();
+    assertThat(visitor.isMessageName("_FOO_HELP")).isFalse();
+    assertThat(visitor.isMessageName("MSGFOOP")).isFalse();
   }
 
   @Test
@@ -785,7 +690,7 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo(
             "Message parse tree malformed. Unrecognized message " + "placeholder referenced: foo");
@@ -798,7 +703,7 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo("Message parse tree malformed. Unused message placeholder: " + "foo");
   }
@@ -811,9 +716,9 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
-        .isEqualTo("Message parse tree malformed. Duplicate placeholder " + "name: foo");
+        .isEqualTo("Message parse tree malformed. duplicate string key: foo");
   }
 
   @Test
@@ -822,7 +727,7 @@ public final class JsMessageVisitorTest {
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
-    assertThat(msg.toString()).isEqualTo("{$foo}:, {$foo}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$foo}:, {$foo}");
   }
 
   @Test
@@ -834,17 +739,38 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_WITH_CAMELCASE");
-    assertThat(msg.toString()).isEqualTo("Slide {$slideNumber}:");
-    List<CharSequence> parts = msg.parts();
+    assertThat(msg.asJsMessageString()).isEqualTo("Slide {$slideNumber}:");
+    ImmutableList<Part> parts = msg.getParts();
     assertThat(parts).hasSize(3);
-    assertThat(((JsMessage.PlaceholderReference) parts.get(1)).getName()).isEqualTo("slideNumber");
+    assertThat(parts.get(1).getJsPlaceholderName()).isEqualTo("slideNumber");
+    assertThat(parts.get(1).getCanonicalPlaceholderName()).isEqualTo("SLIDE_NUMBER");
   }
 
   @Test
-  public void testWithNonCamelcasePlaceholderNamesAreNotOk() {
+  public void testNonCamelcasePlaceholderNamesAreNotOkInMsgText() {
     extractMessages(
-        "var MSG_WITH_CAMELCASE = goog.getMsg("
-            + "'Slide {$slide_number}:', {'slide_number': opt_index + 1});");
+        lines(
+            "var MSG_WITH_CAMELCASE = goog.getMsg(",
+            "    'Slide {$SLIDE_NUMBER}:',",
+            "    {'slideNumber': opt_index + 1});"));
+
+    assertThat(messages).isEmpty();
+    ImmutableList<JSError> errors = compiler.getErrors();
+    assertThat(errors).hasSize(1);
+    JSError error = errors.get(0);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
+    assertThat(error.getDescription())
+        .isEqualTo(
+            "Message parse tree malformed. Placeholder name not in lowerCamelCase: SLIDE_NUMBER");
+  }
+
+  @Test
+  public void testNonCamelcasePlaceholderNamesAreNotOkInPlaceholderObject() {
+    extractMessages(
+        lines(
+            "var MSG_WITH_CAMELCASE = goog.getMsg(",
+            "    'Slide {$slideNumber}:',",
+            "    {'SLIDE_NUMBER': opt_index + 1});"));
 
     assertThat(messages).isEmpty();
     ImmutableList<JSError> errors = compiler.getErrors();
@@ -853,8 +779,8 @@ public final class JsMessageVisitorTest {
     assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo(
-            "Message parse tree malformed. Placeholder name not in "
-                + "lowerCamelCase: slide_number");
+            "Message parse tree malformed. Unrecognized message placeholder referenced:"
+                + " slideNumber");
   }
 
   @Test
@@ -867,29 +793,6 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testIsLowerCamelCaseWithNumericSuffixes() {
-    assertThat(isLowerCamelCaseWithNumericSuffixes("name")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("NAME")).isFalse();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("Name")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("a4Letter")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23b")).isFalse();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("")).isFalse();
-  }
-
-  @Test
-  public void testToLowerCamelCaseWithNumericSuffixes() {
-    assertThat(toLowerCamelCaseWithNumericSuffixes("NAME")).isEqualTo("name");
-    assertThat(toLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isEqualTo("a4Letter");
-    assertThat(toLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isEqualTo("startSpan_1_23");
-  }
-
-  @Test
   public void testDuplicateMessageError() {
     extractMessages(
         "(function () {/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')})"
@@ -980,7 +883,7 @@ public final class JsMessageVisitorTest {
             + "/** @desc Hello */ var MSG_HELLO_2 = goog.getMsg('hello');\n"
             + "/** @desc Hello */ "
             + "var MSG_HELLO_3 = goog.getMsgWithFallback(MSG_HELLO_1, MSG_HELLO_2);");
-    assertOneError(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertOneError(MESSAGE_TREE_MALFORMED);
   }
 
   @Test
@@ -994,7 +897,8 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
     assertThat(msg.getDesc()).isEqualTo("Hello");
-    assertThat(msg.getSourceName()).isEqualTo("[testcode]:1");
+    // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+    assertThat(msg.getSourceName()).isEqualTo("testcode:1");
   }
 
   @Test
@@ -1011,14 +915,229 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testGetMsgWithHtml() {
-    extractMessagesSafely("/** @desc Hello */ var MSG_HELLO = goog.getMsg('a', {}, {html: true})");
+  public void testGetMsgWithOptions() {
+    extractMessagesSafely(
+        lines(
+            "/** @desc Hello */",
+            "var MSG_HELLO =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        {",
+            "          'name': getName(),",
+            "        },",
+            "        {",
+            "          html: false,",
+            "          unescapeHtmlEntities: true,",
+            "          example: {",
+            "            'name': 'George',",
+            "          },",
+            "          original_code: {",
+            "            'name': 'getName()',",
+            "          },",
+            "        })"));
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
     JsMessage msg = messages.get(0);
+    // MSG_HELLO =
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
+    // * @desc Hello
     assertThat(msg.getDesc()).isEqualTo("Hello");
+
+    JsMessageDefinition msgDefinition = messageDefinitions.get(0);
+
+    // goog.getMsg(...)
+    final Node callNode = msgDefinition.getMessageNode();
+    assertNode(callNode).isCall().hasFirstChildThat().matchesQualifiedName("goog.getMsg");
+
+    assertNode(msgDefinition.getTemplateTextNode()).isString("Hello, {$name}");
+
+    // `{ 'name': getName() }`
+    final Node placeholderValuesNode = msgDefinition.getPlaceholderValuesNode();
+    assertNode(placeholderValuesNode).isObjectLit();
+    assertThat(callNode.getChildAtIndex(2)).isSameInstanceAs(placeholderValuesNode);
+
+    // placeholder name 'name' maps to the `getName()` call in the values map
+    final ImmutableMap<String, Node> placeholderValueMap = msgDefinition.getPlaceholderValueMap();
+    assertThat(placeholderValueMap.keySet()).containsExactly("name");
+    final Node nameValueNode = placeholderValueMap.get("name");
+    assertNode(nameValueNode).isCall().hasOneChildThat().isName("getName");
+    assertThat(nameValueNode.getGrandparent()).isSameInstanceAs(placeholderValuesNode);
+
+    // `html: false`
+    assertThat(msgDefinition.shouldEscapeLessThan()).isFalse();
+    // `unescapeHtmlEntities: true`
+    assertThat(msgDefinition.shouldUnescapeHtmlEntities()).isTrue();
+
+    // `example: { 'name': 'George' }`
+    assertThat(msg.getPlaceholderNameToExampleMap()).containsExactly("name", "George");
+    // `original_code: {'name': 'getName()' }`
+    assertThat(msg.getPlaceholderNameToOriginalCodeMap()).containsExactly("name", "getName()");
+  }
+
+  @Test
+  public void testGoogGetMsgWithNoArgs() {
+    extractMessages(
+        lines(
+            "/** @desc something */",
+            "const MSG_X = goog.getMsg();", // no arguments
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Message string literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadValuesArg() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        getName());", // should be an object literal
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadValuesKey() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        {",
+            "          [name]: getName()", // a computed key is not allowed
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. string key expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadOptionsArg() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        options);", // options bag must be an object literal
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithComputedKeyInOptions() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          [options]: true", // option names cannot be computed keys
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. string key expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithUnknownOption() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          unknownOption: true", // not a valid option name
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Unknown option: unknownOption");
+  }
+
+  @Test
+  public void testGoogGetMsgWithInvalidBooleanOption() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          html: 'true'", // boolean option value must be a boolean literal
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. html: Literal true or false expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithOriginalCodeForInvalidExample() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          example: 'name: something'", // not an object literal
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithInvalidOriginalCodeValue() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          original_code: {",
+            "            'name': getName()", // value is not a string
+            "          }",
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. literal string or concatenation expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithOriginalCodeForUnknownPlaceholder() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          original_code: {",
+            "            'unknownPlaceholder': 'something'", // not a valid placeholder name
+            "          }",
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Unknown placeholder: unknownPlaceholder");
   }
 
   @Test
@@ -1069,19 +1188,20 @@ public final class JsMessageVisitorTest {
   private class CollectMessages extends JsMessageVisitor {
 
     private CollectMessages(Compiler compiler) {
-      super(compiler, mode, null);
+      super(compiler, null);
     }
 
     @Override
     protected void processJsMessage(JsMessage message, JsMessageDefinition definition) {
       messages.add(message);
+      messageDefinitions.add(definition);
     }
   }
 
   private static class DummyJsVisitor extends JsMessageVisitor {
 
-    private DummyJsVisitor(Style style) {
-      super(null, style, null);
+    private DummyJsVisitor() {
+      super(null, null);
     }
 
     @Override
diff --git a/test/com/google/javascript/jscomp/LateEs6ToEs3ConverterTest.java b/test/com/google/javascript/jscomp/LateEs6ToEs3ConverterTest.java
index 317edeb..37dc2c4 100644
--- a/test/com/google/javascript/jscomp/LateEs6ToEs3ConverterTest.java
+++ b/test/com/google/javascript/jscomp/LateEs6ToEs3ConverterTest.java
@@ -15,7 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
 
 import com.google.common.base.Preconditions;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
diff --git a/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
index b251403..794e289 100644
--- a/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
+++ b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
@@ -24,6 +24,7 @@ import com.google.javascript.jscomp.LightweightMessageFormatter.LineNumberingFor
 import com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -276,12 +277,12 @@ public final class LightweightMessageFormatterTest {
     return new LightweightMessageFormatter(source(string, originalSource));
   }
 
-  private SourceExcerptProvider source(final String source, final String originalSource) {
+  private SourceExcerptProvider source(final String source, final @Nullable String originalSource) {
     return source(source, originalSource, -1);
   }
 
   private SourceExcerptProvider source(
-      final String source, final String originalSource, final int endLineNumber) {
+      final String source, final @Nullable String originalSource, final int endLineNumber) {
     return new SourceExcerptProvider() {
       @Override
       public String getSourceLine(String sourceName, int lineNumber) {
@@ -315,7 +316,7 @@ public final class LightweightMessageFormatterTest {
     };
   }
 
-  private String format(Region region) {
+  private String format(@Nullable Region region) {
     return new LineNumberingFormatter().formatRegion(region);
   }
 
diff --git a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
index b450c5f..054e9d9 100644
--- a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
@@ -27,6 +27,7 @@ import com.google.javascript.jscomp.NodeUtil.AllVarsDeclaredInFunction;
 import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -38,7 +39,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class LiveVariablesAnalysisTest {
 
-  private LiveVariablesAnalysis liveness = null;
+  private @Nullable LiveVariablesAnalysis liveness = null;
 
   @Test
   public void testStraightLine() {
@@ -360,11 +361,11 @@ public final class LiveVariablesAnalysisTest {
   @Test
   public void testArgumentsArray_doesNotEscape_destructuredParams() {
     // These cases also cover a crash related to assuming all RESTs have a NAME child.
-    assertNotEscaped("function f([a]) { arguments; }", "a");
-    assertNotEscaped("function f([a] = []) { arguments; }", "a");
-    assertNotEscaped("function f(...[a]) { arguments; }", "a");
-    assertNotEscaped("function f({a}) { arguments; }", "a");
-    assertNotEscaped("function f({a} = {}) { arguments; }", "a");
+    assertNotEscaped("function f([a]) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f([a] = []) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f(...[a]) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f({a}) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f({a} = {}) { arguments; }", "a", Wrapper.NONE);
   }
 
   @Test
@@ -420,6 +421,19 @@ public final class LiveVariablesAnalysisTest {
     assertEscaped("var _x", "_x");
   }
 
+  @Test
+  public void testEscapedInClassStaticBlock() {
+    assertEscaped("var a; class C{ static{a()}}", "a");
+    assertEscaped("var a; class C{static{ param1() } }", "param1");
+  }
+
+  @Test
+  public void testNotEscapedInClassStaticBlock() {
+    assertNotEscaped("var a; class C{static{}} a()", "a");
+    assertNotEscaped("let a; class C{static{let a;a()}}a()", "a");
+    assertNotEscaped("var a; class C{static{var c; c()}}", "c");
+  }
+
   // ES6 does not require separate handling for catch because the catch block is already recognized
   // by the scope creator
   @Test
@@ -586,7 +600,12 @@ public final class LiveVariablesAnalysisTest {
 
   private LinearFlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX(
       String src, boolean async) {
-    liveness = computeLiveness(src, async);
+    if (async) {
+      liveness = computeLiveness(src, Wrapper.ASYNC_FUNCTION);
+    } else {
+      liveness = computeLiveness(src, Wrapper.FUNCTION);
+    }
+
     return getFlowStateAtX(liveness.getCfg().getEntry().getValue(), liveness.getCfg());
   }
 
@@ -608,7 +627,7 @@ public final class LiveVariablesAnalysisTest {
 
   private LinearFlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtDeclaration(
       String src, String name) {
-    liveness = computeLiveness(src, false);
+    liveness = computeLiveness(src);
     return getFlowStateAtDeclaration(
         liveness.getCfg().getEntry().getValue(), liveness.getCfg(), name);
   }
@@ -635,7 +654,7 @@ public final class LiveVariablesAnalysisTest {
   }
 
   private static void assertEscaped(String src, String name) {
-    for (Var var : computeLiveness(src, false).getEscapedLocals()) {
+    for (Var var : computeLiveness(src).getEscapedLocals()) {
       if (var.getName().equals(name)) {
         return;
       }
@@ -644,12 +663,25 @@ public final class LiveVariablesAnalysisTest {
   }
 
   private static void assertNotEscaped(String src, String name) {
-    for (Var var : computeLiveness(src, false).getEscapedLocals()) {
+    assertNotEscaped(src, name, Wrapper.FUNCTION);
+  }
+
+  /**
+   * @param wrapper The kind of wrapper function the {@code src} will be placed in.
+   */
+  private static void assertNotEscaped(String src, String name, Wrapper wrapper) {
+    for (Var var : computeLiveness(src, wrapper).getEscapedLocals()) {
       assertThat(var.getName()).isNotEqualTo(name);
     }
   }
 
-  private static LiveVariablesAnalysis computeLiveness(String src, boolean async) {
+  /** Wraps {@code src} in a function and computes a LiveVariablesAnalysis. */
+  private static LiveVariablesAnalysis computeLiveness(String src) {
+    return computeLiveness(src, Wrapper.FUNCTION);
+  }
+
+  /** Optionally wraps the {@code src} in a function and computes a LiveVariablesAnalysis. */
+  private static LiveVariablesAnalysis computeLiveness(String src, Wrapper wrapper) {
     // Set up compiler
     Compiler compiler = new Compiler();
     CompilerOptions options = new CompilerOptions();
@@ -659,8 +691,16 @@ public final class LiveVariablesAnalysisTest {
     compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
 
     // Set up test case
-    src =
-        (async ? "async " : "") + "function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+    switch (wrapper) {
+      case FUNCTION:
+        src = "function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+        break;
+      case ASYNC_FUNCTION:
+        src = "async function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+        break;
+      default:
+        break;
+    }
     Node n = compiler.parseTestCode(src).removeFirstChild();
     checkState(n.isFunction(), n);
     Node script = new Node(Token.SCRIPT, n);
@@ -673,9 +713,12 @@ public final class LiveVariablesAnalysisTest {
     Scope childScope = scopeCreator.createScope(NodeUtil.getFunctionBody(n), scope);
 
     // Control flow graph
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
-    cfa.process(null, n);
-    ControlFlowGraph<Node> cfg = cfa.getCfg();
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder()
+            .setCompiler(compiler)
+            .setCfgRoot(n)
+            .setIncludeEdgeAnnotations(true)
+            .computeCfg();
 
     // All variables declared in function
     AllVarsDeclaredInFunction allVarsDeclaredInFunction =
@@ -688,4 +731,13 @@ public final class LiveVariablesAnalysisTest {
     analysis.analyze();
     return analysis;
   }
+
+  /** The kinds of functions that source code can be wrapped in for testing. */
+  private enum Wrapper {
+    NONE,
+    /** e.g. <code>function f(){ ... }</code> */
+    FUNCTION,
+    /** e.g. <code>async function f(){ ... }</code> */
+    ASYNC_FUNCTION
+  }
 }
diff --git a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
index f58ab64..ac6e66a 100644
--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
@@ -35,7 +35,7 @@ public final class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
   private boolean invert = false;
   // removeConst = true; removes const-ness of a name (e.g. If the variable name is CONST)
   private boolean removeConst = false;
-  private final String localNamePrefix = "unique_";
+  private static final String LOCAL_NAME_PREFIX = "unique_";
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
@@ -48,8 +48,15 @@ public final class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
           if (useDefaultRenamer) {
             renamer = new MakeDeclaredNamesUnique();
           } else {
-            renamer = new MakeDeclaredNamesUnique(new InlineRenamer(compiler.getCodingConvention(),
-                compiler.getUniqueNameIdSupplier(), localNamePrefix, removeConst, true, null));
+            renamer =
+                new MakeDeclaredNamesUnique(
+                    new InlineRenamer(
+                        compiler.getCodingConvention(),
+                        compiler.getUniqueNameIdSupplier(),
+                        LOCAL_NAME_PREFIX,
+                        removeConst,
+                        true,
+                        null));
           }
           NodeTraversal.traverseRoots(compiler, renamer, externs, root);
         }
diff --git a/test/com/google/javascript/jscomp/MinimizedConditionTest.java b/test/com/google/javascript/jscomp/MinimizedConditionTest.java
index 860aec2..79d5b16 100644
--- a/test/com/google/javascript/jscomp/MinimizedConditionTest.java
+++ b/test/com/google/javascript/jscomp/MinimizedConditionTest.java
@@ -39,8 +39,7 @@ public final class MinimizedConditionTest {
 
   private static Node parseExpr(String code) {
     Compiler compiler = new Compiler();
-    List<SourceFile> input =
-        ImmutableList.of(SourceFile.fromCode("code", code));
+    ImmutableList<SourceFile> input = ImmutableList.of(SourceFile.fromCode("code", code));
     List<SourceFile> externs = new ArrayList<>();
     CompilerOptions options = new CompilerOptions();
     compiler.init(externs, input, options);
diff --git a/test/com/google/javascript/jscomp/ModulesTestUtils.java b/test/com/google/javascript/jscomp/ModulesTestUtils.java
index 885e363..a8d97e8 100644
--- a/test/com/google/javascript/jscomp/ModulesTestUtils.java
+++ b/test/com/google/javascript/jscomp/ModulesTestUtils.java
@@ -19,10 +19,10 @@ package com.google.javascript.jscomp;
 import com.google.common.collect.ImmutableList;
 
 /**
- * Test utilities for testing modules, used by {@link Es6RewriteModulesTest}
- * and {@link ProcessCommonJSModulesTest}.
+ * Test utilities for testing modules, used by {@link Es6RewriteModulesTest} and {@link
+ * ProcessCommonJSModulesTest}.
  */
-class ModulesTestUtils {
+final class ModulesTestUtils {
 
   static void testModules(CompilerTestCase test, String fileName, String input, String expected) {
     // Shared with ProcessCommonJSModulesTest.
@@ -58,4 +58,6 @@ class ModulesTestUtils {
             SourceFile.fromCode("other.js", ""), SourceFile.fromCode("testcode.js", input));
     test.testWarning(CompilerTestCase.srcs(inputs), CompilerTestCase.warning(warning));
   }
+
+  private ModulesTestUtils() {}
 }
diff --git a/test/com/google/javascript/jscomp/MultiPassTest.java b/test/com/google/javascript/jscomp/MultiPassTest.java
index a5fe6b1..ed21896 100644
--- a/test/com/google/javascript/jscomp/MultiPassTest.java
+++ b/test/com/google/javascript/jscomp/MultiPassTest.java
@@ -16,11 +16,8 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.parsing.parser.FeatureSet.ES2017_MODULES;
-
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.Es6RewriteDestructuring.ObjectDestructuringRewriteMode;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import java.util.ArrayList;
@@ -58,7 +55,6 @@ public final class MultiPassTest extends CompilerTestCase {
             .setName("validityCheck")
             .setRunInFixedPointLoop(true)
             .setInternalFactory(ValidityCheck::new)
-            .setFeatureSet(ES2017_MODULES)
             .build());
     compiler.setPhaseOptimizer(phaseopt);
     return phaseopt;
@@ -382,7 +378,6 @@ public final class MultiPassTest extends CompilerTestCase {
             .setInternalFactory(
                 (compiler) ->
                     new InlineObjectLiterals(compiler, compiler.getUniqueNameIdSupplier()))
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -392,7 +387,6 @@ public final class MultiPassTest extends CompilerTestCase {
             .setName("removeUnreachableCode")
             .setRunInFixedPointLoop(true)
             .setInternalFactory(UnreachableCodeElimination::new)
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -410,7 +404,6 @@ public final class MultiPassTest extends CompilerTestCase {
                         true,
                         true,
                         CompilerOptions.UNLIMITED_FUN_SIZE_AFTER_INLINING))
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -421,7 +414,6 @@ public final class MultiPassTest extends CompilerTestCase {
             .setRunInFixedPointLoop(true)
             .setInternalFactory(
                 (compiler) -> new InlineVariables(compiler, InlineVariables.Mode.ALL))
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -438,12 +430,11 @@ public final class MultiPassTest extends CompilerTestCase {
                       getName(),
                       new PeepholeMinimizeConditions(late),
                       new PeepholeSubstituteAlternateSyntax(late),
-                      new PeepholeReplaceKnownMethods(late, false /* useTypes */),
+                      new PeepholeReplaceKnownMethods(late, /* useTypes= */ false),
                       new PeepholeRemoveDeadCode(),
                       new PeepholeFoldConstants(late, false /* useTypes */),
                       new PeepholeCollectPropertyAssignments());
                 })
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -458,7 +449,6 @@ public final class MultiPassTest extends CompilerTestCase {
                         .removeUnusedThisProperties(true)
                         .removeUnusedObjectDefinePropertiesDefinitions(true)
                         .build())
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -469,7 +459,6 @@ public final class MultiPassTest extends CompilerTestCase {
             .setRunInFixedPointLoop(true)
             .setInternalFactory(
                 (compiler) -> new RemoveUnusedCode.Builder(compiler).removeLocalVars(true).build())
-            .setFeatureSet(ES2017_MODULES)
             .build());
   }
 
@@ -483,7 +472,6 @@ public final class MultiPassTest extends CompilerTestCase {
                         .setDestructuringRewriteMode(
                             ObjectDestructuringRewriteMode.REWRITE_ALL_OBJECT_PATTERNS)
                         .build())
-            .setFeatureSet(FeatureSet.ES2017_MODULES)
             .build());
   }
 
@@ -492,7 +480,6 @@ public final class MultiPassTest extends CompilerTestCase {
         PassFactory.builder()
             .setName("arrowFunctionPass")
             .setInternalFactory(Es6RewriteArrowFunction::new)
-            .setFeatureSet(FeatureSet.ES2017_MODULES)
             .build());
   }
 
@@ -501,7 +488,6 @@ public final class MultiPassTest extends CompilerTestCase {
         PassFactory.builder()
             .setName("splitVariableDeclarationsPass")
             .setInternalFactory(Es6SplitVariableDeclarations::new)
-            .setFeatureSet(FeatureSet.ES2017_MODULES)
             .build());
   }
 
@@ -510,7 +496,6 @@ public final class MultiPassTest extends CompilerTestCase {
         PassFactory.builder()
             .setName("renameVariablesInParamListsPass")
             .setInternalFactory(Es6RenameVariablesInParamLists::new)
-            .setFeatureSet(FeatureSet.ES2017_MODULES)
             .build());
   }
 
diff --git a/test/com/google/javascript/jscomp/NodeTraversalTest.java b/test/com/google/javascript/jscomp/NodeTraversalTest.java
index dcb2c68..cc43af9 100644
--- a/test/com/google/javascript/jscomp/NodeTraversalTest.java
+++ b/test/com/google/javascript/jscomp/NodeTraversalTest.java
@@ -24,6 +24,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallbackInterface;
+import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -484,6 +485,136 @@ public final class NodeTraversalTest {
   }
 
   @Test
+  public void testTraverseAtScopeWithMemberFieldDefScope() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope();
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  a = this.a;",
+            "}",
+            "class Bar extends Foo {",
+            "  b = super.a;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node memberFieldDefA =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getFirstChild(); // member field def
+    Scope memberFieldDefAScope = creator.createScope(memberFieldDefA, globalScope);
+
+    callback.expect(memberFieldDefA, memberFieldDefA);
+    t.traverseAtScope(memberFieldDefAScope);
+    callback.assertEntered();
+
+    Node memberFieldDefB =
+        tree // script
+            .getSecondChild() // class
+            .getLastChild() // class members
+            .getFirstChild(); // member field def
+    Scope memberFieldDefBScope = creator.createScope(memberFieldDefB, globalScope);
+
+    callback.expect(memberFieldDefB, memberFieldDefB);
+    t.traverseAtScope(memberFieldDefBScope);
+    callback.assertEntered();
+  }
+
+  @Test
+  public void testTraverseAtScopeWithComputedFieldDefScope() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope();
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  x = 'hi';",
+            "  [this.x] = this.x;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node computedFieldDef =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getLastChild(); // computed field def
+    Scope computedFieldDefScope = creator.createScope(computedFieldDef, globalScope);
+
+    callback.expect(computedFieldDef, computedFieldDef);
+    t.traverseAtScope(computedFieldDefScope);
+    callback.assertEntered();
+  }
+
+  @Test
+  public void testTraverseFieldDefScopeRootsInOrder() {
+    Compiler compiler = new Compiler();
+    String code =
+        lines(
+            "class Foo {", //
+            "  x = 'hi';",
+            "  [this.x] = this.x;",
+            "}");
+    Node tree = parse(compiler, code);
+    TokenAccumulator callback = new TokenAccumulator();
+    NodeTraversal.traverse(compiler, tree, callback);
+    assertThat(callback.scopeRoots)
+        .containsExactly(
+            Token.SCRIPT, Token.CLASS, Token.MEMBER_FIELD_DEF, Token.COMPUTED_FIELD_DEF)
+        .inOrder();
+  }
+
+  @Test
+  public void testTraverseComputedFieldsInOrder() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    TokenAccumulator callback = new TokenAccumulator();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  [this.x] = true;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node computedFieldDef =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getLastChild(); // computed field def
+    Scope computedFieldDefScope = creator.createScope(computedFieldDef, globalScope);
+
+    t.traverseAtScope(computedFieldDefScope);
+    assertThat(callback.tokens).containsExactly(Token.TRUE, Token.COMPUTED_FIELD_DEF).inOrder();
+
+    callback.tokens.clear();
+  }
+
+  @Test
   public void testGetVarAccessible() {
     Compiler compiler = new Compiler();
     CompilerOptions options = new CompilerOptions();
@@ -725,6 +856,22 @@ public final class NodeTraversalTest {
     }
   }
 
+  private static final class TokenAccumulator extends AbstractScopedCallback {
+
+    final List<Token> tokens = new ArrayList<>();
+    final List<Token> scopeRoots = new ArrayList<>();
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      tokens.add(n.getToken());
+    }
+
+    @Override
+    public void enterScope(NodeTraversal t) {
+      scopeRoots.add(t.getScopeRoot().getToken());
+    }
+  }
+
   // Helper class used to test getCurrentNode
   private static class ExpectNodeOnEnterScope extends NodeTraversal.AbstractPreOrderCallback
       implements NodeTraversal.ScopedCallback {
@@ -762,6 +909,31 @@ public final class NodeTraversalTest {
     }
   }
 
+  @Test
+  public void testTraverseComputedFieldsInClass() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    StringAccumulator callback = new StringAccumulator();
+
+    String code =
+        lines(
+            "class Foo {",
+            "  ['in field lhs'] = 'in field rhs';",
+            "  ['in method lhs']() {",
+            "    'nested in method';",
+            "  }",
+            "}");
+
+    Node tree = parse(compiler, code);
+
+    NodeTraversal.traverse(compiler, tree, callback);
+    assertThat(callback.strings)
+        .containsExactly("in field lhs", "in method lhs", "in field rhs", "nested in method")
+        .inOrder();
+
+    callback.strings.clear();
+  }
+
   // Helper class used to test accessible variables
   private static class AccessibleCallback extends NodeTraversal.AbstractPreOrderCallback
       implements NodeTraversal.ScopedCallback {
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index bcb04f8..e5ca1fd 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -79,7 +79,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
@@ -103,7 +103,7 @@ public final class NodeUtilTest {
 
   /** Provides methods for parsing and accessing the compiler used for the parsing. */
   private static class ParseHelper {
-    private Compiler compiler = null;
+    private @Nullable Compiler compiler = null;
 
     private Node parse(String js) {
       CompilerOptions options = new CompilerOptions();
@@ -126,6 +126,10 @@ public final class NodeUtilTest {
       checkState(rootNode.isScript(), rootNode);
       return token.equals(SCRIPT) ? rootNode : getNode(rootNode, token);
     }
+
+    private Node parseSecond(Token token, String js) {
+      return getNode(parseFirst(token, js), token);
+    }
   }
 
   private static Node parse(String js) {
@@ -142,6 +146,16 @@ public final class NodeUtilTest {
     return new ParseHelper().parseFirst(token, js);
   }
 
+  /**
+   * Parses {@code js} into an AST and then returns the second Node in pre-traversal order with the
+   * given token.
+   *
+   * <p>TODO(nickreid): Consider an overload that takes a `Predicate` rather than a `Token`.
+   */
+  private static Node parseSecond(Token token, String js) {
+    return new ParseHelper().parseSecond(token, js);
+  }
+
   /** Returns the parsed expression (e.g. returns a NAME given 'a') */
   private static Node parseExpr(String js) {
     Node script = parse("(" + js + ");"); // Parens force interpretation as an expression.
@@ -175,8 +189,7 @@ public final class NodeUtilTest {
    * @return the first matching node, or {@code null} if none match.
    */
   // TODO(nickreid): Consider an overload that takes a `Predicate` rather than a `Token`.
-  @Nullable
-  private static Node getNodeOrNull(Node root, Token token) {
+  private static @Nullable Node getNodeOrNull(Node root, Token token) {
     for (Node n = root.getFirstChild(); n != null; n = n.getNext()) {
       if (n.getToken() == token) {
         return n;
@@ -238,7 +251,7 @@ public final class NodeUtilTest {
     public Tri expectedResult;
 
     @Parameters(name = "getBooleanValue(\"{0}\") => {1}")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // truly literal, side-effect free values are always known
@@ -469,11 +482,11 @@ public final class NodeUtilTest {
     }
 
     private boolean isLiteralValueExcludingFunctions(String code) {
-      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions */ false);
+      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions= */ false);
     }
 
     private boolean isLiteralValue(String code) {
-      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions */ true);
+      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions= */ true);
     }
 
     private void assertLiteralAndImmutable(Node n) {
@@ -713,6 +726,29 @@ public final class NodeUtilTest {
     }
 
     @Test
+    public void testisBlockScopedFunctionDeclaration() {
+      assertThat(
+              NodeUtil.isBlockScopedFunctionDeclaration(parseFirst(FUNCTION, "function foo(){}")))
+          .isFalse();
+      assertThat(
+              NodeUtil.isBlockScopedFunctionDeclaration(
+                  parseFirst(FUNCTION, "var x = function(){}")))
+          .isFalse();
+      assertThat(
+              NodeUtil.isBlockScopedFunctionDeclaration(
+                  parseFirst(FUNCTION, "{ function foo(){} }")))
+          .isTrue();
+      assertThat(
+              NodeUtil.isBlockScopedFunctionDeclaration(
+                  parseFirst(FUNCTION, "class C { static { function foo(){} } }")))
+          .isTrue();
+      assertThat(
+              NodeUtil.isBlockScopedFunctionDeclaration(
+                  parseSecond(FUNCTION, "function foo(){ class C { static { function a(){} } } }")))
+          .isTrue();
+    }
+
+    @Test
     public void testIsMethodDeclaration() {
       assertThat(NodeUtil.isMethodDeclaration(parseFirst(FUNCTION, "class C { constructor() {} }")))
           .isTrue();
@@ -1509,6 +1545,11 @@ public final class NodeUtilTest {
       assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x&&y"))).isFalse();
       assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("1&&y"))).isFalse();
 
+      // Logical assignments are always treated as non-local
+      assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x||=1"))).isFalse();
+      assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x&&=1"))).isFalse();
+      assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x??=1"))).isFalse();
+
       // Only the results of HOOK matter
       assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x?1:2"))).isTrue();
       assertThat(NodeUtil.evaluatesToLocalValue(parseExpr("x?x:2"))).isFalse();
@@ -3585,30 +3626,30 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInNodeWithNameDeclaration() {
-      assertThat(findLhsNodesInNode("var x;")).hasSize(1);
-      assertThat(findLhsNodesInNode("var x, y;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var f = function(x, y, z) {};")).hasSize(1);
+      assertThat(visitLhsNodesInNode("var x;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("var x, y;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var f = function(x, y, z) {};")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithArrayPatternDeclaration() {
-      assertThat(findLhsNodesInNode("var [x=a => a, y = b=>b+1] = arr;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var [x=a => a, y = b=>b+1, ...z] = arr;")).hasSize(3);
-      assertThat(findLhsNodesInNode("var [ , , , y = b=>b+1, ...z] = arr;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var [x=a => a, y = b=>b+1] = arr;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var [x=a => a, y = b=>b+1, ...z] = arr;")).hasSize(3);
+      assertThat(visitLhsNodesInNode("var [ , , , y = b=>b+1, ...z] = arr;")).hasSize(2);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithObjectPatternDeclaration() {
-      assertThat(findLhsNodesInNode("var {x = a=>a, y = b=>b+1} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {p1: x = a=>a, p2: y = b=>b+1} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {[pname]: x = a=>a, [p2name]: y} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {lhs1 = a, p2: [lhs2, lhs3 = b] = [notlhs]} = obj;"))
+      assertThat(visitLhsNodesInNode("var {x = a=>a, y = b=>b+1} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {p1: x = a=>a, p2: y = b=>b+1} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {[pname]: x = a=>a, [p2name]: y} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {lhs1 = a, p2: [lhs2, lhs3 = b] = [notlhs]} = obj;"))
           .hasSize(3);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithCastOnLhs() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("/** @type {*} */ (a.b) = 3;");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("/** @type {*} */ (a.b) = 3;");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).matchesQualifiedName("a.b");
@@ -3616,28 +3657,28 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInNodeWithArrayPatternAssign() {
-      assertThat(findLhsNodesInNode("[this.x] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[this.x, y] = rhs;")).hasSize(2);
-      assertThat(findLhsNodesInNode("[this.x, y, this.z] = rhs;")).hasSize(3);
-      assertThat(findLhsNodesInNode("[y, this.z] = rhs;")).hasSize(2);
-      assertThat(findLhsNodesInNode("[x[y]] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[x.y.z] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[ /** @type {*} */ (x.y.z) ] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[this.x] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[this.x, y] = rhs;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("[this.x, y, this.z] = rhs;")).hasSize(3);
+      assertThat(visitLhsNodesInNode("[y, this.z] = rhs;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("[x[y]] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[x.y.z] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[ /** @type {*} */ (x.y.z) ] = rhs;")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithComplexAssign() {
-      assertThat(findLhsNodesInNode("x += 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y += 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x -= 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y -= 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x *= 2;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y *= 2;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x += 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y += 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x -= 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y -= 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x *= 2;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y *= 2;")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInForOfWithDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (const {x, y} of iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (const {x, y} of iterable) {}");
       assertThat(lhsNodes).hasSize(2);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3646,7 +3687,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForOfWithoutDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for ({x, y: a.b} of iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for ({x, y: a.b} of iterable) {}");
       assertThat(lhsNodes).hasSize(2);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3655,7 +3696,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForInWithDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (const x in obj) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (const x in obj) {}");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3663,7 +3704,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForInWithoutDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (a.b in iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (a.b in iterable) {}");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).matchesQualifiedName("a.b");
@@ -4378,7 +4419,7 @@ public final class NodeUtilTest {
   public static final class GoogRequireInfoTest {
 
     @Parameters(name = "src={0}, name={1}, GoogRequire={2}")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             {
@@ -4451,7 +4492,7 @@ public final class NodeUtilTest {
   @RunWith(Parameterized.class)
   public static final class ReferencesReceiverTest {
     @Parameters(name = "\"{0}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       //
       //
       ImmutableMap<String, Boolean> templateToDefinesOwnReceiver =
@@ -4568,7 +4609,7 @@ public final class NodeUtilTest {
   public static final class GetRValueOfLValueTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // CLASS_MEMBERS
@@ -4599,7 +4640,7 @@ public final class NodeUtilTest {
   public static final class IteratesImpureIterableTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // ITER_SPREAD < ARRAYLIT
@@ -4703,7 +4744,7 @@ public final class NodeUtilTest {
   public static final class CanBeSideEffectedTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // TODO: Expand test cases for more node types.
@@ -4789,17 +4830,17 @@ public final class NodeUtilTest {
     return funcNode == NodeUtil.getRValueOfLValue(nameNode);
   }
 
-  private static void testFunctionName(String js, String expected) {
+  private static void testFunctionName(String js, @Nullable String expected) {
     assertThat(NodeUtil.getNearestFunctionName(parseFirst(FUNCTION, js))).isEqualTo(expected);
   }
 
   /**
-   * @param js JavaScript node to be passed to {@code NodeUtil.findLhsNodesInNode}. Must be either
+   * @param js JavaScript node to be passed to {@code NodeUtil.visitLhsNodesInNode}. Must be either
    *     an EXPR_RESULT containing an assignment operation (e.g. =, +=, /=, etc) in which case the
-   *     assignment node will be passed to {@code NodeUtil.findLhsNodesInNode}, or a VAR, LET, or
+   *     assignment node will be passed to {@code NodeUtil.visitLhsNodesInNode}, or a VAR, LET, or
    *     CONST statement, in which case the declaration statement will be passed.
    */
-  private static Iterable<Node> findLhsNodesInNode(String js) {
+  private static Iterable<Node> visitLhsNodesInNode(String js) {
     Node root = parse(js);
     checkState(root.isScript(), root);
     root = root.getOnlyChild();
@@ -4807,7 +4848,9 @@ public final class NodeUtilTest {
       root = root.getOnlyChild();
       checkState(NodeUtil.isAssignmentOp(root), root);
     }
-    return NodeUtil.findLhsNodesInNode(root);
+    ArrayList<Node> nodes = new ArrayList<>();
+    NodeUtil.visitLhsNodesInNode(root, nodes::add);
+    return nodes;
   }
 
   private static Node getNameNode(Node n, String name) {
@@ -4853,8 +4896,7 @@ public final class NodeUtilTest {
   /**
    * @return The first node in {@code tree} that is an array pattern or object pattern.
    */
-  @Nullable
-  private static Node getPattern(Node tree) {
+  private static @Nullable Node getPattern(Node tree) {
     if (tree.isDestructuringPattern()) {
       return tree;
     }
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 78c7c98..3343ef3 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -22,6 +22,7 @@ import com.google.javascript.jscomp.CompilerOptions.ChunkOutputType;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.CompilerOptions.PropertyCollapseLevel;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -31,7 +32,9 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** @author johnlenz@google.com (John Lenz) */
+/**
+ * @author johnlenz@google.com (John Lenz)
+ */
 @RunWith(JUnit4.class)
 public final class NormalizeTest extends CompilerTestCase {
 
@@ -59,6 +62,15 @@ public final class NormalizeTest extends CompilerTestCase {
     return 1;
   }
 
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    // Validate that Normalize copies colors onto any nodes it synthesizes
+    enableTypeInfoValidation();
+    enableTypeCheck();
+    replaceTypesWithColors();
+  }
+
   @Test
   public void testNullishCoalesce() {
     test("var a = x ?? y, b = foo()", "var a = x ?? y; var b = foo()");
@@ -204,6 +216,7 @@ public final class NormalizeTest extends CompilerTestCase {
   public void testClassField() {
     test(
         lines(
+            "/** @unrestricted */",
             "class Foo {", //
             "  f1;",
             "  ['f2'] = 1;",
@@ -220,6 +233,51 @@ public final class NormalizeTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlock() {
+    test(
+        lines(
+            "var x;",
+            "class Foo {", //
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "  }",
+            "}",
+            "class Bar {",
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "}"),
+        lines(
+            "var x;",
+            "class Foo {", //
+            "  static {",
+            "    var x$jscomp$1;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "  static {",
+            "    var x$jscomp$2;",
+            "    let y$jscomp$1;",
+            "  }",
+            "}",
+            "class Bar {",
+            "  static {",
+            "    var x$jscomp$3;",
+            "    let y$jscomp$2;",
+            "    this.x;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testClassInForLoop() {
     testSame("for (class a {};;) { break; }");
   }
@@ -314,7 +372,7 @@ public final class NormalizeTest extends CompilerTestCase {
     test("x /= 1;", "x = x / 1;");
     test("x %= 1;", "x = x % 1;");
 
-    test("/** @suppress {const} */ x += 1;", "/** @suppress {const} */ x = x + 1;");
+    test("/** @suppress {const} */ x += 1;", "x = x + 1;");
   }
 
   @Test
@@ -431,7 +489,7 @@ public final class NormalizeTest extends CompilerTestCase {
     test(
         externs("var extern;"),
         srcs("/** @suppress {duplicate} */ var extern = 3;"),
-        expected("/** @suppress {duplicate} */ var extern = 3;"));
+        expected("var extern = 3;"));
   }
 
   @Test
@@ -465,6 +523,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForIn1() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-in
     testSame("for(a in b) foo();");
 
@@ -480,7 +540,10 @@ public final class NormalizeTest extends CompilerTestCase {
     test("if (x) for(var a in b) foo()", "if (x) { var a; for(a in b) foo() }");
 
     // Verify names in destructuring declarations are individually declared.
-    test("for (var [a, b] in c) foo();", "var a; var b; for ([a, b] in c) foo();");
+    test(
+        externs(new TestExternsBuilder().addIterable().addString().build()),
+        srcs("for (var [a, b] in c) foo();"),
+        expected("var a; var b; for ([a, b] in c) foo();"));
 
     test("for (var {a, b} in c) foo();", "var a; var b; for ({a: a, b: b} in c) foo();");
   }
@@ -495,6 +558,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForOf() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-of
     testSame("for (a of b) foo();");
 
@@ -517,6 +582,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForAwaitOf() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-await-of
     testSame("async () => { for await (a of b) foo(); }");
 
@@ -618,6 +685,9 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testMakeLocalNamesUnique() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+    disableCompareJsDoc();
+
     // Verify global names are untouched.
     testSame("var a;");
 
@@ -676,6 +746,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testMakeParamNamesUnique() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test(
         "function f(x) { x; }\nfunction g(x) { x; }",
         "function f(x) { x; }\nfunction g(x$jscomp$1) { x$jscomp$1; }");
@@ -699,6 +771,7 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testNoRenameParamNames() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
     testSame("function f(x) { x; }");
 
     testSame("function f(...x) { x; }");
@@ -732,6 +805,10 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testRemoveDuplicateVarDeclarations3() {
+    ignoreWarnings(
+        TypeCheck.FUNCTION_MASKS_VARIABLE,
+        TypeValidator.TYPE_MISMATCH_WARNING,
+        TypeValidator.DUP_VAR_DECLARATION);
     test("var f = 1; function f(){}", "f = 1; function f(){}");
     test("var f; function f(){}", "function f(){}");
 
@@ -747,6 +824,7 @@ public final class NormalizeTest extends CompilerTestCase {
   // http://blickly.github.io/closure-compiler-issues/#290
   @Test
   public void testRemoveDuplicateVarDeclarations4() {
+    disableCompareJsDoc();
     testSame("if (!Arguments) { /** @suppress {duplicate} */ var Arguments = {}; }");
   }
 
@@ -917,6 +995,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testIsConstantByDestructuringWithDefault() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     test("var {CONST = 3} = {}; var b = CONST;", "var {CONST: CONST = 3} = {}; var b = CONST;");
     Node n = getLastCompiler().getRoot();
 
@@ -1041,6 +1121,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testShadowFunctionName() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test(
         lines("function f() {", "  var f = 'test';", "  console.log(f);", "}"),
         lines("function f() {", "  var f$jscomp$1 = 'test';", "  console.log(f$jscomp$1);", "}"));
@@ -1171,26 +1253,36 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testES6ShorthandPropertySyntax05() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a = 5} = obj;", "var {a: a = 5} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax06() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a = 5, b = 3} = obj;", "var {a: a = 5, b: b = 3} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax07() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a: a = 5, b = 3} = obj;", "var {a: a = 5, b: b = 3} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax08() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a, b} = obj;", "var {a: a, b: b} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax09() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("({a = 5} = obj);", "({a: a = 5} = obj);");
   }
 
@@ -1206,6 +1298,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testES6ShorthandPropertySyntax12() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     testSame("({a: a = 5} = obj)");
   }
 
@@ -1221,7 +1315,9 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testRewriteExportSpecShorthand2() {
-    test("export {a, b as c, d};", "export {a as a, b as c, d as d};");
+    test(
+        "let a, b, d; export {a, b as c, d};",
+        "let a; let b; let d;export {a as a, b as c, d as d};");
   }
 
   @Test
@@ -1238,6 +1334,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testSplitExportDeclarationWithDestructuring() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     test("export var {} = {};", "var {} = {}; export {};");
     test(
         lines("let obj = {a: 3, b: 2};", "export var {a, b: d, e: f = 2} = obj;"),
diff --git a/test/com/google/javascript/jscomp/OptimizeCallsTest.java b/test/com/google/javascript/jscomp/OptimizeCallsTest.java
index 449854e..234fbf4 100644
--- a/test/com/google/javascript/jscomp/OptimizeCallsTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeCallsTest.java
@@ -24,6 +24,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.util.ArrayList;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,7 +37,7 @@ public final class OptimizeCallsTest extends CompilerTestCase {
   private OptimizeCalls.ReferenceMap references;
 
   // Whether to consider externs during the next collection. Must be explicitly set.
-  private Boolean considerExterns = null;
+  private @Nullable Boolean considerExterns = null;
 
   @Override
   @Before
@@ -290,6 +291,27 @@ public final class OptimizeCallsTest extends CompilerTestCase {
         .inOrder();
   }
 
+  @Test
+  public void testReferenceCollection_reflectedProps() {
+    considerExterns = false;
+
+    test(
+        srcs(
+            lines(
+                "class C {",
+                "  m() {",
+                "    console.log('hello');",
+                "  }",
+                "}",
+                "C.prototype[goog.reflect.objectProperty('m', C.prototype)]();")));
+
+    final ImmutableMap<String, ArrayList<Node>> nameToRefs =
+        ImmutableMap.copyOf(references.getPropReferences());
+    assertThat(nameToRefs.get("m"))
+        .comparingElementsUsing(HAS_TOKEN)
+        .containsExactly(Token.MEMBER_FUNCTION_DEF, Token.CALL)
+        .inOrder();
+  }
 
   private static final Correspondence<Map.Entry<String, Node>, String> KEY_EQUALITY =
       Correspondence.transforming(Map.Entry::getKey, "has key");
diff --git a/test/com/google/javascript/jscomp/OptimizeParametersTest.java b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
index 8cd66a9..ba2ed5f 100644
--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
@@ -16,6 +16,12 @@
 
 package com.google.javascript.jscomp;
 
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.testing.CodeSubTree;
+import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.Node.SideEffectFlags;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -1598,6 +1604,122 @@ public final class OptimizeParametersTest extends CompilerTestCase {
   }
 
   @Test
+  public void testRewriteClassStaticBlock_removeOptional() {
+    test(
+        lines(
+            "function foo(a,b=1){",
+            "  return a * b;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(a){",
+            "  var b = 1;",
+            "  return a * b;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a,b=1){",
+            "      return(a * b);",
+            "    }",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testRewriteClassStaticBlock_trailingUndefinedLiterals() {
+    test(
+        lines(
+            "function foo(a,b){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1, undefined, 2));",
+            "    use(foo(2));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(a,b){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a,b){",
+            "      return a;",
+            "    }",
+            "    use(foo(1, undefined, 2));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testRewriteClassStaticBlock_inlineParameter() {
+    test(
+        lines(
+            "function foo(a){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(){",
+            "  var a = 1;",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo());",
+            "    use(foo());",
+            "    use(foo());",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a){",
+            "      return(a);",
+            "    }",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testNoRewriteUsedClassConstructorWithClassNonstaticField() {
     testSame(
         lines(
@@ -1883,4 +2005,26 @@ public final class OptimizeParametersTest extends CompilerTestCase {
   public void testTrailingUndefinedLiterals_afterAllFormalParameters_sideEffects() {
     testSame("function foo(a, b) { use(a)}; foo('used', undefined, sideEffects()); foo(2);");
   }
+
+  @Test
+  public void testInliningSideEffectfulArg_updatesInvocationSideEffects() {
+    enableComputeSideEffects();
+    test(
+        externs("function sideEffects() {}"),
+        srcs("function foo() {} foo(sideEffects()); foo(sideEffects());"),
+        expected("function foo() { sideEffects(); } foo(); foo();"));
+
+    // Inspect the AST to verify both calls to `foo()` are marked as mutating global state
+    Node jsRoot = getLastCompiler().getJsRoot();
+    ImmutableList<Node> calls =
+        CodeSubTree.findNodesNonEmpty(
+            jsRoot, n -> (n.isCall() && n.getFirstChild().matchesName("foo")));
+    for (Node call : calls) {
+      assertThat(call.getSideEffectFlags())
+          .isEqualTo(
+              new SideEffectFlags(SideEffectFlags.NO_SIDE_EFFECTS)
+                  .setMutatesGlobalState()
+                  .valueOf());
+    }
+  }
 }
diff --git a/test/com/google/javascript/jscomp/OptionalChainTypeCheckTest.java b/test/com/google/javascript/jscomp/OptionalChainTypeCheckTest.java
index 5c1f857..6f4512c 100644
--- a/test/com/google/javascript/jscomp/OptionalChainTypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/OptionalChainTypeCheckTest.java
@@ -234,7 +234,7 @@ public class OptionalChainTypeCheckTest {
     @Test
     public void test() {
       String js = createTestString(testCase);
-      if (!testCase.mustReport().isPresent()) {
+      if (testCase.mustReport().isEmpty()) {
         newTest().addSource(js).run();
       } else {
         newTest().addSource(js).addDiagnostic(testCase.mustReport().get()).run();
@@ -319,7 +319,7 @@ public class OptionalChainTypeCheckTest {
     @Test
     public void test() {
       String js = createTestString(testCase);
-      if (!testCase.mustReport().isPresent()) {
+      if (testCase.mustReport().isEmpty()) {
         newTest().addSource(js).run();
       } else {
         newTest().addSource(js).addDiagnostic(testCase.mustReport().get()).run();
@@ -538,7 +538,7 @@ public class OptionalChainTypeCheckTest {
     @Test
     public void testOptChainCallExpressions() {
       String js = createOptChainCallTestString(testCase);
-      if (!testCase.mustReport().isPresent()) {
+      if (testCase.mustReport().isEmpty()) {
         newTest().addSource(js).run();
       } else {
         newTest().addSource(js).addDiagnostic(testCase.mustReport().get()).run();
diff --git a/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java b/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java
new file mode 100644
index 0000000..a1317df
--- /dev/null
+++ b/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import java.util.HashSet;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link ParenthesizeFunctionsInChunks} in isolation. */
+@RunWith(JUnit4.class)
+public final class ParenthesizeFunctionsInChunksTest extends CompilerTestCase {
+  private final HashSet<String> chunksToParaenthesize = new HashSet<>();
+  private static final String CHUNK_NAME_FOR_TEST = "$strong$";
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    disableValidateAstChangeMarking();
+  }
+
+  @Override
+  protected CompilerPass getProcessor(final Compiler compiler) {
+    return new ParenthesizeFunctionsInChunks(compiler, chunksToParaenthesize);
+  }
+
+  @Test
+  public void testFunctionWrappingWithParens_withinChunk() {
+    chunksToParaenthesize.add(CHUNK_NAME_FOR_TEST);
+    test("function f() {}", "var f = (function() {})");
+    test("var foo = function foo() {}", "var foo = (function foo() {})");
+    test("foo = function f() {}", "foo = (function f() {})");
+    test("const fn = function() {};", "const fn = (function() {});");
+    test("if (x < 3) { var fn = function() {}; }", "if (x < 3) { var fn = (function() {}); }");
+  }
+
+  @Test
+  public void testFunctionWrappingWithParens_outsideChunk() {
+    chunksToParaenthesize.clear();
+    testSame("function f() {}");
+    testSame("var foo = function foo() {}");
+    testSame("foo = function f() {}");
+    testSame("const fn = function() {};");
+    testSame("if (x < 3) { var fn = function() {}; }");
+  }
+}
diff --git a/test/com/google/javascript/jscomp/PartialCompilationTest.java b/test/com/google/javascript/jscomp/PartialCompilationTest.java
index 58ded58..e57c143 100644
--- a/test/com/google/javascript/jscomp/PartialCompilationTest.java
+++ b/test/com/google/javascript/jscomp/PartialCompilationTest.java
@@ -29,7 +29,6 @@ import com.google.javascript.rhino.jstype.NoType;
 import com.google.javascript.rhino.jstype.ObjectType;
 import com.google.javascript.rhino.jstype.UnionType;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
@@ -173,7 +172,7 @@ public class PartialCompilationTest {
     assertWithMessage("type %s", x.getType()).that(x.getType().isUnionType()).isTrue();
     UnionType unionType = (UnionType) x.getType();
 
-    Collection<JSType> alternatives = unionType.getAlternates();
+    ImmutableList<JSType> alternatives = unionType.getAlternates();
     assertThat(alternatives).hasSize(3);
 
     int nullTypeCount = 0;
diff --git a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
index fb68129..12323e0 100644
--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
@@ -23,9 +23,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.rhino.Node;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -685,8 +682,9 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
     // fold if left is null/undefined
     test("null ?? 1", "1");
     test("undefined ?? false", "false");
+    test("(a(), null) ?? 1", "(a(), null, 1)");
 
-    test("x = [foo()] ?? x", "x = ([foo()],x)");
+    test("x = [foo()] ?? x", "x = [foo()]");
 
     // short circuit on all non nullish LHS
     test("x = false ?? x", "x = false");
@@ -2081,7 +2079,7 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
 
   @Test
   public void testInvertibleOperators() {
-    Map<String, String> inverses =
+    ImmutableMap<String, String> inverses =
         ImmutableMap.<String, String>builder()
             .put("==", "!=")
             .put("===", "!==")
@@ -2092,10 +2090,10 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
             .put("!=", "==")
             .put("!==", "===")
             .buildOrThrow();
-    Set<String> comparators = ImmutableSet.of("<=", "<", ">=", ">");
-    Set<String> equalitors = ImmutableSet.of("==", "===");
-    Set<String> uncomparables = ImmutableSet.of("undefined", "void 0");
-    List<String> operators = ImmutableList.copyOf(inverses.values());
+    ImmutableSet<String> comparators = ImmutableSet.of("<=", "<", ">=", ">");
+    ImmutableSet<String> equalitors = ImmutableSet.of("==", "===");
+    ImmutableSet<String> uncomparables = ImmutableSet.of("undefined", "void 0");
+    ImmutableList<String> operators = ImmutableList.copyOf(inverses.values());
     for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {
       for (int iOperandB = 0;
            iOperandB < LITERAL_OPERANDS.size();
@@ -2133,16 +2131,8 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
   @Test
   public void testCommutativeOperators() {
     late = true;
-    List<String> operators =
-        ImmutableList.of(
-            "==",
-            "!=",
-            "===",
-            "!==",
-            "*",
-            "|",
-            "&",
-            "^");
+    ImmutableList<String> operators =
+        ImmutableList.of("==", "!=", "===", "!==", "*", "|", "&", "^");
     for (String a : LITERAL_OPERANDS) {
       for (String b : LITERAL_OPERANDS) {
         for (String op : operators) {
diff --git a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
index 38dfb92..6f4f0b3 100644
--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
@@ -47,7 +47,7 @@ public class PeepholeIntegrationTest extends CompilerTestCase {
         new PeepholeSubstituteAlternateSyntax(late),
         new PeepholeRemoveDeadCode(),
         new PeepholeFoldConstants(late, false /* useTypes */),
-        new PeepholeReplaceKnownMethods(late, false /* useTypes */));
+        new PeepholeReplaceKnownMethods(late, /* useTypes= */ false));
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
index cd0577b..03a6a2a 100644
--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
@@ -223,6 +223,20 @@ public final class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
   }
 
   @Test
+  public void testConstantConditionWithSideEffect_coalesce() {
+    fold("b = null; b ?? (x = 1)", "b = null; void 0 ?? (x = 1)");
+    fold("b = undefined; b ?? (x = 1)", "b = undefined; void 0 ?? (x = 1)");
+    fold("b = (fn(), null); b ?? (x = 1)", "b = (fn(), null); void 0 ?? (x = 1)");
+
+    fold("b = 34; b ?? (x = 1)", "b = 34; 0 ?? (x = 1)");
+    fold("b = 'test'; b ?? (x = 1)", "b = 'test'; 0 ?? (x = 1)");
+    fold("b = []; b ?? (x = 1)", "b = []; 0 ?? (x = 1)");
+    fold("b = (fn(), 0); b ?? (x = 1)", " b= (fn(), 0); 0 ?? (x = 1)");
+
+    foldSame("b = fn(); b ?? (x = 1)");
+  }
+
+  @Test
   public void testVarLifting() {
     fold("if(true)var a", "var a");
     fold("if(false)var a", "var a");
@@ -251,6 +265,8 @@ public final class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
 
     // Make sure it plays nice with minimizing
     fold("for(;false;) { foo(); continue }", "");
+
+    fold("l1:for(;false;) {  }", "");
   }
 
   @Test
@@ -1386,6 +1402,8 @@ public final class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
     fold("try {} catch (e) {}", "");
     fold("try {} finally {}", "");
     fold("try {} catch (e) {} finally {}", "");
+    fold("L1:try {} catch (e) {} finally {}", "");
+    fold("L2:L1:try {} catch (e) {} finally {}", "");
   }
 
   @Test
@@ -1736,4 +1754,43 @@ public final class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
             "  }",
             "}"));
   }
+
+  @Test
+  public void testClassStaticBlock() {
+    fold(
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "}"));
+
+    foldSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    this.x = 0;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testRemoveUnreachableOptionalChainingCall() {
+    fold("(null)?.();", "");
+    fold("(void 0)?.();", "");
+    fold("(undefined)?.();", "");
+    fold("(void 0)?.(0)", "");
+    fold("(void 0)?.(function f() {})", "");
+    // arguments with unknown side effects are also removed
+    fold("(void 0)?.(f(), g())", "");
+
+    // void arguments with unknown side effects are preserved
+    fold("(void f())?.();", "f();");
+    fold("g((void f())?.());", "g(void f());");
+
+    foldSame("(f(), null)?.()");
+    foldSame("f?.()");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
index e37e41c..6b4f6af 100644
--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
@@ -18,13 +18,10 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
-import static com.google.javascript.jscomp.PhaseOptimizer.FEATURES_NOT_SUPPORTED_BY_PASS;
-import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DIAGNOSTIC_EQUALITY;
 
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.CompilerOptions.TracerMode;
 import com.google.javascript.jscomp.PhaseOptimizer.Loop;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -181,31 +178,6 @@ public final class PhaseOptimizerTest {
     }
   }
 
-  @Test
-  public void testSetSkipUnsupportedPasses() {
-    compiler.getOptions().setSkipUnsupportedPasses(true);
-    addUnsupportedPass("testPassFactory");
-
-    assertPasses();
-
-    // Error will be converted to warning by a `WarningsGuard`.
-    assertThat(compiler.getErrors())
-        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
-        .containsExactly(FEATURES_NOT_SUPPORTED_BY_PASS);
-  }
-
-  @Test
-  public void testSetDontSkipUnsupportedPasses() {
-    compiler.getOptions().setSkipUnsupportedPasses(false);
-    addUnsupportedPass("testPassFactory");
-
-    assertPasses("testPassFactory");
-
-    assertThat(compiler.getErrors())
-        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
-        .containsExactly(FEATURES_NOT_SUPPORTED_BY_PASS);
-  }
-
   public void assertPasses(String... names) {
     optimizer.process(null, dummyRoot);
     assertThat(passesRun).isEqualTo(ImmutableList.copyOf(names));
@@ -219,28 +191,15 @@ public final class PhaseOptimizerTest {
     loop.addLoopedPass(createPassFactory(name, numChanges, false));
   }
 
-  /** Adds a pass with the given name that does not support some of the features used in the AST. */
-  private void addUnsupportedPass(String name) {
-    compiler.setFeatureSet(FeatureSet.latest());
-    optimizer.addOneTimePass(
-        createPassFactory(name, createPass(name, 0), true, FeatureSet.BARE_MINIMUM));
-  }
-
   private PassFactory createPassFactory(String name, int numChanges, boolean isOneTime) {
     return createPassFactory(name, createPass(name, numChanges), isOneTime);
   }
 
   private PassFactory createPassFactory(String name, final CompilerPass pass, boolean isOneTime) {
-    return createPassFactory(name, pass, isOneTime, FeatureSet.latest());
-  }
-
-  private PassFactory createPassFactory(
-      String name, final CompilerPass pass, boolean isOneTime, FeatureSet featureSet) {
     return PassFactory.builder()
         .setName(name)
         .setRunInFixedPointLoop(!isOneTime)
         .setInternalFactory((compiler) -> pass)
-        .setFeatureSet(featureSet)
         .build();
   }
 
diff --git a/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java b/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
index 1d7edd5..db8a612 100644
--- a/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
+++ b/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.testing.NodeSubject;
 import java.util.function.Consumer;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -235,10 +236,10 @@ public final class PolyfillUsageFinderTest {
     }
 
     static final class Builder {
-      private Polyfills polyfillsTable = null;
-      private Compiler compiler = null;
-      private PolyfillUsageFinder polyfillUsageFinder = null;
-      private Node rootNode = null;
+      private @Nullable Polyfills polyfillsTable = null;
+      private @Nullable Compiler compiler = null;
+      private @Nullable PolyfillUsageFinder polyfillUsageFinder = null;
+      private @Nullable Node rootNode = null;
 
       Builder withPolyfillTableLines(String... polyfillTableLines) {
         polyfillsTable = Polyfills.fromTable(lines(polyfillTableLines));
@@ -344,7 +345,7 @@ public final class PolyfillUsageFinderTest {
       return this;
     }
 
-    PolyfillSubject hasKind(Polyfill.Kind expectedKind) {
+    PolyfillSubject hasKind(Kind expectedKind) {
       check("kind").that(actual.kind).isEqualTo(expectedKind);
       return this;
     }
diff --git a/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java b/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
index 013ea2c..ab63eb8 100644
--- a/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
+++ b/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
@@ -27,6 +27,7 @@ import com.google.javascript.jscomp.modules.ModuleMetadataMap;
 import com.google.javascript.jscomp.modules.ModuleMetadataMap.ModuleMetadata;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -38,7 +39,7 @@ import org.junit.runners.JUnit4;
 public class PolymerBehaviorExtractorTest extends CompilerTypeTestCase {
 
   private PolymerBehaviorExtractor extractor;
-  private Node behaviorArray;
+  private @Nullable Node behaviorArray;
   private ModuleMetadataMap moduleMetadataMap;
 
   @Override
@@ -580,7 +581,7 @@ public class PolymerBehaviorExtractorTest extends CompilerTypeTestCase {
    * Tests that the behaviorArray resolves to exactly one behavior, using the provided
    * ModuleMetadata for behavior extraction.
    */
-  private void assertSingleBehaviorExtractionSucceeds(ModuleMetadata metadata) {
+  private void assertSingleBehaviorExtractionSucceeds(@Nullable ModuleMetadata metadata) {
     ImmutableList<BehaviorDefinition> defs = extractor.extractBehaviors(behaviorArray, metadata);
     assertThat(compiler.getErrors()).isEmpty();
     assertThat(defs).hasSize(1);
diff --git a/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java b/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
index 83ca5ec..cfea4d5 100644
--- a/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
+++ b/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
@@ -22,6 +22,7 @@ import com.google.javascript.jscomp.modules.ModuleMap;
 import com.google.javascript.jscomp.modules.ModuleMetadataMap;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,7 +31,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class PolymerClassDefinitionTest extends CompilerTypeTestCase {
 
-  private Node polymerCall;
+  private @Nullable Node polymerCall;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/PolymerPassTest.java b/test/com/google/javascript/jscomp/PolymerPassTest.java
index ceaee3b..dc79264 100644
--- a/test/com/google/javascript/jscomp/PolymerPassTest.java
+++ b/test/com/google/javascript/jscomp/PolymerPassTest.java
@@ -27,7 +27,6 @@ import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNANNOTATED
 import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNEXPECTED_PARAMS;
 import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNQUALIFIED_BEHAVIOR;
 import static com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING;
-import static com.google.javascript.jscomp.modules.ModuleMapCreator.MISSING_NAMESPACE_IMPORT;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.javascript.jscomp.NodeUtil.Visitor;
@@ -546,7 +545,6 @@ public class PolymerPassTest extends CompilerTestCase {
 
   @Test
   public void testPolymerRewriterGeneratesDeclaration_OutsideModule_WithRequires() {
-    ignoreWarnings(MISSING_NAMESPACE_IMPORT);
     test(
         srcs(
             TestExternsBuilder.getClosureExternsAsSource(),
@@ -574,7 +572,6 @@ public class PolymerPassTest extends CompilerTestCase {
 
   @Test
   public void testPolymerRewriterGeneratesDeclaration_OutsideModule_WithRequires2() {
-    ignoreWarnings(MISSING_NAMESPACE_IMPORT);
     test(
         srcs(
             TestExternsBuilder.getClosureExternsAsSource(),
diff --git a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
index be6f0cd..7679411 100644
--- a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
+++ b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
@@ -19,7 +19,7 @@ package com.google.javascript.jscomp;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.deps.ModuleLoader;
-import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,7 +28,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
   private ModuleLoader.ResolutionMode resolutionMode = ModuleLoader.ResolutionMode.NODE;
 
   @Override
@@ -1003,7 +1003,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
                 + " __WEBPACK_AMD_DEFINE_RESULT__$$module$test))",
             "})()"));
 
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
@@ -1335,7 +1335,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequire() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "2", "yet_another.js",
@@ -1354,7 +1354,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequireString() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
@@ -1373,7 +1373,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackAMDModuleShim() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "test.js",
             "2", "/webpack/buildin/module.js");
@@ -1547,7 +1547,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequireNamespace() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
diff --git a/test/com/google/javascript/jscomp/ProcessDefinesTest.java b/test/com/google/javascript/jscomp/ProcessDefinesTest.java
index 64f3dd4..83c7024 100644
--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java
+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java
@@ -497,6 +497,13 @@ public final class ProcessDefinesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDeclareInClassStaticBlock() {
+    testError(
+        "class C {static {/** @define {boolean} */ const DEF=true;}}",
+        ProcessDefines.INVALID_DEFINE_LOCATION);
+  }
+
+  @Test
   public void testDefineAssignmentInLoop() {
     testError(
         "/** @define {boolean} */var DEF=true;var x=0;while (x) {DEF=false;}",
@@ -758,6 +765,16 @@ public final class ProcessDefinesTest extends CompilerTestCase {
 
     test(
         lines(
+            "var CLOSURE_DEFINES = CLOSURE_DEFINES || {};",
+            "CLOSURE_DEFINES['FOO'] = 'closureDefault';",
+            "/** @define {string} */ const FOO = 'original';"),
+        lines(
+            "var CLOSURE_DEFINES = CLOSURE_DEFINES || {};",
+            "CLOSURE_DEFINES['FOO'] = 'closureDefault';",
+            "/** @define {string} */ const FOO = 'closureDefault';"));
+
+    test(
+        lines(
             "var CLOSURE_DEFINES = {'FOO': true};", "/** @define {boolean} */ const FOO = false;"),
         lines(
             "var CLOSURE_DEFINES = {'FOO': true};", //
@@ -784,6 +801,27 @@ public final class ProcessDefinesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClosureDefineValues_duplicateKey() {
+    mode = ProcessDefines.Mode.CHECK_AND_OPTIMIZE;
+    test(
+        srcs(
+            lines(
+                "var CLOSURE_DEFINES = CLOSURE_DEFINES || {};",
+                "CLOSURE_DEFINES['FOO'] = 'firstVersionIgnored';",
+                "CLOSURE_DEFINES['FOO'] = 'closureDefault';",
+                "/** @define {string} */ const FOO = 'original';")),
+        error(ProcessDefines.CLOSURE_DEFINES_MULTIPLE));
+
+    test(
+        srcs(
+            lines(
+                "var CLOSURE_DEFINES = {'FOO': 'firstVersionIgnored'};",
+                "CLOSURE_DEFINES['FOO'] = 'closureDefault';",
+                "/** @define {string} */ const FOO = 'original';")),
+        error(ProcessDefines.CLOSURE_DEFINES_MULTIPLE));
+  }
+
+  @Test
   public void testClosureDefineValues_namespacedReplacement() {
     test(
         lines(
@@ -810,6 +848,7 @@ public final class ProcessDefinesTest extends CompilerTestCase {
 
   @Test
   public void testClosureDefineValues_replacementWithOverriddenDefine() {
+    // Command-line flag takes precedence over CLOSURE_DEFINES.
     mode = ProcessDefines.Mode.CHECK_AND_OPTIMIZE;
     overrides.put("FOO", IR.string("override"));
     test(
@@ -834,6 +873,7 @@ public final class ProcessDefinesTest extends CompilerTestCase {
   public void testClosureDefines_unknownDefineErrors() {
     mode = ProcessDefines.Mode.OPTIMIZE;
     test(srcs("var CLOSURE_DEFINES = {'FOO': 0};"), warning(ProcessDefines.UNKNOWN_DEFINE_WARNING));
+    test(srcs("CLOSURE_DEFINES['FOO'] = 0;"), warning(ProcessDefines.UNKNOWN_DEFINE_WARNING));
   }
 
   @Test
@@ -854,6 +894,15 @@ public final class ProcessDefinesTest extends CompilerTestCase {
                 "}",
                 "/** @define {number} */ const FOO = 1;")),
         error(ProcessDefines.NON_GLOBAL_CLOSURE_DEFINES_ERROR));
+
+    test(
+        srcs(
+            lines(
+                "if (cond) {",
+                "  CLOSURE_DEFINES['FOO'] = 0;",
+                "}",
+                "/** @define {number} */ const FOO = 1;")),
+        error(ProcessDefines.NON_GLOBAL_CLOSURE_DEFINES_ERROR));
   }
 
   @Test
@@ -872,6 +921,9 @@ public final class ProcessDefinesTest extends CompilerTestCase {
     testError(
         "var CLOSURE_DEFINES = {'TEMPLATE': `${template}Sub`};",
         ProcessDefines.CLOSURE_DEFINES_ERROR);
+
+    testError("CLOSURE_DEFINES[notStringLiteral] = 42;", ProcessDefines.CLOSURE_DEFINES_ERROR);
+    testError("CLOSURE_DEFINES['FOO'] = a;", ProcessDefines.CLOSURE_DEFINES_ERROR);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/ProcessTweaksTest.java b/test/com/google/javascript/jscomp/ProcessTweaksTest.java
index c7b82fb..b6addf9 100644
--- a/test/com/google/javascript/jscomp/ProcessTweaksTest.java
+++ b/test/com/google/javascript/jscomp/ProcessTweaksTest.java
@@ -57,7 +57,7 @@ public final class ProcessTweaksTest extends CompilerTestCase {
           ImmutableSet<String> emptySet = ImmutableSet.of();
           final StripCode stripCode =
               new StripCode(
-                  compiler, emptySet, emptySet, emptySet, /* enableTweakStripping */ true);
+                  compiler, emptySet, emptySet, emptySet, /* enableTweakStripping= */ true);
           stripCode.process(externs, root);
         }
       }
diff --git a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
index 64f0722..dc882f9 100644
--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
@@ -26,6 +26,7 @@ import com.google.javascript.jscomp.testing.JSCompCorrespondences;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -626,7 +627,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   public void testNoSideEffectsSimple() {
     String prefix = "function f(){";
     String suffix = "} f()";
-    List<String> expected = ImmutableList.of("f");
+    ImmutableList<String> expected = ImmutableList.of("f");
 
     assertPureCallsMarked(prefix + "" + suffix, expected);
     assertPureCallsMarked(prefix + "return 1" + suffix, expected);
@@ -2135,6 +2136,11 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassInstantiation_literal_implicitCtor_noSuperclass_isPure() {
+    assertPureCallsMarked("new class C {}", ImmutableList.of("class C {}"));
+  }
+
+  @Test
   public void testClassInstantiation_pureCtor_noSuperclass_isPure() {
     assertPureCallsMarked(
         lines(
@@ -2147,6 +2153,12 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassInstantiation_literal_pureCtor_noSuperclass_isPure() {
+    assertPureCallsMarked(
+        "new class C { constructor() {} }", ImmutableList.of("class C { constructor() {} }"));
+  }
+
+  @Test
   public void testClassInstantiation_impureCtor_noSuperclass_isImpure() {
     assertNoPureCalls(
         lines(
@@ -2169,6 +2181,15 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassInstantiation_literal_implictCtor_pureSuperclassCtor_isPure() {
+    assertPureCallsMarked(
+        lines(
+            "class A { }", // Implicit ctor is pure.
+            "new class C extends A { }"),
+        ImmutableList.of("class C extends A { }"));
+  }
+
+  @Test
   public void testClassInstantiation_implictCtor_impureSuperclassCtor_isImpure() {
     assertNoPureCalls(
         lines(
@@ -2181,6 +2202,16 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassInstantiation_literal_implictCtor_impureSuperclassCtor_isImpure() {
+    assertNoPureCalls(
+        lines(
+            "class A {",
+            "  constructor() { throw 0; }",
+            "}", //
+            "new class C extends A { }"));
+  }
+
+  @Test
   public void testClassInstantiation_explitCtor_pureSuperclassCtor_isPure() {
     assertPureCallsMarked(
         lines(
@@ -3003,7 +3034,8 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
     assertPureCallsMarked(source, expected, null);
   }
 
-  void assertPureCallsMarked(String source, final List<String> expected, final Postcondition post) {
+  void assertPureCallsMarked(
+      String source, final List<String> expected, final @Nullable Postcondition post) {
     testSame(
         srcs(source),
         postcondition(
diff --git a/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java b/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
index c5a2fab..db43467 100644
--- a/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
+++ b/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
@@ -69,7 +69,7 @@ public final class RandomNameGeneratorTest {
     // mocking Random to get nicer values. Instead, let's just try to
     // verify the sanity of the results.
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     String prefix = "prefix";
     int prefixLen = prefix.length();
     // Add a prefix to avoid dropping JavaScript keywords.
@@ -130,7 +130,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testFirstCharAlphabet() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", null, random);
     // Generate all 1- and 2-character names.
@@ -162,7 +162,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testPrefix() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     String prefix = "prefix";
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, prefix, null, random);
@@ -183,7 +183,7 @@ public final class RandomNameGeneratorTest {
     // Using different seeds should return different names.
     Random random0 = new Random(0);
     Random random1 = new Random(1);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng0 = new RandomNameGenerator(
         reservedNames, "", null, random0);
     RandomNameGenerator ng1 = new RandomNameGenerator(
@@ -206,7 +206,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testReservedNames() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of("x", "ba");
+    ImmutableSet<String> reservedNames = ImmutableSet.of("x", "ba");
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", null, random);
     // Generate all 1- and 2-character names (and a couple 3-character names,
@@ -226,7 +226,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testReservedCharacters() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", new char[]{'a', 'b'}, random);
     // Generate all 1- and 2-character names (and also many 3-character names,
diff --git a/test/com/google/javascript/jscomp/ReachingUseDefTester.java b/test/com/google/javascript/jscomp/ReachingUseDefTester.java
index c40808f..5341ce6 100644
--- a/test/com/google/javascript/jscomp/ReachingUseDefTester.java
+++ b/test/com/google/javascript/jscomp/ReachingUseDefTester.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
@@ -117,16 +118,18 @@ final class ReachingUseDefTester {
   }
 
   private ControlFlowGraph<Node> computeCfg(Node fn) {
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
-    cfa.process(null, fn);
-    return cfa.getCfg();
+    return ControlFlowAnalysis.builder()
+        .setCompiler(compiler)
+        .setCfgRoot(fn)
+        .setIncludeEdgeAnnotations(true)
+        .computeCfg();
   }
 
   /**
    * Returns may-be-reaching uses of definition of variable `x` on the node extracted at label `D:`.
    */
-  Collection<Node> getComputedUses() {
-    return reachingUse.getUses("x", labelFinder.extractedDef);
+  ImmutableSet<Node> getComputedUses() {
+    return ImmutableSet.copyOf(reachingUse.getUses("x", labelFinder.extractedDef));
   }
 
   /**
diff --git a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
index 0a80042..2afc0ad 100644
--- a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
+++ b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
@@ -29,6 +29,7 @@ import java.nio.file.FileSystem;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -128,7 +129,10 @@ public class RecoverableJsAstTest {
     checkCompile(realAst, ast, expected, ImmutableList.<String>of());
   }
 
-  private void checkCompile(SourceAst realAst, RecoverableJsAst ast, String expected,
+  private void checkCompile(
+      SourceAst realAst,
+      RecoverableJsAst ast,
+      @Nullable String expected,
       ImmutableList<String> expectedErrors) {
     Compiler compiler = new Compiler();
 
diff --git a/test/com/google/javascript/jscomp/ReferenceCollectorTest.java b/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
index f1484ba..6d1edaf 100644
--- a/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
+++ b/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
@@ -24,6 +24,7 @@ import com.google.common.truth.Correspondence;
 import com.google.javascript.jscomp.ReferenceCollector.Behavior;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +32,7 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class ReferenceCollectorTest extends CompilerTestCase {
-  private Behavior behavior;
+  private @Nullable Behavior behavior;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java b/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
index 0391fa9..3d3d1ac 100644
--- a/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import java.util.LinkedHashSet;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,7 +29,7 @@ import org.junit.runners.JUnit4;
 public final class RemoveUnnecessarySyntheticExternsTest extends CompilerTestCase {
 
   // use this set to simulate an earlier compiler pass declaring a synthetic extern
-  private LinkedHashSet<Node> syntheticExternsToAdd = null;
+  private @Nullable LinkedHashSet<Node> syntheticExternsToAdd = null;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
index 05b5a3b..8b5d365 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
@@ -20,6 +20,7 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static java.util.stream.Collectors.joining;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
@@ -28,6 +29,7 @@ import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -1618,6 +1620,136 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlocksDoesRemove() {
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"),
+        "");
+
+    // TODO(bradfordcsmith): Would be nice to remove the whole class at this point
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    var x = 1;",
+            "    let y = 2;",
+            "    const z = 3;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    if (true) {",
+            "      if (true) {",
+            "        var foo = function() {};",
+            "      }",
+            "    }",
+            "  }",
+            "}"),
+        lines(
+            "class C {",
+            "  static {",
+            "    if (true) {",
+            "      if (true) {",
+            "      }",
+            "    }",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    function f() {}",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "const x = 1;", //
+            "class C {",
+            "  static {",
+            "    function f() {",
+            "      x;",
+            "    }",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticBlockDoesntRemove() {
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x;",
+            "    alert(x);",
+            "    console.log(x);",
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            "class C {", //
+            "  static {",
+            "    this.x=1;",
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            "const x = 1;",
+            "class C {",
+            "  static {",
+            "    x;", // reference prevents `const x = 1;` from being removed.
+            "  }",
+            "}",
+            "new C;"));
+
+    testSame(
+        lines(
+            "const x = 1;",
+            "class C {",
+            "  static {",
+            // side-effect of `alert` prevents `x` from being removed
+            "    alert(x);", // reference prevents `x` from being removed.
+            "  }",
+            "}"));
+
+    testSame(
+        lines(
+            "const x = 1;",
+            "class C {",
+            "  static {",
+            "    function f() {",
+            "      x;", // reference prevents `const x = 1;` from being removed.
+            "    }",
+            "    f();", // call prevents f() from being removed.
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testComputedPropSideEffects() {
     testSame(
         lines(
@@ -2083,23 +2215,25 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
 
     // Input source code, which will be prefixed with the polyfills.
     // A value of `null` just means this hasn't been set yet.
-    private String inputSource = null;
+    private @Nullable String inputSource = null;
 
     // Expected output source code, which will be prefixed with the output version of each polyfill.
     // A value of `null` means this value hasn't been set yet or needs to be reset because
     // inputSource has changed.
-    private String expectedSource = null;
+    private @Nullable String expectedSource = null;
 
     // Set of polyfills that are expected to be removed by RemoveUnusedCode.
     // A value of `null` indicates that no expectation has been set since the last time inputSource
     // was modified.
-    private HashSet<String> polyfillsExpectedToBeRemoved = new HashSet<>();
+    private @Nullable HashSet<String> polyfillsExpectedToBeRemoved = new HashSet<>();
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester addExterns(String moreExterns) {
       externs.add(moreExterns);
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester addPolyfill(String polyfill) {
       checkArgument(!polyfills.contains(polyfill), "duplicate polyfill added: >%s<", polyfill);
       polyfills.add(polyfill);
@@ -2108,6 +2242,7 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester inputSourceLines(String... srcLines) {
       inputSource = lines(srcLines);
       // Force updates for the expected output source and polyfills
@@ -2116,22 +2251,26 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester expectSourceUnchanged() {
       checkNotNull(inputSource);
       expectedSource = inputSource;
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester expectSourceLines(String... expectedLines) {
       expectedSource = lines(expectedLines);
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester expectNoPolyfillsRemoved() {
       polyfillsExpectedToBeRemoved = new HashSet<>();
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester expectPolyfillsRemoved(String... removedPolyfills) {
       for (String polyfillToRemove : removedPolyfills) {
         expectPolyfillRemoved(polyfillToRemove);
@@ -2139,6 +2278,7 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
       return this;
     }
 
+    @CanIgnoreReturnValue
     PolyfillRemovalTester expectPolyfillRemoved(String polyfill) {
       checkArgument(
           polyfills.contains(polyfill), "non-existent polyfill cannot be removed: >%s<", polyfill);
diff --git a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
index 4352188..0916cef 100644
--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ public final class RenameLocalVarsTest extends CompilerTestCase {
   private String prefix = DEFAULT_PREFIX;
 
   // NameGenerator to use, or null for a default.
-  private DefaultNameGenerator nameGenerator = null;
+  private @Nullable DefaultNameGenerator nameGenerator = null;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
diff --git a/test/com/google/javascript/jscomp/RenamePropertiesTest.java b/test/com/google/javascript/jscomp/RenamePropertiesTest.java
index 72324e6..c6d425b 100644
--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.collect.ImmutableList;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +39,7 @@ public final class RenamePropertiesTest extends CompilerTestCase {
 
   private RenameProperties renameProperties;
   private boolean generatePseudoNames;
-  private VariableMap prevUsedPropertyMap;
+  private @Nullable VariableMap prevUsedPropertyMap;
 
   public RenamePropertiesTest() {
     super(EXTERNS);
diff --git a/test/com/google/javascript/jscomp/RenameVarsTest.java b/test/com/google/javascript/jscomp/RenameVarsTest.java
index 76975bb..6c507ab 100644
--- a/test/com/google/javascript/jscomp/RenameVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java
@@ -20,15 +20,17 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.jscomp.deps.ModuleLoader.LOAD_WARNING;
+import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.rhino.Node;
+import com.google.javascript.rhino.testing.NodeSubject;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,8 +42,7 @@ public final class RenameVarsTest extends CompilerTestCase {
   private static final String DEFAULT_PREFIX = "";
   private String prefix = DEFAULT_PREFIX;
 
-  private VariableMap previouslyUsedMap =
-      new VariableMap(ImmutableMap.<String, String>of());
+  private VariableMap previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of());
   private RenameVars renameVars;
   private boolean withClosurePass = false;
   private boolean localRenamingOnly = false;
@@ -51,7 +52,7 @@ public final class RenameVarsTest extends CompilerTestCase {
   private boolean withNormalize = false;
 
   // NameGenerator to use, or null for a default.
-  private DefaultNameGenerator nameGenerator = null;
+  private @Nullable DefaultNameGenerator nameGenerator = null;
 
   @Override
   protected CodingConvention getCodingConvention() {
@@ -122,22 +123,139 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testRenameSimple() {
-    test("function Foo(v1, v2) {return v1;} Foo();",
-         "function a(b, c) {return b;} a();");
+    test(
+        lines(
+            "function foo(v1, v2) {", //
+            "  return v1;",
+            "}",
+            "foo();",
+            ""),
+        lines(
+            "function a(b, c) {", //
+            "  return b;",
+            "}",
+            "a();",
+            ""));
+
+    // Do a sanity check on the source info
+    final Node lastScript =
+        getLastCompiler()
+            .getRoot()
+            .getLastChild() // first child is externs tree, last / second is sources
+            .getLastChild();
+    final String lastScriptName = lastScript.getSourceFileName();
+
+    // function foo(v1, v2) { ... }
+    final NodeSubject fnSubject =
+        assertNode(lastScript.getFirstChild())
+            .isFunction()
+            .hasSourceFileName(lastScriptName)
+            .hasLineno(1)
+            .hasCharno(0)
+            .hasLength(37);
+
+    // function foo(v1, v2) {
+    //          ^^^
+    fnSubject
+        .hasFirstChildThat()
+        .isName("a")
+        .hasSourceFileName(lastScriptName)
+        .hasLineno(1)
+        .hasCharno(9)
+        .hasLength(3);
+
+    // function foo(v1, v2) {
+    //             ^^^^^^^^
+    NodeSubject paramListSubject =
+        fnSubject
+            .hasSecondChildThat()
+            .isParamList()
+            .hasSourceFileName(lastScriptName)
+            .hasLineno(1)
+            .hasCharno(12)
+            .hasLength(8)
+            .hasXChildren(2);
+
+    // function foo(v1, v2) {
+    //              ^^
+    paramListSubject
+        .hasFirstChildThat()
+        .isName("b")
+        .hasSourceFileName(lastScriptName)
+        .hasLineno(1)
+        .hasCharno(13)
+        .hasLength(2);
+
+    // function foo(v1, v2) {
+    //                  ^^
+    paramListSubject
+        .hasSecondChildThat()
+        .isName("c")
+        .hasSourceFileName(lastScriptName)
+        .hasLineno(1)
+        .hasCharno(17)
+        .hasLength(2);
+
+    //  { ... }
+    NodeSubject fnBodySubject =
+        fnSubject
+            .hasLastChildThat()
+            .isBlock()
+            .hasSourceFileName(lastScriptName)
+            .hasLineno(1)
+            .hasCharno(21)
+            .hasLength(16);
+
+    // return v1;
+    NodeSubject returnSubject =
+        fnBodySubject
+            .hasOneChildThat()
+            .isReturn()
+            .hasSourceFileName(lastScriptName)
+            .hasLineno(2)
+            .hasCharno(2)
+            .hasLength(10);
+
+    // return v1;
+    //        ^^
+    returnSubject.hasOneChildThat().isName("b").hasLineno(2).hasCharno(9).hasLength(2);
+
+    // foo();
+    assertNode(lastScript)
+        .hasLastChildThat()
+        .isExprResult() // foo(); (statement)
+        .hasSourceFileName(lastScriptName)
+        .hasLineno(4)
+        .hasCharno(0)
+        .hasLength(6)
+        .hasOneChildThat() // foo() (expression)
+        .isCall()
+        .hasSourceFileName(lastScriptName)
+        .hasLineno(4)
+        .hasCharno(0)
+        .hasLength(5)
+        .hasOneChildThat() // foo (function name)
+        .isName("a")
+        .hasLineno(4)
+        .hasCharno(0)
+        .hasLength(3);
   }
 
   @Test
   public void testRenameGlobals() {
-    test("var Foo; var Bar, y; function x() { Bar++; }",
-         "var a; var b, c; function d() { b++; }");
+    test(
+        "var Foo; var Bar, y; function x() { Bar++; }", //
+        "var   a; var   b, c; function d() {   b++; }");
   }
 
   @Test
   public void testRenameLocals() {
-    test("(function (v1, v2) {}); (function (v3, v4) {});",
-        "(function (a, b) {}); (function (a, b) {});");
-    test("function f1(v1, v2) {}; function f2(v3, v4) {};",
-        "function c(a, b) {}; function d(a, b) {};");
+    test(
+        "(function (v1, v2) {}); (function (v3, v4) {});",
+        "(function ( a,  b) {}); (function ( a,  b) {});");
+    test(
+        "function f1(v1, v2) {}; function f2(v3, v4) {};",
+        "function  c( a,  b) {}; function  d( a,  b) {};");
   }
 
   @Test
@@ -178,7 +296,7 @@ public final class RenameVarsTest extends CompilerTestCase {
             "/** @suppress {duplicate} */",
             "function f1(v3, v4) {f1()};"),
         lines(
-            "function a(b, c) {a()};",
+            "function a(b, c) {a()};", //
             "/** @suppress {duplicate} */",
             "function a(b, c) {a()};"));
 
@@ -197,35 +315,32 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testRecursiveFunctions1() {
-    test("var walk = function walk(node, aFunction) {" +
-         "  walk(node, aFunction);" +
-         "};",
-         "var a = function a(b, c) {" +
-         "  a(b, c);" +
-         "};");
+    test(
+        "var walk = function walk(node, aFunction) { walk(node, aFunction); };",
+        "var    a = function    a(   b,         c) {    a(   b,         c); };");
 
     localRenamingOnly = true;
 
-    test("var walk = function walk(node, aFunction) {" +
-         "  walk(node, aFunction);" +
-         "};",
-         "var walk = function walk(a, b) {" +
-         "  walk(a, b);" +
-         "};");
+    test(
+        "var walk = function walk(node, aFunction) {  walk(node, aFunction); };",
+        "var walk = function walk(   a,         b) {  walk(   a,         b); };");
   }
 
   @Test
   public void testRenameLocalsClashingWithGlobals() {
-    test("function a(v1, v2) {return v1;} a();",
-        "function a(b, c) {return b;} a();");
+    test(
+        "function a(v1, v2) {return v1;} a();", //
+        "function a( b,  c) {return  b;} a();");
   }
 
   @Test
   public void testRenameNested() {
-    test("function f1(v1, v2) { (function(v3, v4) {}) }",
-         "function a(b, c) { (function(d, e) {}) }");
-    test("function f1(v1, v2) { function f2(v3, v4) {} }",
-         "function a(b, c) { function d(e, f) {} }");
+    test(
+        "function f1(v1, v2) { (function(v3, v4) {}) }",
+        "function  a( b,  c) { (function( d,  e) {}) }");
+    test(
+        "function f1(v1, v2) { function f2(v3, v4) {} }",
+        "function  a( b,  c) { function  d( e,  f) {} }");
   }
 
   @Test
@@ -233,10 +348,13 @@ public final class RenameVarsTest extends CompilerTestCase {
     // On IE, bleeding functions will interfere with each other if
     // they are in the same scope. In the below example, we want to be
     // sure that a and b get separate names.
-    test("var x = function a(x) { return x ? 1 : a(1); };" +
-         "var y = function b(x) { return x ? 2 : b(2); };",
-         "var c = function b(a) { return a ? 1 : b(1); };" +
-         "var e = function d(a) { return a ? 2 : d(2); };");
+    test(
+        lines(
+            "var x = function a(x) { return x ? 1 : a(1); };",
+            "var y = function b(x) { return x ? 2 : b(2); };"),
+        lines(
+            "var c = function b(a) { return a ? 1 : b(1); };",
+            "var e = function d(a) { return a ? 2 : d(2); };"));
   }
 
   @Test
@@ -273,12 +391,13 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testBleedingFunctionInBlocks() {
-    test(lines(
-            "if (true) {",
+    test(
+        lines(
+            "if (true) {", //
             "   var x = function a(x) {return x;}",
             "}"),
         lines(
-            "if (true) {",
+            "if (true) {", //
             "   var c = function b(a) {return a;}",
             "}"));
   }
@@ -287,17 +406,17 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testRenameWithExterns1() {
     String externs = "var foo;";
     test(
-        externs(externs),
-        srcs("var bar; foo(bar);"),
-        expected("var a; foo(a);"));
+        externs(externs), //
+        srcs("    var bar; foo(bar);"),
+        expected("var   a; foo(  a);"));
   }
 
   @Test
   public void testRenameWithExterns2() {
     String externs = "var a;";
     test(
-        externs(externs),
-        srcs("var b = 5"),
+        externs(externs), //
+        srcs("    var b = 5"),
         expected("var b = 5"));
   }
 
@@ -319,65 +438,67 @@ public final class RenameVarsTest extends CompilerTestCase {
   @Test
   public void testRenameWithPrefix1() {
     prefix = "PRE_";
-    test("function Foo(v1, v2) {return v1} Foo();",
-        "function PRE_(a, b) {return a} PRE_();");
+    test(
+        "function  Foo(v1, v2) {return v1}  Foo();", //
+        "function PRE_( a,  b) {return  a} PRE_();");
     prefix = DEFAULT_PREFIX;
-
   }
 
   @Test
   public void testRenameWithPrefix2() {
     prefix = "PRE_";
-    test("function Foo(v1, v2) {var v3 = v1 + v2; return v3;} Foo();",
-        "function PRE_(a, b) {var c = a + b; return c;} PRE_();");
+    test(
+        "function  Foo(v1, v2) {var v3 = v1 + v2; return v3;}  Foo();",
+        "function PRE_( a,  b) {var  c =  a +  b; return  c;} PRE_();");
     prefix = DEFAULT_PREFIX;
   }
 
   @Test
   public void testRenameWithPrefix3() {
     prefix = "a";
-    test("function Foo() {return 1;}" +
-         "function Bar() {" +
-         "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," +
-         "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" +
-         "  Foo();" +
-         "} Bar();",
-
-        "function a() {return 1;}" +
-         "function aa() {" +
-         "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," +
-         "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" +
-         "  a();" +
-         "} aa();");
+    test(
+        lines(
+            "function Foo() {return 1;}", //
+            "function Bar() {",
+            "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,",
+            "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;",
+            "  Foo();",
+            "} Bar();"),
+        lines(
+            "function a() {return 1;}", //
+            "function aa() {",
+            "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,",
+            "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;",
+            "  a();",
+            "} aa();"));
     prefix = DEFAULT_PREFIX;
   }
 
   @Test
   public void testNamingBasedOnOrderOfOccurrence() {
-    test("var q,p,m,n,l,k; " +
-             "try { } catch(r) {try {} catch(s) {}}; var t = q + q;",
-         "var a,b,c,d,e,f; " +
-             "try { } catch(g) {try {} catch(h) {}}; var i = a + a;"
-         );
-    test("(function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z," +
-         "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){});" +
-         "var a4,a3,a2,a1,b4,b3,b2,b1,ab,ac,ad,fg;function foo(){};",
-         "(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," +
-         "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){});" +
-         "var aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la;function ma(){};");
+    test(
+        "var q,p,m,n,l,k; try { } catch(r) {try {} catch(s) {}}; var t = q + q;",
+        "var a,b,c,d,e,f; try { } catch(g) {try {} catch(h) {}}; var i = a + a;");
+    test(
+        lines(
+            "(function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,",
+            "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){});",
+            "var a4,a3,a2,a1,b4,b3,b2,b1,ab,ac,ad,fg;function foo(){};"),
+        lines(
+            "(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,",
+            "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){});",
+            "var aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la;function ma(){};"));
   }
 
   @Test
   public void testTryCatchLifeTime() {
-    test("var q,p,m,n,l,k; " +
-        "(function (r) {}); try { } catch(s) {}; var t = q + q;",
-    "var a,c,d,e,f,g; " +
-        "(function(b) {}); try { } catch(b) {}; var h = a + a;"
-    );
+    test(
+        "var q,p,m,n,l,k; (function(r) {}); try { } catch(s) {}; var t = q + q;",
+        "var a,c,d,e,f,g; (function(b) {}); try { } catch(b) {}; var h = a + a;");
 
-    test("try {try {} catch(p) {}} catch(s) {};",
-         "try {try {} catch(a) {}} catch(a) {};"
-    );
+    test(
+        "try {try {} catch(p) {}} catch(s) {};", //
+        "try {try {} catch(a) {}} catch(a) {};");
 
     test(
         lines(
@@ -406,70 +527,73 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testStableRenameSimple() {
-    VariableMap expectedVariableMap = makeVariableMap(
-        "Foo", "a", "L 0", "b", "L 1", "c");
-    testRenameMap("function Foo(v1, v2) {return v1;} Foo();",
-                  "function a(b, c) {return b;} a();", expectedVariableMap);
+    VariableMap expectedVariableMap = makeVariableMap("Foo", "a", "L 0", "b", "L 1", "c");
+    testRenameMap(
+        "function Foo(v1, v2) {return v1;} Foo();",
+        "function   a( b,  c) {return  b;}   a();",
+        expectedVariableMap);
 
-    expectedVariableMap = makeVariableMap(
-        "Foo", "a", "L 0", "b", "L 1", "c", "L 2", "d");
-    testRenameMapUsingOldMap("function Foo(v1, v2, v3) {return v1;} Foo();",
-         "function a(b, c, d) {return b;} a();", expectedVariableMap);
+    expectedVariableMap = makeVariableMap("Foo", "a", "L 0", "b", "L 1", "c", "L 2", "d");
+    testRenameMapUsingOldMap(
+        "function Foo(v1, v2, v3) {return v1;} Foo();",
+        "function   a( b,  c,  d) {return  b;}   a();",
+        expectedVariableMap);
   }
 
   @Test
   public void testStableRenameGlobals() {
-    VariableMap expectedVariableMap = makeVariableMap(
-        "Foo", "a", "Bar", "b", "y", "c", "x", "d");
-    testRenameMap("var Foo; var Bar, y; function x() { Bar++; }",
-                  "var a; var b, c; function d() { b++; }",
-                  expectedVariableMap);
-
-    expectedVariableMap = makeVariableMap(
-        "Foo", "a", "Bar", "b", "y", "c", "x", "d", "Baz", "f", "L 0" , "e");
+    VariableMap expectedVariableMap = makeVariableMap("Foo", "a", "Bar", "b", "y", "c", "x", "d");
+    testRenameMap(
+        "var Foo; var Bar, y; function x() { Bar++; }",
+        "var   a; var   b, c; function d() {   b++; }",
+        expectedVariableMap);
+
+    expectedVariableMap =
+        makeVariableMap("Foo", "a", "Bar", "b", "y", "c", "x", "d", "Baz", "f", "L 0", "e");
     testRenameMapUsingOldMap(
         "var Foo, Baz; var Bar, y; function x(R) { return R + Bar++; }",
-        "var a, f; var b, c; function d(e) { return e + b++; }",
+        "var   a,   f; var   b, c; function d(e) { return e +   b++; }",
         expectedVariableMap);
   }
 
   @Test
   public void testStableRenameWithPointlesslyAnonymousFunctions() {
     VariableMap expectedVariableMap = makeVariableMap("L 0", "a", "L 1", "b");
-    testRenameMap("(function (v1, v2) {}); (function (v3, v4) {});",
-                  "(function (a, b) {}); (function (a, b) {});",
-                  expectedVariableMap);
+    testRenameMap(
+        "(function (v1, v2) {}); (function (v3, v4) {});",
+        "(function ( a,  b) {}); (function ( a,  b) {});",
+        expectedVariableMap);
 
     expectedVariableMap = makeVariableMap("L 0", "a", "L 1", "b", "L 2", "c");
-    testRenameMapUsingOldMap("(function (v0, v1, v2) {});" +
-                             "(function (v3, v4) {});",
-                             "(function (a, b, c) {});" +
-                             "(function (a, b) {});",
-                             expectedVariableMap);
+    testRenameMapUsingOldMap(
+        "(function (v0, v1, v2) {}); (function (v3, v4) {});",
+        "(function ( a,  b,  c) {}); (function ( a,  b) {});",
+        expectedVariableMap);
   }
 
   @Test
   public void testStableRenameLocalsClashingWithGlobals() {
-    test("function a(v1, v2) {return v1;} a();",
-         "function a(b, c) {return b;} a();");
+    test("function a(v1, v2) {return v1;} a();", "function a(b, c) {return b;} a();");
     previouslyUsedMap = renameVars.getVariableMap();
-    test("function bar(){return;}function a(v1, v2) {return v1;} a();",
-         "function d(){return;}function a(b, c) {return b;} a();");
+    test(
+        "function bar(){return;}function a(v1, v2) {return v1;} a();",
+        "function   d(){return;}function a( b,  c) {return  b;} a();");
   }
 
   @Test
   public void testStableRenameNested() {
-    VariableMap expectedVariableMap = makeVariableMap(
-        "f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e");
-    testRenameMap("function f1(v1, v2) { (function(v3, v4) {}) }",
-                  "function a(b, c) { (function(d, e) {}) }",
-                  expectedVariableMap);
-
-    expectedVariableMap = makeVariableMap(
-        "f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e", "L 4", "f");
+    VariableMap expectedVariableMap =
+        makeVariableMap("f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e");
+    testRenameMap(
+        "function f1(v1, v2) { (function(v3, v4) {}) }",
+        "function  a( b,  c) { (function( d,  e) {}) }",
+        expectedVariableMap);
+
+    expectedVariableMap =
+        makeVariableMap("f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e", "L 4", "f");
     testRenameMapUsingOldMap(
         "function f1(v1, v2) { (function(v3, v4, v5) {}) }",
-        "function a(b, c) { (function(d, e, f) {}) }",
+        "function  a( b,  c) { (function( d,  e,  f) {}) }",
         expectedVariableMap);
   }
 
@@ -477,28 +601,28 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testStableRenameWithExterns1() {
     String externs = "var foo;";
     test(
-        externs(externs),
-        srcs("var bar; foo(bar);"),
-        expected("var a; foo(a);"));
+        externs(externs), //
+        srcs("    var bar; foo(bar);"),
+        expected("var   a; foo(  a);"));
     previouslyUsedMap = renameVars.getVariableMap();
     test(
-        externs(externs),
-        srcs("var bar, baz; foo(bar, baz);"),
-        expected("var a, b; foo(a, b);"));
+        externs(externs), //
+        srcs("    var bar, baz; foo(bar, baz);"),
+        expected("var   a,   b; foo(  a,   b);"));
   }
 
   @Test
   public void testStableRenameWithExterns2() {
     String externs = "var a;";
     test(
-        externs(externs),
-        srcs("var b = 5"),
+        externs(externs), //
+        srcs("    var b = 5"),
         expected("var b = 5"));
     previouslyUsedMap = renameVars.getVariableMap();
     test(
-        externs(externs),
-        srcs("var b = 5, catty = 9;"),
-        expected("var b = 5, c=9;"));
+        externs(externs), //
+        srcs("    var b = 5, catty = 9;"), //
+        expected("var b = 5,     c = 9;"));
   }
 
   @Test
@@ -511,9 +635,10 @@ public final class RenameVarsTest extends CompilerTestCase {
   @Test
   public void testStableRenameWithAnonymousFunctions() {
     VariableMap expectedVariableMap = makeVariableMap("L 0", "a", "foo", "b");
-    testRenameMap("function foo(bar){return bar;}foo(function(h){return h;});",
-                  "function b(a){return a}b(function(a){return a;})",
-                  expectedVariableMap);
+    testRenameMap(
+        "function foo(bar){return bar;}foo(function(h){return h;});",
+        "function   b(  a){return   a;}  b(function(a){return a;});",
+        expectedVariableMap);
 
     expectedVariableMap = makeVariableMap("foo", "b", "L 0", "a", "L 1", "c");
     testRenameMapUsingOldMap(
@@ -524,23 +649,26 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testStableRenameSimpleExternsChanges() {
-    VariableMap expectedVariableMap = makeVariableMap(
-        "Foo", "a", "L 0", "b", "L 1", "c");
-    testRenameMap("function Foo(v1, v2) {return v1;} Foo();",
-                  "function a(b, c) {return b;} a();", expectedVariableMap);
+    VariableMap expectedVariableMap = makeVariableMap("Foo", "a", "L 0", "b", "L 1", "c");
+    testRenameMap(
+        "function Foo(v1, v2) {return v1;} Foo();",
+        "function   a( b,  c) {return  b;}   a();",
+        expectedVariableMap);
 
     expectedVariableMap = makeVariableMap("L 0", "b", "L 1", "c", "L 2", "a");
     String externs = "var Foo;";
-    testRenameMapUsingOldMap(externs,
-                             "function Foo(v1, v2, v0) {return v1;} Foo();",
-                             "function Foo(b, c, a) {return b;} Foo();",
-                             expectedVariableMap);
+    testRenameMapUsingOldMap(
+        externs,
+        "function Foo(v1, v2, v0) {return v1;} Foo();",
+        "function Foo( b,  c , a) {return  b;} Foo();",
+        expectedVariableMap);
   }
 
   @Test
   public void testStableRenameSimpleLocalNameExterned() {
-    test("function Foo(v1, v2) {return v1;} Foo();",
-         "function a(b, c) {return b;} a();");
+    test(
+        "function Foo(v1, v2) {return v1;} Foo();", //
+        "function   a( b,  c) {return  b;}   a();");
 
     previouslyUsedMap = renameVars.getVariableMap();
 
@@ -553,8 +681,9 @@ public final class RenameVarsTest extends CompilerTestCase {
 
   @Test
   public void testStableRenameSimpleGlobalNameExterned() {
-    test("function Foo(v1, v2) {return v1;} Foo();",
-         "function a(b, c) {return b;} a();");
+    test(
+        "function Foo(v1, v2) {return v1;} Foo();", //
+        "function   a( b,  c) {return  b;}   a();");
 
     previouslyUsedMap = renameVars.getVariableMap();
 
@@ -568,64 +697,69 @@ public final class RenameVarsTest extends CompilerTestCase {
   @Test
   public void testStableRenameWithPrefix1AndUnstableLocalNames() {
     prefix = "PRE_";
-    test("function Foo(v1, v2) {return v1} Foo();",
-         "function PRE_(a, b) {return a} PRE_();");
+    test(
+        "function  Foo(v1, v2) {return v1}  Foo();", //
+        "function PRE_( a,  b) {return  a} PRE_();");
 
     previouslyUsedMap = renameVars.getVariableMap();
 
     prefix = "PRE_";
-    test("function Foo(v0, v1, v2) {return v1} Foo();",
-         "function PRE_(a, b, c) {return b} PRE_();");
+    test(
+        "function  Foo(v0, v1, v2) {return v1}  Foo();", //
+        "function PRE_( a,  b,  c) {return  b} PRE_();");
   }
 
   @Test
   public void testStableRenameWithPrefix2() {
     prefix = "a";
-    test("function Foo() {return 1;}" +
-         "function Bar() {" +
-         "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," +
-         "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" +
-         "  Foo();" +
-         "} Bar();",
-
-         "function a() {return 1;}" +
-         "function aa() {" +
-         "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," +
-         "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" +
-         "  a();" +
-         "} aa();");
+    test(
+        lines(
+            "function Foo() {return 1;}", //
+            "function Bar() {",
+            "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,",
+            "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;",
+            "  Foo();",
+            "} Bar();"),
+        lines(
+            "function a() {return 1;}",
+            "function aa() {",
+            "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,",
+            "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;",
+            "  a();",
+            "} aa();"));
 
     previouslyUsedMap = renameVars.getVariableMap();
 
     prefix = "a";
-    test("function Foo() {return 1;}" +
-         "function Baz() {return 1;}" +
-         "function Bar() {" +
-         "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," +
-         "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" +
-         "  Foo();" +
-         "} Bar();",
-
-         "function a() {return 1;}" +
-         "function ab() {return 1;}" +
-         "function aa() {" +
-         "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," +
-         "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" +
-         "  a();" +
-         "} aa();");
+    test(
+        lines(
+            "function Foo() {return 1;}",
+            "function Baz() {return 1;}",
+            "function Bar() {",
+            "  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,",
+            "      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;",
+            "  Foo();",
+            "} Bar();"),
+        lines(
+            "function a() {return 1;}",
+            "function ab() {return 1;}",
+            "function aa() {",
+            "  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,",
+            "      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;",
+            "  a();",
+            "} aa();"));
   }
 
   @Test
   public void testContrivedExampleWhereConsistentRenamingIsWorse() {
-    previouslyUsedMap = makeVariableMap(
-        "Foo", "LongString", "L 0", "b", "L 1", "c");
+    previouslyUsedMap = makeVariableMap("Foo", "LongString", "L 0", "b", "L 1", "c");
 
-    test("function Foo(v1, v2) {return v1;} Foo();",
-         "function LongString(b, c) {return b;} LongString();");
+    test(
+        "function        Foo(v1, v2) {return v1;}        Foo();",
+        "function LongString( b,  c) {return  b;} LongString();");
 
     previouslyUsedMap = renameVars.getVariableMap();
-    VariableMap expectedVariableMap = makeVariableMap(
-        "Foo", "LongString", "L 0", "b", "L 1", "c");
+    VariableMap expectedVariableMap = makeVariableMap("Foo", "LongString", "L 0", "b", "L 1", "c");
     assertVariableMapsEqual(expectedVariableMap, previouslyUsedMap);
   }
 
@@ -635,48 +769,55 @@ public final class RenameVarsTest extends CompilerTestCase {
       makeVariableMap("Foo", "z", "Bar", "z");
       testSame("");
       throw new AssertionError();
-    } catch (java.lang.IllegalArgumentException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test
   public void testExportSimpleSymbolReservesName() {
-    test("var goog, x; goog.exportSymbol('a', x);",
-         "var a, b; a.exportSymbol('a', b);");
+    test(
+        "var goog, x; goog.exportSymbol('a', x);", //
+        "var    a, b;    a.exportSymbol('a', b);");
     withClosurePass = true;
-    test("var goog, x; goog.exportSymbol('a', x);",
-         "var b, c; b.exportSymbol('a', c);");
+    test(
+        "var goog, x; goog.exportSymbol('a', x);", //
+        "var    b, c;    b.exportSymbol('a', c);");
   }
 
   @Test
   public void testExportComplexSymbolReservesName() {
-    test("var goog, x; goog.exportSymbol('a.b', x);",
-         "var a, b; a.exportSymbol('a.b', b);");
+    test(
+        "var goog, x; goog.exportSymbol('a.b', x);", //
+        "var    a, b;    a.exportSymbol('a.b', b);");
     withClosurePass = true;
-    test("var goog, x; goog.exportSymbol('a.b', x);",
-         "var b, c; b.exportSymbol('a.b', c);");
+    test(
+        "var goog, x; goog.exportSymbol('a.b', x);", //
+        "var    b, c;    b.exportSymbol('a.b', c);");
   }
 
   @Test
   public void testExportToNonStringDoesntExplode() {
     withClosurePass = true;
-    test("var goog, a, b; goog.exportSymbol(a, b);",
-         "var a, b, c; a.exportSymbol(b, c);");
+    test(
+        "var goog, a, b; goog.exportSymbol(a, b);", //
+        "var    a, b, c;    a.exportSymbol(b, c);");
   }
 
   @Test
   public void testDollarSignSuperExport1() {
     useGoogleCodingConvention = false;
     // See http://blickly.github.io/closure-compiler-issues/#32
-    test("var x = function($super,duper,$fantastic){}",
-         "var c = function($super,    a,        b){}");
+    test(
+        "var x = function($super,duper,$fantastic){}",
+        "var c = function($super,    a,        b){}");
 
     localRenamingOnly = false;
     test("var $super = 1", "var a = 1");
 
     useGoogleCodingConvention = true;
-    test("var x = function($super,duper,$fantastic){}",
-         "var c = function($super,a,b){}");
+    test(
+        "var x = function($super,duper,$fantastic){}", //
+        "var c = function($super,    a,         b){}");
   }
 
   @Test
@@ -685,19 +826,17 @@ public final class RenameVarsTest extends CompilerTestCase {
 
     useGoogleCodingConvention = false;
     // See http://blickly.github.io/closure-compiler-issues/#32
-    test("var x = function($super,duper,$fantastic){};" +
-            "var y = function($super,duper){};",
-         "var c = function($super,    a,         b){};" +
-            "var d = function($super,    a){};");
+    test(
+        "var x = function($super,duper,$fantastic){}; var y = function($super,duper){};",
+        "var c = function($super,    a,         b){}; var d = function($super,    a){};");
 
     localRenamingOnly = false;
     test("var $super = 1", "var a = 1");
 
     useGoogleCodingConvention = true;
-    test("var x = function($super,duper,$fantastic){};" +
-            "var y = function($super,duper){};",
-         "var c = function($super,   a,    b         ){};" +
-            "var d = function($super,a){};");
+    test(
+        "var x = function($super,duper,$fantastic){}; var y = function($super,duper){};",
+        "var c = function($super,    a,         b){}; var d = function($super,    a){};");
   }
 
   @Test
@@ -711,30 +850,36 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testPseudoNames() {
     generatePseudoNames = false;
     // See http://blickly.github.io/closure-compiler-issues/#32
-    test("var foo = function(a, b, c){}",
-         "var d = function(a, b, c){}");
+    test(
+        "var foo = function(a, b, c){}", //
+        "var   d = function(a, b, c){}");
 
     generatePseudoNames = true;
-    test("var foo = function(a, b, c){}",
-         "var $foo$$ = function($a$$, $b$$, $c$$){}");
+    test(
+        "var    foo = function(   a,    b,    c){}", //
+        "var $foo$$ = function($a$$, $b$$, $c$$){}");
 
-    test("var a = function(a, b, c){}",
-         "var $a$$ = function($a$$, $b$$, $c$$){}");
+    test(
+        "var    a = function(   a,    b,    c){}", //
+        "var $a$$ = function($a$$, $b$$, $c$$){}");
   }
 
   @Test
   public void testArrowFunctions() {
-    test("foo => {return foo + 3;}",
-        "a => {return a + 3;}");
+    test(
+        "foo => {return foo + 3;}", //
+        "  a => {return   a + 3;}");
 
-    test("(foo, bar) => {return foo + bar + 3;}",
-        "(a, b) => {return a + b + 3;}");
+    test(
+        "(foo, bar) => {return foo + bar + 3;}", //
+        "(  a,   b) => {return   a +   b + 3;}");
   }
 
   @Test
   public void testClasses() {
-    test("class fooBar {}",
-        "class a {}");
+    test(
+        "class fooBar {}", //
+        "class      a {}");
 
     test(
         lines(
@@ -778,19 +923,18 @@ public final class RenameVarsTest extends CompilerTestCase {
             "  }",
             "}",
             "var d = new b(2,3);",
-            "var e = d.func(5);"
-            ));
-
+            "var e = d.func(5);"));
   }
 
   @Test
   public void testLetConst() {
-    test("let xyz;",
-        "let a;"
-    );
+    test(
+        "let xyz;", //
+        "let   a;");
 
-    test("const xyz = 1;",
-        "const a = 1");
+    test(
+        "const xyz = 1;", //
+        "const   a = 1");
 
     test(
         lines(
@@ -800,8 +944,7 @@ public final class RenameVarsTest extends CompilerTestCase {
             "  zyx = 3;",
             "}",
             "let xyz = 'potato';",
-            "zyx = 4;"
-        ),
+            "zyx = 4;"),
         lines(
             "let a = 1; {",
             "  const c = 1;",
@@ -816,14 +959,13 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testGenerators() {
     test(
         lines(
-            "function* gen() {",
+            "function* gen() {", //
             "  var xyz = 3;",
             "  yield xyz + 4;",
             "}",
-            "gen().next()"
-        ),
+            "gen().next()"),
         lines(
-            "function* a() {",
+            "function* a() {", //
             "  var b = 3;",
             "  yield b + 4;",
             "}",
@@ -833,25 +975,25 @@ public final class RenameVarsTest extends CompilerTestCase {
   @Test
   public void testForOf() {
     test(
-        "for (var item of items) {}",
-        "for (var a of items) {}");
+        "for (var item of items) {}", //
+        "for (var    a of items) {}");
   }
 
   @Test
   public void testTemplateStrings() {
     test(
         lines(
-            "var name = 'Foo';",
-            "`My name is ${name}`;"
-        ),
+            "var name = 'Foo';", //
+            "`My name is ${name}`;"),
         lines(
-            "var a = 'Foo';",
+            "var a = 'Foo';", //
             "`My name is ${a}`;"));
   }
 
   @Test
   public void testArrayDestructuring() {
-    test("var [x, y, z] = [1, 2, 3];",
+    test(
+        "var [x, y, z] = [1, 2, 3];", //
         "var [a, b, c] = [1, 2, 3];");
   }
 
@@ -867,18 +1009,18 @@ public final class RenameVarsTest extends CompilerTestCase {
     // Also, this is only relevant if language_out >= ES6.
     test(
         lines(
-            "var obj = {p: 5, h: false};",
+            "var obj = {p: 5, h: false};", //
             "var {p, h} = obj;"),
         lines(
-            "var a = {p: 5, h: false};",
+            "var a = {p: 5, h: false};", //
             "var {p: b, h: c} = a;"));
 
-   test(
+    test(
         lines(
-            "var obj = {p: 5, h: false};",
+            "var obj = {p: 5, h: false};", //
             "var {p: x, h: y} = obj;"),
         lines(
-            "var a = {p: 5, h: false};",
+            "var a = {p: 5, h: false};", //
             "var {p: b, h: c} = a;"));
   }
 
@@ -886,12 +1028,11 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testDefaultFunction() {
     test(
         lines(
-            "function f(x, y=12) {",
+            "function f(x, y=12) {", //
             "  return x * y;",
-            "}"
-        ),
+            "}"),
         lines(
-            "function c(a, b=12) {",
+            "function c(a, b=12) {", //
             "  return a * b;",
             "}"));
   }
@@ -900,12 +1041,11 @@ public final class RenameVarsTest extends CompilerTestCase {
   public void testRestFunction() {
     test(
         lines(
-            "function f(x, ...y) {",
+            "function f(x, ...y) {", //
             "  return x * y[0];",
-            "}"
-        ),
+            "}"),
         lines(
-            "function c(a, ...b) {",
+            "function c(a, ...b) {", //
             "  return a * b[0];",
             "}"));
   }
@@ -924,8 +1064,7 @@ public final class RenameVarsTest extends CompilerTestCase {
             "    return super.f;",
             "  }",
             "};",
-            "obj.x();"
-        ),
+            "obj.x();"),
         lines(
             "var a = {",
             "  f: 'potato'",
@@ -963,30 +1102,24 @@ public final class RenameVarsTest extends CompilerTestCase {
         "import {name as a} from './other.js'; use(a);");
   }
 
-  private void testRenameMapUsingOldMap(String input, String expected,
-                                        VariableMap expectedMap) {
+  private void testRenameMapUsingOldMap(String input, String expected, VariableMap expectedMap) {
     previouslyUsedMap = renameVars.getVariableMap();
     testRenameMap("", input, expected, expectedMap);
   }
 
-  private void testRenameMapUsingOldMap(String externs, String input,
-                                        String expected,
-                                        VariableMap expectedMap) {
+  private void testRenameMapUsingOldMap(
+      String externs, String input, String expected, VariableMap expectedMap) {
     previouslyUsedMap = renameVars.getVariableMap();
     testRenameMap(externs, input, expected, expectedMap);
   }
 
-  private void testRenameMap(String input, String expected,
-                             VariableMap expectedRenameMap) {
+  private void testRenameMap(String input, String expected, VariableMap expectedRenameMap) {
     testRenameMap("", input, expected, expectedRenameMap);
   }
 
-  private void testRenameMap(String externs, String input, String expected,
-                             VariableMap expectedRenameMap) {
-    test(
-        externs(externs),
-        srcs(input),
-        expected(expected));
+  private void testRenameMap(
+      String externs, String input, String expected, VariableMap expectedRenameMap) {
+    test(externs(externs), srcs(input), expected(expected));
     VariableMap renameMap = renameVars.getVariableMap();
     assertVariableMapsEqual(expectedRenameMap, renameMap);
   }
@@ -1036,8 +1169,8 @@ public final class RenameVarsTest extends CompilerTestCase {
   }
 
   private static void assertVariableMapsEqual(VariableMap a, VariableMap b) {
-    Map<String, String> ma = a.getOriginalNameToNewNameMap();
-    Map<String, String> mb = b.getOriginalNameToNewNameMap();
+    ImmutableMap<String, String> ma = a.getOriginalNameToNewNameMap();
+    ImmutableMap<String, String> mb = b.getOriginalNameToNewNameMap();
     assertWithMessage("VariableMaps not equal").that(mb).isEqualTo(ma);
   }
 
@@ -1074,8 +1207,7 @@ public final class RenameVarsTest extends CompilerTestCase {
     private final Compiler compiler;
     private final CompilerPass wrappedPass;
 
-    private NormalizePassWrapper(Compiler compiler,
-        CompilerPass wrappedPass) {
+    private NormalizePassWrapper(Compiler compiler, CompilerPass wrappedPass) {
       this.compiler = compiler;
       this.wrappedPass = wrappedPass;
     }
diff --git a/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java b/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
index 21d10ed..1775831 100644
--- a/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
@@ -84,7 +84,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
     };
   }
 
-  protected CssRenamingMap getPartialMap() {
+  CssRenamingMap getPartialMap() {
     return new CssRenamingMap.ByPart() {
       @Override
       public String get(String value) {
@@ -93,7 +93,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
     };
   }
 
-  protected CssRenamingMap getFullMap() {
+  CssRenamingMap getFullMap() {
     return new CssRenamingMap.ByWhole() {
       @Override public String get(String value) {
         return replacementMapFull.get(value);
@@ -127,7 +127,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'goog-colorswatch-disabled'");
     test("setClass(goog.getCssName('active-buttonbar'))",
          "setClass('active-buttonbar')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("goog", 2)
             .put("footer", 1)
@@ -162,7 +162,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'c'");
     test("setClass(goog.getCssName('elephant'))",
          "setClass('e')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("buttonbar", 1)
             .put("colorswatch", 1)
@@ -183,7 +183,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'g-c-d'");
     test("setClass(goog.getCssName('active-buttonbar'))",
          "setClass('a-b')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("goog", 2)
             .put("footer", 1)
diff --git a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
index 4efee02..0e838da 100644
--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
@@ -20,6 +20,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static com.google.javascript.jscomp.ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER;
 
 import com.google.common.collect.ImmutableMap;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,8 +34,8 @@ import org.junit.runners.JUnit4;
 public final class ReplaceIdGeneratorsTest extends CompilerTestCase {
 
   private boolean generatePseudoNames = false;
-  private ReplaceIdGenerators lastPass = null;
-  private String previousMappings = null;
+  private @Nullable ReplaceIdGenerators lastPass = null;
+  private @Nullable String previousMappings = null;
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
@@ -60,7 +61,7 @@ public final class ReplaceIdGeneratorsTest extends CompilerTestCase {
                 .buildOrThrow(),
             generatePseudoNames,
             previousMappings,
-            null /* xidHashFunction */);
+            /* xidHashFunction= */ null);
     return lastPass;
   }
 
diff --git a/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java b/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
index c88a47c..b9a1aa3 100644
--- a/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
@@ -16,9 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.JsMessage.Style.RELAX;
-
-import com.google.javascript.jscomp.JsMessage.Style;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,11 +25,9 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ReplaceMessagesForChromeTest extends CompilerTestCase {
 
-  private Style style = RELAX;
-
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(null), style);
+    return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(null));
   }
 
   @Override
@@ -45,7 +40,6 @@ public final class ReplaceMessagesForChromeTest extends CompilerTestCase {
   @Before
   public void setUp() throws Exception {
     super.setUp();
-    style = RELAX;
     enableTypeCheck();
     replaceTypesWithColors();
     enableTypeInfoValidation();
diff --git a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
index 3024e62..c6d7650 100644
--- a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
@@ -17,8 +17,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE;
-import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX;
+import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY;
 import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
@@ -64,7 +63,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     final ReplaceMessages replaceMessages =
-        new ReplaceMessages(compiler, new SimpleMessageBundle(), CLOSURE, strictReplacement);
+        new ReplaceMessages(compiler, new SimpleMessageBundle(), strictReplacement);
     switch (testMode) {
       case FULL_REPLACE:
         return replaceMessages.getFullReplacementPass();
@@ -251,7 +250,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testReplaceSimpleMessage() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         lines(
@@ -273,8 +272,79 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testReplaceExternalMessage() {
+    registerMessage(getTestMessageBuilder("12345").appendStringPart("Saluton!").build());
+
+    multiPhaseTest(
+        lines(
+            "/** @desc d */", //
+            "var MSG_EXTERNAL_12345 = goog.getMsg('Hello!');"),
+        lines(
+            "/**",
+            " * @desc d",
+            " */",
+            "var MSG_EXTERNAL_12345 =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_EXTERNAL_12345\",",
+            "          \"msg_text\":\"Hello!\",",
+            "        });"),
+        lines(
+            "/** @desc d */", //
+            "var MSG_EXTERNAL_12345='Saluton!'"));
+  }
+
+  @Test
+  public void testReplaceExternalIcuSelectorMessageWithPlaceholders() {
+    // Message in the bundle is in ICU selector format with has placeholders with explicit
+    // placeholders.
+    // The JS code treats the message as a simple string without placeholders.
+    // The compiler should join the placeholder names together with the string parts in order to
+    // get the runtime string value.
+    registerMessage(
+        getTestMessageBuilder("123456")
+            .appendStringPart("{USER_GENDER,select,female{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}male{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}other{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}}")
+            .build());
+
+    multiPhaseTest(
+        lines(
+            "/** @desc ICU gender-sensitive greeting */",
+            // Message in the JS code does not define placeholders for the compiler.
+            "const MSG_EXTERNAL_123456 = goog.getMsg(",
+            "    '{USER_GENDER,select,' +",
+            "    'female{Hello {USER_IDENTIFIER}.}' +",
+            "    'male{Hello {USER_IDENTIFIER}.}' +",
+            "    'other{Hello {USER_IDENTIFIER}.}}');"),
+        lines(
+            "/** @desc ICU gender-sensitive greeting */",
+            "const MSG_EXTERNAL_123456 =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_EXTERNAL_123456\",",
+            "          \"msg_text\":",
+            "    '{USER_GENDER,select,"
+                + "female{Hello {USER_IDENTIFIER}.}"
+                + "male{Hello {USER_IDENTIFIER}.}"
+                + "other{Hello {USER_IDENTIFIER}.}}',",
+            "        });"),
+        lines(
+            "/** @desc ICU gender-sensitive greeting */", //
+            "const MSG_EXTERNAL_123456 =",
+            "    '{USER_GENDER,select,"
+                + "female{Saluton {USER_IDENTIFIER}.}"
+                + "male{Saluton {USER_IDENTIFIER}.}"
+                + "other{Saluton {USER_IDENTIFIER}.}}';"));
+  }
+
+  @Test
   public void testReplaceSimpleMessageDefinedWithAdd() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         lines(
@@ -327,12 +397,12 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testAlternateMessageWithMismatchedParts() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("1984")
             .setDesc("B desc")
             .setMeaning("B meaning")
             .appendStringPart("Hello!")
             .appendStringPart(" Welcome!")
-            .build((meaning, messageParts) -> "1984"));
+            .build());
 
     multiPhaseTest(
         lines(
@@ -362,15 +432,82 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testAlternateIcuSelectorMessageWithPlaceholders() {
+    // Message in the bundle is in ICU selector format with has placeholders with explicit
+    // placeholders.
+    // The JS code treats the message as a simple string without placeholders.
+    // The compiler should join the placeholder names together with the string parts in order to
+    // get the runtime string value.
+    // Note that we are not putting a translation for the actual message from the JS Code into the
+    // bundle here. Instead, we are providing the alternate message.
+    registerMessage(
+        getTestMessageBuilder("1984")
+            .appendStringPart("{USER_GENDER,select,female{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}male{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}other{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}}")
+            .build());
+
+    multiPhaseTest(
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            // Message in the JS code does not define placeholders for the compiler.
+            "const MSG_ICU_SELECT = goog.getMsg(",
+            "    '{USER_GENDER,select,' +",
+            "    'female{Hello {USER_IDENTIFIER}.}' +",
+            "    'male{Hello {USER_IDENTIFIER}.}' +",
+            "    'other{Hello {USER_IDENTIFIER}.}}');"),
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            "const MSG_ICU_SELECT =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_ICU_SELECT\",",
+            "          \"alt_id\": \"1984\",",
+            "          \"msg_text\":",
+            "    '{USER_GENDER,select,"
+                + "female{Hello {USER_IDENTIFIER}.}"
+                + "male{Hello {USER_IDENTIFIER}.}"
+                + "other{Hello {USER_IDENTIFIER}.}}',",
+            "        });"),
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            "const MSG_ICU_SELECT =",
+            "    '{USER_GENDER,select,"
+                + "female{Saluton {USER_IDENTIFIER}.}"
+                + "male{Saluton {USER_IDENTIFIER}.}"
+                + "other{Saluton {USER_IDENTIFIER}.}}';"));
+  }
+
+  /**
+   * Returns a message builder that will use the same string as both the key and ID of the message.
+   */
+  private JsMessage.Builder getTestMessageBuilder(String keyAndId) {
+    return new JsMessage.Builder().setKey(keyAndId).setId(keyAndId);
+  }
+
+  @Test
   public void testAlternateMessageWithMismatchedPlaceholders() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("1984")
             .setDesc("B desc")
             .setMeaning("B meaning")
             .appendStringPart("Hello, ")
-            .appendPlaceholderReference("first_name")
+            .appendJsPlaceholderReference("firstName")
             .appendStringPart("!")
-            .build((meaning, messageParts) -> "1984"));
+            .build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -401,10 +538,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testReplaceValidAlternateMessage() {
-    registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
     multiPhaseTest(
         lines(
@@ -435,12 +569,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testIgnoreUnnecessaryAlternateMessage() {
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
     registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
-    registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .setDesc("Greeting.")
             .setAlternateId("1984")
             .appendStringPart("Hi\nthere")
@@ -476,12 +607,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testAlternateTrumpsFallback() {
-    registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("Good\nmorrow, sir").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("Good\nmorrow, sir").build());
 
     multiPhaseTest(
         lines(
@@ -532,10 +660,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testFallbackWithAlternate() {
-    registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
     multiPhaseTest(
         lines(
@@ -587,9 +712,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testNameReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -613,9 +738,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testNameReplacementWithFullOptionsBag() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -659,7 +784,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testGetPropReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_C").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -683,7 +808,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testFunctionCallReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_D").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_D").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines("/** @desc d */", "var MSG_D = goog.getMsg('${$amount}', {amount: getAmt()});"),
@@ -705,7 +830,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testMethodCallReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_E").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_E").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -728,7 +853,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testMethodCallReplacementEmptyMessage() {
-    registerMessage(new JsMessage.Builder("MSG_M").build());
+    registerMessage(getTestMessageBuilder("MSG_M").build());
 
     multiPhaseTest(
         lines(
@@ -750,9 +875,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testHookReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_F")
+        getTestMessageBuilder("MSG_F")
             .appendStringPart("#")
-            .appendPlaceholderReference("amount")
+            .appendJsPlaceholderReference("amount")
             .appendStringPart(".")
             .build());
 
@@ -776,7 +901,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testAddReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_G").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_G").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -799,12 +924,12 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testPlaceholderValueReferencedTwice() {
     registerMessage(
-        new JsMessage.Builder("MSG_H")
-            .appendPlaceholderReference("dick")
+        getTestMessageBuilder("MSG_H")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(", ")
-            .appendPlaceholderReference("dick")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(" and ")
-            .appendPlaceholderReference("jane")
+            .appendJsPlaceholderReference("jane")
             .build());
 
     multiPhaseTest(
@@ -826,11 +951,66 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testInvalidMessageStringType() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */", //
+            "const MSG_H = goog.getMsg(10);"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testPlaceholderValueDefinedTwice() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y, jane: x});"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testInvalidPlaceholderArgument() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    'this should be an object literal');"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testInvalidOptionsArgumentType() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y},",
+            "    'should be an object literal');"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testComputedKeyInOptions() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y},",
+            "    {[computedOpt]: true});"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
   public void testPlaceholderNameInLowerCamelCase() {
     registerMessage(
-        new JsMessage.Builder("MSG_I")
+        getTestMessageBuilder("MSG_I")
             .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amtEarned")
+            .appendJsPlaceholderReference("amtEarned")
             .build());
 
     multiPhaseTest(
@@ -856,9 +1036,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testQualifiedMessageName() {
     registerMessage(
-        new JsMessage.Builder("MSG_J")
+        getTestMessageBuilder("MSG_J")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -886,10 +1066,10 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testPlaceholderInPlaceholderValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_L")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_L")
+            .appendJsPlaceholderReference("a")
             .appendStringPart(" has ")
-            .appendPlaceholderReference("b")
+            .appendJsPlaceholderReference("b")
             .build());
 
     multiPhaseTest(
@@ -925,7 +1105,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
         lines(
             "/** @desc d */", //
             "var MSG_E = 'd*6a0@z>t'"),
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -963,9 +1143,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testStrictModeAndMessageReplacementAbsentInNonEmptyBundle() {
     registerMessage(
-        new JsMessage.Builder("MSG_J")
+        getTestMessageBuilder("MSG_J")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -994,7 +1174,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "      {});",
             "};"),
         "var MSG_F = function() {return'asdf'}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -1011,7 +1191,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"measly\":measly});",
             "    };"),
         "var MSG_G = function(measly) { return 'asdf' + measly}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -1022,7 +1202,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testBadPlaceholderReferenceInReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_K").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_K").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -1040,8 +1220,13 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
-  public void testEmptyObjLit() {
-    registerMessage(new JsMessage.Builder("MSG_E").appendPlaceholderReference("amount").build());
+  public void testTranslatedMessageWithPlaceholdersForGoogGetMsgWithoutAny() {
+    registerMessage(
+        getTestMessageBuilder("MSG_E")
+            .appendStringPart("You have purchased ")
+            .appendJsPlaceholderReference("amount")
+            .appendStringPart(" items.")
+            .build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -1054,34 +1239,33 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "    __jscomp_define_msg__({\"key\":\"MSG_E\", \"msg_text\":\"no placeholders\"});",
             ""),
         MESSAGE_TREE_MALFORMED,
-        "Message parse tree malformed. "
-            + "Empty placeholder value map for a translated message "
-            + "with placeholders.");
+        "Message parse tree malformed. The translated message has placeholders, but the definition"
+            + " in the JS code does not.");
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersVarSyntaxConcat() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_A = 'abc' + 'def';", //
         "var MSG_A = __jscomp_define_msg__({\"key\":\"MSG_A\", \"msg_text\":\"abcdef\"});",
         "var MSG_A = 'Hi\\nthere'",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersVarSyntax() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_A = 'd*6a0@z>t';", //
         "var MSG_A = __jscomp_define_msg__({\"key\":\"MSG_A\", \"msg_text\":\"d*6a0@z\\x3et\"});",
         "var MSG_A='Hi\\nthere'",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersFunctionSyntax() {
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_B = function() {return 'asdf'};", //
         lines(
@@ -1094,15 +1278,15 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {});",
             "};"),
         "var MSG_B=function(){return'Hi\\nthere'}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleOnePlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_C")
+        getTestMessageBuilder("MSG_C")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
     multiPhaseTestWarning(
@@ -1117,16 +1301,16 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"measly\":measly});",
             "};"),
         "var MSG_C=function(measly){ return 'One ' + measly + ' ph'; }",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleTwoPlaceholders() {
     registerMessage(
-        new JsMessage.Builder("MSG_D")
-            .appendPlaceholderReference("dick")
+        getTestMessageBuilder("MSG_D")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(" and ")
-            .appendPlaceholderReference("jane")
+            .appendJsPlaceholderReference("jane")
             .build());
     multiPhaseTestWarning(
         "var MSG_D = function(jane, dick) {return jane + dick};", //
@@ -1141,15 +1325,15 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "};",
             ""),
         "var MSG_D = function(jane,dick) { return dick + ' and ' + jane; }",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStylePlaceholderNameInLowerCamelCase() {
     registerMessage(
-        new JsMessage.Builder("MSG_E")
+        getTestMessageBuilder("MSG_E")
             .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amtEarned")
+            .appendJsPlaceholderReference("amtEarned")
             .build());
     multiPhaseTestWarning(
         "var MSG_E = function(amtEarned) {return amtEarned + 'x'};",
@@ -1163,51 +1347,30 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"amtEarned\":amtEarned});",
             "};"),
         "var MSG_E=function(amtEarned){return'Sum: $'+amtEarned}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
-  public void testLegacyStylePlaceholderNameInLowerUnderscoreCase() {
-    registerMessage(
-        new JsMessage.Builder("MSG_F")
-            .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amt_earned")
-            .build());
-
-    // Placeholder named in lower-underscore case (discouraged nowadays)
+  public void testInvalidRhs() {
+    // If the RHS of a variable named `MSG_*` is not a function call, just report a warning.
     multiPhaseTestWarning(
-        "var MSG_F = function(amt_earned) {return amt_earned + 'x'};",
-        lines(
-            "var MSG_F = function(amt_earned) {",
-            "    return __jscomp_define_msg__(",
-            "        {",
-            "          \"key\":\"MSG_F\",",
-            "          \"msg_text\":\"{$amt_earned}x\"",
-            "        },",
-            "        {\"amt_earned\":amt_earned});",
-            "};"),
-        "var MSG_F=function(amt_earned){return'Sum: $'+amt_earned}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
-  }
+        "var MSG_A = 'string value';",
+        "var MSG_A = 'string value';",
+        "var MSG_A = 'string value';",
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
 
-  @Test
-  public void testLegacyStyleBadPlaceholderReferenceInReplacement() {
-    registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Ola, ")
-            .appendPlaceholderReference("chimp")
-            .build());
-
-    testWarning(
-        "var MSG_B = function(chump) {return chump + 'x'};",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+    multiPhaseTestWarning(
+        "var MSG_A = 15 * 12;",
+        "var MSG_A = 15 * 12;",
+        "var MSG_A = 15 * 12;",
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testTranslatedPlaceHolderMissMatch() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1217,8 +1380,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedBadBooleanOptionValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1235,8 +1398,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedMisspelledExamples() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1249,8 +1412,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedMisspelledOriginalCode() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1263,8 +1426,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithUnknownPlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1276,8 +1439,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithNonStringPlaceholderValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1289,8 +1452,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithBadValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1302,8 +1465,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithComputedProperty() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1371,7 +1534,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testUseFallback() {
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1446,7 +1609,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testNoUseFallback() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1484,7 +1647,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testNoUseFallback2() {
-    registerMessage(new JsMessage.Builder("MSG_C").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1522,7 +1685,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testTemplateLiteralSimple() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         "/** @desc d */\n var MSG_A = goog.getMsg(`asdf`);",
@@ -1543,9 +1706,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTemplateLiteralNameReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -1571,7 +1734,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTemplateLiteralSubstitutions() {
     // Only allow template literals that are constant strings
-    registerMessage(new JsMessage.Builder("MSG_C").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendStringPart("Hi\nthere").build());
 
     multiPhaseTestPreLookupError(
         "/** @desc d */\n var MSG_C = goog.getMsg(`asdf ${42}`);",
@@ -1668,7 +1831,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testReplaceUnescapeHtmlEntitiesMessageWithReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .appendStringPart("User")
             .appendStringPart("&")
             .appendStringPart("apos;s &")
@@ -1698,7 +1861,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "var MSG_A = 'User\\'s < email & address > are \"correct\"';"));
 
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("User")
             .appendStringPart("&apos;")
             .appendStringPart("s ")
@@ -1730,14 +1893,14 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
         "/** @desc d */\n var MSG_B = 'User\\'s < email & address > are \"correct\"';");
 
     registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendPlaceholderReference("br")
+        getTestMessageBuilder("MSG_C")
+            .appendJsPlaceholderReference("br")
             .appendStringPart("&")
             .appendStringPart("amp;")
-            .appendPlaceholderReference("x")
-            .appendPlaceholderReference("y")
+            .appendJsPlaceholderReference("x")
+            .appendJsPlaceholderReference("y")
             .appendStringPart("&ap")
-            .appendPlaceholderReference("z")
+            .appendJsPlaceholderReference("z")
             .appendStringPart("os;")
             .build());
     multiPhaseTest(
@@ -1771,9 +1934,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testReplaceHtmlMessageWithPlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .appendStringPart("Hello <") // html option changes `<` to `&lt;
-            .appendPlaceholderReference("br")
+            .appendJsPlaceholderReference("br")
             .appendStringPart("&gt;")
             .build());
 
diff --git a/test/com/google/javascript/jscomp/ReplaceStringsTest.java b/test/com/google/javascript/jscomp/ReplaceStringsTest.java
index 1b5dff4..8b28235 100644
--- a/test/com/google/javascript/jscomp/ReplaceStringsTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java
@@ -40,7 +40,7 @@ public final class ReplaceStringsTest extends CompilerTestCase {
   private boolean runDisambiguateProperties;
   private boolean rename;
 
-  private final ImmutableList<String> defaultFunctionsToInspect =
+  private static final ImmutableList<String> DEFAULT_FUNCTIONS_TO_INSPECT =
       ImmutableList.of(
           "Error(?)",
           "goog.debug.Trace.startTracer(*)",
@@ -92,7 +92,7 @@ public final class ReplaceStringsTest extends CompilerTestCase {
     enableTypeCheck();
     enableNormalize();
     enableParseTypeInfo();
-    functionsToInspect = defaultFunctionsToInspect;
+    functionsToInspect = DEFAULT_FUNCTIONS_TO_INSPECT;
     runDisambiguateProperties = false;
     rename = false;
   }
diff --git a/test/com/google/javascript/jscomp/RewriteClassFieldsTest.java b/test/com/google/javascript/jscomp/RewriteClassFieldsTest.java
deleted file mode 100644
index 51857a1..0000000
--- a/test/com/google/javascript/jscomp/RewriteClassFieldsTest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2021 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.javascript.jscomp;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * Test cases for transpilation pass that replaces public class fields: `class C { x = 2; ['y'] = 3;
- * static a; static ['b'] = 'hi'; }`
- */
-@RunWith(JUnit4.class)
-public final class RewriteClassFieldsTest extends CompilerTestCase {
-
-  @Override
-  @Before
-  public void setUp() throws Exception {
-    super.setUp();
-    enableTypeInfoValidation();
-    enableTypeCheck();
-    replaceTypesWithColors();
-    enableMultistageCompilation();
-  }
-
-  @Override
-  protected CompilerPass getProcessor(Compiler compiler) {
-    return new RewriteClassFields(compiler);
-  }
-
-  @Test
-  public void testCannotConvertYet() {
-    testError(
-        lines(
-            "class C {", //
-            "  x = 2;",
-            "}"),
-        Es6ToEs3Util.CANNOT_CONVERT_YET);
-    testError(
-        lines(
-            "/** @unrestricted */", //
-            "class C {",
-            "  ['x'] = 2;",
-            "}"),
-        Es6ToEs3Util.CANNOT_CONVERT_YET);
-    testError(
-        lines(
-            "class C {", //
-            "  static x = 2;",
-            "}"),
-        Es6ToEs3Util.CANNOT_CONVERT_YET);
-    testError(
-        lines(
-            "/** @unrestricted */", //
-            "class C {",
-            "  static ['x'] = 2;",
-            "}"),
-        Es6ToEs3Util.CANNOT_CONVERT_YET);
-  }
-}
diff --git a/test/com/google/javascript/jscomp/RewriteClassMembersTest.java b/test/com/google/javascript/jscomp/RewriteClassMembersTest.java
new file mode 100644
index 0000000..e666974
--- /dev/null
+++ b/test/com/google/javascript/jscomp/RewriteClassMembersTest.java
@@ -0,0 +1,1278 @@
+/*
+ * Copyright 2021 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.javascript.jscomp;
+
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Test cases for transpilation pass that replaces public class fields and class static blocks:
+ * <code><pre>
+ * class C {
+ *   x = 2;
+ *   ['y'] = 3;
+ *   static a;
+ *   static ['b'] = 'hi';
+ *   static {
+ *     let c = 4;
+ *     this.z = c;
+ *   }
+ * }
+ * </pre></code>
+ */
+@RunWith(JUnit4.class)
+public final class RewriteClassMembersTest extends CompilerTestCase {
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    enableTypeInfoValidation();
+    enableTypeCheck();
+    replaceTypesWithColors();
+    enableMultistageCompilation();
+  }
+
+  @Override
+  protected CompilerPass getProcessor(Compiler compiler) {
+    return new RewriteClassMembers(compiler);
+  }
+
+  @Test
+  public void testCannotConvertYet() {
+    testError(
+        lines(
+            "/** @unrestricted */", //
+            "class C {",
+            "  ['x'] = 2;",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // computed prop
+
+    testError(
+        lines(
+            "/** @unrestricted */", //
+            "class C {",
+            "  static ['x'] = 2;",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // computed prop
+
+    testError(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = 2",
+            "    this.y = x",
+            "  }",
+            "}"),
+        /*lines(
+        "class C {}", //
+        "{",
+        "  let x = 2;",
+        "  C.y = x", // TODO(b/235871861): Need to correct references to `this`
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET); // uses `this`
+
+    testError(
+        lines(
+            "class C extends B{", //
+            "  static {",
+            "    let x = super.y",
+            "  }",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // uses `super`
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  static {",
+            "    C.y = 2;",
+            "    let x = C.y",
+            "  }",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "foo(class C {", //
+            "  static {",
+            "    C.y = 2;",
+            "    let x = C.y",
+            "  }",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "class A {}",
+            "foo(A.b.c = class C {", //
+            "  static {",
+            "    C.y = 2;",
+            "    let x = C.y",
+            "  }",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "foo(class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "class C {", //
+            "  static {",
+            "    C.x = 2",
+            "    const y = this.x",
+            "  }",
+            "}"),
+        /*lines(
+        "class C {}", //
+        "{",
+        "  C.x = 2;",
+        "  const y = C.x",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "var z = 1", //
+            "class C {",
+            "  static {",
+            "    let x = 2",
+            "    var z = 3;",
+            "  }",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // `var` in static block
+
+    testError(
+        lines(
+            "class C {", //
+            "  static x = 1;",
+            "  static y = this.x;",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // `this` in static field
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  static y = 2;",
+            "  static x = C.y",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "foo(class C {", //
+            "  static y = 2;",
+            "  static x = C.y",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "foo(class {", //
+            "  static x = 1",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    testError(
+        lines(
+            "class C {", //
+            "  x = 1;",
+            "  y = this.x;",
+            "}"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // `this` in public field
+
+    testError(
+        lines(
+            "foo(class C {", //
+            "  static y = 2;",
+            "  x = C.y",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "class C {", //
+                "  static [1] = 1;",
+                "  static [2] = this[1];",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // use of `this`
+
+    test(
+        srcs(
+            lines(
+                "let c = class C {", //
+                "  static [1] = 2;",
+                "  static [2] = C[1]",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "foo(class C {", //
+                "  static [1] = 2;",
+                "  static [2] = C[1]",
+                "})")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    testError(
+        lines(
+            "foo(class {", //
+            "  static [1] = 1",
+            "})"),
+        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "class C {", //
+                "  [1] = 1;",
+                "  [2] = this[1];",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // use of `this`
+
+    test(
+        srcs(
+            lines(
+                "let c = class C {", //
+                "  static [1] = 2;",
+                "  [2] = C[1]",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "foo(class C {", //
+                "  static [1] = 2;",
+                "  [2] = C[1]",
+                "})")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "let c = class {", //
+                "  x = 1",
+                "  y = this.x",
+                "}",
+                "class B {",
+                "  [1] = 2;",
+                "  [2] = this[1]",
+                "}" // testing that the correct number of diagnostics are thrown
+                )),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET));
+  }
+
+  @Test
+  public void testClassStaticBlocksNoFieldAssign() {
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "}",
+            "{}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = 2",
+            "    const y = x",
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  let x = 2;",
+            "  const y = x",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = 2",
+            "    const y = x",
+            "    let z;",
+            "    if (x - y == 0) {z = 1} else {z = 2}",
+            "    while (x - z > 10) {z++;}",
+            "    for (;;) {break;}",
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  let x = 2;",
+            "  const y = x",
+            "  let z;",
+            "  if (x - y == 0) {z = 1} else {z = 2}",
+            "  while (x - z > 10) {z++;}",
+            "  for (;;) {break;}",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = 2",
+            "  }",
+            "  static {",
+            "    const y = x",
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  let x = 2;",
+            "}",
+            "{",
+            "  const y = x",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = 2",
+            "  }",
+            "  static {",
+            "    const y = x",
+            "  }",
+            "}",
+            "class D {",
+            "  static {",
+            "    let z = 1",
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  let x = 2;",
+            "}",
+            "{",
+            "  const y = x",
+            "}",
+            "class D {}",
+            "{",
+            "  let z = 1;",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    let x = function () {return 1;}",
+            "    const y = () => {return 2;}",
+            "    function a() {return 3;}",
+            "    let z = (() => {return 4;})();",
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  let x = function () {return 1;}",
+            "  const y = () => {return 2;}",
+            "  function a() {return 3;}",
+            "  let z = (() => {return 4;})();",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static {",
+            "    C.x = 2",
+            // "    const y = C.x", //TODO(b/235871861) blocked on typechecking, gets
+            // JSC_INEXISTENT_PROPERTY
+            "  }",
+            "}"),
+        lines(
+            "class C {}", //
+            "{",
+            "  C.x = 2;",
+            // "  const y = C.x",
+            "}"));
+
+    test(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    let x = 5;",
+            "    class Bar {",
+            "      static {",
+            "        let x = 'str';",
+            "      }",
+            "    }",
+            "  }",
+            "}"),
+        lines(
+            "class Foo {}", //
+            "{",
+            "  let x = 5;",
+            "  class Bar {}",
+            "  {let x = 'str';}",
+            "}"));
+  }
+
+  @Test
+  public void testStaticNoncomputed() {
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "}"),
+        lines("class C {}", "C.x = 2;"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x;",
+            "}"),
+        lines("class C {}", "C.x;"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  static y = 'hi'",
+            "  static z;",
+            "}"),
+        lines("class C {}", "C.x = 2;", "C.y = 'hi'", "C.z;"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  static y = 3",
+            "}",
+            "class D {",
+            "  static z = 1",
+            "}"),
+        lines(
+            "class C {}", //
+            "C.x = 2;",
+            "C.y = 3",
+            "class D {}",
+            "D.z = 1;"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static w = function () {return 1;};",
+            "  static x = () => {return 2;};",
+            "  static y = (function a() {return 3;})();",
+            "  static z = (() => {return 4;})();",
+            "}"),
+        lines(
+            "class C {}", //
+            "C.w = function () {return 1;};",
+            "C.x = () => {return 2;};",
+            "C.y = (function a() {return 3;})();",
+            "C.z = (() => {return 4;})();"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  static y = C.x",
+            "}"),
+        lines(
+            "class C {}", //
+            "C.x = 2;",
+            "C.y = C.x"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  static {let y = C.x}",
+            "}"),
+        lines(
+            "class C {}", //
+            "C.x = 2;",
+            "{let y = C.x}"));
+  }
+
+  @Test
+  public void testInstanceNoncomputedWithNonemptyConstructor() {
+    test(
+        lines(
+            "class C {", //
+            "  x = 1;",
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x;",
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x;",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  y = 2",
+            "  constructor() {",
+            "    this.z = 3;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "    this.z = 3;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  y = 2",
+            "  constructor() {",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  constructor() {",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "  y = 2",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  constructor() {",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "  y = 2",
+            "}",
+            "class D {",
+            "  a = 5;",
+            "  constructor() { this.b = 6;}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}",
+            "class D {",
+            "constructor() {",
+            "  this.a = 5;",
+            "  this.b = 6",
+            "}",
+            "}"));
+  }
+
+  @Test
+  public void testInstanceNoncomputedWithNonemptyConstructorAndSuper() {
+    test(
+        lines(
+            "class A { constructor() { alert(1); } }",
+            "class C extends A {", //
+            "  x = 1;",
+            "  constructor() {",
+            "    super()",
+            "    this.y = 2;",
+            "  }",
+            "}"),
+        lines(
+            "class A { constructor() { alert(1); } }",
+            "class C extends A {", //
+            "  constructor() {",
+            "    super()",
+            "    this.x = 1",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class A { constructor() { this.x = 1; } }",
+            "class C extends A {", //
+            "  y;",
+            "  constructor() {",
+            "    super()",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}"),
+        lines(
+            "class A { constructor() { this.x = 1; } }",
+            "class C extends A {", //
+            "  constructor() {",
+            "    super()",
+            "    this.y;",
+            "    alert(3);",
+            "    this.z = 4;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class A { constructor() { this.x = 1; } }",
+            "class C extends A {", //
+            "  y;",
+            "  constructor() {",
+            "    alert(3);",
+            "    super()",
+            "    this.z = 4;",
+            "  }",
+            "}"),
+        lines(
+            "class A { constructor() { this.x = 1; } }",
+            "class C extends A {", //
+            "  constructor() {",
+            "    alert(3);",
+            "    super()",
+            "    this.y;",
+            "    this.z = 4;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testNonComputedInstanceWithEmptyConstructor() {
+    test(
+        lines(
+            "class C {", //
+            "  x = 2;",
+            "  constructor() {}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 2;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x;",
+            "  constructor() {}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 2",
+            "  y = 'hi'",
+            "  z;",
+            "  constructor() {}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 2",
+            "    this.y = 'hi'",
+            "    this.z;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  constructor() {",
+            "  }",
+            "  y = 2",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 1",
+            "  constructor() {",
+            "  }",
+            "  y = 2",
+            "}",
+            "class D {",
+            "  a = 5;",
+            "  constructor() {}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.x = 1;",
+            "    this.y = 2;",
+            "  }",
+            "}",
+            "class D {",
+            "constructor() {",
+            "  this.a = 5;",
+            "}",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  w = function () {return 1;};",
+            "  x = () => {return 2;};",
+            "  y = (function a() {return 3;})();",
+            "  z = (() => {return 4;})();",
+            "  constructor() {}",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.w = function () {return 1;};",
+            "    this.x = () => {return 2;};",
+            "    this.y = (function a() {return 3;})();",
+            "    this.z = (() => {return 4;})();",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  constructor() {}",
+            "  y = C.x",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() { this.y = C.x; }",
+            "}",
+            "C.x = 2;"));
+  }
+
+  @Test
+  public void testInstanceNoncomputedNoConstructor() {
+    test(
+        lines(
+            "class C {", //
+            "  x = 2;",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {this.x=2;}",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x;",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {this.x;}",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  x = 2",
+            "  y = 'hi'",
+            "  z;",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {this.x=2; this.y='hi'; this.z;}",
+            "}"));
+    test(
+        lines(
+            "class C {", //
+            "  foo() {}",
+            "  x = 1;",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {this.x = 1;}",
+            "  foo() {}",
+            "}"));
+
+    test(
+        lines(
+            "class C {", //
+            "  static x = 2",
+            "  y = C.x",
+            "}"),
+        lines(
+            "class C {constructor() {",
+            "this.y = C.x",
+            "}}", //
+            "C.x = 2;"));
+
+    test(
+        lines(
+            "class C {", //
+            "  w = function () {return 1;};",
+            "  x = () => {return 2;};",
+            "  y = (function a() {return 3;})();",
+            "  z = (() => {return 4;})();",
+            "}"),
+        lines(
+            "class C {", //
+            "  constructor() {",
+            "    this.w = function () {return 1;};",
+            "    this.x = () => {return 2;};",
+            "    this.y = (function a() {return 3;})();",
+            "    this.z = (() => {return 4;})();",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testInstanceNonComputedNoConstructorWithSuperclass() {
+    test(
+        lines(
+            "class B {}", //
+            "class C extends B {x = 1;}"),
+        lines(
+            "class B {}",
+            "class C extends B {",
+            "  constructor() {",
+            "    super(...arguments);",
+            "    this.x = 1;",
+            "  }",
+            "}"));
+    test(
+        lines(
+            "class B {constructor() {}; y = 2;}", //
+            "class C extends B {x = 1;}"),
+        lines(
+            "class B {constructor() {this.y = 2}}",
+            "class C extends B {",
+            "  constructor() {",
+            "    super(...arguments);",
+            "    this.x = 1;",
+            "  }",
+            "}"));
+    test(
+        lines(
+            "class B {constructor(a, b) {}; y = 2;}", //
+            "class C extends B {x = 1;}"),
+        lines(
+            "class B {constructor(a, b) {this.y = 2}}",
+            "class C extends B {",
+            "  constructor() {",
+            "    super(...arguments);",
+            "    this.x = 1;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testNonClassDeclarationsStaticBlocks() {
+    test(
+        lines(
+            "let c = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        lines("let c = class {}", "{", "  let x = 1", "}"));
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        lines("class A {}", "A.c = class {}", "{", "  let x = 1", "}"));
+
+    testError(
+        lines(
+            "class A {}",
+            "A[1] = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        // lines("class A {}", "A[1] = class {}", "{", "  let x = 1", "}")
+        // TODO(b/189993301): transpile computed prop = class
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsStaticNoncomputedFields() {
+    test(
+        lines(
+            "let c = class {", //
+            "  static x = 1",
+            "}"),
+        lines("let c = class {}", "c.x = 1"));
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  static x = 1",
+            "}"),
+        lines("class A {}", "A.c = class {}", "A.c.x = 1"));
+
+    testError(
+        lines(
+            "class A {}",
+            "A[1] = class {", //
+            "  static x = 1",
+            "}"),
+        // lines("class A {}", "A[1] = class {}", "A[1].x = 1")
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsInstanceNoncomputedFields() {
+    test(
+        lines(
+            "let c = class {", //
+            "  y = 2;",
+            "}"),
+        lines(
+            "let c = class {", //
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "let c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  y = 2;",
+            "}"),
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    testError(
+        lines(
+            "A[1] = class {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "A[1] = class {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "foo(class {", //
+            "  y = 2;",
+            "})"),
+        /*lines("foo(class {", "  constructor() {", "    this.y = 2;", "  }", "})")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "let c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "class A {}",
+            "A.c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "class A {}",
+        "A.c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "A[1] = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "A[1] = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "foo(class C {", //
+            "  y = 2;",
+            "})"),
+        /*lines("foo(class C {", "  constructor() {", "    this.y = 2;", "  }", "})")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testConstuctorAndStaticFieldDontConflict() {
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  static y = x",
+            "  constructor(x) {}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor(x) {}",
+            "}",
+            "C.y = x"));
+  }
+
+  @Test
+  public void testInstanceInitializerShadowsConstructorDeclaration() {
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { let x;}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { {var x;} }",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "function f() { return 4; };", //
+            "class C {",
+            "  y = f();",
+            "  constructor() {function f() { return 'str'; }}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    // TODO(b/189993301): Technically this has no shadowing, so we could inline without renaming
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = (x) => x;",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testInstanceInitializerDoesntShadowConstructorDeclaration() {
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { {let x;} }",
+            "}"),
+        lines(
+            "let x = 2;",
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    {let x;}",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() {() => { let x; };}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    () => { let x; };",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() {(x) => 3;}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    (x) => 3;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testInstanceFieldInitializersDontBleedOut() {
+    test(
+        lines("class C {", "  y = z", "  method() { x; }", "  constructor(x) {}", "}"),
+        lines(
+            "class C {", "  method() { x; }", "  constructor(x) {", "    this.y = z;", "  }", "}"));
+  }
+
+  @Test
+  public void testNestedClassesWithShadowingInstanceFields() {
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = () => {",
+            "    class Foo { z = x };",
+            "  };",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsFunctionArgs() {
+    testError(
+        "A[foo()] = class {static x;}",
+        TranspilationUtil.CANNOT_CONVERT_YET); // impure computed prop
+
+    testError(
+        "foo(c = class {static x;})", TranspilationUtil.CANNOT_CONVERT_YET); // named function param
+
+    testError(
+        "function foo(c = class {static x;}) {}",
+        TranspilationUtil.CANNOT_CONVERT_YET); // default function param
+  }
+}
diff --git a/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java b/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
index fdfd5bf..de2917c 100644
--- a/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
+++ b/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,9 +41,9 @@ import org.junit.runners.JUnit4;
 /** Unit tests for {@link RewriteDynamicImports} */
 @RunWith(JUnit4.class)
 public class RewriteDynamicImportsTest extends CompilerTestCase {
-  private String dynamicImportAlias = "imprt_";
-  private LanguageMode language = null;
-  private LanguageMode languageIn = null;
+  private @Nullable String dynamicImportAlias = "imprt_";
+  private @Nullable LanguageMode language = null;
+  private @Nullable LanguageMode languageIn = null;
   private ChunkOutputType chunkOutputType = ChunkOutputType.GLOBAL_NAMESPACE;
 
   public RewriteDynamicImportsTest() {
diff --git a/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java b/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
index c55bc94..3312230 100644
--- a/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
+++ b/test/com/google/javascript/jscomp/RewriteNewDotTargetTest.java
@@ -15,7 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.Es6ToEs3Util.CANNOT_CONVERT_YET;
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
 
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import org.junit.Before;
diff --git a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
index b27595d..09c95c0 100644
--- a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
+++ b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
@@ -26,6 +26,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,7 +46,7 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
   private boolean isolatePolyfills = false;
   private boolean injectPolyfills = true;
 
-  private void addLibrary(String name, String from, String to, String library) {
+  private void addLibrary(String name, String from, String to, @Nullable String library) {
     if (library != null) {
       injectableLibraries.put(
           library,
@@ -82,7 +83,7 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
   @Override
   protected Compiler createCompiler() {
     return new NoninjectingCompiler() {
-      Node lastInjected = null;
+      @Nullable Node lastInjected = null;
 
       @Override
       public Node ensureLibraryInjected(String library, boolean force) {
diff --git a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
index f6dc81e..d9245c9 100644
--- a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
@@ -22,7 +22,6 @@ import static com.google.javascript.jscomp.parsing.JsDocInfoParser.BAD_TYPE_WIKI
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -134,9 +133,8 @@ public final class RhinoErrorReporterTest {
 
     options.setLanguageIn(languageIn);
 
-    List<SourceFile> externs = ImmutableList.of();
-    List<SourceFile> inputs = ImmutableList.of(
-        SourceFile.fromCode("input", code));
+    ImmutableList<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("input", code));
     compiler.init(externs, inputs, options);
     compiler.parseInputs();
     return compiler;
diff --git a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
index f0033f1..d6411eb 100644
--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
@@ -22,7 +22,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class RuntimeTypeCheckTest extends CompilerTestCase {
-  @Nullable private String logFunction = null;
+  private @Nullable String logFunction = null;
 
   public RuntimeTypeCheckTest() {
     super("/** @const */ var undefined;");
diff --git a/test/com/google/javascript/jscomp/ScopedAliasesTest.java b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
index 9b8b731..d027156 100644
--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java
+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
@@ -35,6 +35,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -1512,7 +1513,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   private static class TypeVerifyingPass implements CompilerPass, NodeTraversal.Callback {
     private final Compiler compiler;
-    private List<Node> actualTypes = null;
+    private @Nullable List<Node> actualTypes = null;
 
     public TypeVerifyingPass(Compiler compiler) {
       this.compiler = compiler;
diff --git a/test/com/google/javascript/jscomp/SortingErrorManagerTest.java b/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
index 991daa1..a65f44d 100644
--- a/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
+++ b/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
@@ -23,6 +23,7 @@ import com.google.javascript.jscomp.SortingErrorManager.ErrorWithLevel;
 import com.google.javascript.jscomp.SortingErrorManager.LeveledJSErrorComparator;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class SortingErrorManagerTest {
-  private static final String NULL_SOURCE = null;
+  private static final @Nullable String NULL_SOURCE = null;
 
   private final LeveledJSErrorComparator comparator = new LeveledJSErrorComparator();
 
diff --git a/test/com/google/javascript/jscomp/SourceFileTest.java b/test/com/google/javascript/jscomp/SourceFileTest.java
index 9e4ea14..5bab41b 100644
--- a/test/com/google/javascript/jscomp/SourceFileTest.java
+++ b/test/com/google/javascript/jscomp/SourceFileTest.java
@@ -91,16 +91,22 @@ public final class SourceFileTest {
     assertThat(f0.getColumnOfOffset(0)).isEqualTo(0);
     assertThat(f0.getLineOfOffset(10)).isEqualTo(1);
     assertThat(f0.getColumnOfOffset(10)).isEqualTo(10);
+    assertThat(f0.getNumBytes()).isEqualTo(0);
+    assertThat(f0.getNumLines()).isEqualTo(1);
 
     SourceFile f1 = factory.apply("'1';\n'2';\n'3'\n");
     assertThat(f1.getLineOffset(1)).isEqualTo(0);
     assertThat(f1.getLineOffset(2)).isEqualTo(5);
     assertThat(f1.getLineOffset(3)).isEqualTo(10);
+    assertThat(f1.getNumBytes()).isEqualTo(14);
+    assertThat(f1.getNumLines()).isEqualTo(4);
 
     SourceFile f2 = factory.apply("'100';\n'200;'\n'300'\n");
     assertThat(f2.getLineOffset(1)).isEqualTo(0);
     assertThat(f2.getLineOffset(2)).isEqualTo(7);
     assertThat(f2.getLineOffset(3)).isEqualTo(14);
+    assertThat(f2.getNumBytes()).isEqualTo(20);
+    assertThat(f2.getNumLines()).isEqualTo(4);
 
     String longLine = stringOfLength(300);
     SourceFile f3 = factory.apply(longLine + "\n" + longLine + "\n" + longLine + "\n");
@@ -116,6 +122,9 @@ public final class SourceFileTest {
     assertThat(f3.getLineOfOffset(902)).isEqualTo(3);
     assertThat(f3.getLineOfOffset(903)).isEqualTo(4);
 
+    assertThat(f3.getNumBytes()).isEqualTo(903);
+    assertThat(f3.getNumLines()).isEqualTo(4);
+
     // TODO(nickreid): This seems like a bug.
     assertThat(f3.getLineOfOffset(-1)).isEqualTo(0);
     assertThrows(Exception.class, () -> f3.getColumnOfOffset(-1));
@@ -124,6 +133,8 @@ public final class SourceFileTest {
     assertThat(startsWithNewline.getLineOffset(1)).isEqualTo(0);
     assertThat(startsWithNewline.getLineOffset(2)).isEqualTo(1);
     assertThat(startsWithNewline.getLineOffset(3)).isEqualTo(5);
+    assertThat(startsWithNewline.getNumBytes()).isEqualTo(8);
+    assertThat(startsWithNewline.getNumLines()).isEqualTo(3);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/SourceMapTest.java b/test/com/google/javascript/jscomp/SourceMapTest.java
index af46f49..9c4b53b 100644
--- a/test/com/google/javascript/jscomp/SourceMapTest.java
+++ b/test/com/google/javascript/jscomp/SourceMapTest.java
@@ -26,7 +26,6 @@ import com.google.debugging.sourcemap.SourceMapConsumerV3;
 import com.google.debugging.sourcemap.SourceMapTestCase;
 import com.google.javascript.jscomp.SourceMap.Format;
 import java.io.IOException;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +37,7 @@ public final class SourceMapTest extends SourceMapTestCase {
 
   public SourceMapTest() {}
 
-  private List<SourceMap.LocationMapping> mappings;
+  private ImmutableList<SourceMap.LocationMapping> mappings;
   private ImmutableMap.Builder<String, SourceMapInput> inputMaps;
 
   @Test
diff --git a/test/com/google/javascript/jscomp/StrictModeCheckTest.java b/test/com/google/javascript/jscomp/StrictModeCheckTest.java
index c9e9af2..2ad0c0f 100644
--- a/test/com/google/javascript/jscomp/StrictModeCheckTest.java
+++ b/test/com/google/javascript/jscomp/StrictModeCheckTest.java
@@ -52,23 +52,21 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testUseOfWith2() {
-    testSame("var a;\n" +
-             "/** @suppress {with} */" +
-             "with(a){}");
+    testSame("var a;\n" + "/** @suppress {with} */" + "with(a){}");
   }
 
   @Test
   public void testUseOfWith3() {
     testSame(
-        "function f(expr, context) {\n" +
-        "  try {\n" +
-        "    /** @suppress{with} */ with (context) {\n" +
-        "      return eval('[' + expr + '][0]');\n" +
-        "    }\n" +
-        "  } catch (e) {\n" +
-        "    return null;\n" +
-        "  }\n" +
-        "};\n");
+        "function f(expr, context) {\n"
+            + "  try {\n"
+            + "    /** @suppress{with} */ with (context) {\n"
+            + "      return eval('[' + expr + '][0]');\n"
+            + "    }\n"
+            + "  } catch (e) {\n"
+            + "    return null;\n"
+            + "  }\n"
+            + "};\n");
   }
 
   @Test
@@ -264,12 +262,7 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testClass() {
-    testSame(
-        lines(
-            "class A {",
-            "  method1() {}",
-            "  method2() {}",
-            "}"));
+    testSame(lines("class A {", "  method1() {}", "  method2() {}", "}"));
 
     // Duplicate class methods test
     testWarning(
@@ -280,16 +273,8 @@ public final class StrictModeCheckTest extends CompilerTestCase {
     // The two following tests should have reported FUNCTION_CALLER_FORBIDDEN and
     // FUNCTION_ARGUMENTS_PROP_FORBIDDEN. Typecheck needed for them to work.
     // TODO(user): Add tests for these after typecheck supports class.
-    testSame(
-        lines(
-            "class A {",
-            "  method() {this.method.caller}",
-            "}"));
-    testSame(
-        lines(
-            "class A {",
-            "  method() {this.method.arguments}",
-            "}"));
+    testSame(lines("class A {", "  method() {this.method.caller}", "}"));
+    testSame(lines("class A {", "  method() {this.method.arguments}", "}"));
 
     // Duplicate obj literal key in classes
     testWarning(
@@ -297,11 +282,7 @@ public final class StrictModeCheckTest extends CompilerTestCase {
         StrictModeCheck.DUPLICATE_MEMBER);
 
     // Delete test. Class methods are configurable, thus deletable.
-    testSame(lines(
-        "class A {",
-        "  methodA() {}",
-        "  methodB() {delete this.methodA}",
-        "}"));
+    testSame(lines("class A {", "  methodA() {}", "  methodB() {delete this.methodA}", "}"));
 
     // Use of with test
     testWarning(
@@ -339,42 +320,22 @@ public final class StrictModeCheckTest extends CompilerTestCase {
 
   @Test
   public void testComputedPropInClass() {
-    testSame(
-        lines(
-            "class Example {",
-            "  [computed()]() {}",
-            "  [computed()]() {}",
-            "}"));
+    testSame(lines("class Example {", "  [computed()]() {}", "  [computed()]() {}", "}"));
   }
 
   @Test
   public void testStaticAndNonstaticMethodWithSameName() {
-    testSame(
-        lines(
-            "class Example {",
-            "  foo() {}",
-            "  static foo() {}",
-            "}"));
+    testSame(lines("class Example {", "  foo() {}", "  static foo() {}", "}"));
   }
 
   @Test
   public void testStaticAndNonstaticGetterWithSameName() {
-    testSame(
-        lines(
-            "class Example {",
-            "  get foo() {}",
-            "  static get foo() {}",
-            "}"));
+    testSame(lines("class Example {", "  get foo() {}", "  static get foo() {}", "}"));
   }
 
   @Test
   public void testStaticAndNonstaticSetterWithSameName() {
-    testSame(
-        lines(
-            "class Example {",
-            "  set foo(x) {}",
-            "  static set foo(x) {}",
-            "}"));
+    testSame(lines("class Example {", "  set foo(x) {}", "  static set foo(x) {}", "}"));
   }
 
   @Test
@@ -391,6 +352,13 @@ public final class StrictModeCheckTest extends CompilerTestCase {
             "  a;",
             "}"),
         StrictModeCheck.DUPLICATE_MEMBER);
+    testWarning(
+        lines(
+            "class Example {", //
+            "  static a = 2;",
+            "  static a = 3;",
+            "}"),
+        StrictModeCheck.DUPLICATE_MEMBER);
   }
 
   @Test
@@ -398,6 +366,13 @@ public final class StrictModeCheckTest extends CompilerTestCase {
     testWarning(
         lines(
             "class Example {", //
+            "  static a = 2;",
+            "  static a = 3;",
+            "}"),
+        StrictModeCheck.DUPLICATE_MEMBER);
+    testWarning(
+        lines(
+            "class Example {", //
             "  static a;",
             "  static a;",
             "}"),
@@ -414,6 +389,66 @@ public final class StrictModeCheckTest extends CompilerTestCase {
             "}"));
   }
 
+  @Test
+  public void testClassStaticBlocksDuplicates() {
+    // testing that duplicates are ok in class static blocks
+    testSame("class Foo {static {this.a; this.a;}}");
+
+    // even if they are in 2 different static blocks
+    testSame("class Foo {static {this.a} static {this.a}}");
+
+    // testing that duplicates between class static blocks and public fields are ok
+    testSame("class Foo {static x; static {this.x}}");
+
+    // duplicate functions are also okay
+    testSame("class Foo {static f() {}; static{this.f = function g() {}}}");
+
+    // testing that duplicates in obj literals are still invalid
+    testWarning("class Foo {static {var obj = {a : 1, a : 2};}}", StrictModeCheck.DUPLICATE_MEMBER);
+  }
+
+  @Test
+  public void testClassStaticBlocksWith() {
+    testWarning(
+        lines("class A {", "  static x;", "  static {", "    with (this.x) {}", "  }", "}"),
+        StrictModeCheck.USE_OF_WITH);
+  }
+
+  @Test
+  public void testClassStaticBlocksEval() {
+    testWarning("class A { static {var eval;}}", StrictModeCheck.EVAL_DECLARATION);
+    testWarning("class A { static {function eval() {};}}", StrictModeCheck.EVAL_DECLARATION);
+    testWarning(
+        "class A { static {this.e = function eval() {};}}", StrictModeCheck.EVAL_DECLARATION);
+    testWarning("class A { static {eval = 3;}}", StrictModeCheck.EVAL_ASSIGNMENT);
+
+    // eval as a field is okay
+    testSame("class A { static {this.eval;}}");
+  }
+
+  @Test
+  public void testClassStaticBlocksArguments() {
+    testWarning(
+        lines("class A {", "  static {var arguments = 1;}", "}"),
+        StrictModeCheck.ARGUMENTS_DECLARATION);
+    testWarning(
+        lines("class A {", "  static {arguments = 1}", "}"), StrictModeCheck.ARGUMENTS_ASSIGNMENT);
+    testWarning(
+        lines("class A {", "  static {arguments.callee}", "}"),
+        StrictModeCheck.ARGUMENTS_CALLEE_FORBIDDEN);
+    testWarning(
+        lines("class A {", "  static {arguments.caller}", "}"),
+        StrictModeCheck.ARGUMENTS_CALLER_FORBIDDEN);
+  }
+
+  @Test
+  public void testClassStaticBlockDelete() {
+    testSame("class A {static{this.a; delete this.a;}}");
+    testSame("class A {static a; static{delete this.a;}}");
+    testWarning("class A {static a; static{var a; delete a;}}", StrictModeCheck.DELETE_VARIABLE);
+    testSame("class A {static f() {}; static{delete this.f;}}");
+  }
+
   private static String inFn(String body) {
     return "function func() {" + body + "}";
   }
diff --git a/test/com/google/javascript/jscomp/SymbolTableTest.java b/test/com/google/javascript/jscomp/SymbolTableTest.java
index b1c37ad..0ed541d 100644
--- a/test/com/google/javascript/jscomp/SymbolTableTest.java
+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java
@@ -105,7 +105,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).hasSize(1);
   }
 
@@ -117,7 +117,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).isEmpty();
   }
 
@@ -128,7 +128,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).hasSize(2);
   }
 
@@ -159,7 +159,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(2);
   }
 
@@ -167,7 +167,7 @@ public final class SymbolTableTest {
   public void testGlobalVarReferences() {
     SymbolTable table = createSymbolTable("/** @type {number} */ var x = 5; x = 6;");
     Symbol x = getGlobalVar(table, "x");
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
 
     assertThat(refs).hasSize(2);
     assertThat(refs.get(0)).isEqualTo(x.getDeclaration());
@@ -179,7 +179,7 @@ public final class SymbolTableTest {
   public void testLocalVarReferences() {
     SymbolTable table = createSymbolTable("function f(x) { return x; }");
     Symbol x = getLocalVar(table, "x");
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
 
     assertThat(refs).hasSize(2);
     assertThat(refs.get(0)).isEqualTo(x.getDeclaration());
@@ -198,7 +198,7 @@ public final class SymbolTableTest {
     Symbol t = table.getParameterInFunction(f, "this");
     assertThat(t).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(t);
+    ImmutableList<Reference> refs = table.getReferenceList(t);
     assertThat(refs).hasSize(2);
   }
 
@@ -239,7 +239,7 @@ public final class SymbolTableTest {
 
     Symbol objFn = getGlobalVar(table, "obj.fn");
     assertThat(objFn).isNotNull();
-    List<Reference> references = table.getReferenceList(objFn);
+    ImmutableList<Reference> references = table.getReferenceList(objFn);
     assertThat(references).hasSize(2);
 
     // The declaration node corresponds to "fn", not "fn() {}", in the source info.
@@ -419,7 +419,7 @@ public final class SymbolTableTest {
                 (s) -> s.getSourceFileName().equals("file1.js") && s.getName().equals(symbolName))
             .findFirst()
             .get();
-    for (SymbolTable.Reference ref : table.getReferences(symbol)) {
+    for (Reference ref : table.getReferences(symbol)) {
       if (ref.getNode().getSourceFileName().equals("file2.js")) {
         return;
       }
@@ -454,7 +454,7 @@ public final class SymbolTableTest {
             .filter((s) -> s.getSourceFileName().equals("file2.js") && s.getName().equals("one"))
             .findFirst()
             .get();
-    for (SymbolTable.Reference ref : table.getReferences(symbol)) {
+    for (Reference ref : table.getReferences(symbol)) {
       if (ref.getNode().getSourceFileName().equals("file1.js")) {
         return;
       }
@@ -666,7 +666,7 @@ public final class SymbolTableTest {
     SymbolTable table =
         createSymbolTable("customExternFn(1);", "function customExternFn(customExternArg) {}");
     Symbol fn = getGlobalVar(table, "customExternFn");
-    List<Reference> refs = table.getReferenceList(fn);
+    ImmutableList<Reference> refs = table.getReferenceList(fn);
     assertThat(refs).hasSize(3);
 
     SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode());
@@ -678,7 +678,7 @@ public final class SymbolTableTest {
   public void testLocalVarInExterns() {
     SymbolTable table = createSymbolTable("", "function customExternFn(customExternArg) {}");
     Symbol arg = getLocalVar(table, "customExternArg");
-    List<Reference> refs = table.getReferenceList(arg);
+    ImmutableList<Reference> refs = table.getReferenceList(arg);
     assertThat(refs).hasSize(1);
 
     Symbol fn = getGlobalVar(table, "customExternFn");
@@ -840,7 +840,7 @@ public final class SymbolTableTest {
     Symbol prototype = getGlobalVar(table, "DomHelper.prototype");
     assertThat(prototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
 
     // One of the refs is implicit in the declaration of the function.
     assertWithMessage(refs.toString()).that(refs).hasSize(2);
@@ -854,7 +854,7 @@ public final class SymbolTableTest {
     Symbol prototype = getGlobalVar(table, "Snork.prototype");
     assertThat(prototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
     assertThat(refs).hasSize(2);
   }
 
@@ -864,7 +864,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(fooPrototype);
+    ImmutableList<Reference> refs = table.getReferenceList(fooPrototype);
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.NAME);
 
@@ -882,7 +882,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = ImmutableList.copyOf(table.getReferences(fooPrototype));
+    ImmutableList<Reference> refs = ImmutableList.copyOf(table.getReferences(fooPrototype));
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.GETPROP);
     assertThat(refs.get(0).getNode().getQualifiedName()).isEqualTo("Foo.prototype");
@@ -895,7 +895,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "goog.Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(fooPrototype);
+    ImmutableList<Reference> refs = table.getReferenceList(fooPrototype);
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.GETPROP);
 
@@ -910,7 +910,7 @@ public final class SymbolTableTest {
     SymbolTable table = createSymbolTable(lines("class DomHelper { method() {} }"));
     Symbol prototype = getGlobalVar(table, "DomHelper.prototype");
     assertThat(prototype).isNotNull();
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
 
     // The class declaration creates an implicit .prototype reference.
     assertWithMessage(refs.toString()).that(refs).hasSize(1);
@@ -933,7 +933,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(5);
 
     assertThat(refs.get(0).getNode().getLineno()).isEqualTo(1);
@@ -960,7 +960,7 @@ public final class SymbolTableTest {
     Symbol str = getGlobalVar(table, "String");
     assertThat(str).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(str);
+    ImmutableList<Reference> refs = table.getReferenceList(str);
 
     // We're going to pick up a lot of references from the externs,
     // so it's not meaningful to check the number of references.
@@ -995,7 +995,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "goog.Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(5);
 
     assertThat(refs.get(0).getNode().getLineno()).isEqualTo(2);
@@ -1022,7 +1022,7 @@ public final class SymbolTableTest {
     Symbol x = getLocalVar(table, "x");
     assertThat(x).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
     assertThat(refs).hasSize(2);
 
     assertThat(refs.get(0).getNode().getCharno()).isEqualTo(code.indexOf("x) {"));
@@ -1073,7 +1073,7 @@ public final class SymbolTableTest {
                 "goog.addSingletonGetter = function(x) {};"));
 
     Symbol method = getGlobalVar(table, "goog.addSingletonGetter");
-    List<Reference> refs = table.getReferenceList(method);
+    ImmutableList<Reference> refs = table.getReferenceList(method);
     assertThat(refs).hasSize(2);
 
     // Note that the declaration should show up second.
@@ -1119,14 +1119,14 @@ public final class SymbolTableTest {
     Symbol bCtor = getGlobalVar(table, "goog.B.prototype.constructor");
     assertThat(bCtor).isNotNull();
 
-    List<Reference> bRefs = table.getReferenceList(bCtor);
+    ImmutableList<Reference> bRefs = table.getReferenceList(bCtor);
     assertThat(bRefs).hasSize(2);
     assertThat(bCtor.getDeclaration().getNode().getLineno()).isEqualTo(11);
 
     Symbol cCtor = getGlobalVar(table, "goog.C.prototype.constructor");
     assertThat(cCtor).isNotNull();
 
-    List<Reference> cRefs = table.getReferenceList(cCtor);
+    ImmutableList<Reference> cRefs = table.getReferenceList(cCtor);
     assertThat(cRefs).hasSize(2);
     assertThat(cCtor.getDeclaration().getNode().getLineno()).isEqualTo(26);
   }
@@ -1219,7 +1219,7 @@ public final class SymbolTableTest {
     Symbol good = getGlobalVar(table, "a.b.BaseClass.prototype.doSomething");
     assertThat(good).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(good);
+    ImmutableList<Reference> refs = table.getReferenceList(good);
     assertThat(refs).hasSize(2);
     assertThat(refs.get(1).getNode().getQualifiedName())
         .isEqualTo("a.b.DerivedClass.superClass_.doSomething");
@@ -1632,9 +1632,6 @@ public final class SymbolTableTest {
   @Test
   public void testSymbolSuperclassStaticInheritance() {
     // set this option so that typechecking sees untranspiled classes.
-    // TODO(b/76025401): remove this option after class transpilation is always post-typechecking
-    options.setSkipUnsupportedPasses(false);
-
     SymbolTable table =
         createSymbolTable(
             lines(
@@ -1777,8 +1774,9 @@ public final class SymbolTableTest {
   }
 
   private SymbolTable createSymbolTable(String input, String externsCode) {
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", input));
-    List<SourceFile> externs = ImmutableList.of(SourceFile.fromCode("externs1", externsCode));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", input));
+    ImmutableList<SourceFile> externs =
+        ImmutableList.of(SourceFile.fromCode("externs1", externsCode));
 
     Compiler compiler = new Compiler(new BlackHoleErrorManager());
     compiler.compile(externs, inputs, options);
@@ -1790,7 +1788,7 @@ public final class SymbolTableTest {
     for (int i = 0; i < inputs.length; i++) {
       sources.add(SourceFile.fromCode("file" + (i + 1) + ".js", inputs[i]));
     }
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler(new BlackHoleErrorManager());
     compiler.compile(externs, sources.build(), options);
@@ -1827,7 +1825,7 @@ public final class SymbolTableTest {
     assertThat(global.getDeclaration()).isNotNull();
     assertThat(global.getDeclaration().getNode().getToken()).isEqualTo(Token.SCRIPT);
 
-    List<Reference> globalRefs = table.getReferenceList(global);
+    ImmutableList<Reference> globalRefs = table.getReferenceList(global);
 
     // The main reference list should never contain the synthetic declaration
     // for the global root.
diff --git a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
index 5f21fe7..a95d773 100644
--- a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
@@ -35,10 +35,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link SyntacticScopeCreator}.
- *
- */
+/** Tests for {@link SyntacticScopeCreator}. */
 @RunWith(JUnit4.class)
 @SuppressWarnings("RhinoNodeGetFirstFirstChild")
 public final class SyntacticScopeCreatorTest {
@@ -60,9 +57,7 @@ public final class SyntacticScopeCreatorTest {
     return root;
   }
 
-  /**
-   * Helper to create a top-level scope from a JavaScript string
-   */
+  /** Helper to create a top-level scope from a JavaScript string */
   private Scope getScope(String js) {
     return scopeCreator.createScope(getRoot(js), null);
   }
@@ -75,6 +70,7 @@ public final class SyntacticScopeCreatorTest {
     redeclarations = HashMultiset.create();
     RedeclarationHandler handler = new RecordingRedeclarationHandler();
     scopeCreator = new SyntacticScopeCreator(compiler, handler);
+    options.setLanguageIn(CompilerOptions.LanguageMode.UNSUPPORTED);
   }
 
   @Test
@@ -96,10 +92,10 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // VAR
-        .getNext()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // VAR
+            .getNext() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -113,10 +109,10 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // VAR
-        .getNext()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // VAR
+            .getNext() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -130,9 +126,9 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -308,10 +304,10 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // VAR
-        .getNext()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // VAR
+            .getNext() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -353,10 +349,10 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // VAR
-        .getNext()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // VAR
+            .getNext() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -370,9 +366,9 @@ public final class SyntacticScopeCreatorTest {
 
     Scope globalScope = scopeCreator.createScope(root, null);
 
-    Node block = root
-        .getFirstChild()  // IF
-        .getLastChild();  // BLOCK
+    Node block =
+        root.getFirstChild() // IF
+            .getLastChild(); // BLOCK
     checkState(block.isBlock(), block);
     scopeCreator.createScope(block, globalScope);
 
@@ -404,13 +400,14 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testArrayDestructuringLet() {
-    String js = ""
-        + "function foo() {\n"
-        + "  var [a, b] = getVars();"
-        + "  if (true) {"
-        + "    let [x, y] = getLets();"
-        + "  }"
-        + "}";
+    String js =
+        ""
+            + "function foo() {\n"
+            + "  var [a, b] = getVars();"
+            + "  if (true) {"
+            + "    let [x, y] = getLets();"
+            + "  }"
+            + "}";
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -442,13 +439,14 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testArrayDestructuringVarInBlock() {
-    String js = ""
-        + "function foo() {\n"
-        + "  var [a, b] = getVars();"
-        + "  if (true) {"
-        + "    var [x, y] = getMoreVars();"
-        + "  }"
-        + "}";
+    String js =
+        ""
+            + "function foo() {\n"
+            + "  var [a, b] = getVars();"
+            + "  if (true) {"
+            + "    var [x, y] = getMoreVars();"
+            + "  }"
+            + "}";
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -467,10 +465,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testObjectDestructuring() {
-    String js = lines(
-        "function foo() {",
-        "  var {a, b} = bar();",
-        "}");
+    String js = lines("function foo() {", "  var {a, b} = bar();", "}");
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -487,10 +482,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testObjectDestructuring2() {
-    String js = lines(
-        "function foo() {",
-        "  var {a: b = 1} = bar();",
-        "}");
+    String js = lines("function foo() {", "  var {a: b = 1} = bar();", "}");
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -507,10 +499,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testObjectDestructuringComputedProp() {
-    String js = lines(
-        "function foo() {",
-        "  var {['s']: a} = bar();",
-        "}");
+    String js = lines("function foo() {", "  var {['s']: a} = bar();", "}");
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -538,10 +527,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testObjectDestructuringNested() {
-    String js = lines(
-        "function foo() {",
-        "  var {a:{b}} = bar();",
-        "}");
+    String js = lines("function foo() {", "  var {a:{b}} = bar();", "}");
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -558,10 +544,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testObjectDestructuringWithInitializer() {
-    String js = lines(
-        "function foo() {",
-        "  var {a=1} = bar();",
-        "}");
+    String js = lines("function foo() {", "  var {a=1} = bar();", "}");
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -591,11 +574,12 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testFunctionScope() {
-    Scope scope = getScope("function foo() {}\n"
-                         + "var x = function bar(a1) {};"
-                         + "[function bar2() { var y; }];"
-                         + "if (true) { function z() {} }"
-                          );
+    Scope scope =
+        getScope(
+            "function foo() {}\n"
+                + "var x = function bar(a1) {};"
+                + "[function bar2() { var y; }];"
+                + "if (true) { function z() {} }");
     assertScope(scope).declares("foo").directly();
     assertScope(scope).declares("x").directly();
     assertScope(scope).doesNotDeclare("z");
@@ -610,11 +594,12 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testClassScope() {
-    Scope scope = getScope("class Foo {}\n"
-                         + "var x = class Bar {};"
-                         + "[class Bar2 { constructor(a1) {} static y() {} }];"
-                         + "if (true) { class Z {} }"
-                          );
+    Scope scope =
+        getScope(
+            "class Foo {}\n"
+                + "var x = class Bar {};"
+                + "[class Bar2 { constructor(a1) {} static y() {} }];"
+                + "if (true) { class Z {} }");
     assertScope(scope).declares("Foo").directly();
     assertScope(scope).declares("x").directly();
     assertScope(scope).doesNotDeclare("Z");
@@ -629,9 +614,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testScopeRootNode() {
-    String js = "function foo() {\n"
-        + " var x = 10;"
-        + "}";
+    String js = "function foo() {\n" + " var x = 10;" + "}";
     Node root = getRoot(js);
 
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -702,6 +685,355 @@ public final class SyntacticScopeCreatorTest {
   }
 
   @Test
+  public void testClassFieldsThisAndSuper() {
+    String js =
+        lines(
+            "class Foo {", //
+            "  a = this.a;",
+            "  [this.a] = this.a;",
+            "}",
+            "class Bar extends Foo {",
+            "  b = super.a;",
+            "}");
+
+    Node root = getRoot(js);
+    Node classFoo = root.getFirstChild();
+    Node classBar = root.getLastChild();
+    Node memberFieldDefA = classFoo.getLastChild().getFirstChild();
+    Node memberFieldDefB = classBar.getLastChild().getFirstChild();
+    Node computedFieldDef = classFoo.getLastChild().getLastChild();
+
+    Scope globalScope = scopeCreator.createScope(root, null);
+    Scope fooScope = scopeCreator.createScope(classFoo, globalScope);
+    Scope barScope = scopeCreator.createScope(classBar, globalScope);
+    Scope memberFieldDefAScope = scopeCreator.createScope(memberFieldDefA, fooScope);
+    Scope memberFieldDefBScope = scopeCreator.createScope(memberFieldDefB, barScope);
+    Scope computedFieldDefRhsScope = scopeCreator.createScope(computedFieldDef, fooScope);
+
+    assertScope(globalScope).declares("Foo").directly();
+    assertScope(globalScope).declares("Bar").directly();
+    assertScope(globalScope).doesNotDeclare("this");
+    assertScope(fooScope).doesNotDeclare("this");
+    assertScope(barScope).doesNotDeclare("this");
+    assertScope(memberFieldDefAScope).declares("this").directly();
+    assertScope(computedFieldDefRhsScope).declares("this").directly();
+    assertScope(globalScope).doesNotDeclare("super");
+    assertScope(fooScope).doesNotDeclare("super");
+    assertScope(barScope).doesNotDeclare("super");
+    assertScope(memberFieldDefBScope).declares("super").directly();
+  }
+
+  @Test
+  public void testClassStaticFieldsThisAndSuper() {
+    String js =
+        lines(
+            "class Foo {", //
+            "  static a = 2;",
+            "  static b = this.b;",
+            "  static [this.a] = this.a;",
+            "}",
+            "class Bar extends Foo {",
+            "  static c = super.a + 1;",
+            "}");
+
+    Node root = getRoot(js);
+    Node classFoo = root.getFirstChild();
+    Node classBar = root.getLastChild();
+    Node memberFieldDefA = classFoo.getLastChild().getFirstChild();
+    Node memberFieldDefB = classBar.getLastChild().getFirstChild();
+    Node computedFieldDef = classFoo.getLastChild().getLastChild();
+
+    Scope globalScope = scopeCreator.createScope(root, null);
+    Scope fooScope = scopeCreator.createScope(classFoo, globalScope);
+    Scope barScope = scopeCreator.createScope(classBar, globalScope);
+    Scope memberFieldDefAScope = scopeCreator.createScope(memberFieldDefA, fooScope);
+    Scope memberFieldDefBScope = scopeCreator.createScope(memberFieldDefB, barScope);
+    Scope computedFieldDefRhsScope = scopeCreator.createScope(computedFieldDef, fooScope);
+
+    assertScope(globalScope).declares("Foo").directly();
+    assertScope(globalScope).declares("Bar").directly();
+    assertScope(globalScope).doesNotDeclare("this");
+    assertScope(fooScope).doesNotDeclare("this");
+    assertScope(barScope).doesNotDeclare("this");
+    assertScope(memberFieldDefAScope).declares("this").directly();
+    assertScope(computedFieldDefRhsScope).declares("this").directly();
+    assertScope(globalScope).doesNotDeclare("super");
+    assertScope(fooScope).doesNotDeclare("super");
+    assertScope(barScope).doesNotDeclare("super");
+    assertScope(memberFieldDefBScope).declares("super").directly();
+  }
+
+  @Test
+  public void testStaticBlockScope() {
+    String js = "class C {static {}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).declares("C").directly();
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("C").onSomeParent();
+    assertThat(staticBlockScope.isBlockScope()).isTrue();
+    assertThat(staticBlockScope.getClosestHoistScope()).isEqualTo(staticBlockScope);
+    assertThat(staticBlockScope.isHoistScope()).isTrue();
+  }
+
+  @Test
+  public void testStaticBlockScopeClassExpr() {
+    String js = "let c = class C {static {}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).declares("c").directly();
+    assertScope(globalScope).doesNotDeclare("C");
+    assertScope(classScope).declares("c").onSomeParent();
+    assertScope(classScope).declares("C").directly();
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("C").onSomeParent();
+    assertScope(staticBlockScope).declares("c").onSomeParent();
+    assertThat(staticBlockScope.isBlockScope()).isTrue();
+    assertThat(staticBlockScope.getClosestHoistScope()).isEqualTo(staticBlockScope);
+    assertThat(staticBlockScope.isHoistScope()).isTrue();
+  }
+
+  @Test
+  public void testStaticBlockScopeWithLet() {
+    String js = "class C {static {let x;}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeClassExprWithLet() {
+    String js = "let c = class C {static {let x;}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeWithVar() {
+    String js = "class C {static {var x;}} var y; ";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeClassExprWithVar() {
+    String js = "let c = class C {static {var x;}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeWithLetInnerBlock() {
+    String js = "class C {static {if (true) {let x;}}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).doesNotDeclare("x");
+
+    Node ifBodyNode = classStaticBlockNode.getFirstChild().getLastChild();
+    Scope ifBodyScope = scopeCreator.createScope(ifBodyNode, staticBlockScope);
+    assertScope(ifBodyScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeClassExprWithLetInnerBlock() {
+    String js = "let c = class C {static {if (true) {let x;}}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).doesNotDeclare("x");
+
+    Node ifBodyNode = classStaticBlockNode.getFirstChild().getLastChild();
+    Scope ifBodyScope = scopeCreator.createScope(ifBodyNode, staticBlockScope);
+    assertScope(ifBodyScope).declares("x").directly();
+  }
+
+  @Test
+  public void testStaticBlockScopeWithVarInnerBlock() {
+    String js = "class C {static {if (true) {var x;}}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+
+    Node ifBodyNode = classStaticBlockNode.getFirstChild().getLastChild();
+    Scope ifBodyScope = scopeCreator.createScope(ifBodyNode, staticBlockScope);
+    assertScope(ifBodyScope).declares("x").onClosestContainerScope();
+  }
+
+  @Test
+  public void testStaticBlockScopeClassExprWithVarInnerBlock() {
+    String js = "let c = class C {static {if (true) {var x;}}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+    assertScope(staticBlockScope).declares("x").directly();
+
+    Node ifBodyNode = classStaticBlockNode.getFirstChild().getLastChild();
+    Scope ifBodyScope = scopeCreator.createScope(ifBodyNode, staticBlockScope);
+    assertScope(ifBodyScope).declares("x").onClosestContainerScope();
+  }
+
+  @Test
+  public void testClassStaticBlockWithLoop() {
+    String js = "let f = class Foo { static { for (;;) { var x; }}}";
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+
+    Node classDecl = root.getFirstChild().getFirstFirstChild();
+    Scope classScope = scopeCreator.createScope(classDecl, globalScope);
+
+    Node classStaticBlockNode = classDecl.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+
+    Node forBodyNode = classStaticBlockNode.getFirstChild().getLastChild();
+    Scope forBodyScope = scopeCreator.createScope(forBodyNode, staticBlockScope);
+
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+    assertScope(forBodyScope).declares("x").onClosestContainerScope();
+  }
+
+  @Test
+  public void testStaticBlockThis() {
+    String js =
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    this.x;",
+            "  }",
+            "}");
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+    Node classFoo = root.getFirstChild();
+    Scope classScope = scopeCreator.createScope(classFoo, globalScope);
+    Node classStaticBlockNode = classFoo.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classScope);
+
+    assertThat(staticBlockScope.isBlockScope()).isTrue();
+    assertThat(staticBlockScope.getClosestHoistScope()).isEqualTo(staticBlockScope);
+    assertThat(staticBlockScope.isHoistScope()).isTrue();
+
+    assertScope(globalScope).declares("Foo").directly();
+    assertScope(staticBlockScope).declares("Foo").onSomeParent();
+    assertScope(globalScope).doesNotDeclare("this");
+    assertScope(classScope).doesNotDeclare("this");
+    assertScope(staticBlockScope).declares("this").directly();
+  }
+
+  @Test
+  public void testClassStaticBlockSuper() {
+    String js =
+        lines(
+            "class Foo {", //
+            "  static x;",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    super.x = 'str';",
+            "  }",
+            "}");
+    Node root = getRoot(js);
+    Scope globalScope = scopeCreator.createScope(root, null);
+    Node classFoo = root.getFirstChild();
+    Scope classFooScope = scopeCreator.createScope(classFoo, globalScope);
+    Node classBar = root.getLastChild();
+    Scope classBarScope = scopeCreator.createScope(classBar, globalScope);
+    Node classStaticBlockNode = classBar.getLastChild().getFirstChild();
+    Scope staticBlockScope = scopeCreator.createScope(classStaticBlockNode, classBarScope);
+
+    assertThat(staticBlockScope.isBlockScope()).isTrue();
+    assertThat(staticBlockScope.getClosestHoistScope()).isEqualTo(staticBlockScope);
+    assertThat(staticBlockScope.isHoistScope()).isTrue();
+
+    assertScope(globalScope).declares("Foo").directly();
+    assertScope(staticBlockScope).declares("Foo").onSomeParent();
+    assertScope(globalScope).declares("Bar").directly();
+    assertScope(staticBlockScope).declares("Bar").onSomeParent();
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(globalScope).doesNotDeclare("super");
+    assertScope(classFooScope).doesNotDeclare("x");
+    assertScope(classFooScope).doesNotDeclare("super");
+    assertScope(classBarScope).doesNotDeclare("x");
+    assertScope(classBarScope).doesNotDeclare("super");
+    assertScope(staticBlockScope).doesNotDeclare("x");
+    assertScope(staticBlockScope).declares("super").directly();
+  }
+
+  @Test
   public void testSwitchScope() {
     String js =
         "switch (b) { "
@@ -822,9 +1154,11 @@ public final class SyntacticScopeCreatorTest {
     Node outerBody = NodeUtil.getFunctionBody(outer);
     Scope outerBodyScope = scopeCreator.createScope(outerBody, outerFunctionScope);
 
-    Node inner = outerBody.getFirstChild()   // VAR
-                          .getFirstChild()   // NAME
-                          .getFirstChild();  // FUNCTION
+    Node inner =
+        outerBody
+            .getFirstChild() // VAR
+            .getFirstChild() // NAME
+            .getFirstChild(); // FUNCTION
     checkState(inner.isFunction(), inner);
     checkState(inner.isArrowFunction(), inner);
     Scope innerFunctionScope = scopeCreator.createScope(inner, outerBodyScope);
@@ -910,9 +1244,11 @@ public final class SyntacticScopeCreatorTest {
     Node outerBody = NodeUtil.getFunctionBody(outer);
     Scope outerBodyScope = scopeCreator.createScope(outerBody, outerFunctionScope);
 
-    Node inner = outerBody.getFirstChild()   // VAR
-                          .getFirstChild()   // NAME
-                          .getFirstChild();  // FUNCTION
+    Node inner =
+        outerBody
+            .getFirstChild() // VAR
+            .getFirstChild() // NAME
+            .getFirstChild(); // FUNCTION
     checkState(inner.isFunction(), inner);
     checkState(inner.isArrowFunction(), inner);
     Scope innerFunctionScope = scopeCreator.createScope(inner, outerBodyScope);
@@ -970,11 +1306,12 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testImport() {
-    String js = lines(
-        "import * as ns from 'm1';",
-        "import d from 'm2';",
-        "import {foo} from 'm3';",
-        "import {x as y} from 'm4';");
+    String js =
+        lines(
+            "import * as ns from 'm1';",
+            "import d from 'm2';",
+            "import {foo} from 'm3';",
+            "import {x as y} from 'm4';");
 
     Node root = getRoot(js);
     Scope globalScope = scopeCreator.createScope(root, null);
@@ -1062,13 +1399,7 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testVarAfterLet() {
-    String js = lines(
-        "function f() {",
-        "  if (a) {",
-        "    let x;",
-        "  }",
-        "  var y;",
-        "}");
+    String js = lines("function f() {", "  if (a) {", "    let x;", "  }", "  var y;", "}");
 
     Node root = getRoot(js);
     Scope global = scopeCreator.createScope(root, null);
diff --git a/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java b/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java
new file mode 100644
index 0000000..898e52a
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2014 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import org.jspecify.nullness.Nullable;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Test cases for transpile-only mode.
+ *
+ * <p>This class actually tests several transpilation passes together.
+ */
+@RunWith(JUnit4.class)
+public final class TranspileOnlyIntegrationTest {
+
+  private @Nullable Compiler compiler = null;
+  private @Nullable CompilerOptions options = null;
+
+  @Before
+  public void init() {
+    compiler = new Compiler();
+    options = new CompilerOptions();
+    options.setLanguage(LanguageMode.ECMASCRIPT_NEXT);
+    options.setSkipNonTranspilationPasses(true);
+    options.setEmitUseStrict(false);
+  }
+
+  @Test
+  public void esModuleNoTranspilationForSameLanguageLevel() {
+    String js = "export default function fn(){};";
+    test(js, js);
+  }
+
+  @Test
+  public void esModuleTranspilationForDifferentLanguageLevel() {
+    String js = "export default function fn() {}";
+    String transpiled =
+        "function fn$$module$in(){}var module$in={};module$in.default=fn$$module$in;";
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2020);
+    test(js, transpiled);
+  }
+
+  private void test(String js, String transpiled) {
+    compiler.compile(SourceFile.fromCode("ext.js", ""), SourceFile.fromCode("in.js", js), options);
+    assertThat(compiler.getErrors()).isEmpty();
+    assertThat(compiler.toSource()).isEqualTo(transpiled);
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckAbstractClassesAndMethodsTest.java b/test/com/google/javascript/jscomp/TypeCheckAbstractClassesAndMethodsTest.java
new file mode 100644
index 0000000..05a0b14
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckAbstractClassesAndMethodsTest.java
@@ -0,0 +1,1009 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckAbstractClassesAndMethodsTest extends TypeCheckTestCase {
+
+  @Test
+  public void testAbstractMethodInAbstractClass() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var C = function() {};",
+            "/** @abstract */ C.prototype.foo = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInAbstractEs6Class() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class C {", //
+            "  /** @abstract */ foo() {}",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInConcreteClass() {
+    newTest()
+        .addSource(
+            "/** @constructor */ var C = function() {};",
+            "/** @abstract */ C.prototype.foo = function() {};")
+        .addDiagnostic(
+            "Abstract methods can only appear in abstract classes. Please declare the class as "
+                + "@abstract")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInConcreteEs6Class() {
+    newTest()
+        .addSource(
+            "class C {", //
+            "  /** @abstract */ foo() {}",
+            "}")
+        .addDiagnostic(
+            "Abstract methods can only appear in abstract classes. Please declare the class as "
+                + "@abstract")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInConcreteClassExtendingAbstractClass() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @abstract */ B.prototype.foo = function() {};")
+        .addDiagnostic(
+            "Abstract methods can only appear in abstract classes. Please declare the class as "
+                + "@abstract")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInConcreteEs6ClassExtendingAbstractEs6Class() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {}",
+            "/** @extends {A} */ class B {",
+            "  /** @abstract */ foo() {}",
+            "}")
+        .addDiagnostic(
+            "Abstract methods can only appear in abstract classes. Please declare the class as "
+                + "@abstract")
+        .run();
+  }
+
+  @Test
+  public void testConcreteMethodOverridingAbstractMethod() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testConcreteMethodOverridingAbstractMethodInEs6() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract*/ foo() {}",
+            "}",
+            "/** @extends {A} */ class B {",
+            "  /** @override */ foo() {}",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testConcreteMethodInAbstractClass1() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testConcreteMethodInAbstractEs6Class1() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {", //
+            "  foo() {}",
+            "}",
+            "class B extends A {}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testConcreteMethodInAbstractClass2() {
+    // Currently goog.abstractMethod are not considered abstract, so no warning is given when a
+    // concrete subclass fails to implement it.
+    newTest()
+        .addSource(
+            CLOSURE_DEFS,
+            "/** @abstract @constructor */ var A = function() {};",
+            "A.prototype.foo = goog.abstractMethod;",
+            "/** @constructor @extends {A} */ var B = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInInterface() {
+    // TODO(moz): There's no need to tag methods with @abstract in interfaces, maybe give a warning
+    // on this.
+    newTest()
+        .addSource(
+            "/** @interface */ var I = function() {};",
+            "/** @abstract */ I.prototype.foo = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6Interface() {
+    // TODO(moz): There's no need to tag methods with @abstract in interfaces, maybe give a warning
+    // on this.
+    newTest()
+        .addSource(
+            "/** @interface */ class I {", //
+            "  /** @abstract */ foo() {}",
+            "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented1() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};")
+        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6NotImplemented1() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "}",
+            "class B extends A {}")
+        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented2() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @abstract */ A.prototype.bar = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() {};")
+        .addDiagnostic("property bar on abstract class A is not implemented by type B")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6NotImplemented2() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "  /** @abstract */ bar() {}",
+            "}",
+            "class B extends A {",
+            "  /** @override */ foo() {}",
+            "}")
+        .addDiagnostic("property bar on abstract class A is not implemented by type B")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented3() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @abstract @constructor @extends {A} */ var B = function() {};",
+            "/** @abstract @override */ B.prototype.foo = function() {};",
+            "/** @constructor @extends {B} */ var C = function() {};")
+        .addDiagnostic("property foo on abstract class B is not implemented by type C")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6NotImplemented3() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "}",
+            "/** @abstract */ class B extends A {",
+            "  /** @abstract @override */ foo() {}",
+            "}",
+            "class C extends B {}")
+        .addDiagnostic("property foo on abstract class B is not implemented by type C")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented4() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @abstract @constructor @extends {A} */ var B = function() {};",
+            "/** @constructor @extends {B} */ var C = function() {};")
+        .addDiagnostic("property foo on abstract class A is not implemented by type C")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6NotImplemented4() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "}",
+            "/** @abstract */ class B extends A {}",
+            "class C extends B {}")
+        .addDiagnostic("property foo on abstract class A is not implemented by type C")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented5() {
+    newTest()
+        .addSource(
+            "/** @interface */ var I = function() {};",
+            "I.prototype.foo = function() {};",
+            "/** @abstract @constructor @implements {I} */ var A = function() {};",
+            "/** @abstract @override */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};")
+        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6NotImplemented5() {
+    newTest()
+        .addSource(
+            "/** @interface */ class I {",
+            "  foo() {}",
+            "  bar() {}", // Not overridden by abstract class
+            "}",
+            "/** @abstract @implements {I} */ class A {",
+            "  /** @abstract @override */ foo() {}",
+            "}",
+            "class B extends A {}")
+        .addDiagnostic("property bar on interface I is not implemented by type B")
+        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodNotImplemented6() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override @type {number} */ B.prototype.foo;")
+        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodImplemented1() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @abstract */ A.prototype.bar = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() {};",
+            "/** @override */ B.prototype.bar = function() {};",
+            "/** @constructor @extends {B} */ var C = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6Implemented1() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "  /** @abstract */ bar() {}",
+            "}",
+            "class B extends A {",
+            "  /** @override */ foo() {}",
+            "  /** @override */ bar() {}",
+            "}",
+            "class C extends B {}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodImplemented2() {
+    newTest()
+        .addSource(
+            "/** @abstract @constructor */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @abstract */ A.prototype.bar = function() {};",
+            "/** @abstract @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() {};",
+            "/** @constructor @extends {B} */ var C = function() {};",
+            "/** @override */ C.prototype.bar = function() {};")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodInEs6Implemented2() {
+    newTest()
+        .addSource(
+            "/** @abstract */ class A {",
+            "  /** @abstract */ foo() {}",
+            "  /** @abstract */ bar() {}",
+            "}",
+            "/** @abstract */ class B extends A {",
+            "  /** @override */ foo() {}",
+            "}",
+            "class C extends B {",
+            "  /** @override */ bar() {}",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodHandling1() {
+    newTest()
+        .addSource("/** @type {Function} */ var abstractFn = function() {};" + "abstractFn(1);")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodHandling2() {
+    newTest()
+        .addSource("var abstractFn = function() {};" + "abstractFn(1);")
+        .addDiagnostic(
+            "Function abstractFn: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodHandling3() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @type {Function} */ goog.abstractFn = function() {};"
+                + "goog.abstractFn(1);")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodHandling4() {
+    newTest()
+        .addSource("var goog = {};" + "goog.abstractFn = function() {};" + "goog.abstractFn(1);")
+        .addDiagnostic(
+            "Function goog.abstractFn: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .run();
+  }
+
+  @Test
+  public void testAbstractFunctionHandling() {
+    newTest()
+        .addSource(
+            "/** @type {!Function} */ var abstractFn = function() {};"
+                // the type of 'f' will become 'Function'
+                + "/** @param {number} x */ var f = abstractFn;"
+                + "f('x');")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodHandling6() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @type {Function} */ goog.abstractFn = function() {};"
+                + "/** @param {number} x */ goog.f = abstractFn;"
+                + "goog.f('x');")
+        .addDiagnostic(
+            "actual parameter 1 of goog.f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
+        .run();
+  }
+
+  // https://github.com/google/closure-compiler/issues/2458
+  @Test
+  public void testAbstractSpread() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class X {",
+            "  /** @abstract */",
+            "  m1() {}",
+            "",
+            "  m2() {",
+            "    return () => this.m1(...[]);",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testOverriddenReturnOnAbstractClass() {
+    newTest()
+        .addSource(
+            "/** @interface */ function IFoo() {}",
+            "/** @return {*} */ IFoo.prototype.foo = function() {}",
+            "/** @constructor */ function Foo() {}",
+            "/** @return {string} */ Foo.prototype.foo = function() {}",
+            "/** @constructor @extends {Foo} */ function Bar() {}",
+            "/**",
+            " * @constructor @abstract",
+            " * @extends {Bar} @implements {IFoo}",
+            " */",
+            "function Baz() {}",
+            // Even there is a closer definition in IFoo, Foo should be still the source of truth.
+            "/** @return {string} */",
+            "function test() { return (/** @type {Baz} */ (null)).foo(); }")
+        .run();
+  }
+
+  @Test
+  public void testOverriddenReturnDoesntMatchOnAbstractClass() {
+    newTest()
+        .addSource(
+            "/** @interface */ function IFoo() {}",
+            "/** @return {number} */ IFoo.prototype.foo = function() {}",
+            "/** @constructor */ function Foo() {}",
+            "/** @return {string} */ Foo.prototype.foo = function() {}",
+            "/** @constructor @extends {Foo} */ function Bar() {}",
+            "/**",
+            " * @constructor @abstract",
+            " * @extends {Bar} @implements {IFoo}",
+            " */",
+            "function Baz() {}",
+            "/** @return {string} */",
+            "function test() { return (/** @type {Baz} */ (null)).foo(); }")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Baz and the type of the property it overrides"
+                    + " from interface IFoo",
+                "original: function(this:IFoo): number",
+                "override: function(this:Foo): string"))
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall1() {
+    // Converted from Closure style "goog.base" super call
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "B.superClass_ = A.prototype",
+            "/** @override */ B.prototype.foo = function() { B.superClass_.foo.call(this); };")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall2() {
+    // Converted from Closure style "goog.base" super call, with namespace
+    newTest()
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @constructor @abstract */ ns.A = function() {};",
+            "/** @abstract */ ns.A.prototype.foo = function() {};",
+            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
+            "ns.B.superClass_ = ns.A.prototype",
+            "/** @override */ ns.B.prototype.foo = function() {",
+            "  ns.B.superClass_.foo.call(this);",
+            "};")
+        .addDiagnostic("Abstract super method ns.A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall3() {
+    // Converted from ES6 super call
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() { A.prototype.foo.call(this); };")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall4() {
+    newTest()
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @constructor @abstract */ ns.A = function() {};",
+            "ns.A.prototype.foo = function() {};",
+            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
+            "ns.B.superClass_ = ns.A.prototype",
+            "/** @override */ ns.B.prototype.foo = function() {",
+            "  ns.B.superClass_.foo.call(this);",
+            "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall5() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() { A.prototype.foo.call(this); };")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall6() {
+    newTest()
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @constructor @abstract */ ns.A = function() {};",
+            "ns.A.prototype.foo = function() {};",
+            "ns.A.prototype.foo.bar = function() {};",
+            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
+            "ns.B.superClass_ = ns.A.prototype",
+            "/** @override */ ns.B.prototype.foo = function() {",
+            "  ns.B.superClass_.foo.bar.call(this);",
+            "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall7() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "A.prototype.foo = function() {};",
+            "A.prototype.foo.bar = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() { A.prototype.foo.bar.call(this);"
+                + " };")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall8() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() { A.prototype.foo['call'](this);"
+                + " };")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall9() {
+    newTest()
+        .addSource(
+            "/** @struct @constructor */ var A = function() {};",
+            "A.prototype.foo = function() {};",
+            "/** @struct @constructor @extends {A} */ var B = function() {};",
+            "/** @override */ B.prototype.foo = function() {",
+            "  (function() {",
+            "    return A.prototype.foo.call($jscomp$this);",
+            "  })();",
+            "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall10() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "A.prototype.foo.call(new Subtype);")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall11() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ function A() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ function B() {};",
+            "/** @override */ B.prototype.foo = function() {};",
+            "var abstractMethod = A.prototype.foo;",
+            "abstractMethod.call(new B);")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall12() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ var B = function() {};",
+            "B.superClass_ = A.prototype",
+            "/** @override */ B.prototype.foo = function() { B.superClass_.foo.apply(this);"
+                + " };")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall13() {
+    // Calling abstract @constructor is allowed
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ var A = function() {};",
+            "/** @constructor @extends {A} */ var B = function() { A.call(this); };")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Indirect1() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ function A() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ function B() {};",
+            "/** @override */ B.prototype.foo = function() {};",
+            "var abstractMethod = A.prototype.foo;",
+            "(0, abstractMethod).call(new B);")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Indirect2() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ function A() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "/** @constructor @extends {A} */ function B() {};",
+            "/** @override */ B.prototype.foo = function() {};",
+            "var abstractMethod = A.prototype.foo;",
+            "(abstractMethod = abstractMethod).call(new B);")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testDefiningPropOnAbstractMethodForbidden() {
+    newTest()
+        .addSource(
+            "/** @constructor @abstract */ function A() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "A.prototype.foo.callFirst = true;")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testPassingAbstractMethodAsArgForbidden() {
+    newTest()
+        .addExterns("function externsFn(callback) {}")
+        .addSource(
+            "/** @constructor @abstract */ function A() {};",
+            "/** @abstract */ A.prototype.foo = function() {};",
+            "externsFn(A.prototype.foo);")
+        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "  bar() {",
+            "    this.foo();",
+            "  }",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  /** @override */",
+            "  bar() {",
+            "    this.foo();",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_prototype() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  bar() {",
+            "    Sub.prototype.foo();",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_prototype_warning() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  bar() {",
+            "    Base.prototype.foo();",
+            "  }",
+            "}")
+        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_abstractSubclass_warns() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "/** @abstract */",
+            "class Sub extends Base {",
+            "  bar() {",
+            "    Sub.prototype.foo();",
+            "  }",
+            "}")
+        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_onAbstractSubclassPrototype_warns() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "/** @abstract */",
+            "class Sub extends Base {",
+            "  bar() {",
+            "    Base.prototype.foo();",
+            "  }",
+            "}")
+        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_concreteSubclassMissingImplementation_warns() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends Base {",
+            "  bar() {",
+            "    Sub.prototype.foo();",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .addDiagnostic("property foo on abstract class Base is not implemented by type Sub")
+        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_Es6Class_concreteSubclassWithImplementation_noWarning() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  bar() {",
+            "    Sub.prototype.foo();",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testAbstractMethodCall_NamespacedEs6Class_prototype_warns() {
+    newTest()
+        .addSource(
+            "const ns = {};",
+            "/** @abstract */",
+            "ns.Base = class {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends ns.Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  bar() {",
+            "    ns.Base.prototype.foo();",
+            "  }",
+            "}")
+        .addDiagnostic("Abstract super method ns.Base.prototype.foo cannot be dereferenced")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testNonAbstractMethodCall_Es6Class_prototype() {
+    newTest()
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "  bar() {}",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  /** @override */",
+            "  bar() {",
+            "    Base.prototype.bar();",
+            "  }",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  // GitHub issue #2262: https://github.com/google/closure-compiler/issues/2262
+  @Test
+  public void testAbstractMethodCall_Es6ClassWithSpread() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addObject().addArray().addArguments().build())
+        .addSource(
+            "/** @abstract */",
+            "class Base {",
+            "  /** @abstract */",
+            "  foo() {}",
+            "}",
+            "class Sub extends Base {",
+            "  /** @override */",
+            "  foo() {}",
+            "  /** @param {!Array} arr */",
+            "  bar(arr) {",
+            "    this.foo.apply(this, [].concat(arr));",
+            "  }",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testImplementedInterfacePropertiesShouldFailOnConflictForAbstractClasses() {
+    // TODO(b/132718172): Provide an error message.
+    newTest()
+        .addSource(
+            "/** @interface */function Int0() {};",
+            "/** @interface */function Int1() {};",
+            "/** @type {number} */",
+            "Int0.prototype.foo;",
+            "/** @type {string} */",
+            "Int1.prototype.foo;",
+            "/** @constructor @abstract @implements {Int0} @implements {Int1} */",
+            "function Foo() {};")
+        .run();
+  }
+
+  @Test
+  public void testImplementedInterfacePropertiesShouldFailOnConflictForAbstractClasses2() {
+    // TODO(b/132718172): Provide an error message.
+    newTest()
+        .addSource(
+            "/** @interface */function Int0() {};",
+            "/** @interface */function Int1() {};",
+            "/** @type {number} */",
+            "Int0.prototype.foo;",
+            "/** @type {string} */",
+            "Int1.prototype.foo;",
+            "/** @constructor @abstract @implements {Int0} */",
+            "function Foo() {};",
+            "/** @constructor @abstract @extends {Foo} @implements {Int1} */",
+            "function Zoo() {};")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java b/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java
new file mode 100644
index 0000000..ccfa159
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java
@@ -0,0 +1,528 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckBigIntTest extends TypeCheckTestCase {
+
+  @Test
+  public void testTypeofBigInt() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @param {bigint|number} i",
+            " * @return {boolean}",
+            " */",
+            "function foo(i) {",
+            "  return typeof i === 'bigint';",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testBigIntArgument() {
+    newTest().addSource("BigInt(1)").run();
+    newTest()
+        .addSource("BigInt({})")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of BigInt does not match formal parameter",
+                "found   : {}",
+                "required: (bigint|number|string)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_increment() {
+    newTest().addSource("const x = 1n; x++;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; x++;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; x++;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; x++;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_decrement() {
+    newTest().addSource("const x = 1n; x--;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; x--;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; x--;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; x--;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_logicalNot() {
+    newTest().addSource("const x = 1n; !x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; !x;").run();
+    newTest().addSource("/** @type {bigint|string} */var x; !x;").run();
+  }
+
+  @Test
+  public void testBigIntOperators_bitwiseNot() {
+    newTest().addSource("const x = 1n; ~x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; ~x;").run();
+    newTest().addSource("/** @type {?} */var x; ~x;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; ~x;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; ~x;")
+        .addDiagnostic(
+            lines(
+                "bitwise NOT", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntValueOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("var x = 1n; +x;")
+        .addDiagnostic("unary operator + cannot be applied to bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntObjectOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @type {!BigInt} */ var x; +x;")
+        .addDiagnostic("unary operator + cannot be applied to BigInt")
+        .run();
+  }
+
+  @Test
+  public void testBigIntUnionOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; +x;")
+        .addDiagnostic("unary operator + cannot be applied to (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; +BIGINTS.ONE;")
+        .addDiagnostic("unary operator + cannot be applied to BIGINTS<bigint>")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_unaryMinus() {
+    newTest().addSource("const x = 1n; -x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; -x;").run();
+    newTest().addSource("/** @type {?} */var x; -x;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; -x;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; -x;")
+        .addDiagnostic(
+            lines(
+                "unary minus operator", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x * y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x *= y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryBitwiseOperationWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x | y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_additionWithString() {
+    newTest().addSource("const x = 1n; const y = 'str'; x + y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignAddWithString() {
+    newTest().addSource("const x = 1n; const y = 'str'; x += y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'str'; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and string")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'str'; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and string")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithUnknown() {
+    newTest()
+        .addSource("var x = 1n; /** @type {?} */var y; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and ?")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithUnknown() {
+    newTest()
+        .addSource("var x = 1n; /** @type {?} */var y; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and ?")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryBitwiseOperationWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x | y")
+        .addDiagnostic("operator | cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntLeftShift() {
+    newTest().addSource("1n << 2n").run();
+    newTest().addSource("let x = 1n; x <<= 2n").run();
+  }
+
+  @Test
+  public void testBigIntRightShift() {
+    newTest().addSource("2n >> 1n").run();
+    newTest().addSource("let x = 2n; x >>= 1n").run();
+  }
+
+  @Test
+  public void testBigIntOperators_unsignedRightShift() {
+    newTest()
+        .addSource("const x = 1n; x >>> x;")
+        .addDiagnostic("operator >>> cannot be applied to bigint and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignUnsignedRightShift() {
+    newTest()
+        .addSource("let x = 1n; x >>>= x;")
+        .addDiagnostic("operator >>>= cannot be applied to bigint and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryOperationWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x * x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignOpWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x *= x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x | x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryOperationWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x * y;")
+        .addDiagnostic("operator * cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignOpWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x | y;")
+        .addDiagnostic("operator | cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_unsignedRightShift() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x = 1n; x >>> x;")
+        .addDiagnostic("operator >>> cannot be applied to (bigint|number) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignUnsignedRightShift() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x = 1n; x >>>= x;")
+        .addDiagnostic("operator >>>= cannot be applied to (bigint|number) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_binaryOperationWithBigInt() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x * y;")
+        .addDiagnostic("operator * cannot be applied to (bigint|string) and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_assignOpWithBigInt() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to (bigint|string) and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_binaryOperationWithBigIntOrNumber() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x * y;")
+        .addDiagnostic("operator * cannot be applied to (bigint|string) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_assignOpWithBigIntOrNumber() {
+    newTest()
+        .addSource(
+            "/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to (bigint|string) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_binaryOperationWithSelf() {
+    newTest()
+        .addSource(
+            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE * BIGINTS.TWO;")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_assignOpWithSelf() {
+    newTest()
+        .addSource(
+            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE *= BIGINTS.TWO;")
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntComparisons() {
+    newTest().addSource("var x = 1n; var y = 2n; x < y").run();
+    newTest().addSource("var x = 1n; /** @type {!BigInt} */ var y; x < y").run();
+    newTest().addSource("var x = 1n; var y = 2; x < y").run();
+    newTest().addSource("var x = 1n; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntComparisonWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'asdf'; x < y;")
+        .addDiagnostic(
+            lines(
+                "right side of numeric comparison",
+                "found   : string",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntObjectComparisons() {
+    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2n; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {!BigInt} */ var y; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testValidBigIntOrNumberComparisons() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; /** @type {bigint|number} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2; x < y;").run();
+    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2n; x < y;").run();
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; /** @type {!BigInt} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|number} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberComparisonWithString() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; 'asdf' < x;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison", //
+                "found   : string",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntOrOtherComparisons() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|string} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|string} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntOrOtherComparisonWithBigint() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 2n; x < y;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison",
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherComparisonWithNumber() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 2; x < y;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison",
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntObjectIndex() {
+    // As is, TypeCheck allows for objects to be indexed with bigint. An error could be reported as
+    // is done with arrays, but for now we will avoid such restrictions.
+    newTest()
+        .addSource(
+            "var obj = {};",
+            "/** @type {bigint} */ var b;",
+            "/** @type {bigint|number} */ var bn;",
+            "obj[b] = 1;",
+            "obj[bn] = 3;")
+        .run();
+  }
+
+  @Test
+  public void testBigIntArrayIndex() {
+    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
+    // to maintain consistency with TypeScript.
+    newTest()
+        .addSource("var arr = []; /** @type {bigint} */ var b; arr[b];")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : bigint",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntConstructorWithNew() {
+    // BigInt object function type cannot be called with "new" keyword
+    newTest().addSource("new BigInt(1)").addDiagnostic("cannot instantiate non-constructor").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberArrayIndex() {
+    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
+    // to maintain consistency with TypeScript.
+    newTest()
+        .addSource("var arr = []; /** @type {bigint|number} */ var bn; arr[bn];")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : (bigint|number)",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForObjects() {
+    newTest().addSource("/** @type {bigint} */ var x; ({[x]: 'value', 123n() {}});").run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForClasses() {
+    newTest().addSource("/** @unrestricted */ class C { 123n() {} }").run();
+    newTest().addSource("/** @dict */ class C { 123n() {} }").run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForStructClasses() {
+    newTest()
+        .addSource("class C { 123n() {} }")
+        .addDiagnostic("Cannot do '[]' access on a struct")
+        .run();
+  }
+
+  @Test
+  public void testBigIntLiteralProperty() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addBigInt().build())
+        .addSource("(1n).toString()")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java b/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java
new file mode 100644
index 0000000..a610b25
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java
@@ -0,0 +1,1129 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION;
+
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
+import com.google.javascript.rhino.jstype.JSType;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckBugsAndIssuesTest extends TypeCheckTestCase {
+
+  @Test
+  public void testIssue61a() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "var ns = {};"
+                + "(function() {"
+                + "  /** @param {string} b */"
+                + "  ns.a = function(b) {};"
+                + "})();"
+                + "function d() {"
+                + "  ns.a(123);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue61b() {
+    newTest()
+        .addSource(
+            "/** @const */ var ns = {};",
+            "(function() {",
+            "  /** @param {string} b */",
+            "  ns.a = function(b) {};",
+            "})();",
+            "ns.a(123);")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue61c() {
+    newTest()
+        .addSource(
+            "var ns = {};",
+            "(function() {",
+            "  /** @param {string} b */",
+            "  ns.a = function(b) {};",
+            "})();",
+            "ns.a(123);")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue86() {
+    newTest()
+        .addSource(
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.get = function(){};"
+                + "/** @constructor \n * @implements {I} */ function F() {}"
+                + "/** @override */ F.prototype.get = function() { return true; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue124() {
+    newTest()
+        .addSource(
+            "var t = null;"
+                + "function test() {"
+                + "  if (t != null) { t = null; }"
+                + "  t = 1;"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testIssue124b() {
+    newTest()
+        .addSource(
+            "var t = null;"
+                + "function test() {"
+                + "  if (t != null) { t = null; }"
+                + "  t = undefined;"
+                + "}")
+        .addDiagnostic(
+            "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null")
+        .run();
+  }
+
+  @Test
+  public void testIssue259() {
+    newTest()
+        .addSource(
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */"
+                + "var Clock = function() {"
+                + "  /** @constructor */"
+                + "  this.Date = function() {};"
+                + "  f(new this.Date());"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : this.Date\n"
+                + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue301() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addString().addArray().build())
+        .addSource(
+            "Array.indexOf = function() {};",
+            "var s = 'hello';",
+            "alert(s.toLowerCase.indexOf('1'));")
+        .addDiagnostic("Property indexOf never defined on String.prototype.toLowerCase")
+        .run();
+  }
+
+  @Test
+  public void testIssue368() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo(){}"
+                + "/**\n"
+                + " * @param {number} one\n"
+                + " * @param {string} two\n"
+                + " */\n"
+                + "Foo.prototype.add = function(one, two) {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar(){}"
+                + "/** @override */\n"
+                + "Bar.prototype.add = function(ignored) {};"
+                + "(new Bar()).add(1, 2);")
+        .addDiagnostic(
+            "actual parameter 2 of Bar.prototype.add does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue380() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().addObject().build())
+        .addSource(
+            "/** @type { function(string): {innerHTML: string} } */",
+            "document.getElementById;",
+            "var list = /** @type {!Array<string>} */ ['hello', 'you'];",
+            "list.push('?');",
+            "document.getElementById('node').innerHTML = list.toString();")
+        .run();
+  }
+
+  @Test
+  public void testIssue483() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/** @constructor */ function C() {",
+            "  /** @type {?Array} */ this.a = [];",
+            "}",
+            "C.prototype.f = function() {",
+            "  if (this.a.length > 0) {",
+            "    g(this.a);",
+            "  }",
+            "};",
+            "/** @param {number} a */ function g(a) {}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : Array",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testIssue537a() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {method: function() {}};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz()) this.method(1);"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic(
+            "Function Foo.prototype.method: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537b() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {method: function() {}};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz(1)) this.method();"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic(
+            "Function Bar.prototype.baz: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537c() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz2()) alert(1);"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic("Property baz2 never defined on Bar")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537d() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {"
+                + "  /** @return {Bar} */ x: function() { new Bar(); },"
+                + "  /** @return {Foo} */ y: function() { new Bar(); }"
+                + "};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  this.xy = 3;"
+                + "}"
+                + "/** @return {Bar} */ function f() { return new Bar(); }"
+                + "/** @return {Foo} */ function g() { return new Bar(); }"
+                + "Bar.prototype = {"
+                + "  /** @override @return {Bar} */ x: function() { new Bar(); },"
+                + "  /** @override @return {Foo} */ y: function() { new Bar(); }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue586() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var MyClass = function() {};"
+                + "/** @param {boolean} success */"
+                + "MyClass.prototype.fn = function(success) {};"
+                + "MyClass.prototype.test = function() {"
+                + "  this.fn();"
+                + "  this.fn = function() {};"
+                + "};")
+        .addDiagnostic(
+            "Function MyClass.prototype.fn: called with 0 argument(s). "
+                + "Function requires at least 1 argument(s) "
+                + "and no more than 1 argument(s).")
+        .run();
+  }
+
+  @Test
+  public void testIssue635() {
+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "function F() {}"
+                + "F.prototype.bar = function() { this.baz(); };"
+                + "F.prototype.baz = function() {};"
+                + "/** @constructor */"
+                + "function G() {}"
+                + "G.prototype.bar = F.prototype.bar;")
+        .run();
+  }
+
+  @Test
+  public void testIssue635b() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "function F() {}",
+            "/** @constructor */",
+            "function G() {}",
+            "/** @type {function(new:G)} */ var x = F;")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : (typeof F)",
+                "required: function(new:G): ?"))
+        .run();
+  }
+
+  @Test
+  public void testIssue669() {
+    newTest()
+        .addSource(
+            "/** @return {{prop1: (Object|undefined)}} */"
+                + "function f(a) {"
+                + "  var results;"
+                + "  if (a) {"
+                + "    results = {};"
+                + "    results.prop1 = {a: 3};"
+                + "  } else {"
+                + "    results = {prop2: 3};"
+                + "  }"
+                + "  return results;"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testIssue688() {
+    newTest()
+        .addSource(
+            "/** @const */ var SOME_DEFAULT =\n"
+                + "    /** @type {TwoNumbers} */ ({first: 1, second: 2});\n"
+                + "/**\n"
+                + "* Class defining an interface with two numbers.\n"
+                + "* @interface\n"
+                + "*/\n"
+                + "function TwoNumbers() {}\n"
+                + "/** @type {number} */\n"
+                + "TwoNumbers.prototype.first;\n"
+                + "/** @type {number} */\n"
+                + "TwoNumbers.prototype.second;\n"
+                + "/** @return {number} */ function f() { return SOME_DEFAULT; }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (TwoNumbers|null)\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue700() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {{text: string}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp1(opt_data) {\n"
+                + "  return opt_data.text;\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp2(opt_data) {\n"
+                + "  /** @suppress {checkTypes} */\n"
+                + "  function __inner() {\n"
+                + "    return temp1(opt_data.activity);\n"
+                + "  }\n"
+                + "  return __inner();\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {{n: number, text: string, b: boolean}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp3(opt_data) {\n"
+                + "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n"
+                + "}\n"
+                + "\n"
+                + "function callee() {\n"
+                + "  var output = temp3({\n"
+                + "    n: 0,\n"
+                + "    text: 'a string',\n"
+                + "    b: true\n"
+                + "  })\n"
+                + "  alert(output);\n"
+                + "}\n"
+                + "\n"
+                + "callee();")
+        .run();
+  }
+
+  @Test
+  public void testIssue725() {
+    newTest()
+        .addSource(
+            "/** @typedef {{name: string}} */ var RecordType1;"
+                + "/** @typedef {{name2222: string}} */ var RecordType2;"
+                + "/** @param {RecordType1} rec */ function f(rec) {"
+                + "  alert(rec.name2222);"
+                + "}")
+        .addDiagnostic("Property name2222 never defined on rec")
+        .run();
+  }
+
+  @Test
+  public void testIssue726() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @return {!Function} */ "
+                + "Foo.prototype.getDeferredBar = function() { "
+                + "  var self = this;"
+                + "  return function() {"
+                + "    self.bar(true);"
+                + "  };"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue765() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var AnotherType = function(parent) {"
+                + "    /** @param {string} stringParameter Description... */"
+                + "    this.doSomething = function(stringParameter) {};"
+                + "};"
+                + "/** @constructor */"
+                + "var YetAnotherType = function() {"
+                + "    this.field = new AnotherType(self);"
+                + "    this.testfun=function(stringdata) {"
+                + "        this.field.doSomething(null);"
+                + "    };"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of AnotherType.doSomething "
+                + "does not match formal parameter\n"
+                + "found   : null\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue783() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var Type = function() {"
+                + "  /** @type {Type} */"
+                + "  this.me_ = this;"
+                + "};"
+                + "Type.prototype.doIt = function() {"
+                + "  var me = this.me_;"
+                + "  for (var i = 0; i < me.unknownProp; i++) {}"
+                + "};")
+        .addDiagnostic("Property unknownProp never defined on Type")
+        .run();
+  }
+
+  @Test
+  public void testIssue791() {
+    newTest()
+        .addSource(
+            "/** @param {{func: function()}} obj */"
+                + "function test1(obj) {}"
+                + "var fnStruc1 = {};"
+                + "fnStruc1.func = function() {};"
+                + "test1(fnStruc1);")
+        .run();
+  }
+
+  @Test
+  public void testIssue810() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "var Type = function() {",
+            "  this.prop = x;",
+            "};",
+            "Type.prototype.doIt = function(obj) {",
+            "  this.prop = obj.unknownProp;",
+            "};")
+        .addDiagnostic(
+            "Property unknownProp never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .run();
+  }
+
+  @Test
+  public void testIssue1002() {
+    newTest()
+        .addSource(
+            "/** @interface */"
+                + "var I = function() {};"
+                + "/** @constructor @implements {I} */"
+                + "var A = function() {};"
+                + "/** @constructor @implements {I} */"
+                + "var B = function() {};"
+                + "var f = function() {"
+                + "  if (A === B) {"
+                + "    new B();"
+                + "  }"
+                + "};")
+        .run();
+  }
+
+  @Test
+  public void testIssue1023() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "function F() {}"
+                + "(function() {"
+                + "  F.prototype = {"
+                + "    /** @param {string} x */"
+                + "    bar: function(x) {  }"
+                + "  };"
+                + "})();"
+                + "(new F()).bar(true)")
+        .addDiagnostic(
+            "actual parameter 1 of F.prototype.bar does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue1047() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C2() {}\n"
+                + "\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C3(c2) {\n"
+                + "  /**\n"
+                + "   * @type {C2} \n"
+                + "   * @private\n"
+                + "   */\n"
+                + "  this.c2_;\n"
+                + "\n"
+                + "  var x = this.c2_.prop;\n"
+                + "}")
+        .addDiagnostic("Property prop never defined on C2")
+        .run();
+  }
+
+  @Test
+  public void testIssue1056() {
+    newTest()
+        .addSource("/** @type {Array} */ var x = null;" + "x.push('hi');")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+        .run();
+  }
+
+  @Test
+  public void testIssue1072() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {string} x\n"
+                + " * @return {number}\n"
+                + " */\n"
+                + "var f1 = function(x) {\n"
+                + "  return 3;\n"
+                + "};\n"
+                + "\n"
+                + "/** Function */\n"
+                + "var f2 = function(x) {\n"
+                + "  if (!x) throw new Error()\n"
+                + "  return /** @type {number} */ (f1('x'))\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {string} x\n"
+                + " */\n"
+                + "var f3 = function(x) {};\n"
+                + "\n"
+                + "f1(f3);")
+        .addDiagnostic(
+            "actual parameter 1 of f1 does not match formal parameter\n"
+                + "found   : function(string): undefined\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue1123() {
+    newTest()
+        .addSource("/** @param {function(number)} g */ function f(g) {}" + "f(function(a, b) {})")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : function(?, ?): undefined\n"
+                + "required: function(number): ?")
+        .run();
+  }
+
+  @Test
+  public void testIssue1201() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "/** @constructor */ function F() {}"
+                + "/** desc */ F.prototype.bar = function() {};"
+                + "g(new F().bar);")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : function(this:F): undefined\n"
+                + "required: function(this:undefined): ?")
+        .run();
+  }
+
+  @Test
+  public void testIssue1201b() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "/** @constructor */ function F() {}"
+                + "/** desc */ F.prototype.bar = function() {};"
+                + "var f = new F();"
+                + "g(f.bar.bind(f));")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue1201c() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "g(function() { this.alert() })")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+        .run();
+  }
+
+  @Test
+  public void testIssue926a() {
+    newTest()
+        .addSource(
+            "/** x */ function error() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @param {string} error\n"
+                + " */\n"
+                + "function C(error) {\n"
+                + " /** @const */ this.e = error;\n"
+                + "}"
+                + "/** @type {number} */ var x = (new C('x')).e;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue926b() {
+    newTest()
+        .addSource(
+            "/** @constructor */\n"
+                + "function A() {\n"
+                + " /** @constructor */\n"
+                + " function B() {}\n"
+                + " /** @type {!B} */ this.foo = new B();"
+                + " /** @type {!B} */ var C = new B();"
+                + "}"
+                + "/** @type {number} */ var x = (new A()).foo;")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: number")
+        .run();
+  }
+
+  /**
+   * Tests that the || operator is type checked correctly, that is of the type of the first argument
+   * or of the second argument. See bugid 592170 for more details.
+   */
+  @Test
+  public void testBug592170() {
+    newTest()
+        .addSource(
+            "/** @param {Function} opt_f ... */"
+                + "function foo(opt_f) {"
+                + "  /** @type {Function} */"
+                + "  return opt_f || function() {};"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testNullishCoalesceTypeIsFirstOrSecondArgument() {
+    newTest()
+        .addSource(
+            "/** @param {Function} opt_f ... */",
+            "function foo(opt_f) {",
+            "  /** @type {Function} */",
+            "  return opt_f ?? function() {};",
+            "}")
+        .run();
+  }
+
+  /**
+   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
+   * of the side on which the undefined value is.
+   */
+  @Test
+  public void testBug901455a() {
+    newTest()
+        .addSource(
+            "/** @return {(number|undefined)} */ function a() { return 3; }"
+                + "var b = undefined === a()")
+        .run();
+  }
+
+  /**
+   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
+   * of the side on which the undefined value is.
+   */
+  @Test
+  public void testBug901455b() {
+    newTest()
+        .addSource(
+            "/** @return {(number|undefined)} */ function a() { return 3; }"
+                + "var b = a() === undefined")
+        .run();
+  }
+
+  /** Tests that the match method of strings returns nullable arrays. */
+  @Test
+  public void testBug908701() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
+        .addSource(
+            "/** @type {String} */ var s = new String('foo');", //
+            "var b = s.match(/a/) != null;")
+        .run();
+  }
+
+  /** Tests that named types play nicely with subtyping. */
+  @Test
+  public void testBug908625() {
+    newTest()
+        .addSource(
+            "/** @constructor */function A(){}"
+                + "/** @constructor\n * @extends A */function B(){}"
+                + "/** @param {B} b"
+                + "\n @return {(A|undefined)} */function foo(b){return b}")
+        .run();
+  }
+
+  /**
+   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
+   * this variable is legal.
+   */
+  @Test
+  public void testBug911118a() {
+    // verifying the type assigned to function expressions assigned variables
+    TypedScope s = parseAndTypeCheckWithScope("var a = function(){};").scope;
+    JSType type = s.getVar("a").getType();
+    assertThat(type.toString()).isEqualTo("function(): undefined");
+  }
+
+  /**
+   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
+   * this variable is legal.
+   */
+  @Test
+  public void testBug911118b() {
+    // verifying the bug example
+    newTest()
+        .addSource(
+            "function nullFunction() {};"
+                + "var foo = nullFunction;"
+                + "foo = function() {};"
+                + "foo();")
+        .run();
+  }
+
+  @Test
+  public void testBug909000() {
+    newTest()
+        .addSource(
+            "/** @constructor */function A(){}\n"
+                + "/** @param {!A} a\n"
+                + "@return {boolean}*/\n"
+                + "function y(a) { return a }")
+        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: boolean")
+        .run();
+  }
+
+  @Test
+  public void testBug930117() {
+    newTest()
+        .addSource("/** @param {boolean} x */function f(x){}" + "f(null);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : null\n"
+                + "required: boolean")
+        .run();
+  }
+
+  @Test
+  public void testBug1484445() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {number?} */ Foo.prototype.bar = null;"
+                + "/** @type {number?} */ Foo.prototype.baz = null;"
+                + "/** @param {Foo} foo */"
+                + "function f(foo) {"
+                + "  while (true) {"
+                + "    if (foo.bar == null && foo.baz == null) {"
+                + "      foo.bar;"
+                + "    }"
+                + "  }"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testBug1859535() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {Function} childCtor Child class.\n"
+                + " * @param {Function} parentCtor Parent class.\n"
+                + " */"
+                + "var inherits = function(childCtor, parentCtor) {"
+                + "  /** @constructor */"
+                + "  function tempCtor() {};"
+                + "  tempCtor.prototype = parentCtor.prototype;"
+                + "  childCtor.superClass_ = parentCtor.prototype;"
+                + "  childCtor.prototype = new tempCtor();"
+                + "  /** @override */ childCtor.prototype.constructor = childCtor;"
+                + "};"
+                + "/**"
+                + " * @param {Function} constructor\n"
+                + " * @param {Object} var_args\n"
+                + " * @return {Object}\n"
+                + " */"
+                + "var factory = function(constructor, var_args) {"
+                + "  /** @constructor */"
+                + "  var tempCtor = function() {};"
+                + "  tempCtor.prototype = constructor.prototype;"
+                + "  var obj = new tempCtor();"
+                + "  constructor.apply(obj, arguments);"
+                + "  return obj;"
+                + "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testBug1940591() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @type {Object} */"
+                + "var a = {};\n"
+                + "/** @type {number} */\n"
+                + "a.name = 0;\n"
+                + "/**\n"
+                + " * @param {Function} x anything.\n"
+                + " */\n"
+                + "a.g = function(x) { x.name = 'a'; }")
+        .run();
+  }
+
+  @Test
+  public void testBug1942972() {
+    newTest()
+        .addSource(
+            "var google = {\n"
+                + "  gears: {\n"
+                + "    factory: {},\n"
+                + "    workerPool: {}\n"
+                + "  }\n"
+                + "};\n"
+                + "\n"
+                + "google.gears = {factory: {}};\n")
+        .run();
+  }
+
+  @Test
+  public void testBug1943776() {
+    newTest()
+        .addSource(
+            "/** @return  {{foo: Array}} */" + "function bar() {" + "  return {foo: []};" + "}")
+        .run();
+  }
+
+  @Test
+  public void testBug1987544() {
+    newTest()
+        .addSource(
+            "/** @param {string} x */ function foo(x) {}"
+                + "var duration;"
+                + "if (true && !(duration = 3)) {"
+                + " foo(duration);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug1940769() {
+    newTest()
+        .addSource(
+            "/** @return {!Object} */ "
+                + "function proto(obj) { return obj.prototype; }"
+                + "/** @constructor */ function Map() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Map}\n"
+                + " */"
+                + "function Map2() { Map.call(this); };"
+                + "Map2.prototype = proto(Map);")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testBug2335992() {
+    disableStrictMissingPropertyChecks();
+
+    newTest()
+        .addSource(
+            "/** @return {*} */ function f() { return 3; }"
+                + "var x = f();"
+                + "/** @type {string} */"
+                + "x.y = 3;")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug2341812() {
+    disableStrictMissingPropertyChecks();
+
+    newTest()
+        .addSource(
+            "/** @interface */"
+                + "function EventTarget() {}"
+                + "/** @constructor \n * @implements {EventTarget} */"
+                + "function Node() {}"
+                + "/** @type {number} */ Node.prototype.index;"
+                + "/** @param {EventTarget} x \n * @return {string} */"
+                + "function foo(x) { return x.index; }")
+        .run();
+  }
+
+  @Test
+  public void testBug7701884() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/**",
+            " * @param {Array<T>} x",
+            " * @param {function(T)} y",
+            " * @template T",
+            " */",
+            "var forEach = function(x, y) {",
+            "  for (var i = 0; i < x.length; i++) y(x[i]);",
+            "};",
+            "/** @param {number} x */",
+            "function f(x) {}",
+            "/** @param {?} x */",
+            "function h(x) {",
+            "  var top = null;",
+            "  forEach(x, function(z) { top = z; });",
+            "  if (top) f(top);",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testBug8017789() {
+    newTest()
+        .addSource(
+            "/** @param {(map|function())} isResult */"
+                + "var f = function(isResult) {"
+                + "    while (true)"
+                + "        isResult['t'];"
+                + "};"
+                + "/** @typedef {Object<string, number>} */"
+                + "var map;")
+        .run();
+  }
+
+  @Test
+  public void testBug12441160() {
+    newTest()
+        .addSource(
+            "/** @param {string} a */ \n"
+                + "function use(a) {};\n"
+                + "/**\n"
+                + " * @param {function(this:THIS)} fn\n"
+                + " * @param {THIS} context \n"
+                + " * @constructor\n"
+                + " * @template THIS\n"
+                + " */\n"
+                + "var P = function(fn, context) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function C() { /** @type {number} */ this.a = 1; }\n"
+                + "\n"
+                + "/** @return {P} */ \n"
+                + "C.prototype.method = function() {\n"
+                + "   return new P(function() { use(this.a); }, this);\n"
+                + "};\n"
+                + "\n")
+        .addDiagnostic(
+            "actual parameter 1 of use does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug13641083a() {
+    newTest()
+        .addSource("/** @constructor @struct */ function C() {};" + "new C().bar;")
+        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testBug13641083b() {
+    newTest()
+        .addSource("/** @type {?} */ var C;" + "C.bar + 1;")
+        .addDiagnostic(TypeCheck.POSSIBLE_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testBug12722936() {
+    // Verify we don't use a weaker type when a
+    // stronger type is known for a slot.
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function X() {}\n"
+                + "/** @constructor */ function C() {\n"
+                + "  /** @type {!X<boolean>}*/\n"
+                + "  this.a = new X();\n"
+                + "  /** @type {null} */ var x = this.a;\n"
+                + "};\n"
+                + "\n")
+        .addDiagnostic("initializing variable\n" + "found   : X<boolean>\n" + "required: null")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java b/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java
new file mode 100644
index 0000000..1167933
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java
@@ -0,0 +1,1104 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.javascript.jscomp.TypeCheck.STRICT_INEXISTENT_PROPERTY;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckCovarianceTest extends TypeCheckTestCase {
+
+  @Test
+  public void testIterableCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterable<(number|string)>*/ x){};",
+            "function g(/** !Iterable<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testLocalShadowOfIterableNotCovariant() {
+    newTest()
+        .addSource(
+            "/** @template T */",
+            "class Iterable {}",
+            "function f(/** !Iterable<(number|string)>*/ x) {};",
+            "function g(/** !Iterable<number> */ arr) {",
+            "    f(arr);",
+            "}",
+            "export {};")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Iterable<number>",
+                "required: Iterable<(number|string)>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableNotContravariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterable<number>*/ x){};",
+            "function g(/** !Iterable<(number|string)> */ arr) {",
+            "    f(arr);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Iterable<(number|string)>",
+                "required: Iterable<number>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableCovariantWhenComparingToSubtype() {
+    newTest()
+        .addExterns(
+            "/** @constructor",
+            " * @implements {Iterable<T>}",
+            " * @template T",
+            " */",
+            "function Set() {}")
+        .addSource(
+            "function f(/** !Iterable<(number|string)>*/ x){};",
+            "function g(/** !Set<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIteratorCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterator<(string|number)>*/ x){};",
+            "function g(/** !Iterator<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testGeneratorCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Generator<(string|number)>*/ x){};",
+            "function g(/** !Generator<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableImplementorInvariant() {
+    newTest()
+        .addExterns(
+            "/** @constructor",
+            " * @implements {Iterable<T>}",
+            " * @template T",
+            " */",
+            "function Set() {}")
+        .addSource(
+            "function f(/** !Set<(string|number)>*/ x){};",
+            "function g(/** !Set<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Set<number>",
+                "required: Set<(number|string)>"))
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeCovariant1() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<(string|number)>*/ x){};",
+            "function g(/** !IArrayLike<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeCovariant2() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<(string|number)>*/ x){};",
+            "function g(/** !Array<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeBivaraint() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<number>*/ x){};",
+            "function g(/** !IArrayLike<(string|number)> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType1() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor ",
+            "  * @extends {C} ",
+            "  */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType2() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor ",
+            "  * @extends {C} ",
+            "  */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C, prop2: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType3() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType4() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C, prop2: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C2|null)}",
+                "required: {\n  prop: (C|null),\n  prop2: (C|null)\n}",
+                "missing : [prop2]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType5() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function C() {}",
+            "/** @constructor */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C2|null)}",
+                "required: {prop: (C|null)}",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType6() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C2}} */",
+            "var r1;",
+            "/** @type {{prop: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C|null)}",
+                "required: {prop: (C2|null)}",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType7() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C2, prop2: C2}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {\n  prop: (C2|null),\n  prop2: (C|null)\n}",
+                "required: {\n  prop: (C2|null),\n  prop2: (C2|null)\n}",
+                "missing : []",
+                "mismatch: [prop2]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType8() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo(){}",
+            "/** @type {number} */",
+            "Foo.prototype.x = 5",
+            "/** @type {string} */",
+            "Foo.prototype.y = 'str'")
+        .addSource(
+            "/** @type {{x: number, y: string}} */",
+            "var r1 = {x: 1, y: 'value'};",
+            "",
+            "/** @type {!Foo} */",
+            "var f = new Foo();",
+            "r1 = f;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType9() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo(){}",
+            "/** @type {number} */",
+            "Foo.prototype.x1 = 5",
+            "/** @type {string} */",
+            "Foo.prototype.y = 'str'")
+        .addSource(
+            "/** @type {{x: number, y: string}} */",
+            "var r1 = {x: 1, y: 'value'};",
+            "",
+            "/** @type {!Foo} */",
+            "var f = new Foo();",
+            "f = r1;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : {\n  x: number,\n  y: string\n}",
+                "required: Foo"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType10() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {{x: !Foo}} */",
+            "Foo.prototype.x = {x: new Foo()};")
+        .addSource(
+            "/** @type {!Foo} */",
+            "var o = new Foo();",
+            "",
+            "/** @type {{x: !Foo}} */",
+            "var r = {x : new Foo()};",
+            "r = o;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : Foo",
+                "required: {x: Foo}",
+                "missing : []",
+                "mismatch: [x]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType11() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "/** @return {number} */",
+            "Bar1.prototype.y = function(){return 1;};",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {string} */",
+            "Bar.prototype.y = function(){return 'test';};")
+        .addSource(
+            "function fun(/** Foo */f) {", //
+            "  f.y();",
+            "}",
+            "fun(new Bar1())",
+            "fun(new Bar());")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType12() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {undefined} */",
+            "Bar.prototype.y = function(){};")
+        .addSource(
+            "/** @type{Foo} */", //
+            "var f = new Bar1();",
+            "f.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run(); // Only if strict warnings are enabled.
+  }
+
+  @Test
+  public void testCovarianceForRecordType13() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor @implements {I} */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{{x: {obj: I}}} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run(); // Only if strict warnings are enabled.
+  }
+
+  @Test
+  public void testCovarianceForRecordType14a() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType14b() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .addDiagnostic("Property y not defined on all member types of (I|C)")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType15() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y1 = function(){};",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @return {undefined} */",
+            "C1.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */",
+            "var ri;",
+            "ri.x.obj.y1();",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType16() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {number} */",
+            "C.prototype.y = function(){return 1;};",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @return {string} */",
+            "C1.prototype.y = function(){return 'test';};")
+        .addSource(
+            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType17() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "Bar1.prototype.y = function(){return {};};",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {number} */",
+            "Bar.prototype.y = function(){return 1;};")
+        .addSource(
+            "/** @type {Foo} */ var f;", //
+            "f.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType18() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor*/",
+            "function Bar1() {}",
+            "/** @type {{x: number}} */",
+            "Bar1.prototype.prop;",
+            "/** @constructor */",
+            "function Bar() {}",
+            "/** @type {{x: number, y: number}} */",
+            "Bar.prototype.prop;")
+        .addSource(
+            "/** @type {{x: number}} */ var f;", //
+            "f.z;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType19a() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @constructor */",
+            "function Bar2() {}",
+            "/** @type {number} */",
+            "Bar2.prototype.prop;")
+        .addSource(
+            "/** @type {(Bar1|Bar2)} */ var b;", //
+            "var x = b.prop1")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType19b() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @constructor */",
+            "function Bar2() {}",
+            "/** @type {number} */",
+            "Bar2.prototype.prop;")
+        .addSource(
+            "/** @type {(Bar1|Bar2)} */ var b;", //
+            "var x = b.prop1")
+        .addDiagnostic("Property prop1 not defined on all member types of (Bar1|Bar2)")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType20() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop2;")
+        .addSource(
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {(Bar1|{prop:number, prop2: number})} */ var b;",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = b.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType20_2() {
+    newTest()
+        .includeDefaultExterns()
+        .addSource(
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {({prop:number, prop1: number, prop2: number}|",
+            "{prop:number, prop2: number})} */ var b;",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = b.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType21() {
+    newTest()
+        .addExterns("")
+        .addSource(
+            "/** @constructor */",
+            "function Bar1() {};",
+            "/** @type {number} */",
+            "Bar1.prototype.propName;",
+            "/** @type {number} */",
+            "Bar1.prototype.propName1;",
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {(Bar1|{propName:number, propName1: number})} */ var b;",
+            "var x = b.prop2;")
+        .addDiagnostic("Property prop2 never defined on b")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType23() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function A() {}",
+            "/** @constructor @extends{A} */",
+            "function B() {}",
+            "",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @type {B} */",
+            "C.prototype.prop2;",
+            "/** @type {number} */",
+            "C.prototype.prop3;",
+            "",
+            "/** @constructor */",
+            "function D() {}",
+            "/** @type {number} */",
+            "D.prototype.prop;",
+            "/** @type {number} */",
+            "D.prototype.prop1;",
+            "/** @type {B} */",
+            "D.prototype.prop2;")
+        .addSource(
+            "/** @type {{prop2: A}} */ var record;",
+            "var xhr = new C();",
+            "if (true) { xhr = new D(); }",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = xhr.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType24() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** @type {!Function} */",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function, count: number}} */",
+            "  var x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{abort: Function})} */",
+            "  var y;",
+            "  y.abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType25() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** @type {!Function} */",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{!Function} */ var f;",
+            "  var x = {abort: f, count: 1}",
+            "  return x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{test2: number})} */",
+            "  var y;",
+            "  y.abort();",
+            "}")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType26() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function}} */",
+            "  var x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{test2: number})} */",
+            "  var y;",
+            "  /** @type {C} */ (y).abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType26AndAHalf() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;",
+            "var g = function /** !C */(){};")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function}} */",
+            "  var x;",
+            "}",
+            "function f2() {",
+            "  var y = g();",
+            "  y.abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType27() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C(){}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop2:C}} */ var c;",
+            "/** @type {({prop:number, prop1: number, prop2: C}|",
+            "{prop:number, prop1: number, prop2: number})} */ var b;",
+            "var x = b.prop2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType28() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function XMLHttpRequest() {}",
+            "/**",
+            " * @return {undefined}",
+            " */",
+            "XMLHttpRequest.prototype.abort = function() {};",
+            "",
+            "/** @constructor */",
+            "function XDomainRequest() {}",
+            "",
+            "XDomainRequest.prototype.abort = function() {};")
+        .addSource(
+            "/**",
+            " * @typedef {{abort: !Function, close: !Function}}",
+            " */",
+            "var WritableStreamSink;",
+            "function sendCrossOrigin() {",
+            "  var xhr = new XMLHttpRequest;",
+            "  xhr = new XDomainRequest;",
+            "  return function() {",
+            "    xhr.abort();",
+            "  };",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType29() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function XMLHttpRequest() {}",
+            "/**",
+            " * @type {!Function}",
+            " */",
+            "XMLHttpRequest.prototype.abort = function() {};",
+            "",
+            "/** @constructor */",
+            "function XDomainRequest() {}",
+            "/**",
+            " * @type {!Function}",
+            " */",
+            "XDomainRequest.prototype.abort = function() {};")
+        .addSource(
+            "/**",
+            " * @typedef {{close: !Function, abort: !Function}}",
+            " */",
+            "var WritableStreamSink;",
+            "function sendCrossOrigin() {",
+            "  var xhr = new XMLHttpRequest;",
+            "  xhr = new XDomainRequest;",
+            "  return function() {",
+            "    xhr.abort();",
+            "  };",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType30() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function A() {}")
+        .addSource(
+            "/**",
+            " * @type {{prop1: (A)}}",
+            " */",
+            "var r1;",
+            "/**",
+            " * @type {{prop1: (A|undefined)}}",
+            " */",
+            "var r2;",
+            "r1 = r2")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop1: (A|null|undefined)}",
+                "required: {prop1: (A|null)}",
+                "missing : []",
+                "mismatch: [prop1]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType31() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function A() {}")
+        .addSource(
+            "/**",
+            " * @type {{prop1: (A|null)}}",
+            " */",
+            "var r1;",
+            "/**",
+            " * @type {{prop1: (A|null|undefined)}}",
+            " */",
+            "var r2;",
+            "r1 = r2")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop1: (A|null|undefined)}",
+                "required: {prop1: (A|null)}",
+                "missing : []",
+                "mismatch: [prop1]"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable1() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string|number>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable2() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !IThenable<string|number> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : IThenable<(number|string)>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable3() {
+    newTest()
+        .addSource(
+            "/** @type {!Promise<string|number>} */ var x;",
+            "function fn(/** !Promise<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable4() {
+    newTest()
+        .addSource(
+            "/** @type {!Promise<string>} */ var x;",
+            "function fn(/** !Promise<string|number> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : Promise<(number|string)>",
+                "required: Promise<string>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable1() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : IThenable<string>",
+                "required: Array<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable2() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !Array<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : Array<string>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable3() {
+    newTest()
+        .addSource(
+            "/** ",
+            "  @constructor",
+            "  @template T",
+            " */",
+            "function C() {}",
+            "/** @type {!C<string>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : IThenable<string>",
+                "required: C<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable4() {
+    newTest()
+        .addSource(
+            "/** ",
+            "  @constructor",
+            "  @template T",
+            " */",
+            "function C() {}",
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !C<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : C<string>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonNativeSubclass() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @implements {IThenable<T>}",
+            " * @template T",
+            " */",
+            "class CustomPromise {}",
+            "/** @type {!CustomPromise<(number|string)>} */ var x;",
+            "function fn(/** !CustomPromise<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
index c61176d..66722b5 100644
--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
@@ -21,6 +21,7 @@ import static com.google.javascript.jscomp.FunctionTypeBuilder.VAR_ARGS_MUST_BE_
 import static com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT;
 
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class TypeCheckFunctionCheckTest extends CompilerTestCase {
 
-  private CodingConvention convention = null;
+  private @Nullable CodingConvention convention = null;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
diff --git a/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java b/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
index ced3f0a..d5d4f19 100644
--- a/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
@@ -4752,6 +4752,417 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
   }
 
   @Test
+  public void testClassFields() {
+    newTest()
+        .addSource(
+            "class A {", //
+            "  x = 2;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class B {", //
+            "  x;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class C {", //
+            "  x",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class D {", //
+            "  /** @type {string|undefined} */",
+            "  x;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class E {", //
+            "  /** @type {string} @suppress {checkTypes} */",
+            "  x = 2;",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testClassFieldsThis() {
+    newTest()
+        .addSource(
+            "class F {", //
+            "  /** @type {number} */",
+            "  x = 2;",
+            "  /** @type {boolean} */",
+            "  y = this.x",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of F", //
+                "found   : number",
+                "required: boolean"))
+        .run();
+  }
+
+  @Test
+  public void testClassFieldsSuper() {
+    newTest()
+        .addSource(
+            "class G {", //
+            "  /** @return {number} */",
+            "  getX() { return 2; }",
+            "}",
+            "class H extends G {",
+            "  /** @return {?} */",
+            "  /** @override*/ getX() {}",
+            "  /** @type {string} */",
+            "  y = super.getX();",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of H", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testComputedFields() {
+    newTest()
+        .addSource(
+            "var /** number */ x = 1;",
+            "function takesNumber(/** number */ x) {}",
+            "/** @unrestricted */",
+            "class Foo {",
+            "  /** @type {boolean} */",
+            "  x = true;",
+            "  [this.x] = takesNumber(this.x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of takesNumber does not match formal parameter", //
+                "found   : boolean",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testStaticClassFields() {
+    newTest()
+        .addSource(
+            "class A {", //
+            "  static x = 2;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class B {", //
+            "  static x;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class C {", //
+            "  static x",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class D {", //
+            "  /** @type {string|undefined} */",
+            "  static x;",
+            "}")
+        .run();
+    newTest()
+        .addSource(
+            "class E {", //
+            "  /** @type {string} @suppress {checkTypes} */",
+            "  static x = 2;",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testStaticClassFieldsThis() {
+    newTest()
+        .addSource(
+            "class F {", //
+            "  /** @type {number} */",
+            "  static x = 2;",
+            "  /** @type {boolean} */",
+            "  static y = this.x",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of F", //
+                "found   : number",
+                "required: boolean"))
+        .run();
+  }
+
+  @Test
+  public void testStaticComputedFields() {
+    newTest()
+        .addSource(
+            "var /** number */ x = 1;",
+            "function takesNumber(/** number */ x) {}",
+            "/** @unrestricted */",
+            "class Foo {",
+            "  /** @type {boolean} */",
+            "  static x = true;",
+            "  static [this.x] = takesNumber(this.x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of takesNumber does not match formal parameter", //
+                "found   : boolean",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testStaticClassFieldsSuper() {
+    newTest()
+        .addSource(
+            "class G {", //
+            "  /** @type {number} */",
+            "  static x = 2;",
+            "}",
+            "class H extends G {",
+            "  /** @type {string} */",
+            "  static y = super.x;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of H", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockVariablesWrongTypes() {
+    newTest()
+        .addSource(
+            "class Foo {", //
+            "  static {",
+            "    /** @type {number} */",
+            "    let str = 'str';",
+            "    /** @type {boolean|string} */",
+            "    const num = 5;",
+            "    /** @type {?string} */",
+            "    var bool = true;",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : string",
+                "required: number"))
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: (boolean|string)"))
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : boolean",
+                "required: (null|string)"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockPropertyWithThis() {
+    newTest()
+        .addSource(
+            "/** @type {number} */",
+            "var x = 4;",
+            "class Foo {", //
+            "  static {",
+            "    this.x;",
+            "  }",
+            "};")
+        .addDiagnostic("Property x never defined on this")
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockWithWrongTypeThisRHS() {
+    newTest()
+        .addSource(
+            "class Foo {",
+            "  static {",
+            "    /** @type {number} */",
+            "    this.num = 1;",
+            "    /** @type {string} */",
+            "    var str = this.num;",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockWithWrongTypeThisLHS() {
+    newTest()
+        .addSource(
+            "class Foo { ",
+            "  static {",
+            "    /** @type {string} */",
+            "    this.str = 2;",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "assignment to property str of this", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockWithSuper() {
+    newTest()
+        .addSource(
+            "class Foo {",
+            "  /** @type {string} */",
+            "  static str;",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    super.str = 'str';",
+            "  }",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockWithWrongTypeSuper() {
+    newTest()
+        .addSource(
+            "class Foo {",
+            "  /** @type {string} */",
+            "  static str;",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    super.str = 5;",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "assignment to property str of super", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockInheritanceWithClassName() {
+    newTest()
+        .addSource(
+            "class Foo {",
+            "  static foo(/** number */ arg) {}",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    Foo.foo('str');",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of Foo.foo does not match formal parameter", //
+                "found   : string",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockWithWrongTypeSuperParameter() {
+    newTest()
+        .addSource(
+            "class Foo {",
+            "  static foo(/** number */ arg) {}",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    super.foo('str');",
+            "  }",
+            "};")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of super.foo does not match formal parameter",
+                "found   : string",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockTypeNarrowing() {
+    newTest()
+        .addSource(
+            "class C {",
+            "  static {",
+            "    /** @param {?string} x */",
+            "    function foo(x) {",
+            "      if (x != null) {",
+            "        /** @type {string} */",
+            "        const noNull = x;",
+            "      }",
+            "    }",
+            "  }",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockTypeNarrowing2() {
+    newTest()
+        .addExterns("/** @type {?string} */ var strOrNull;")
+        .addSource(
+            "class C {",
+            "  static {",
+            "    if (strOrNull != null) {",
+            "      /** @type {string} */",
+            "      const noNull = strOrNull;",
+            "    }",
+            "  }",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testClassStaticBlockOverrideSupertypeOnAnonymousClass() {
+    newTest()
+        .addSource(
+            "function use(ctor) {}",
+            "",
+            "class Foo { ",
+            "  static {",
+            "    /** @type {string} */",
+            "    this.str;",
+            "  }",
+            "}",
+            "use(class extends Foo {",
+            "  static { this.str = 3; }",
+            "});")
+        .addDiagnostic(
+            lines(
+                "assignment to property str of this", //
+                "found   : number",
+                "required: string"))
+        .addDiagnostic(
+            "property str already defined on supertype (typeof Foo); use @override to override it")
+        .run();
+  }
+
+  @Test
   public void testClassTypeOfThisInConstructor() {
     newTest()
         .addSource(
@@ -5173,7 +5584,7 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
   public void testClassExtendsItself() {
     newTest()
         .addSource("class Foo extends Foo {}")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type Foo")
+        .addDiagnostic("Cycle detected in inheritance chain of type Foo")
         .run();
   }
 
@@ -5183,7 +5594,7 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
         .addSource(
             "class Foo extends Bar {}", //
             "class Bar extends Foo {}")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type Bar")
+        .addDiagnostic("Cycle detected in inheritance chain of type Bar")
         .run();
   }
 
@@ -5194,7 +5605,7 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "class Bar {}", //
             "/** @extends {Foo} */",
             "class Foo extends Bar {}")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type Foo")
+        .addDiagnostic("Cycle detected in inheritance chain of type Foo")
         .addDiagnostic("Could not resolve type in @extends tag of Foo")
         .run();
   }
diff --git a/test/com/google/javascript/jscomp/TypeCheckStructuralInterfaceTest.java b/test/com/google/javascript/jscomp/TypeCheckStructuralInterfaceTest.java
new file mode 100644
index 0000000..12f800f
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckStructuralInterfaceTest.java
@@ -0,0 +1,1802 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckStructuralInterfaceTest extends TypeCheckTestCase {
+
+  /**
+   * although C1 does not declare to extend Interface1, obj2 : C1 still structurally matches obj1 :
+   * Interface1 because of the structural interface matching (Interface1 is declared with @record
+   * tag)
+   */
+  @Test
+  public void testStructuralInterfaceMatching1() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function Interface1() {}",
+            "/** @type {number} */",
+            "Interface1.prototype.length;",
+            "",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @type {number} */",
+            "C1.prototype.length;")
+        .addSource(
+            "/** @type{Interface1} */",
+            "var obj1;",
+            "/** @type{C1} */",
+            "var obj2 = new C1();",
+            "obj1 = obj2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching2() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function Interface1() {}",
+            "/** @type {number} */",
+            "Interface1.prototype.length;",
+            "",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @type {number} */",
+            "C1.prototype.length;")
+        .addSource(
+            "/** @type{Interface1} */", //
+            "var obj1;",
+            "var obj2 = new C1();",
+            "obj1 = obj2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching3() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I1() {}",
+            "",
+            "/** @record */",
+            "function I2() {}")
+        .addSource(
+            "/** @type {I1} */", //
+            "var i1;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i1 = i2;",
+            "i2 = i1;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching4_1() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I1() {}",
+            "",
+            "/** @record */",
+            "function I2() {}")
+        .addSource(
+            "/** @type {I1} */", //
+            "var i1;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i2 = i1;",
+            "i1 = i2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching5_1() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function I1() {}",
+            "",
+            "/** @interface */",
+            "function I3() {}",
+            "/** @type {number} */",
+            "I3.prototype.length;")
+        .addSource(
+            "/** @type {I1} */", //
+            "var i1;",
+            "/** @type {I3} */",
+            "var i3;",
+            "i1 = i3;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching7_1() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function I1() {}",
+            "",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @type {number} */",
+            "C1.prototype.length;")
+        .addSource(
+            "/** @type {I1} */",
+            "var i1;" + "/** @type {C1} */",
+            "var c1;",
+            "i1 = c1;   // no warning")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching9() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @type {number} */",
+            "C1.prototype.length;",
+            "",
+            "/** @constructor */",
+            "function C2() {}",
+            "/** @type {number} */",
+            "C2.prototype.length;")
+        .addSource(
+            "/** @type {C1} */", //
+            "var c1;" + "/** @type {C2} */",
+            "var c2;",
+            "c1 = c2;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C2|null)",
+                "required: (C1|null)"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching11_1() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I3() {}",
+            "/** @type {number} */",
+            "I3.prototype.length;",
+            "",
+            "/** ",
+            " * @record",
+            " * @extends I3",
+            " */",
+            "function I4() {}",
+            "/** @type {boolean} */",
+            "I4.prototype.prop;",
+            "",
+            "/** @constructor */",
+            "function C4() {}",
+            "/** @type {number} */",
+            "C4.prototype.length;",
+            "/** @type {boolean} */",
+            "C4.prototype.prop;")
+        .addSource(
+            "/** @type {I4} */", //
+            "var i4;" + "/** @type {C4} */",
+            "var c4;",
+            "i4 = c4;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching13() {
+    newTest()
+        .addExterns(
+            "/**",
+            "   * @record",
+            "   */",
+            "  function I5() {}",
+            "  /** @type {I5} */",
+            "  I5.prototype.next;",
+            "",
+            "  /**",
+            "   * @interface",
+            "   */",
+            "  function C5() {}",
+            "  /** @type {C5} */",
+            "  C5.prototype.next;")
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching13_2() {
+    newTest()
+        .addExterns(
+            "/**",
+            "   * @record",
+            "   */",
+            "  function I5() {}",
+            "  /** @type {I5} */",
+            "  I5.prototype.next;",
+            "",
+            "  /**",
+            "   * @record",
+            "   */",
+            "  function C5() {}",
+            "  /** @type {C5} */",
+            "  C5.prototype.next;")
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching13_3() {
+    newTest()
+        .addExterns(
+            "/**",
+            "   * @interface",
+            "   */",
+            "  function I5() {}",
+            "  /** @type {I5} */",
+            "  I5.prototype.next;",
+            "",
+            "  /**",
+            "   * @record",
+            "   */",
+            "  function C5() {}",
+            "  /** @type {C5} */",
+            "  C5.prototype.next;")
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C5|null)",
+                "required: (I5|null)"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching15() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function I5() {}",
+            "/** @type {I5} */",
+            "I5.prototype.next;",
+            "",
+            "/** @constructor */",
+            "function C6() {}",
+            "/** @type {C6} */",
+            "C6.prototype.next;",
+            "",
+            "/** @constructor */",
+            "function C5() {}",
+            "/** @type {C6} */",
+            "C5.prototype.next;")
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * a very long structural chain, all property types from I5 and C5 are structurally the same, I5
+   * is declared as @record so structural interface matching will be performed
+   */
+  private static final String EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD =
+      lines(
+          "/** @record */",
+          "function I5() {}",
+          "/** @type {I5} */",
+          "I5.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6() {}",
+          "/** @type {C6} */",
+          "C6.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_1() {}",
+          "/** @type {C6} */",
+          "C6_1.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_2() {}",
+          "/** @type {C6_1} */",
+          "C6_2.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_3() {}",
+          "/** @type {C6_2} */",
+          "C6_3.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_4() {}",
+          "/** @type {C6_3} */",
+          "C6_4.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_5() {}",
+          "/** @type {C6_4} */",
+          "C6_5.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C5() {}",
+          "/** @type {C6_5} */",
+          "C5.prototype.next;");
+
+  @Test
+  public void testStructuralInterfaceMatching16_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching17_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
+        .addSource(
+            "/** @type {C5} */",
+            "var c5;",
+            "/**",
+            " * @param {I5} i5",
+            " */",
+            "function f(i5) {}",
+            "",
+            "f(c5);")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching18_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;" + "/** @type {C5} */",
+            "var c5;",
+            "i5.next = c5;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * a very long non-structural chain, there is a slight difference between the property type
+   * structural of I5 and that of C5: I5.next.next.next.next.next has type I5 while
+   * C5.next.next.next.next.next has type number
+   */
+  private static final String EXTERNS_FOR_LONG_NONMATCHING_CHAIN =
+      lines(
+          "/** @record */",
+          "function I5() {}",
+          "/** @type {I5} */",
+          "I5.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6() {}",
+          "/** @type {number} */",
+          "C6.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_1() {}",
+          "/** @type {C6} */",
+          "C6_1.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_2() {}",
+          "/** @type {C6_1} */",
+          "C6_2.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_3() {}",
+          "/** @type {C6_2} */",
+          "C6_3.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_4() {}",
+          "/** @type {C6_3} */",
+          "C6_4.prototype.next;",
+          "",
+          "/** @constructor */",
+          "function C6_5() {}",
+          "/** @type {C6_4} */",
+          "C6_5.prototype.next;",
+          "",
+          "/** @interface */",
+          "function C5() {}",
+          "/** @type {C6_5} */",
+          "C5.prototype.next;");
+
+  @Test
+  public void testStructuralInterfaceMatching19() {
+    // the type structure of I5 and C5 are different
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;",
+            "/** @type {C5} */",
+            "var c5;",
+            "i5 = c5;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C5|null)",
+                "required: (I5|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching20() {
+    // the type structure of I5 and C5 are different
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
+        .addSource(
+            "/** @type {C5} */",
+            "var c5;",
+            "/**",
+            " * @param {I5} i5",
+            " */",
+            "function f(i5) {}",
+            "",
+            "f(c5);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : (C5|null)",
+                "required: (I5|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching21() {
+    // the type structure of I5 and C5 are different
+    newTest()
+        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
+        .addSource(
+            "/** @type {I5} */", //
+            "var i5;",
+            "/** @type {C5} */",
+            "var c5;",
+            "i5.next = c5;")
+        .addDiagnostic(
+            lines(
+                "assignment to property next of I5", //
+                "found   : (C5|null)",
+                "required: (I5|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the return types of the ordinary function types match (should match, since declared
+   * with @record)
+   */
+  @Test
+  public void testStructuralInterfaceMatching22_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the return types of the ordinary function types match (should not match)
+   */
+  @Test
+  public void testStructuralInterfaceMatching23() {
+    // the type structure of I5 and C5 are different
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_NONMATCHING_CHAIN,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C7|null)",
+                "required: (I7|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the parameter types of the ordinary function types match (should match, since declared
+   * with @record)
+   */
+  @Test
+  public void testStructuralInterfaceMatching24_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(C5): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(I5): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the parameter types of the ordinary function types match (should match, since declared
+   * with @record)
+   */
+  @Test
+  public void testStructuralInterfaceMatching26_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(C5, C5, I5): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(I5, C5): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the parameter types of the ordinary function types match (should match)
+   */
+  @Test
+  public void testStructuralInterfaceMatching29_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** the "this" of I5 and C5 are covariants, so should match */
+  @Test
+  public void testStructuralInterfaceMatching30_1_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** the "this" of I5 and C5 are covariants, so should match */
+  @Test
+  public void testStructuralInterfaceMatching30_2_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** the "this" of I5 and C5 are covariants, so should match */
+  @Test
+  public void testStructuralInterfaceMatching30_3_1() {
+    newTest()
+        .addExterns(
+            "/** @record */ function I5() {}",
+            "/** @constructor @implements {I5} */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** I7 is declared with @record tag, so it will match */
+  @Test
+  public void testStructuralInterfaceMatching30_3_2() {
+    newTest()
+        .addExterns(
+            "/** @interface */ function I5() {}",
+            "/** @constructor @implements {I5} */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * Although I7 is declared with @record tag, note that I5 is declared with @interface and C5 does
+   * not extend I5, so it will not match
+   */
+  @Test
+  public void testStructuralInterfaceMatching30_3_3() {
+    newTest()
+        .addExterns(
+            "/** @interface */ function I5() {}",
+            "/** @constructor */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C7|null)",
+                "required: (I7|null)"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching30_3_4() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            "/** @record */ function I5() {}",
+            "/** @constructor */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** the "this" of I5 and C5 are covariants, so should match */
+  @Test
+  public void testStructuralInterfaceMatching30_4_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            "/** @record */ function I5() {}",
+            "/** @constructor @implements {I5} */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * although I7 is declared with @record tag I5 is declared with @interface tag, so no structural
+   * interface matching
+   */
+  @Test
+  public void testStructuralInterfaceMatching30_4_2() {
+    newTest()
+        .addExterns(
+            "/** @interface */ function I5() {}",
+            "/** @constructor */ function C5() {}",
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C7|null)",
+                "required: (I7|null)"))
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the this types of the ordinary function types match (should match)
+   */
+  @Test
+  public void testStructuralInterfaceMatching31_1() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** test structural interface matching for record types */
+  @Test
+  public void testStructuralInterfaceMatching32_2() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {{prop: I7, prop2: C7}}*/",
+            "var r1;",
+            "/** @type {{prop: C7, prop2: C7}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** test structural interface matching for record types */
+  @Test
+  public void testStructuralInterfaceMatching33_3() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {{prop: I7, prop2: C7}}*/",
+            "var r1;",
+            "/** @type {{prop: C7, prop2: C7, prop3: C7}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * test structural interface matching for a combination of ordinary function types and record
+   * types
+   */
+  @Test
+  public void testStructuralInterfaceMatching36_2() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
+            " var com1;",
+            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
+            "var com2;",
+            "",
+            "com1 = com2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * test structural interface matching for a combination of ordinary function types and record
+   * types
+   */
+  @Test
+  public void testStructuralInterfaceMatching36_3() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
+            " var com1;",
+            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
+            "var com2;",
+            "",
+            "com1 = com2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * test structural interface matching for a combination of ordinary function types and record
+   * types here C7 does not structurally match I7
+   */
+  @Test
+  public void testStructuralInterfaceMatching37() {
+    // the type structure of I5 and C5 are different
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_NONMATCHING_CHAIN,
+            "/** @record */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
+            "var com1;",
+            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
+            "var com2;",
+            "",
+            "com1 = com2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {\n  fun: function((I7|null)): (C7|null),\n  prop: {prop: (C7|null)}\n}",
+                "required: {\n  fun: function((C7|null)): (I7|null),\n  prop: {prop: (I7|null)}\n}",
+                "missing : []",
+                "mismatch: [fun,prop]"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_39() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {I2} */", //
+            "var o1 = {length : 'test'};")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : {length: string}",
+                "required: (I2|null)",
+                "missing : []",
+                "mismatch: [length]"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_matching() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {I2} */", //
+            "var o1 = {length : 123};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_matching() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {",
+            "  /** @type {number} */",
+            "  this.length;",
+            "}")
+        .addSource(
+            "/** @type {!I2} */", //
+            "var o1 = {length : 123};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_missing() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {!I2} */", //
+            "var o1 = {};")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : {}",
+                "required: I2",
+                "missing : [length]",
+                "mismatch: []"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_missing() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {",
+            "  /** @type {number} */",
+            "  this.length;",
+            "}")
+        .addSource(
+            "/** @type {!I2} */", //
+            "var o1 = {};")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : {}",
+                "required: I2",
+                "missing : [length]",
+                "mismatch: []"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_mismatch() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {!I2} */", //
+            "var o1 = {length: null};")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : {length: null}",
+                "required: I2",
+                "missing : []",
+                "mismatch: [length]"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_mismatch() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {",
+            "  /** @type {number} */",
+            "  this.length;",
+            "}")
+        .addSource(
+            "/** @type {!I2} */", //
+            "var o1 = {length: null};")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : {length: null}",
+                "required: I2",
+                "missing : []",
+                "mismatch: [length]"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_41() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {I2} */",
+            "var o1 = {length : 123};",
+            "/** @type {I2} */",
+            "var i;",
+            "i = o1;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching41_forObjectLiterals_41_1() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {I2} */",
+            "var o1 = {length : 123};",
+            "/** @type {I2} */",
+            "var i;",
+            "i = o1;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_42() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "/** @type {{length: number}} */",
+            "var o1 = {length : 123};",
+            "/** @type {I2} */",
+            "var i;",
+            "i = o1;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching_forObjectLiterals_43() {
+    newTest()
+        .addExterns(
+            "/** @record */", //
+            "function I2() {}",
+            "/** @type {number} */",
+            "I2.prototype.length;")
+        .addSource(
+            "var o1 = {length : 123};", //
+            "/** @type {I2} */",
+            "var i;",
+            "i = o1;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching44() {
+    newTest()
+        .addExterns(
+            "/** @record */ function I() {}",
+            "/** @type {!Function} */ I.prototype.removeEventListener;",
+            "/** @type {!Function} */ I.prototype.addEventListener;",
+            "/** @constructor */ function C() {}",
+            "/** @type {!Function} */ C.prototype.addEventListener;")
+        .addSource(
+            "/** @param {C|I} x */", //
+            "function f(x) { x.addEventListener(); }",
+            "f(new C());")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /**
+   * Currently, the structural interface matching does not support structural matching for template
+   * types Using @template @interfaces requires @implements them explicitly.
+   */
+  @Test
+  public void testStructuralInterfaceMatching45() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @record",
+            " * @template X",
+            " */",
+            "function I() {}",
+            "/** @constructor */",
+            "function C() {}",
+            "var /** !I */ i = new C;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching46() {
+    newTest()
+        .addSource(
+            "/** @interface */",
+            "function I2() {}",
+            "/**",
+            " * @interface",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}",
+            "/**",
+            " * @record",
+            " * @extends {I3}",
+            " */",
+            "function I4() {}",
+            "/** @type {I4} */",
+            "var i4;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i4 = i2;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching47() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I2() {}",
+            "/**",
+            " * @interface",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}",
+            "/**",
+            " * @record",
+            " * @extends {I3}",
+            " */",
+            "function I4() {}")
+        .addSource(
+            "/** @type {I4} */", //
+            "var i4;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i4 = i2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching48() {
+    newTest()
+        .addExterns("")
+        .addSource(
+            "/** @interface */",
+            "function I2() {}",
+            "/**",
+            " * @record",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}",
+            "/** @type {I3} */",
+            "var i3;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i3 = i2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching49() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I2() {}",
+            "/**",
+            " * @record",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}")
+        .addSource(
+            "/** @type {I3} */", //
+            "var i3;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i3 = i2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching49_2() {
+    newTest()
+        .addExterns(
+            "/** @record */",
+            "function I2() {}",
+            "/**",
+            " * @record",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}")
+        .addSource(
+            "/** @type {I3} */", //
+            "var i3;",
+            "/** @type {I2} */",
+            "var i2;",
+            "i3 = i2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching50() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I2() {}",
+            "/**",
+            " * @record",
+            " * @extends {I2}",
+            " */",
+            "function I3() {}")
+        .addSource(
+            "/** @type {I3} */",
+            "var i3;",
+            "/** @type {{length : number}} */",
+            "var r = {length: 123};",
+            "i3 = r;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceMatching1_1() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Interface1() {}",
+            "/** @type {number} */",
+            "Interface1.prototype.length;",
+            "",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @type {number} */",
+            "C1.prototype.length;")
+        .addSource(
+            "/** @type{Interface1} */",
+            "var obj1;",
+            "/** @type{C1} */",
+            "var obj2 = new C1();",
+            "obj1 = obj2;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C1|null)",
+                "required: (Interface1|null)"))
+        .run();
+  }
+
+  /**
+   * structural interface matching will also be able to structurally match ordinary function types
+   * check if the return types of the ordinary function types match (should not match, since I7 is
+   * declared with @interface)
+   */
+  @Test
+  public void testStructuralInterfaceMatching22_2() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
+            "/** @interface */",
+            "function I7() {}",
+            "/** @type{function(): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C7|null)",
+                "required: (I7|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  /** declared with @interface, no structural interface matching */
+  @Test
+  public void testStructuralInterfaceMatching30_3() {
+    // I5 and C5 shares the same type structure
+    newTest()
+        .addExterns(
+            "/** @interface */ function I5() {}",
+            "/** @constructor @implements {I5} */ function C5() {}",
+            "/** @interface */",
+            "function I7() {}",
+            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
+            "I7.prototype.getElement = function(){};",
+            "",
+            "/** @constructor */",
+            "function C7() {}",
+            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
+            "C7.prototype.getElement = function(){};")
+        .addSource(
+            "/** @type {I7} */", //
+            "var i7;",
+            "/** @type {C7} */",
+            "var c7;",
+            "",
+            "i7 = c7;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (C7|null)",
+                "required: (I7|null)"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceWithOptionalProperty() {
+    newTest()
+        .addSource(
+            "/** @record */ function Rec() {}",
+            "/** @type {string} */ Rec.prototype.str;",
+            "/** @type {(number|undefined)} */ Rec.prototype.opt_num;",
+            "",
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** !Rec */ x = new Foo;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceWithUnknownProperty() {
+    newTest()
+        .addSource(
+            "/** @record */ function Rec() {}",
+            "/** @type {string} */ Rec.prototype.str;",
+            "/** @type {?} */ Rec.prototype.unknown;",
+            "",
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** !Rec */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: Rec",
+                "missing : [unknown]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceWithOptionalUnknownProperty() {
+    newTest()
+        .addSource(
+            "/** @record */ function Rec() {}",
+            "/** @type {string} */ Rec.prototype.str;",
+            "/** @type {?|undefined} */ Rec.prototype.opt_unknown;",
+            "",
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** !Rec */ x = new Foo;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceWithTopProperty() {
+    newTest()
+        .addSource(
+            "/** @record */ function Rec() {}",
+            "/** @type {string} */ Rec.prototype.str;",
+            "/** @type {*} */ Rec.prototype.top;",
+            "",
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** !Rec */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: Rec",
+                "missing : [top]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfaceCycleDoesntCrash() {
+    newTest()
+        .addSource(
+            "/**  @record */ function Foo() {};",
+            "/**  @return {MutableFoo} */ Foo.prototype.toMutable;",
+            "/**  @record */ function MutableFoo() {};",
+            "/**  @param {Foo} from */ MutableFoo.prototype.copyFrom;",
+            "",
+            "/**  @record */ function Bar() {};",
+            "/**  @return {MutableBar} */ Bar.prototype.toMutable;",
+            "/**  @record */ function MutableBar() {};",
+            "/**  @param {Bar} from */ MutableBar.prototype.copyFrom;",
+            "",
+            "/** @constructor @implements {MutableBar} */ function MutableBarImpl() {};",
+            "/** @override */ MutableBarImpl.prototype.copyFrom = function(from) {};",
+            "/** @constructor  @implements {MutableFoo} */ function MutableFooImpl() {};",
+            "/** @override */ MutableFooImpl.prototype.copyFrom = function(from) {};")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchOwnProperties1() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.prop = 5;",
+            "}",
+            "var /** !WithProp */ wp = new Foo;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchOwnProperties2() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.oops = 5;",
+            "}",
+            "var /** !WithProp */ wp = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: WithProp",
+                "missing : [prop]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchOwnProperties3() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {string} */ this.prop = 'str';",
+            "}",
+            "var /** !WithProp */ wp = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: WithProp",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchFunctionNamespace1() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "var ns = function() {};",
+            "/** @type {number} */ ns.prop;",
+            "var /** !WithProp */ wp = ns;")
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchFunctionNamespace2() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "var ns = function() {};",
+            "/** @type {number} */ ns.oops;",
+            "var /** !WithProp */ wp = ns;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : function(): undefined",
+                "required: WithProp",
+                "missing : [prop]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testStructuralInterfacesMatchFunctionNamespace3() {
+    newTest()
+        .addSource(
+            "/** @record */ function WithProp() {}",
+            "/** @type {number} */ WithProp.prototype.prop;",
+            "",
+            "var ns = function() {};",
+            "/** @type {string} */ ns.prop;",
+            "var /** !WithProp */ wp = ns;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : function(): undefined",
+                "required: WithProp",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testRecursiveTemplatizedStructuralInterface() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @record",
+            " * @template T",
+            " */",
+            "var Rec = function() { };",
+            "/** @type {!Rec<T>} */",
+            "Rec.prototype.p;",
+            "",
+            "/**",
+            " * @constructor @implements {Rec<U>}",
+            " * @template U",
+            " */",
+            "var Foo = function() {};",
+            "/** @override */",
+            "Foo.prototype.p = new Foo;")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java b/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java
new file mode 100644
index 0000000..982214a
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java
@@ -0,0 +1,573 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.javascript.rhino.jstype.JSType;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckTemplatizedTest extends TypeCheckTestCase {
+
+  @Test
+  public void testTemplatizedArray1() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray2() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<!Array<number>>} a\n"
+                + "* @return {number}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : Array<number>\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray3() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<number>} a\n"
+                + "* @return {number}\n"
+                + "*/ var f = function(a) { a[1] = 0; return a[0]; };")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray4() {
+    newTest()
+        .addSource("/** @param {!Array<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray5() {
+    newTest()
+        .addSource("/** @param {!Array<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray6() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<*>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : *\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray7() {
+    newTest()
+        .addSource(
+            "/** @param {?Array<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject1() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObjectOnWindow() {
+    newTest()
+        .addExterns("/** @constructor */ window.Object = Object;")
+        .addSource(
+            "/** @param {!window.Object<number>} a",
+            " *  @return {string}",
+            " */ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObjectOnWindow2() {
+    newTest()
+        .addExterns("/** @const */ window.Object = Object;")
+        .addSource(
+            "/** @param {!window.Object<number>} a",
+            " *  @return {string}",
+            " */ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject2() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<string,number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject3() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<number,string>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject4() {
+    newTest()
+        .addSource(
+            "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n"
+                + "/** @param {!Object<E,string>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: E<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject5() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {"
+                + "  /** @type {Object<number, string>} */ this.numbers = {};"
+                + "}"
+                + "(new F()).numbers['ten'] = '10';")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized1() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */"
+                + "var arr1 = [];\n"
+                + "/** @type {!Array<number>} */"
+                + "var arr2 = [];\n"
+                + "arr1 = arr2;")
+        .addDiagnostic("assignment\n" + "found   : Array<number>\n" + "required: Array<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized2() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : Array<number>\n" + "required: Array<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized3() {
+    newTest()
+        .addSource(
+            "/** @type {Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : Array<number>\n"
+                + "required: (Array<string>|null)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized4() {
+    newTest()
+        .addSource(
+            "/** @type {Array<string>} */"
+                + "var arr1 = [];\n"
+                + "/** @type {Array<number>} */"
+                + "var arr2 = arr1;\n")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : (Array<string>|null)\n"
+                + "required: (Array<number>|null)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized5() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {Object<T>} obj\n"
+                + " * @return {boolean|undefined}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var some = function(obj) {"
+                + "  for (var key in obj) if (obj[key]) return true;"
+                + "};"
+                + "/** @return {!Array} */ function f() { return []; }"
+                + "/** @return {!Array<string>} */ function g() { return []; }"
+                + "some(f());\n"
+                + "some(g());\n")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized6() {
+    newTest()
+        .addSource(
+            "/** @interface */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {I}\n"
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + ""
+                + "/** @type {null} */ var some = new C().method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized7() {
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " * @implements {I<number>}\n"
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {null} */ var some = new C().method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  @Ignore
+  public void testTemplatized8() {
+    // TODO(johnlenz): this should generate a warning but does not.
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " *  @implements {I<R>}\n"
+                + " *  @template R\n "
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {C<number>} var x = new C();"
+                + "/** @type {null} */ var some = x.method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized9() {
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " *  @param {R} a\n"
+                + " *  @implements {I<R>}\n"
+                + " *  @template R\n "
+                + " */ function C(a){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {null} */ var some = new C(1).method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized10() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Parent() {};\n"
+                + "\n"
+                + "/** @param {T} x */\n"
+                + "Parent.prototype.method = function(x) {};\n"
+                + "\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Parent<string>}\n"
+                + " */\n"
+                + "function Child() {};\n"
+                + "Child.prototype = new Parent();\n"
+                + "\n"
+                + "(new Child()).method(123); \n")
+        .addDiagnostic(
+            "actual parameter 1 of Parent.prototype.method does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized11() {
+    newTest()
+        .addSource(
+            "/** \n"
+                + " * @template T\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C() {}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {T|K} a\n"
+                + " * @return {T}\n"
+                + " * @template K\n"
+                + " */\n"
+                + "C.prototype.method = function(a) {};\n"
+                + "\n"
+                +
+                // method returns "?"
+                "/** @type {void} */ var x = new C().method(1);")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedTypeSubtypes2() {
+    JSType arrayOfNumber = createTemplatizedType(getNativeArrayType(), getNativeNumberType());
+    JSType arrayOfString = createTemplatizedType(getNativeArrayType(), getNativeStringType());
+    assertThat(arrayOfString.isSubtypeOf(createUnionType(arrayOfNumber, getNativeNullVoidType())))
+        .isFalse();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch1() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop;",
+            "function f(/** !WithPropT<number> */ x){}",
+            "/** @constructor */ function Foo() {}",
+            "/** @type {number} */ Foo.prototype.prop;",
+            "f(new Foo);")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch2() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {number} */ Foo.prototype.prop",
+            "f(new Foo)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch3() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<string> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {U} */ Foo.prototype.prop",
+            "f(new Foo)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch1() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor */ function Foo() {}",
+            "/** @type {string} */ Foo.prototype.prop = 'str'",
+            "f(new Foo)")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch2() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {string} */ Foo.prototype.prop = 'str'",
+            "f(new Foo)")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<?>",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch3() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/**",
+            " * @constructor",
+            " * @template U",
+            " * @param {U} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {U} */ this.prop = x",
+            "}",
+            "f(new Foo('str'))")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<string>",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch4() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithProp() {}",
+            "/** @type {T} */ WithProp.prototype.prop;",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.prop = 4;",
+            "}",
+            "/**",
+            " * @template U",
+            " * @param {!WithProp<U>} x",
+            " * @param {U} y",
+            " */",
+            "function f(x, y){};",
+            "f(new Foo, 'str')")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo",
+                "required: WithProp<string>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatchNotFound() {
+    // TODO(blickly): We would like to find the parameter mismatch here.
+    // Currently they match with type WithProp<?>, which is somewhat unsatisfying.
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithProp() {}",
+            "/** @type {T} */ WithProp.prototype.prop;",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.prop = 4;",
+            "}",
+            "/** @constructor */",
+            "function Bar() {",
+            "  /** @type {string} */ this.prop = 'str';",
+            "}",
+            "/**",
+            " * @template U",
+            " * @param {!WithProp<U>} x",
+            " * @param {!WithProp<U>} y",
+            " */",
+            "function f(x, y){};",
+            "f(new Foo, new Bar)")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index 8b11904..0967062 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.jscomp.TypeCheck.CONFLICTING_GETTER_SETTER_TYPE;
+import static com.google.javascript.jscomp.TypeCheck.ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE;
 import static com.google.javascript.jscomp.TypeCheck.INSTANTIATE_ABSTRACT_CLASS;
 import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION;
 import static com.google.javascript.jscomp.TypeCheck.STRICT_INEXISTENT_PROPERTY;
@@ -46,6 +47,7 @@ import com.google.javascript.rhino.jstype.ObjectType;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -419,165 +421,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testTemplatizedArray1() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray2() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<!Array<number>>} a\n"
-                + "* @return {number}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : Array<number>\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray3() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<number>} a\n"
-                + "* @return {number}\n"
-                + "*/ var f = function(a) { a[1] = 0; return a[0]; };")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray4() {
-    newTest()
-        .addSource("/** @param {!Array<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray5() {
-    newTest()
-        .addSource("/** @param {!Array<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray6() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<*>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : *\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray7() {
-    newTest()
-        .addSource(
-            "/** @param {?Array<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject1() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObjectOnWindow() {
-    newTest()
-        .addExterns("/** @constructor */ window.Object = Object;")
-        .addSource(
-            "/** @param {!window.Object<number>} a",
-            " *  @return {string}",
-            " */ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObjectOnWindow2() {
-    newTest()
-        .addExterns("/** @const */ window.Object = Object;")
-        .addSource(
-            "/** @param {!window.Object<number>} a",
-            " *  @return {string}",
-            " */ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject2() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<string,number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject3() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<number,string>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject4() {
-    newTest()
-        .addSource(
-            "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n"
-                + "/** @param {!Object<E,string>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: E<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject5() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {"
-                + "  /** @type {Object<number, string>} */ this.numbers = {};"
-                + "}"
-                + "(new F()).numbers['ten'] = '10';")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
   public void testUnionOfFunctionAndType() {
     newTest()
         .addSource(
@@ -2165,5905 +2008,5922 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testAbstractMethodInAbstractClass() {
+  public void testPropertyUsedBeforeDefinition1() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var C = function() {};",
-            "/** @abstract */ C.prototype.foo = function() {};")
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @return {string} */"
+                + "T.prototype.f = function() { return this.g(); };\n"
+                + "/** @return {number} */ T.prototype.g = function() { return 1; };\n")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInAbstractEs6Class() {
+  public void testPropertyUsedBeforeDefinition2() {
     newTest()
         .addSource(
-            "/** @abstract */ class C {", //
-            "  /** @abstract */ foo() {}",
-            "}")
+            "var n = {};\n"
+                + "/** @constructor */ n.T = function() {};\n"
+                + "/** @return {string} */"
+                + "n.T.prototype.f = function() { return this.g(); };\n"
+                + "/** @return {number} */ n.T.prototype.g = function() { return 1; };\n")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInConcreteClass() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var C = function() {};",
-            "/** @abstract */ C.prototype.foo = function() {};")
-        .addDiagnostic(
-            "Abstract methods can only appear in abstract classes. Please declare the class as "
-                + "@abstract")
-        .run();
+  public void testAdd1() {
+    newTest().addSource("/**@return {void}*/function foo(){var a = 'abc'+foo();}").run();
+  }
+
+  @Test
+  public void testAdd2() {
+    newTest().addSource("/**@return {void}*/function foo(){var a = foo()+4;}").run();
   }
 
   @Test
-  public void testAbstractMethodInConcreteEs6Class() {
+  public void testAdd3() {
     newTest()
         .addSource(
-            "class C {", //
-            "  /** @abstract */ foo() {}",
-            "}")
-        .addDiagnostic(
-            "Abstract methods can only appear in abstract classes. Please declare the class as "
-                + "@abstract")
+            "/** @type {string} */ var a = 'a';"
+                + "/** @type {string} */ var b = 'b';"
+                + "/** @type {string} */ var c = a + b;")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInConcreteClassExtendingAbstractClass() {
+  public void testAdd4() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @abstract */ B.prototype.foo = function() {};")
-        .addDiagnostic(
-            "Abstract methods can only appear in abstract classes. Please declare the class as "
-                + "@abstract")
+            "/** @type {number} */ var a = 5;"
+                + "/** @type {string} */ var b = 'b';"
+                + "/** @type {string} */ var c = a + b;")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInConcreteEs6ClassExtendingAbstractEs6Class() {
+  public void testAdd5() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {}",
-            "/** @extends {A} */ class B {",
-            "  /** @abstract */ foo() {}",
-            "}")
-        .addDiagnostic(
-            "Abstract methods can only appear in abstract classes. Please declare the class as "
-                + "@abstract")
+            "/** @type {string} */ var a = 'a';"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {string} */ var c = a + b;")
         .run();
   }
 
   @Test
-  public void testConcreteMethodOverridingAbstractMethod() {
+  public void testAdd6() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() {};")
+            "/** @type {number} */ var a = 5;"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {number} */ var c = a + b;")
         .run();
   }
 
   @Test
-  public void testConcreteMethodOverridingAbstractMethodInEs6() {
+  public void testAdd7() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract*/ foo() {}",
-            "}",
-            "/** @extends {A} */ class B {",
-            "  /** @override */ foo() {}",
-            "}")
+            "/** @type {number} */ var a = 5;"
+                + "/** @type {string} */ var b = 'b';"
+                + "/** @type {number} */ var c = a + b;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testConcreteMethodInAbstractClass1() {
+  public void testAdd8() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};")
+            "/** @type {string} */ var a = 'a';"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {number} */ var c = a + b;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testConcreteMethodInAbstractEs6Class1() {
+  public void testAdd9() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {", //
-            "  foo() {}",
-            "}",
-            "class B extends A {}")
-        .includeDefaultExterns()
+            "/** @type {number} */ var a = 5;"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {string} */ var c = a + b;")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testConcreteMethodInAbstractClass2() {
-    // Currently goog.abstractMethod are not considered abstract, so no warning is given when a
-    // concrete subclass fails to implement it.
+  public void testAdd10() {
+    // d.e.f will have unknown type.
     newTest()
         .addSource(
-            CLOSURE_DEFS,
-            "/** @abstract @constructor */ var A = function() {};",
-            "A.prototype.foo = goog.abstractMethod;",
-            "/** @constructor @extends {A} */ var B = function() {};")
+            suppressMissingProperty("e", "f")
+                + "/** @type {number} */ var a = 5;"
+                + "/** @type {string} */ var c = a + d.e.f;")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInInterface() {
-    // TODO(moz): There's no need to tag methods with @abstract in interfaces, maybe give a warning
-    // on this.
+  public void testAdd11() {
+    // d.e.f will have unknown type.
     newTest()
         .addSource(
-            "/** @interface */ var I = function() {};",
-            "/** @abstract */ I.prototype.foo = function() {};")
+            suppressMissingProperty("e", "f")
+                + "/** @type {number} */ var a = 5;"
+                + "/** @type {number} */ var c = a + d.e.f;")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6Interface() {
-    // TODO(moz): There's no need to tag methods with @abstract in interfaces, maybe give a warning
-    // on this.
+  public void testAdd12() {
     newTest()
         .addSource(
-            "/** @interface */ class I {", //
-            "  /** @abstract */ foo() {}",
-            "};")
-        .includeDefaultExterns()
+            "/** @return {(number|string)} */ function a() { return 5; }"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {boolean} */ var c = a() + b;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented1() {
+  public void testAdd13() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};")
-        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+            "/** @type {number} */ var a = 5;"
+                + "/** @return {(number|string)} */ function b() { return 5; }"
+                + "/** @type {boolean} */ var c = a + b();")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6NotImplemented1() {
+  public void testAdd14() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "}",
-            "class B extends A {}")
-        .addDiagnostic("property foo on abstract class A is not implemented by type B")
-        .includeDefaultExterns()
+            "/** @type {(null|string)} */ var a = unknown;"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {boolean} */ var c = a + b;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented2() {
+  public void testAdd15() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @abstract */ A.prototype.bar = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() {};")
-        .addDiagnostic("property bar on abstract class A is not implemented by type B")
+            "/** @type {number} */ var a = 5;"
+                + "/** @return {(number|string)} */ function b() { return 5; }"
+                + "/** @type {boolean} */ var c = a + b();")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6NotImplemented2() {
+  public void testAdd16() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "  /** @abstract */ bar() {}",
-            "}",
-            "class B extends A {",
-            "  /** @override */ foo() {}",
-            "}")
-        .addDiagnostic("property bar on abstract class A is not implemented by type B")
-        .includeDefaultExterns()
+            "/** @type {(undefined|string)} */ var a = unknown;"
+                + "/** @type {number} */ var b = 5;"
+                + "/** @type {boolean} */ var c = a + b;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented3() {
+  public void testAdd17() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @abstract @constructor @extends {A} */ var B = function() {};",
-            "/** @abstract @override */ B.prototype.foo = function() {};",
-            "/** @constructor @extends {B} */ var C = function() {};")
-        .addDiagnostic("property foo on abstract class B is not implemented by type C")
+            "/** @type {number} */ var a = 5;"
+                + "/** @type {(undefined|string)} */ var b = unknown;"
+                + "/** @type {boolean} */ var c = a + b;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6NotImplemented3() {
+  public void testAdd18() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "}",
-            "/** @abstract */ class B extends A {",
-            "  /** @abstract @override */ foo() {}",
-            "}",
-            "class C extends B {}")
-        .addDiagnostic("property foo on abstract class B is not implemented by type C")
-        .includeDefaultExterns()
+            "function f() {};"
+                + "/** @type {string} */ var a = 'a';"
+                + "/** @type {number} */ var c = a + f();")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented4() {
+  public void testAdd19() {
     newTest()
         .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @abstract @constructor @extends {A} */ var B = function() {};",
-            "/** @constructor @extends {B} */ var C = function() {};")
-        .addDiagnostic("property foo on abstract class A is not implemented by type C")
+            "/** @param {number} opt_x\n@param {number} opt_y\n"
+                + "@return {number} */ function f(opt_x, opt_y) {"
+                + "return opt_x + opt_y;}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6NotImplemented4() {
+  public void testAdd20() {
     newTest()
         .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "}",
-            "/** @abstract */ class B extends A {}",
-            "class C extends B {}")
-        .addDiagnostic("property foo on abstract class A is not implemented by type C")
-        .includeDefaultExterns()
+            "/** @param {!Number} opt_x\n@param {!Number} opt_y\n"
+                + "@return {number} */ function f(opt_x, opt_y) {"
+                + "return opt_x + opt_y;}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented5() {
+  public void testAdd21() {
     newTest()
         .addSource(
-            "/** @interface */ var I = function() {};",
-            "I.prototype.foo = function() {};",
-            "/** @abstract @constructor @implements {I} */ var A = function() {};",
-            "/** @abstract @override */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};")
-        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+            "/** @param {Number|Boolean} opt_x\n"
+                + "@param {number|boolean} opt_y\n"
+                + "@return {number} */ function f(opt_x, opt_y) {"
+                + "return opt_x + opt_y;}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6NotImplemented5() {
-    newTest()
-        .addSource(
-            "/** @interface */ class I {",
-            "  foo() {}",
-            "  bar() {}", // Not overridden by abstract class
-            "}",
-            "/** @abstract @implements {I} */ class A {",
-            "  /** @abstract @override */ foo() {}",
-            "}",
-            "class B extends A {}")
-        .addDiagnostic("property bar on interface I is not implemented by type B")
-        .addDiagnostic("property foo on abstract class A is not implemented by type B")
-        .run();
+  public void testNumericComparison1() {
+    newTest().addSource("/**@param {number} a*/ function f(a) {return a < 3;}").run();
   }
 
   @Test
-  public void testAbstractMethodNotImplemented6() {
+  public void testNumericComparison2() {
     newTest()
-        .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override @type {number} */ B.prototype.foo;")
-        .addDiagnostic("property foo on abstract class A is not implemented by type B")
+        .addSource("/**@param {!Object} a*/ function f(a) {return a < 3;}")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison", //
+                "found   : Object",
+                "required: (bigint|number)"))
         .run();
   }
 
   @Test
-  public void testAbstractMethodImplemented1() {
-    newTest()
-        .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @abstract */ A.prototype.bar = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() {};",
-            "/** @override */ B.prototype.bar = function() {};",
-            "/** @constructor @extends {B} */ var C = function() {};")
-        .run();
+  public void testNumericComparison3() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("/**@param {string} a*/ function f(a) {return a < 3;}").run();
   }
 
   @Test
-  public void testAbstractMethodInEs6Implemented1() {
+  public void testNumericComparison4() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
-        .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "  /** @abstract */ bar() {}",
-            "}",
-            "class B extends A {",
-            "  /** @override */ foo() {}",
-            "  /** @override */ bar() {}",
-            "}",
-            "class C extends B {}")
-        .includeDefaultExterns()
+        .addSource("/**@param {(number|undefined)} a*/ " + "function f(a) {return a < 3;}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodImplemented2() {
+  public void testNumericComparison5() {
     newTest()
-        .addSource(
-            "/** @abstract @constructor */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @abstract */ A.prototype.bar = function() {};",
-            "/** @abstract @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() {};",
-            "/** @constructor @extends {B} */ var C = function() {};",
-            "/** @override */ C.prototype.bar = function() {};")
+        .addSource("/**@param {*} a*/ function f(a) {return a < 3;}")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison", //
+                "found   : *",
+                "required: (bigint|number)"))
         .run();
   }
 
   @Test
-  public void testAbstractMethodInEs6Implemented2() {
+  public void testNumericComparison6() {
     newTest()
-        .addSource(
-            "/** @abstract */ class A {",
-            "  /** @abstract */ foo() {}",
-            "  /** @abstract */ bar() {}",
-            "}",
-            "/** @abstract */ class B extends A {",
-            "  /** @override */ foo() {}",
-            "}",
-            "class C extends B {",
-            "  /** @override */ bar() {}",
-            "}")
-        .includeDefaultExterns()
+        .addSource("/**@return {void} */ function foo() { if (3 >= foo()) return; }")
+        .addDiagnostic(
+            lines(
+                "right side of numeric comparison",
+                "found   : undefined",
+                "required: (bigint|number)"))
         .run();
   }
 
   @Test
-  public void testPropertyUsedBeforeDefinition1() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @return {string} */"
-                + "T.prototype.f = function() { return this.g(); };\n"
-                + "/** @return {number} */ T.prototype.g = function() { return 1; };\n")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testStringComparison1() {
+    newTest().addSource("/**@param {string} a*/ function f(a) {return a < 'x';}").run();
   }
 
   @Test
-  public void testPropertyUsedBeforeDefinition2() {
-    newTest()
-        .addSource(
-            "var n = {};\n"
-                + "/** @constructor */ n.T = function() {};\n"
-                + "/** @return {string} */"
-                + "n.T.prototype.f = function() { return this.g(); };\n"
-                + "/** @return {number} */ n.T.prototype.g = function() { return 1; };\n")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testStringComparison2() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("/**@param {Object} a*/ function f(a) {return a < 'x';}").run();
   }
 
   @Test
-  public void testAdd1() {
-    newTest().addSource("/**@return {void}*/function foo(){var a = 'abc'+foo();}").run();
+  public void testStringComparison3() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("/**@param {number} a*/ function f(a) {return a < 'x';}").run();
   }
 
   @Test
-  public void testAdd2() {
-    newTest().addSource("/**@return {void}*/function foo(){var a = foo()+4;}").run();
+  public void testStringComparison4() {
+    newTest()
+        .addSource("/**@param {string|undefined} a*/ " + "function f(a) {return a < 'x';}")
+        .run();
   }
 
   @Test
-  public void testAdd3() {
+  public void testStringComparison5() {
+    newTest().addSource("/**@param {*} a*/ " + "function f(a) {return a < 'x';}").run();
+  }
+
+  @Test
+  public void testStringComparison6() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
-        .addSource(
-            "/** @type {string} */ var a = 'a';"
-                + "/** @type {string} */ var b = 'b';"
-                + "/** @type {string} */ var c = a + b;")
+        .addSource("/**@return {void} */ " + "function foo() { if ('a' >= foo()) return; }")
+        .addDiagnostic("right side of comparison\n" + "found   : undefined\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAdd4() {
+  public void testValueOfComparison1() {
     newTest()
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @type {string} */ var b = 'b';"
-                + "/** @type {string} */ var c = a + b;")
+            "/** @constructor */function O() {};",
+            "/**@override*/O.prototype.valueOf = function() { return 1; };",
+            "/**@param {!O} a\n@param {!O} b*/ function f(a,b) { return a < b; }")
         .run();
   }
 
   @Test
-  public void testAdd5() {
+  public void testValueOfComparison2() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {string} */ var a = 'a';"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {string} */ var c = a + b;")
+            "/** @constructor */function O() {};",
+            "/**@override*/O.prototype.valueOf = function() { return 1; };",
+            "/**",
+            " * @param {!O} a",
+            " * @param {number} b",
+            " */",
+            "function f(a,b) { return a < b; }")
         .run();
   }
 
   @Test
-  public void testAdd6() {
+  public void testValueOfComparison3() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {number} */ var c = a + b;")
+            "/** @constructor */function O() {};",
+            "/**@override*/O.prototype.toString = function() { return 'o'; };",
+            "/**",
+            " * @param {!O} a",
+            " * @param {string} b",
+            " */",
+            "function f(a,b) { return a < b; }")
         .run();
   }
 
   @Test
-  public void testAdd7() {
+  public void testGenericRelationalExpression() {
     newTest()
-        .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @type {string} */ var b = 'b';"
-                + "/** @type {number} */ var c = a + b;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+        .addSource("/**@param {*} a\n@param {*} b*/ " + "function f(a,b) {return a < b;}")
         .run();
   }
 
   @Test
-  public void testAdd8() {
+  public void testInstanceof1() {
     newTest()
-        .addSource(
-            "/** @type {string} */ var a = 'a';"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {number} */ var c = a + b;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+        .addSource("function foo(){" + "if (bar instanceof 3)return;}")
+        .addDiagnostic(
+            "instanceof requires an object\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testAdd9() {
+  public void testInstanceof2() {
     newTest()
-        .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {string} */ var c = a + b;")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .addSource("/**@return {void}*/function foo(){" + "if (foo() instanceof Object)return;}")
+        .addDiagnostic(
+            "deterministic instanceof yields false\n"
+                + "found   : undefined\n"
+                + "required: NoObject")
         .run();
   }
 
   @Test
-  public void testAdd10() {
-    // d.e.f will have unknown type.
+  public void testInstanceof3() {
     newTest()
-        .addSource(
-            suppressMissingProperty("e", "f")
-                + "/** @type {number} */ var a = 5;"
-                + "/** @type {string} */ var c = a + d.e.f;")
+        .addSource("/**@return {*} */function foo(){" + "if (foo() instanceof Object)return;}")
         .run();
   }
 
   @Test
-  public void testAdd11() {
-    // d.e.f will have unknown type.
+  public void testInstanceof4() {
     newTest()
         .addSource(
-            suppressMissingProperty("e", "f")
-                + "/** @type {number} */ var a = 5;"
-                + "/** @type {number} */ var c = a + d.e.f;")
+            "/**@return {(Object|number)} */function foo(){"
+                + "if (foo() instanceof Object)return 3;}")
         .run();
   }
 
   @Test
-  public void testAdd12() {
+  public void testInstanceof5() {
+    // No warning for unknown types.
     newTest()
-        .addSource(
-            "/** @return {(number|string)} */ function a() { return 5; }"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {boolean} */ var c = a() + b;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+        .addSource("/** @return {?} */ function foo(){" + "if (foo() instanceof Object)return;}")
         .run();
   }
 
   @Test
-  public void testAdd13() {
+  public void testInstanceof6() {
     newTest()
         .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @return {(number|string)} */ function b() { return 5; }"
-                + "/** @type {boolean} */ var c = a + b();")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+            "/**@return {(Array|number)} */function foo(){"
+                + "if (foo() instanceof Object)return 3;}")
         .run();
   }
 
   @Test
-  public void testAdd14() {
+  public void testInstanceOfReduction3() {
     newTest()
         .addSource(
-            "/** @type {(null|string)} */ var a = unknown;"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {boolean} */ var c = a + b;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+            "/** \n"
+                + " * @param {Object} x \n"
+                + " * @param {Function} y \n"
+                + " * @return {boolean} \n"
+                + " */\n"
+                + "var f = function(x, y) {\n"
+                + "  return x instanceof y;\n"
+                + "};")
         .run();
   }
 
   @Test
-  public void testAdd15() {
+  public void testScoping1() {
     newTest()
         .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @return {(number|string)} */ function b() { return 5; }"
-                + "/** @type {boolean} */ var c = a + b();")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+            "/**@param {string} a*/function foo(a){"
+                + "  /**@param {Array|string} a*/function bar(a){"
+                + "    if (a instanceof Array)return;"
+                + "  }"
+                + "}")
         .run();
   }
 
   @Test
-  public void testAdd16() {
+  public void testScoping2() {
     newTest()
         .addSource(
-            "/** @type {(undefined|string)} */ var a = unknown;"
-                + "/** @type {number} */ var b = 5;"
-                + "/** @type {boolean} */ var c = a + b;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+            "/** @type {number} */ var a;"
+                + "function Foo() {"
+                + "  /** @type {string} */ var a;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testAdd17() {
+  public void testScoping3() {
     newTest()
-        .addSource(
-            "/** @type {number} */ var a = 5;"
-                + "/** @type {(undefined|string)} */ var b = unknown;"
-                + "/** @type {boolean} */ var c = a + b;")
+        .addSource("\n\n/** @type{Number}*/var b;\n/** @type{!String} */var b;")
         .addDiagnostic(
-            "initializing variable\n" + "found   : (number|string)\n" + "required: boolean")
+            "variable b redefined with type String, original "
+                + "definition at [testcode]:3 with type (Number|null)")
         .run();
   }
 
   @Test
-  public void testAdd18() {
+  public void testScoping4() {
     newTest()
-        .addSource(
-            "function f() {};"
-                + "/** @type {string} */ var a = 'a';"
-                + "/** @type {number} */ var c = a + f();")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+        .addSource("/** @type{Number}*/var b; if (true) /** @type{!String} */var b;")
+        .addDiagnostic(
+            "variable b redefined with type String, original "
+                + "definition at [testcode]:1 with type (Number|null)")
         .run();
   }
 
   @Test
-  public void testAdd19() {
+  public void testScoping5() {
+    // multiple definitions are not checked by the type checker but by a
+    // subsequent pass
+    newTest().addSource("if (true) var b; var b;").run();
+  }
+
+  @Test
+  public void testScoping6() {
+    // multiple definitions are not checked by the type checker but by a
+    // subsequent pass
+    newTest().addSource("if (true) var b; if (true) var b;").run();
+  }
+
+  @Test
+  public void testScoping7() {
+    newTest()
+        .addSource("/** @constructor */function A() {" + "  /** @type {!A} */this.a = null;" + "}")
+        .addDiagnostic("assignment to property a of A\n" + "found   : null\n" + "required: A")
+        .run();
+  }
+
+  @Test
+  public void testScoping8() {
     newTest()
         .addSource(
-            "/** @param {number} opt_x\n@param {number} opt_y\n"
-                + "@return {number} */ function f(opt_x, opt_y) {"
-                + "return opt_x + opt_y;}")
+            "/** @constructor */function A() {}"
+                + "/** @constructor */function B() {"
+                + "  /** @type {!A} */this.a = null;"
+                + "}")
+        .addDiagnostic("assignment to property a of B\n" + "found   : null\n" + "required: A")
         .run();
   }
 
   @Test
-  public void testAdd20() {
+  public void testScoping9() {
     newTest()
         .addSource(
-            "/** @param {!Number} opt_x\n@param {!Number} opt_y\n"
-                + "@return {number} */ function f(opt_x, opt_y) {"
-                + "return opt_x + opt_y;}")
+            "/** @constructor */function B() {"
+                + "  /** @type {!A} */this.a = null;"
+                + "}"
+                + "/** @constructor */function A() {}")
+        .addDiagnostic("assignment to property a of B\n" + "found   : null\n" + "required: A")
         .run();
   }
 
   @Test
-  public void testAdd21() {
+  public void testScoping10() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("var a = function b(){};");
+
+    // a declared, b is not
+    assertScope(p.scope).declares("a");
+    assertScope(p.scope).doesNotDeclare("b");
+
+    // checking that a has the correct assigned type
+    assertThat(p.scope.getVar("a").getType().toString()).isEqualTo("function(): undefined");
+  }
+
+  @Test
+  public void testDontDropPropertiesInUnion1() {
     newTest()
         .addSource(
-            "/** @param {Number|Boolean} opt_x\n"
-                + "@param {number|boolean} opt_y\n"
-                + "@return {number} */ function f(opt_x, opt_y) {"
-                + "return opt_x + opt_y;}")
+            "/** @param {{a: number}|{a:number, b:string}} x */",
+            "function f(x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
         .run();
   }
 
   @Test
-  public void testNumericComparison1() {
-    newTest().addSource("/**@param {number} a*/ function f(a) {return a < 3;}").run();
+  public void testDontDropPropertiesInUnion2() {
+    newTest()
+        .addSource(
+            "/** @param {{a:number, b:string}|{a: number}} x */",
+            "function f(x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
   }
 
   @Test
-  public void testNumericComparison2() {
+  public void testDontDropPropertiesInUnion3() {
     newTest()
-        .addSource("/**@param {!Object} a*/ function f(a) {return a < 3;}")
-        .addDiagnostic(
-            lines(
-                "left side of numeric comparison", //
-                "found   : Object",
-                "required: (bigint|number)"))
+        .addSource(
+            "/** @param {{a: number}|{a:number, b:string}} x */",
+            "function f(x) {}",
+            "/** @param {{a: number}} x */",
+            "function g(x) { return x.b; }")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
         .run();
   }
 
   @Test
-  public void testNumericComparison3() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("/**@param {string} a*/ function f(a) {return a < 3;}").run();
+  public void testDontDropPropertiesInUnion4() {
+    newTest()
+        .addSource(
+            "/** @param {{a: number}|{a:number, b:string}} x */",
+            "function f(x) {}",
+            "/** @param {{c: number}} x */",
+            "function g(x) { return x.b; }")
+        .addDiagnostic("Property b never defined on x")
+        .run();
   }
 
   @Test
-  public void testNumericComparison4() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testDontDropPropertiesInUnion5() {
     newTest()
-        .addSource("/**@param {(number|undefined)} a*/ " + "function f(a) {return a < 3;}")
+        .addSource(
+            "/** @param {{a: number}|{a: number, b: string}} x */",
+            "function f(x) {}",
+            "f({a: 123});")
         .run();
   }
 
   @Test
-  public void testNumericComparison5() {
+  public void testDontDropPropertiesInUnion6() {
     newTest()
-        .addSource("/**@param {*} a*/ function f(a) {return a < 3;}")
+        .addSource(
+            "/** @param {{a: number}|{a: number, b: string}} x */",
+            "function f(x) {",
+            "  var /** null */ n = x;",
+            "}")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison", //
-                "found   : *",
-                "required: (bigint|number)"))
+                "initializing variable", //
+                "found   : {a: number}",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testNumericComparison6() {
+  public void testDontDropPropertiesInUnion7() {
+    // Only a strict warning because in the registry we map {a, c} to {b, d}
     newTest()
-        .addSource("/**@return {void} */ function foo() { if (3 >= foo()) return; }")
+        .addSource(
+            "/** @param {{a: number}|{a:number, b:string}} x */",
+            "function f(x) {}",
+            "/** @param {{c: number}|{c:number, d:string}} x */",
+            "function g(x) { return x.b; }")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testScoping11() {
+    // named function expressions create a binding in their body only
+    // the return is wrong but the assignment is OK since the type of b is ?
+    newTest()
+        .addSource("/** @return {number} */var a = function b(){ return b };")
         .addDiagnostic(
-            lines(
-                "right side of numeric comparison",
-                "found   : undefined",
-                "required: (bigint|number)"))
+            "inconsistent return type\n" + "found   : function(): number\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testStringComparison1() {
-    newTest().addSource("/**@param {string} a*/ function f(a) {return a < 'x';}").run();
+  public void testScoping12() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @type {number} */ F.prototype.bar = 3;"
+                + "/** @param {!F} f */ function g(f) {"
+                + "  /** @return {string} */"
+                + "  function h() {"
+                + "    return f.bar;"
+                + "  }"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
   }
 
   @Test
-  public void testStringComparison2() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("/**@param {Object} a*/ function f(a) {return a < 'x';}").run();
+  public void testFunctionArguments1() {
+    testFunctionType(
+        "/** @param {number} a\n@return {string} */" + "function f(a) {}",
+        "function(number): string");
   }
 
   @Test
-  public void testStringComparison3() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("/**@param {number} a*/ function f(a) {return a < 'x';}").run();
+  public void testFunctionArguments2() {
+    testFunctionType(
+        "/** @param {number} opt_a\n@return {string} */" + "function f(opt_a) {}",
+        "function(number=): string");
   }
 
   @Test
-  public void testStringComparison4() {
-    newTest()
-        .addSource("/**@param {string|undefined} a*/ " + "function f(a) {return a < 'x';}")
-        .run();
+  public void testFunctionArguments3() {
+    testFunctionType(
+        "/** @param {number} b\n@return {string} */" + "function f(a,b) {}",
+        "function(?, number): string");
   }
 
   @Test
-  public void testStringComparison5() {
-    newTest().addSource("/**@param {*} a*/ " + "function f(a) {return a < 'x';}").run();
+  public void testFunctionArguments4() {
+    testFunctionType(
+        "/** @param {number} opt_a\n@return {string} */" + "function f(a,opt_a) {}",
+        "function(?, number=): string");
   }
 
   @Test
-  public void testStringComparison6() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testFunctionArguments5() {
     newTest()
-        .addSource("/**@return {void} */ " + "function foo() { if ('a' >= foo()) return; }")
-        .addDiagnostic("right side of comparison\n" + "found   : undefined\n" + "required: string")
+        .addSource("function a(opt_a,a) {}")
+        .addDiagnostic("optional arguments must be at the end")
         .run();
   }
 
   @Test
-  public void testValueOfComparison1() {
+  public void testFunctionArguments6() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
-        .addSource(
-            "/** @constructor */function O() {};",
-            "/**@override*/O.prototype.valueOf = function() { return 1; };",
-            "/**@param {!O} a\n@param {!O} b*/ function f(a,b) { return a < b; }")
+        .addSource("function a(var_args,a) {}")
+        .addDiagnostic("variable length argument must be last")
         .run();
   }
 
   @Test
-  public void testValueOfComparison2() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testFunctionArguments7() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */function O() {};",
-            "/**@override*/O.prototype.valueOf = function() { return 1; };",
-            "/**",
-            " * @param {!O} a",
-            " * @param {number} b",
-            " */",
-            "function f(a,b) { return a < b; }")
+            "/** @param {number} opt_a\n@return {string} */" + "function a(a,opt_a,var_args) {}")
         .run();
   }
 
   @Test
-  public void testValueOfComparison3() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testFunctionArguments8() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
-        .addSource(
-            "/** @constructor */function O() {};",
-            "/**@override*/O.prototype.toString = function() { return 'o'; };",
-            "/**",
-            " * @param {!O} a",
-            " * @param {string} b",
-            " */",
-            "function f(a,b) { return a < b; }")
+        .addSource("function a(a,opt_a,var_args,b) {}")
+        .addDiagnostic("variable length argument must be last")
         .run();
   }
 
   @Test
-  public void testGenericRelationalExpression() {
+  public void testFunctionArguments9() {
+    // testing that only one error is reported
     newTest()
-        .addSource("/**@param {*} a\n@param {*} b*/ " + "function f(a,b) {return a < b;}")
+        .addSource("function a(a,opt_a,var_args,b,c) {}")
+        .addDiagnostic("variable length argument must be last")
         .run();
   }
 
   @Test
-  public void testInstanceof1() {
+  public void testFunctionArguments10() {
+    // testing that only one error is reported
     newTest()
-        .addSource("function foo(){" + "if (bar instanceof 3)return;}")
-        .addDiagnostic(
-            "instanceof requires an object\n" + "found   : number\n" + "required: Object")
+        .addSource("function a(a,opt_a,b,c) {}")
+        .addDiagnostic("optional arguments must be at the end")
         .run();
   }
 
   @Test
-  public void testInstanceof2() {
+  public void testFunctionArguments11() {
     newTest()
-        .addSource("/**@return {void}*/function foo(){" + "if (foo() instanceof Object)return;}")
-        .addDiagnostic(
-            "deterministic instanceof yields false\n"
-                + "found   : undefined\n"
-                + "required: NoObject")
+        .addSource("function a(a,opt_a,b,c,var_args,d) {}")
+        .addDiagnostic("optional arguments must be at the end")
         .run();
   }
 
   @Test
-  public void testInstanceof3() {
+  public void testFunctionArguments12() {
     newTest()
-        .addSource("/**@return {*} */function foo(){" + "if (foo() instanceof Object)return;}")
+        .addSource("/** @param {String} foo  */function bar(baz){}")
+        .addDiagnostic("parameter foo does not appear in bar's parameter list")
         .run();
   }
 
   @Test
-  public void testInstanceof4() {
+  public void testFunctionArguments13() {
+    // verifying that the argument type have non-inferable types
     newTest()
         .addSource(
-            "/**@return {(Object|number)} */function foo(){"
-                + "if (foo() instanceof Object)return 3;}")
+            "/** @return {boolean} */ function u() { return true; }"
+                + "/** @param {boolean} b\n@return {?boolean} */"
+                + "function f(b) { if (u()) { b = null; } return b; }")
+        .addDiagnostic("assignment\n" + "found   : null\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testInstanceof5() {
-    // No warning for unknown types.
+  public void testFunctionArguments14() {
     newTest()
-        .addSource("/** @return {?} */ function foo(){" + "if (foo() instanceof Object)return;}")
+        .addSource(
+            "/**\n"
+                + " * @param {string} x\n"
+                + " * @param {number} opt_y\n"
+                + " * @param {boolean} var_args\n"
+                + " */ function f(x, opt_y, var_args) {}"
+                + "f('3'); f('3', 2); f('3', 2, true); f('3', 2, true, false);")
         .run();
   }
 
   @Test
-  public void testInstanceof6() {
+  public void testFunctionArguments15() {
     newTest()
-        .addSource(
-            "/**@return {(Array|number)} */function foo(){"
-                + "if (foo() instanceof Object)return 3;}")
+        .addSource("/** @param {?function(*)} f */" + "function g(f) { f(1, 2); }")
+        .addDiagnostic(
+            "Function f: called with 2 argument(s). "
+                + "Function requires at least 1 argument(s) "
+                + "and no more than 1 argument(s).")
         .run();
   }
 
   @Test
-  public void testInstanceOfReduction3() {
+  public void testFunctionArguments16() {
     newTest()
         .addSource(
-            "/** \n"
-                + " * @param {Object} x \n"
-                + " * @param {Function} y \n"
-                + " * @return {boolean} \n"
-                + " */\n"
-                + "var f = function(x, y) {\n"
-                + "  return x instanceof y;\n"
-                + "};")
+            "/** @param {...number} var_args */", //
+            "function g(var_args) {}",
+            "g(1, true);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 2 of g does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testScoping1() {
+  public void testUndefinedPassedForVarArgs() {
     newTest()
         .addSource(
-            "/**@param {string} a*/function foo(a){"
-                + "  /**@param {Array|string} a*/function bar(a){"
-                + "    if (a instanceof Array)return;"
-                + "  }"
-                + "}")
+            "/** @param {...number} var_args */", //
+            "function g(var_args) {}",
+            "g(undefined, 1);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : undefined",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testScoping2() {
+  public void testFunctionArguments17() {
     newTest()
         .addSource(
-            "/** @type {number} */ var a;"
-                + "function Foo() {"
-                + "  /** @type {string} */ var a;"
-                + "}")
+            "/** @param {booool|string} x */"
+                + "function f(x) { g(x) }"
+                + "/** @param {number} x */"
+                + "function g(x) {}")
+        .addDiagnostic("Bad type annotation. Unknown type booool")
         .run();
   }
 
   @Test
-  public void testScoping3() {
+  public void testFunctionArguments18() {
     newTest()
-        .addSource("\n\n/** @type{Number}*/var b;\n/** @type{!String} */var b;")
-        .addDiagnostic(
-            "variable b redefined with type String, original "
-                + "definition at [testcode]:3 with type (Number|null)")
+        .addSource("function f(x) {}" + "f(/** @param {number} y */ (function() {}));")
+        .addDiagnostic("parameter y does not appear in <anonymous>'s parameter list")
         .run();
   }
 
   @Test
-  public void testScoping4() {
-    newTest()
-        .addSource("/** @type{Number}*/var b; if (true) /** @type{!String} */var b;")
+  public void testVarArgParameterWithTemplateType() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/**",
+            " * @template T",
+            " * @param {...T} var_args",
+            " * @return {T}",
+            " */",
+            "function firstOf(var_args) { return arguments[0]; }",
+            "/** @type {null} */ var a = firstOf('hi', 1);",
+            "")
         .addDiagnostic(
-            "variable b redefined with type String, original "
-                + "definition at [testcode]:1 with type (Number|null)")
+            lines(
+                "initializing variable", //
+                "found   : (number|string)",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testScoping5() {
-    // multiple definitions are not checked by the type checker but by a
-    // subsequent pass
-    newTest().addSource("if (true) var b; var b;").run();
+  public void testRestParameters() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/**",
+            " * @param {...number} x",
+            " */",
+            "function f(...x) {",
+            "  var /** string */ s = x[0];",
+            "}")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: string"))
+        .run();
   }
 
   @Test
-  public void testScoping6() {
-    // multiple definitions are not checked by the type checker but by a
-    // subsequent pass
-    newTest().addSource("if (true) var b; if (true) var b;").run();
+  public void testRestParameterWithTemplateType() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/**",
+            " * @template T",
+            " * @param {...T} rest",
+            " * @return {T}",
+            " */",
+            "function firstOf(...rest) {",
+            "  return rest[0];",
+            "}",
+            "/** @type {null} */ var a = firstOf('hi', 1);",
+            "")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : (number|string)",
+                "required: null"))
+        .run();
   }
 
+  // Test that when transpiling we don't use T in the body of f; it would cause a spurious
+  // unknown-type warning.
   @Test
-  public void testScoping7() {
+  public void testRestParametersWithGenericsNoWarning() {
     newTest()
-        .addSource("/** @constructor */function A() {" + "  /** @type {!A} */this.a = null;" + "}")
-        .addDiagnostic("assignment to property a of A\n" + "found   : null\n" + "required: A")
+        .addExterns(new TestExternsBuilder().addObject().addArray().build())
+        .addSource(
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "function Foo() {}",
+            "/**",
+            " * @template T",
+            " * @param {...!Foo<T>} x",
+            " */",
+            "function f(...x) {",
+            "  return 123;",
+            "}")
         .run();
   }
 
   @Test
-  public void testScoping8() {
+  public void testPrintFunctionName1() {
+    // Ensures that the function name is pretty.
     newTest()
-        .addSource(
-            "/** @constructor */function A() {}"
-                + "/** @constructor */function B() {"
-                + "  /** @type {!A} */this.a = null;"
-                + "}")
-        .addDiagnostic("assignment to property a of B\n" + "found   : null\n" + "required: A")
+        .addSource("var goog = {}; goog.run = function(f) {};" + "goog.run();")
+        .addDiagnostic(
+            "Function goog.run: called with 0 argument(s). "
+                + "Function requires at least 1 argument(s) "
+                + "and no more than 1 argument(s).")
         .run();
   }
 
   @Test
-  public void testScoping9() {
+  public void testPrintFunctionName2() {
     newTest()
         .addSource(
-            "/** @constructor */function B() {"
-                + "  /** @type {!A} */this.a = null;"
-                + "}"
-                + "/** @constructor */function A() {}")
-        .addDiagnostic("assignment to property a of B\n" + "found   : null\n" + "required: A")
+            "/** @constructor */ var Foo = function() {}; "
+                + "Foo.prototype.run = function(f) {};"
+                + "(new Foo).run();")
+        .addDiagnostic(
+            "Function Foo.prototype.run: called with 0 argument(s). "
+                + "Function requires at least 1 argument(s) "
+                + "and no more than 1 argument(s).")
         .run();
   }
 
   @Test
-  public void testScoping10() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("var a = function b(){};");
-
-    // a declared, b is not
-    assertScope(p.scope).declares("a");
-    assertScope(p.scope).doesNotDeclare("b");
-
-    // checking that a has the correct assigned type
-    assertThat(p.scope.getVar("a").getType().toString()).isEqualTo("function(): undefined");
+  public void testFunctionInference1() {
+    testFunctionType("function f(a) {}", "function(?): undefined");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion1() {
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a:number, b:string}} x */",
-            "function f(x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run();
+  public void testFunctionInference2() {
+    testFunctionType("function f(a,b) {}", "function(?, ?): undefined");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion2() {
-    newTest()
-        .addSource(
-            "/** @param {{a:number, b:string}|{a: number}} x */",
-            "function f(x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run();
+  public void testFunctionInference3() {
+    testFunctionType("function f(var_args) {}", "function(...?): undefined");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion3() {
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a:number, b:string}} x */",
-            "function f(x) {}",
-            "/** @param {{a: number}} x */",
-            "function g(x) { return x.b; }")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run();
+  public void testFunctionInference4() {
+    testFunctionType("function f(a,b,c,var_args) {}", "function(?, ?, ?, ...?): undefined");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion4() {
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a:number, b:string}} x */",
-            "function f(x) {}",
-            "/** @param {{c: number}} x */",
-            "function g(x) { return x.b; }")
-        .addDiagnostic("Property b never defined on x")
-        .run();
+  public void testFunctionInference5() {
+    testFunctionType(
+        "/** @this {Date}\n@return {string} */function f(a) {}", "function(this:Date, ?): string");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion5() {
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a: number, b: string}} x */",
-            "function f(x) {}",
-            "f({a: 123});")
-        .run();
+  public void testFunctionInference6() {
+    testFunctionType(
+        "/** @this {Date}\n@return {string} */function f(opt_a) {}",
+        "function(this:Date, ?=): string");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion6() {
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a: number, b: string}} x */",
-            "function f(x) {",
-            "  var /** null */ n = x;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : {a: number}",
-                "required: null"))
-        .run();
+  public void testFunctionInference7() {
+    testFunctionType(
+        "/** @this {Date} */function f(a,b,c,var_args) {}",
+        "function(this:Date, ?, ?, ?, ...?): undefined");
   }
 
   @Test
-  public void testDontDropPropertiesInUnion7() {
-    // Only a strict warning because in the registry we map {a, c} to {b, d}
-    newTest()
-        .addSource(
-            "/** @param {{a: number}|{a:number, b:string}} x */",
-            "function f(x) {}",
-            "/** @param {{c: number}|{c:number, d:string}} x */",
-            "function g(x) { return x.b; }")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run();
+  public void testFunctionInference8() {
+    testFunctionType("function f() {}", "function(): undefined");
   }
 
   @Test
-  public void testScoping11() {
-    // named function expressions create a binding in their body only
-    // the return is wrong but the assignment is OK since the type of b is ?
-    newTest()
-        .addSource("/** @return {number} */var a = function b(){ return b };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : function(): number\n" + "required: number")
-        .run();
+  public void testFunctionInference9() {
+    testFunctionType("var f = function() {};", "function(): undefined");
   }
 
   @Test
-  public void testScoping12() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @type {number} */ F.prototype.bar = 3;"
-                + "/** @param {!F} f */ function g(f) {"
-                + "  /** @return {string} */"
-                + "  function h() {"
-                + "    return f.bar;"
-                + "  }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testFunctionInference10() {
+    testFunctionType(
+        "/** @this {Date}\n@param {boolean} b\n@return {string} */" + "var f = function(a,b) {};",
+        "function(this:Date, ?, boolean): string");
   }
 
   @Test
-  public void testFunctionArguments1() {
+  public void testFunctionInference11() {
     testFunctionType(
-        "/** @param {number} a\n@return {string} */" + "function f(a) {}",
-        "function(number): string");
+        "var goog = {};" + "/** @return {number}*/goog.f = function(){};",
+        "goog.f",
+        "function(): number");
   }
 
   @Test
-  public void testFunctionArguments2() {
+  public void testFunctionInference12() {
     testFunctionType(
-        "/** @param {number} opt_a\n@return {string} */" + "function f(opt_a) {}",
-        "function(number=): string");
+        "var goog = {};" + "goog.f = function(){};", "goog.f", "function(): undefined");
   }
 
   @Test
-  public void testFunctionArguments3() {
+  public void testFunctionInference13() {
     testFunctionType(
-        "/** @param {number} b\n@return {string} */" + "function f(a,b) {}",
-        "function(?, number): string");
+        "var goog = {};"
+            + "/** @constructor */ goog.Foo = function(){};"
+            + "/** @param {!goog.Foo} f */function eatFoo(f){};",
+        "eatFoo",
+        "function(goog.Foo): undefined");
   }
 
   @Test
-  public void testFunctionArguments4() {
+  public void testFunctionInference14() {
     testFunctionType(
-        "/** @param {number} opt_a\n@return {string} */" + "function f(a,opt_a) {}",
-        "function(?, number=): string");
+        "var goog = {};"
+            + "/** @constructor */ goog.Foo = function(){};"
+            + "/** @return {!goog.Foo} */function eatFoo(){ return new goog.Foo; };",
+        "eatFoo",
+        "function(): goog.Foo");
   }
 
   @Test
-  public void testFunctionArguments5() {
-    newTest()
-        .addSource("function a(opt_a,a) {}")
-        .addDiagnostic("optional arguments must be at the end")
-        .run();
+  public void testFunctionInference15() {
+    testFunctionType(
+        "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};",
+        "f.prototype.foo",
+        "function(this:f): undefined");
   }
 
   @Test
-  public void testFunctionArguments6() {
-    newTest()
-        .addSource("function a(var_args,a) {}")
-        .addDiagnostic("variable length argument must be last")
-        .run();
+  public void testFunctionInference16() {
+    testFunctionType(
+        "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};",
+        "(new f).foo",
+        "function(this:f): undefined");
   }
 
   @Test
-  public void testFunctionArguments7() {
-    newTest()
-        .addSource(
-            "/** @param {number} opt_a\n@return {string} */" + "function a(a,opt_a,var_args) {}")
-        .run();
+  public void testFunctionInference17() {
+    testFunctionType(
+        "/** @constructor */ function f() {}"
+            + "function abstractMethod() {}"
+            + "/** @param {number} x */ f.prototype.foo = abstractMethod;",
+        "(new f).foo",
+        "function(this:f, number): ?");
   }
 
   @Test
-  public void testFunctionArguments8() {
-    newTest()
-        .addSource("function a(a,opt_a,var_args,b) {}")
-        .addDiagnostic("variable length argument must be last")
-        .run();
+  public void testFunctionInference18() {
+    testFunctionType(
+        "var goog = {};" + "/** @this {Date} */ goog.eatWithDate;",
+        "goog.eatWithDate",
+        "function(this:Date): ?");
   }
 
   @Test
-  public void testFunctionArguments9() {
-    // testing that only one error is reported
-    newTest()
-        .addSource("function a(a,opt_a,var_args,b,c) {}")
-        .addDiagnostic("variable length argument must be last")
-        .run();
+  public void testFunctionInference19() {
+    testFunctionType("/** @param {string} x */ var f;", "f", "function(string): ?");
   }
 
   @Test
-  public void testFunctionArguments10() {
-    // testing that only one error is reported
-    newTest()
-        .addSource("function a(a,opt_a,b,c) {}")
-        .addDiagnostic("optional arguments must be at the end")
-        .run();
+  public void testFunctionInference20() {
+    testFunctionType("/** @this {Date} */ var f;", "f", "function(this:Date): ?");
   }
 
   @Test
-  public void testFunctionArguments11() {
+  public void testFunctionInference21a() {
     newTest()
-        .addSource("function a(a,opt_a,b,c,var_args,d) {}")
-        .addDiagnostic("optional arguments must be at the end")
+        .addSource("var f = function() { throw 'x' };" + "/** @return {boolean} */ var g = f;")
         .run();
   }
 
   @Test
-  public void testFunctionArguments12() {
-    newTest()
-        .addSource("/** @param {String} foo  */function bar(baz){}")
-        .addDiagnostic("parameter foo does not appear in bar's parameter list")
-        .run();
+  public void testFunctionInference21b() {
+    testFunctionType("var f = function() { throw 'x' };", "f", "function(): ?");
   }
 
   @Test
-  public void testFunctionArguments13() {
-    // verifying that the argument type have non-inferable types
+  public void testFunctionInference22() {
     newTest()
         .addSource(
-            "/** @return {boolean} */ function u() { return true; }"
-                + "/** @param {boolean} b\n@return {?boolean} */"
-                + "function f(b) { if (u()) { b = null; } return b; }")
-        .addDiagnostic("assignment\n" + "found   : null\n" + "required: boolean")
+            "/** @type {!Function} */ var f = function() { g(this); };"
+                + "/** @param {boolean} x */ var g = function(x) {};")
         .run();
   }
 
   @Test
-  public void testFunctionArguments14() {
+  public void testFunctionInference23a() {
+    // We want to make sure that 'prop' isn't declared on all objects.
+
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {string} x\n"
-                + " * @param {number} opt_y\n"
-                + " * @param {boolean} var_args\n"
-                + " */ function f(x, opt_y, var_args) {}"
-                + "f('3'); f('3', 2); f('3', 2, true); f('3', 2, true, false);")
+            "/** @type {!Function} */ var f = function() {",
+            "  /** @type {number} */ this.prop = 3;",
+            "};",
+            "/**",
+            " * @param {Object} x",
+            " * @return {string}",
+            " */ var g = function(x) { return x.prop; };")
         .run();
   }
 
   @Test
-  public void testFunctionArguments15() {
+  public void testFunctionInference23b() {
+    // We want to make sure that 'prop' isn't declared on all objects.
+
     newTest()
-        .addSource("/** @param {?function(*)} f */" + "function g(f) { f(1, 2); }")
-        .addDiagnostic(
-            "Function f: called with 2 argument(s). "
-                + "Function requires at least 1 argument(s) "
-                + "and no more than 1 argument(s).")
+        .addSource(
+            "/** @type {!Function} */ var f = function() {",
+            "  /** @type {number} */ this.prop = 3;",
+            "};",
+            "/**",
+            " * @param {Object} x",
+            " * @return {string}",
+            " */ var g = function(x) { return x.prop; };")
+        .addDiagnostic("Property prop never defined on Object")
         .run();
   }
 
   @Test
-  public void testFunctionArguments16() {
-    newTest()
-        .addSource(
-            "/** @param {...number} var_args */", //
-            "function g(var_args) {}",
-            "g(1, true);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 2 of g does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
-        .run();
+  public void testFunctionInference24() {
+    testFunctionType(
+        "var f = (/** number */ n, /** string= */ s) => null;", "function(number, string=): ?");
   }
 
   @Test
-  public void testUndefinedPassedForVarArgs() {
+  public void testFunctionInference25() {
+    testFunctionType(
+        "var f = (/** number */ n, /** ...string */ s) => null;", "function(number, ...string): ?");
+  }
+
+  @Test
+  public void testInnerFunction1() {
     newTest()
         .addSource(
-            "/** @param {...number} var_args */", //
-            "function g(var_args) {}",
-            "g(undefined, 1);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : undefined",
-                "required: number"))
+            "function f() {"
+                + " /** @type {number} */ var x = 3;\n"
+                + " function g() { x = null; }"
+                + " return x;"
+                + "}")
+        .addDiagnostic("assignment\n" + "found   : null\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testFunctionArguments17() {
+  public void testInnerFunction2() {
     newTest()
         .addSource(
-            "/** @param {booool|string} x */"
-                + "function f(x) { g(x) }"
-                + "/** @param {number} x */"
-                + "function g(x) {}")
-        .addDiagnostic("Bad type annotation. Unknown type booool")
+            "/** @return {number} */\n"
+                + "function f() {"
+                + " var x = null;\n"
+                + " function g() { x = 3; }"
+                + " g();"
+                + " return x;"
+                + "}")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (null|number)\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testFunctionArguments18() {
+  public void testInnerFunction3() {
     newTest()
-        .addSource("function f(x) {}" + "f(/** @param {number} y */ (function() {}));")
-        .addDiagnostic("parameter y does not appear in <anonymous>'s parameter list")
+        .addSource(
+            "var x = null;"
+                + "/** @return {number} */\n"
+                + "function f() {"
+                + " x = 3;\n"
+                + " /** @return {number} */\n"
+                + " function g() { x = true; return x; }"
+                + " return x;"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testVarArgParameterWithTemplateType() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
+  public void testInnerFunction4() {
+    newTest()
         .addSource(
-            "/**",
-            " * @template T",
-            " * @param {...T} var_args",
-            " * @return {T}",
-            " */",
-            "function firstOf(var_args) { return arguments[0]; }",
-            "/** @type {null} */ var a = firstOf('hi', 1);",
-            "")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (number|string)",
-                "required: null"))
+            "var x = null;"
+                + "/** @return {number} */\n"
+                + "function f() {"
+                + " x = '3';\n"
+                + " /** @return {number} */\n"
+                + " function g() { x = 3; return x; }"
+                + " return x;"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testRestParameters() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
+  public void testInnerFunction5() {
+    newTest()
         .addSource(
-            "/**",
-            " * @param {...number} x",
-            " */",
-            "function f(...x) {",
-            "  var /** string */ s = x[0];",
-            "}")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: string"))
+            "/** @return {number} */\n"
+                + "function f() {"
+                + " var x = 3;\n"
+                + " /** @return {number} */"
+                + " function g() { var x = 3;x = true; return x; }"
+                + " return x;"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testRestParameterWithTemplateType() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
-        .addSource(
-            "/**",
-            " * @template T",
-            " * @param {...T} rest",
-            " * @return {T}",
-            " */",
-            "function firstOf(...rest) {",
-            "  return rest[0];",
-            "}",
-            "/** @type {null} */ var a = firstOf('hi', 1);",
-            "")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (number|string)",
-                "required: null"))
-        .run();
+  public void testInnerFunction6NullishCoalesce() {
+    testClosureTypes(
+        lines(
+            "function f() {",
+            " var x = null ?? function() {};",
+            " function g() { if (goog.isFunction(x)) { x(1); } }",
+            " g();",
+            "}"),
+        "Function x: called with 1 argument(s). "
+            + "Function requires at least 0 argument(s) "
+            + "and no more than 0 argument(s).");
   }
 
-  // Test that when transpiling we don't use T in the body of f; it would cause a spurious
-  // unknown-type warning.
   @Test
-  public void testRestParametersWithGenericsNoWarning() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addObject().addArray().build())
-        .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function Foo() {}",
-            "/**",
-            " * @template T",
-            " * @param {...!Foo<T>} x",
-            " */",
-            "function f(...x) {",
-            "  return 123;",
-            "}")
-        .run();
+  public void testInnerFunction7NullishCoalesce() {
+    testClosureTypes(
+        lines(
+            "function f() {",
+            " /** @type {function()} */",
+            " var x = null ?? function() {};",
+            " function g() { if (goog.isFunction(x)) { x(1); } }",
+            " g();",
+            "}"),
+        "Function x: called with 1 argument(s). "
+            + "Function requires at least 0 argument(s) "
+            + "and no more than 0 argument(s).");
   }
 
   @Test
-  public void testPrintFunctionName1() {
-    // Ensures that the function name is pretty.
-    newTest()
-        .addSource("var goog = {}; goog.run = function(f) {};" + "goog.run();")
-        .addDiagnostic(
-            "Function goog.run: called with 0 argument(s). "
-                + "Function requires at least 1 argument(s) "
-                + "and no more than 1 argument(s).")
-        .run();
+  public void testInnerFunction8() {
+    testClosureTypes(
+        "function f() {"
+            + " function x() {};\n"
+            + " function g() { if (goog.isFunction(x)) { x(1); } }"
+            + " g();"
+            + "}",
+        "Function x: called with 1 argument(s). "
+            + "Function requires at least 0 argument(s) "
+            + "and no more than 0 argument(s).");
   }
 
   @Test
-  public void testPrintFunctionName2() {
+  public void testInnerFunction9() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {}; "
-                + "Foo.prototype.run = function(f) {};"
-                + "(new Foo).run();")
-        .addDiagnostic(
-            "Function Foo.prototype.run: called with 0 argument(s). "
-                + "Function requires at least 1 argument(s) "
-                + "and no more than 1 argument(s).")
+            "function f() {"
+                + " var x = 3;\n"
+                + " function g() { x = null; };\n"
+                + " function h() { return x == null; }"
+                + " return h();"
+                + "}")
         .run();
   }
 
   @Test
-  public void testFunctionInference1() {
-    testFunctionType("function f(a) {}", "function(?): undefined");
+  public void testInnerFunction10() {
+    newTest()
+        .addSource(
+            "function f() {"
+                + "  /** @type {?number} */ var x = null;"
+                + "  /** @return {string} */"
+                + "  function g() {"
+                + "    if (!x) {"
+                + "      x = 1;"
+                + "    }"
+                + "    return x;"
+                + "  }"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
   }
 
   @Test
-  public void testFunctionInference2() {
-    testFunctionType("function f(a,b) {}", "function(?, ?): undefined");
+  public void testInnerFunction11() {
+    // TODO(nicksantos): This is actually bad inference, because
+    // h sets x to null. We should fix this, but for now we do it
+    // this way so that we don't break existing binaries. We will
+    // need to change TypeInference#isUnflowable to fix this.
+    newTest()
+        .addSource(
+            "function f() {"
+                + "  /** @type {?number} */ var x = null;"
+                + "  /** @return {number} */"
+                + "  function g() {"
+                + "    x = 1;"
+                + "    h();"
+                + "    return x;"
+                + "  }"
+                + "  function h() {"
+                + "    x = null;"
+                + "  }"
+                + "}")
+        .run();
   }
 
   @Test
-  public void testFunctionInference3() {
-    testFunctionType("function f(var_args) {}", "function(...?): undefined");
+  public void testMethodInference1() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @return {number} */ F.prototype.foo = function() { return 3; };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ G.prototype.foo = function() { return true; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference4() {
-    testFunctionType("function f(a,b,c,var_args) {}", "function(?, ?, ?, ...?): undefined");
+  public void testMethodInference2() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */ goog.F = function() {};"
+                + "/** @return {number} */ goog.F.prototype.foo = "
+                + "    function() { return 3; };"
+                + "/** @constructor \n * @extends {goog.F} */ "
+                + "goog.G = function() {};"
+                + "/** @override */ goog.G.prototype.foo = function() { return true; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference5() {
-    testFunctionType(
-        "/** @this {Date}\n@return {string} */function f(a) {}", "function(this:Date, ?): string");
+  public void testMethodInference3() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @param {boolean} x \n * @return {number} */ "
+                + "F.prototype.foo = function(x) { return 3; };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ "
+                + "G.prototype.foo = function(x) { return x; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference6() {
-    testFunctionType(
-        "/** @this {Date}\n@return {string} */function f(opt_a) {}",
-        "function(this:Date, ?=): string");
+  public void testMethodInference4() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @param {boolean} x \n * @return {number} */ "
+                + "F.prototype.foo = function(x) { return 3; };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ "
+                + "G.prototype.foo = function(y) { return y; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference7() {
-    testFunctionType(
-        "/** @this {Date} */function f(a,b,c,var_args) {}",
-        "function(this:Date, ?, ?, ?, ...?): undefined");
+  public void testMethodInference5() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @param {number} x \n * @return {string} */ "
+                + "F.prototype.foo = function(x) { return 'x'; };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @type {number} */ G.prototype.num = 3;"
+                + "/** @override */ "
+                + "G.prototype.foo = function(y) { return this.num + y; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
   }
 
   @Test
-  public void testFunctionInference8() {
-    testFunctionType("function f() {}", "function(): undefined");
+  public void testMethodInference6() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** @param {number} x */ F.prototype.foo = function(x) { };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ G.prototype.foo = function() { };"
+                + "(new G()).foo(1);")
+        .run();
   }
 
   @Test
-  public void testFunctionInference9() {
-    testFunctionType("var f = function() {};", "function(): undefined");
+  public void testMethodInference7() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "F.prototype.foo = function() { };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ G.prototype.foo = function(x, y) { };")
+        .addDiagnostic(
+            "mismatch of the foo property type and the type of the property "
+                + "it overrides from superclass F\n"
+                + "original: function(this:F): undefined\n"
+                + "override: function(this:G, ?, ?): undefined")
+        .run();
   }
 
   @Test
-  public void testFunctionInference10() {
-    testFunctionType(
-        "/** @this {Date}\n@param {boolean} b\n@return {string} */" + "var f = function(a,b) {};",
-        "function(this:Date, ?, boolean): string");
+  public void testMethodInference8() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "F.prototype.foo = function() { };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ "
+                + "G.prototype.foo = function(opt_b, var_args) { };"
+                + "(new G()).foo(1, 2, 3);")
+        .run();
   }
 
   @Test
-  public void testFunctionInference11() {
-    testFunctionType(
-        "var goog = {};" + "/** @return {number}*/goog.f = function(){};",
-        "goog.f",
-        "function(): number");
+  public void testMethodInference9() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "F.prototype.foo = function() { };"
+                + "/** @constructor \n * @extends {F} */ "
+                + "function G() {}"
+                + "/** @override */ "
+                + "G.prototype.foo = function(var_args, opt_b) { };")
+        .addDiagnostic("variable length argument must be last")
+        .run();
   }
 
   @Test
-  public void testFunctionInference12() {
-    testFunctionType(
-        "var goog = {};" + "goog.f = function(){};", "goog.f", "function(): undefined");
+  public void testStaticMethodDeclaration1() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() { F.foo(true); }"
+                + "/** @param {number} x */ F.foo = function(x) {};")
+        .addDiagnostic(
+            "actual parameter 1 of F.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference13() {
-    testFunctionType(
-        "var goog = {};"
-            + "/** @constructor */ goog.Foo = function(){};"
-            + "/** @param {!goog.Foo} f */function eatFoo(f){};",
-        "eatFoo",
-        "function(goog.Foo): undefined");
+  public void testStaticMethodDeclaration2() {
+    newTest()
+        .addSource(
+            "var goog = goog || {}; function f() { goog.foo(true); }"
+                + "/** @param {number} x */ goog.foo = function(x) {};")
+        .addDiagnostic(
+            "actual parameter 1 of goog.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
   }
 
   @Test
-  public void testFunctionInference14() {
-    testFunctionType(
-        "var goog = {};"
-            + "/** @constructor */ goog.Foo = function(){};"
-            + "/** @return {!goog.Foo} */function eatFoo(){ return new goog.Foo; };",
-        "eatFoo",
-        "function(): goog.Foo");
+  public void testStaticMethodDeclaration3() {
+    newTest()
+        .addSource(
+            "var goog = goog || {}; function f() { goog.foo(true); }" + "goog.foo = function() {};")
+        .addDiagnostic(
+            "Function goog.foo: called with 1 argument(s). Function requires "
+                + "at least 0 argument(s) and no more than 0 argument(s).")
+        .run();
   }
 
   @Test
-  public void testFunctionInference15() {
-    testFunctionType(
-        "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};",
-        "f.prototype.foo",
-        "function(this:f): undefined");
+  public void testDuplicateStaticMethodDecl1() {
+    newTest()
+        .addSource(
+            "var goog = goog || {};"
+                + "/** @param {number} x */ goog.foo = function(x) {};"
+                + "/** @param {number} x */ goog.foo = function(x) {};")
+        .addDiagnostic("variable goog.foo redefined, original definition at [testcode]:1")
+        .run();
   }
 
   @Test
-  public void testFunctionInference16() {
-    testFunctionType(
-        "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};",
-        "(new f).foo",
-        "function(this:f): undefined");
+  public void testDuplicateStaticMethodDecl2() {
+    newTest()
+        .addSource(
+            "var goog = goog || {};"
+                + "/** @param {number} x */ goog.foo = function(x) {};"
+                + "/** @param {number} x \n * @suppress {duplicate} */ "
+                + "goog.foo = function(x) {};")
+        .run();
   }
 
   @Test
-  public void testFunctionInference17() {
-    testFunctionType(
-        "/** @constructor */ function f() {}"
-            + "function abstractMethod() {}"
-            + "/** @param {number} x */ f.prototype.foo = abstractMethod;",
-        "(new f).foo",
-        "function(this:f, number): ?");
+  public void testDuplicateStaticMethodDecl3() {
+    newTest()
+        .addSource(
+            "var goog = goog || {};" + "goog.foo = function(x) {};" + "goog.foo = function(x) {};")
+        .run();
   }
 
   @Test
-  public void testFunctionInference18() {
-    testFunctionType(
-        "var goog = {};" + "/** @this {Date} */ goog.eatWithDate;",
-        "goog.eatWithDate",
-        "function(this:Date): ?");
+  public void testDuplicateStaticMethodDecl4() {
+    newTest()
+        .addSource(
+            "var goog = goog || {};"
+                + "/** @type {Function} */ goog.foo = function(x) {};"
+                + "goog.foo = function(x) {};")
+        .run();
   }
 
   @Test
-  public void testFunctionInference19() {
-    testFunctionType("/** @param {string} x */ var f;", "f", "function(string): ?");
+  public void testDuplicateStaticMethodDecl5() {
+    newTest()
+        .addSource(
+            "var goog = goog || {};"
+                + "goog.foo = function(x) {};"
+                + "/** @return {undefined} */ goog.foo = function(x) {};")
+        .addDiagnostic("variable goog.foo redefined, " + "original definition at [testcode]:1")
+        .run();
   }
 
   @Test
-  public void testFunctionInference20() {
-    testFunctionType("/** @this {Date} */ var f;", "f", "function(this:Date): ?");
+  public void testDuplicateStaticMethodDecl6() {
+    // Make sure the CAST node doesn't interfere with the @suppress
+    // annotation.
+    newTest()
+        .addSource(
+            "var goog = goog || {};"
+                + "goog.foo = function(x) {};"
+                + "/**\n"
+                + " * @suppress {duplicate}\n"
+                + " * @return {undefined}\n"
+                + " */\n"
+                + "goog.foo = "
+                + "   /** @type {!Function} */ (function(x) {});")
+        .run();
   }
 
   @Test
-  public void testFunctionInference21a() {
+  public void testDuplicateStaticMethodDecl7() {
     newTest()
-        .addSource("var f = function() { throw 'x' };" + "/** @return {boolean} */ var g = f;")
+        .addSource("/** @type {string} */ var foo;\n" + "var z = function foo() {};\n")
+        .addDiagnostic(TypeCheck.FUNCTION_MASKS_VARIABLE)
         .run();
   }
 
   @Test
-  public void testFunctionInference21b() {
-    testFunctionType("var f = function() { throw 'x' };", "f", "function(): ?");
+  public void testDuplicateStaticMethodDecl8() {
+    newTest()
+        .addSource(
+            "/** @fileoverview @suppress {duplicate} */\n"
+                + "/** @type {string} */ var foo;\n"
+                + "var z = function foo() {};\n")
+        .run();
   }
 
   @Test
-  public void testFunctionInference22() {
+  public void testDuplicateStaticPropertyDecl1() {
     newTest()
         .addSource(
-            "/** @type {!Function} */ var f = function() { g(this); };"
-                + "/** @param {boolean} x */ var g = function(x) {};")
+            "var goog = goog || {};"
+                + "/** @type {Foo} */ goog.foo;"
+                + "/** @type {Foo} */ goog.foo;"
+                + "/** @constructor */ function Foo() {}")
         .run();
   }
 
   @Test
-  public void testFunctionInference23a() {
-    // We want to make sure that 'prop' isn't declared on all objects.
-
-    // This test is specifically checking loose property check behavior.
-    disableStrictMissingPropertyChecks();
-
+  public void testDuplicateStaticPropertyDecl2() {
     newTest()
         .addSource(
-            "/** @type {!Function} */ var f = function() {",
-            "  /** @type {number} */ this.prop = 3;",
-            "};",
-            "/**",
-            " * @param {Object} x",
-            " * @return {string}",
-            " */ var g = function(x) { return x.prop; };")
+            "var goog = goog || {};"
+                + "/** @type {Foo} */ goog.foo;"
+                + "/** @type {Foo} \n * @suppress {duplicate} */ goog.foo;"
+                + "/** @constructor */ function Foo() {}")
         .run();
   }
 
   @Test
-  public void testFunctionInference23b() {
-    // We want to make sure that 'prop' isn't declared on all objects.
-
+  public void testDuplicateStaticPropertyDecl3() {
     newTest()
         .addSource(
-            "/** @type {!Function} */ var f = function() {",
-            "  /** @type {number} */ this.prop = 3;",
-            "};",
-            "/**",
-            " * @param {Object} x",
-            " * @return {string}",
-            " */ var g = function(x) { return x.prop; };")
-        .addDiagnostic("Property prop never defined on Object")
+            "var goog = goog || {};"
+                + "/** @type {!Foo} */ goog.foo;"
+                + "/** @type {string} */ goog.foo;"
+                + "/** @constructor */ function Foo() {}")
+        .addDiagnostic(
+            "variable goog.foo redefined with type string, "
+                + "original definition at [testcode]:1 with type Foo")
         .run();
   }
 
   @Test
-  public void testFunctionInference24() {
-    testFunctionType(
-        "var f = (/** number */ n, /** string= */ s) => null;", "function(number, string=): ?");
+  public void testDuplicateStaticPropertyDecl4() {
+    testClosureTypesMultipleWarnings(
+        "/** @type {!Foo} */ goog.foo;"
+            + "/** @type {string} */ goog.foo = 'x';"
+            + "/** @constructor */ function Foo() {}",
+        ImmutableList.of(
+            "assignment to property foo of goog\nfound   : string\nrequired: Foo",
+            // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+            "variable goog.foo redefined with type string, "
+                + "original definition at testcode:1 with type Foo"));
   }
 
   @Test
-  public void testFunctionInference25() {
-    testFunctionType(
-        "var f = (/** number */ n, /** ...string */ s) => null;", "function(number, ...string): ?");
+  public void testDuplicateStaticPropertyDecl5() {
+    testClosureTypesMultipleWarnings(
+        "var goog = goog || {};"
+            + "/** @type {!Foo} */ goog.foo;"
+            + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';"
+            + "/** @constructor */ function Foo() {}",
+        ImmutableList.of(
+            "assignment to property foo of goog\n" + "found   : string\n" + "required: Foo"));
   }
 
   @Test
-  public void testInnerFunction1() {
+  public void testDuplicateStaticPropertyDecl6() {
     newTest()
         .addSource(
-            "function f() {"
-                + " /** @type {number} */ var x = 3;\n"
-                + " function g() { x = null; }"
-                + " return x;"
-                + "}")
-        .addDiagnostic("assignment\n" + "found   : null\n" + "required: number")
+            "var goog = goog || {};"
+                + "/** @type {string} */ goog.foo = 'y';"
+                + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';")
         .run();
   }
 
   @Test
-  public void testInnerFunction2() {
+  public void testDuplicateStaticPropertyDecl7() {
     newTest()
         .addSource(
-            "/** @return {number} */\n"
-                + "function f() {"
-                + " var x = null;\n"
-                + " function g() { x = 3; }"
-                + " g();"
-                + " return x;"
-                + "}")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (null|number)\n" + "required: number")
+            "var goog = goog || {};"
+                + "/** @param {string} x */ goog.foo;"
+                + "/** @type {function(string)} */ goog.foo;")
         .run();
   }
 
   @Test
-  public void testInnerFunction3() {
+  public void testDuplicateStaticPropertyDecl8() {
     newTest()
         .addSource(
-            "var x = null;"
-                + "/** @return {number} */\n"
-                + "function f() {"
-                + " x = 3;\n"
-                + " /** @return {number} */\n"
-                + " function g() { x = true; return x; }"
-                + " return x;"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "var goog = goog || {};"
+                + "/** @return {EventCopy} */ goog.foo;"
+                + "/** @constructor */ function EventCopy() {}"
+                + "/** @return {EventCopy} */ goog.foo;")
         .run();
   }
 
   @Test
-  public void testInnerFunction4() {
+  public void testDuplicateStaticPropertyDecl9() {
     newTest()
         .addSource(
-            "var x = null;"
-                + "/** @return {number} */\n"
-                + "function f() {"
-                + " x = '3';\n"
-                + " /** @return {number} */\n"
-                + " function g() { x = 3; return x; }"
-                + " return x;"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
+            "var goog = goog || {};"
+                + "/** @return {EventCopy} */ goog.foo;"
+                + "/** @return {EventCopy} */ goog.foo;"
+                + "/** @constructor */ function EventCopy() {}")
         .run();
   }
 
   @Test
-  public void testInnerFunction5() {
+  public void testDuplicateStaticPropertyDec20() {
     newTest()
         .addSource(
-            "/** @return {number} */\n"
-                + "function f() {"
-                + " var x = 3;\n"
-                + " /** @return {number} */"
-                + " function g() { var x = 3;x = true; return x; }"
-                + " return x;"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/**\n"
+                + " * @fileoverview\n"
+                + " * @suppress {duplicate}\n"
+                + " */"
+                + "var goog = goog || {};"
+                + "/** @type {string} */ goog.foo = 'y';"
+                + "/** @type {string} */ goog.foo = 'x';")
         .run();
   }
 
   @Test
-  public void testInnerFunction6NullishCoalesce() {
-    testClosureTypes(
-        lines(
-            "function f() {",
-            " var x = null ?? function() {};",
-            " function g() { if (goog.isFunction(x)) { x(1); } }",
-            " g();",
-            "}"),
-        "Function x: called with 1 argument(s). "
-            + "Function requires at least 0 argument(s) "
-            + "and no more than 0 argument(s).");
-  }
-
-  @Test
-  public void testInnerFunction7NullishCoalesce() {
-    testClosureTypes(
-        lines(
-            "function f() {",
-            " /** @type {function()} */",
-            " var x = null ?? function() {};",
-            " function g() { if (goog.isFunction(x)) { x(1); } }",
-            " g();",
-            "}"),
-        "Function x: called with 1 argument(s). "
-            + "Function requires at least 0 argument(s) "
-            + "and no more than 0 argument(s).");
-  }
-
-  @Test
-  public void testInnerFunction8() {
-    testClosureTypes(
-        "function f() {"
-            + " function x() {};\n"
-            + " function g() { if (goog.isFunction(x)) { x(1); } }"
-            + " g();"
-            + "}",
-        "Function x: called with 1 argument(s). "
-            + "Function requires at least 0 argument(s) "
-            + "and no more than 0 argument(s).");
+  public void testDuplicateLocalVarDecl() {
+    testClosureTypesMultipleWarnings(
+        "/** @param {number} x */\n" + "function f(x) { /** @type {string} */ var x = ''; }",
+        ImmutableList.of(
+            // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+            "variable x redefined with type string, original definition"
+                + " at testcode:2 with type number",
+            "initializing variable\n" + "found   : string\n" + "required: number"));
   }
 
   @Test
-  public void testInnerFunction9() {
+  public void testDuplicateLocalVarDeclSuppressed() {
+    // We can't just leave this to VarCheck since otherwise if that warning is suppressed, we'll end
+    // up redeclaring it as undefined in the function block, which can cause spurious errors.
     newTest()
         .addSource(
-            "function f() {"
-                + " var x = 3;\n"
-                + " function g() { x = null; };\n"
-                + " function h() { return x == null; }"
-                + " return h();"
-                + "}")
+            "/** @suppress {duplicate} */", //
+            "function f(x) {",
+            "  var x = x;",
+            "  x.y = true;",
+            "}")
         .run();
   }
 
   @Test
-  public void testInnerFunction10() {
+  public void testShadowBleedingFunctionName() {
+    // This is allowed and creates a new binding inside the function shadowing the bled name.
     newTest()
         .addSource(
-            "function f() {"
-                + "  /** @type {?number} */ var x = null;"
-                + "  /** @return {string} */"
-                + "  function g() {"
-                + "    if (!x) {"
-                + "      x = 1;"
-                + "    }"
-                + "    return x;"
-                + "  }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "var f = function x() {", //
+            "  var x;",
+            "  var /** undefined */ y = x;",
+            "};")
         .run();
   }
 
   @Test
-  public void testInnerFunction11() {
-    // TODO(nicksantos): This is actually bad inference, because
-    // h sets x to null. We should fix this, but for now we do it
-    // this way so that we don't break existing binaries. We will
-    // need to change TypeInference#isUnflowable to fix this.
+  public void testDuplicateInstanceMethod1() {
+    // If there's no jsdoc on the methods, then we treat them like
+    // any other inferred properties.
     newTest()
         .addSource(
-            "function f() {"
-                + "  /** @type {?number} */ var x = null;"
-                + "  /** @return {number} */"
-                + "  function g() {"
-                + "    x = 1;"
-                + "    h();"
-                + "    return x;"
-                + "  }"
-                + "  function h() {"
-                + "    x = null;"
-                + "  }"
-                + "}")
+            "/** @constructor */ function F() {}"
+                + "F.prototype.bar = function() {};"
+                + "F.prototype.bar = function() {};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodHandling1() {
+  public void testDuplicateInstanceMethod2() {
     newTest()
-        .addSource("/** @type {Function} */ var abstractFn = function() {};" + "abstractFn(1);")
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** jsdoc */ F.prototype.bar = function() {};"
+                + "/** jsdoc */ F.prototype.bar = function() {};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodHandling2() {
+  public void testDuplicateInstanceMethod3() {
     newTest()
-        .addSource("var abstractFn = function() {};" + "abstractFn(1);")
-        .addDiagnostic(
-            "Function abstractFn: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "F.prototype.bar = function() {};"
+                + "/** jsdoc */ F.prototype.bar = function() {};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodHandling3() {
+  public void testDuplicateInstanceMethod4() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @type {Function} */ goog.abstractFn = function() {};"
-                + "goog.abstractFn(1);")
+            "/** @constructor */ function F() {}"
+                + "/** jsdoc */ F.prototype.bar = function() {};"
+                + "F.prototype.bar = function() {};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodHandling4() {
+  public void testDuplicateInstanceMethod5() {
     newTest()
-        .addSource("var goog = {};" + "goog.abstractFn = function() {};" + "goog.abstractFn(1);")
-        .addDiagnostic(
-            "Function goog.abstractFn: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
+        .addSource(
+            "/** @constructor */ function F() {}"
+                + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {"
+                + "  return 3;"
+                + "};"
+                + "/** jsdoc \n * @suppress {duplicate} */ "
+                + "F.prototype.bar = function() { return ''; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testAbstractFunctionHandling() {
+  public void testDuplicateInstanceMethod6() {
     newTest()
         .addSource(
-            "/** @type {!Function} */ var abstractFn = function() {};"
-                // the type of 'f' will become 'Function'
-                + "/** @param {number} x */ var f = abstractFn;"
-                + "f('x');")
+            "/** @constructor */ function F() {}"
+                + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {"
+                + "  return 3;"
+                + "};"
+                + "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ "
+                + "F.prototype.bar = function() { return ''; };")
+        .addDiagnostic(
+            "assignment to property bar of F.prototype\n"
+                + "found   : function(this:F): string\n"
+                + "required: function(this:F): number")
         .run();
   }
 
   @Test
-  public void testAbstractMethodHandling6() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @type {Function} */ goog.abstractFn = function() {};"
-                + "/** @param {number} x */ goog.f = abstractFn;"
-                + "goog.f('x');")
-        .addDiagnostic(
-            "actual parameter 1 of goog.f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .run();
+  public void testStubFunctionDeclaration1() {
+    testFunctionType(
+        "/** @constructor */ function f() {};"
+            + "/** @param {number} x \n * @param {string} y \n"
+            + "  * @return {number} */ f.prototype.foo;",
+        "(new f).foo",
+        "function(this:f, number, string): number");
   }
 
   @Test
-  public void testMethodInference1() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @return {number} */ F.prototype.foo = function() { return 3; };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ G.prototype.foo = function() { return true; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testStubFunctionDeclaration2() {
+    testExternFunctionType(
+        // externs
+        "/** @constructor */ function f() {};"
+            + "/** @constructor \n * @extends {f} */ f.subclass;",
+        "f.subclass",
+        "function(new:f.subclass): ?");
   }
 
   @Test
-  public void testMethodInference2() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.F = function() {};"
-                + "/** @return {number} */ goog.F.prototype.foo = "
-                + "    function() { return 3; };"
-                + "/** @constructor \n * @extends {goog.F} */ "
-                + "goog.G = function() {};"
-                + "/** @override */ goog.G.prototype.foo = function() { return true; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testStubFunctionDeclaration_static_onEs5Class() {
+    testFunctionType(
+        lines(
+            "/** @constructor */ function f() {};", //
+            "/** @return {undefined} */ f.foo;"),
+        "f.foo",
+        "function(): undefined");
   }
 
   @Test
-  public void testMethodInference3() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @param {boolean} x \n * @return {number} */ "
-                + "F.prototype.foo = function(x) { return 3; };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ "
-                + "G.prototype.foo = function(x) { return x; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testStubFunctionDeclaration4() {
+    testFunctionType(
+        "/** @constructor */ function f() { " + "  /** @return {number} */ this.foo;" + "}",
+        "(new f).foo",
+        "function(this:f): number");
   }
 
   @Test
-  public void testMethodInference4() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @param {boolean} x \n * @return {number} */ "
-                + "F.prototype.foo = function(x) { return 3; };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ "
-                + "G.prototype.foo = function(y) { return y; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testStubFunctionDeclaration5() {
+    testFunctionType(
+        lines(
+            "/** @constructor */ function f() { ", //
+            "  /** @type {Function} */ this.foo;",
+            "}"),
+        "(new f).foo",
+        createNullableType(getNativeFunctionType()).toString());
   }
 
   @Test
-  public void testMethodInference5() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @param {number} x \n * @return {string} */ "
-                + "F.prototype.foo = function(x) { return 'x'; };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @type {number} */ G.prototype.num = 3;"
-                + "/** @override */ "
-                + "G.prototype.foo = function(y) { return this.num + y; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testStubFunctionDeclaration6() {
+    testFunctionType(
+        lines(
+            "/** @constructor */ function f() {} ", //
+            "/** @type {Function} */ f.prototype.foo;"),
+        "(new f).foo",
+        createNullableType(getNativeFunctionType()).toString());
   }
 
   @Test
-  public void testMethodInference6() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @param {number} x */ F.prototype.foo = function(x) { };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ G.prototype.foo = function() { };"
-                + "(new G()).foo(1);")
-        .run();
+  public void testStubFunctionDeclaration7() {
+    testFunctionType(
+        lines(
+            "/** @constructor */ function f() {} ",
+            "/** @type {Function} */ f.prototype.foo = function() {};"),
+        "(new f).foo",
+        createNullableType(getNativeFunctionType()).toString());
   }
 
   @Test
-  public void testMethodInference7() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.foo = function() { };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ G.prototype.foo = function(x, y) { };")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property "
-                + "it overrides from superclass F\n"
-                + "original: function(this:F): undefined\n"
-                + "override: function(this:G, ?, ?): undefined")
-        .run();
+  public void testStubFunctionDeclaration8() {
+    testFunctionType(
+        "/** @type {Function} */ var f = function() {}; ",
+        "f",
+        createNullableType(getNativeFunctionType()).toString());
   }
 
   @Test
-  public void testMethodInference8() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.foo = function() { };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ "
-                + "G.prototype.foo = function(opt_b, var_args) { };"
-                + "(new G()).foo(1, 2, 3);")
-        .run();
+  public void testStubFunctionDeclaration9() {
+    testFunctionType("/** @type {function():number} */ var f; ", "f", "function(): number");
   }
 
   @Test
-  public void testMethodInference9() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.foo = function() { };"
-                + "/** @constructor \n * @extends {F} */ "
-                + "function G() {}"
-                + "/** @override */ "
-                + "G.prototype.foo = function(var_args, opt_b) { };")
-        .addDiagnostic("variable length argument must be last")
-        .run();
+  public void testStubFunctionDeclaration10() {
+    testFunctionType(
+        "/** @type {function(number):number} */ var f = function(x) {};",
+        "f",
+        "function(number): number");
   }
 
   @Test
-  public void testStaticMethodDeclaration1() {
+  public void testStubMethodDeclarationDoesntBlockTypechecking_1() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() { F.foo(true); }"
-                + "/** @param {number} x */ F.foo = function(x) {};")
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @return {number} */",
+            "Foo.prototype.method = function() {};",
+            "/**",
+            " * @constructor",
+            " * @implements {Foo}",
+            " */",
+            "function Bar() {}",
+            "Bar.prototype.method;",
+            "var /** null */ n = (new Bar).method();")
         .addDiagnostic(
-            "actual parameter 1 of F.foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testStaticMethodDeclaration2() {
+  public void testStubMethodDeclarationDoesntBlockTypechecking_2() {
     newTest()
         .addSource(
-            "var goog = goog || {}; function f() { goog.foo(true); }"
-                + "/** @param {number} x */ goog.foo = function(x) {};")
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @return {number} */",
+            "Foo.prototype.method = function() {};",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo}",
+            " */",
+            "function Bar() {}",
+            "Bar.prototype.method;",
+            "var /** null */ n = (new Bar).method();")
         .addDiagnostic(
-            "actual parameter 1 of goog.foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testStaticMethodDeclaration3() {
+  public void testStubMethodDeclarationDoesntBlockTypechecking_3() {
     newTest()
         .addSource(
-            "var goog = goog || {}; function f() { goog.foo(true); }" + "goog.foo = function() {};")
-        .addDiagnostic(
-            "Function goog.foo: called with 1 argument(s). Function requires "
-                + "at least 0 argument(s) and no more than 0 argument(s).")
+            "/** @interface */",
+            "var Foo = function() {};",
+            "/** @type {number} */",
+            "Foo.prototype.num;",
+            "/**",
+            " * @constructor",
+            " * @implements {Foo}",
+            " */",
+            "var Bar = function() {};",
+            "/** @type {?} */",
+            "Bar.prototype.num;",
+            "var /** string */ x = (new Bar).num;")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl1() {
-    newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "/** @param {number} x */ goog.foo = function(x) {};"
-                + "/** @param {number} x */ goog.foo = function(x) {};")
-        .addDiagnostic("variable goog.foo redefined, original definition at [testcode]:1")
-        .run();
+  public void testNestedFunctionInference1() {
+    String nestedAssignOfFooAndBar =
+        "/** @constructor */ function f() {};"
+            + "f.prototype.foo = f.prototype.bar = function(){};";
+    testFunctionType(nestedAssignOfFooAndBar, "(new f).bar", "function(this:f): undefined");
   }
 
-  @Test
-  public void testDuplicateStaticMethodDecl2() {
+  /**
+   * Tests the type of a function definition. The function defined by {@code functionDef} should be
+   * named {@code "f"}.
+   */
+  private void testFunctionType(String functionDef, String functionType) {
+    testFunctionType(functionDef, "f", functionType);
+  }
+
+  /**
+   * Tests the type of a function definition. The function defined by {@code functionDef} should be
+   * named {@code functionName}.
+   */
+  private void testFunctionType(String functionDef, String functionName, String functionType) {
+    // using the variable initialization check to verify the function's type
     newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "/** @param {number} x */ goog.foo = function(x) {};"
-                + "/** @param {number} x \n * @suppress {duplicate} */ "
-                + "goog.foo = function(x) {};")
+        .addSource(functionDef + "/** @type {number} */var a=" + functionName + ";")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : " + functionType + "\n" + "required: number")
         .run();
   }
 
-  @Test
-  public void testDuplicateStaticMethodDecl3() {
+  /**
+   * Tests the type of a function definition in externs. The function defined by {@code functionDef}
+   * should be named {@code functionName}.
+   */
+  private void testExternFunctionType(
+      String functionDef, String functionName, String functionType) {
     newTest()
-        .addSource(
-            "var goog = goog || {};" + "goog.foo = function(x) {};" + "goog.foo = function(x) {};")
+        .addExterns(functionDef)
+        .addSource("/** @type {number} */var a=" + functionName + ";")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : " + functionType + "\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl4() {
-    newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "/** @type {Function} */ goog.foo = function(x) {};"
-                + "goog.foo = function(x) {};")
-        .run();
+  public void testTypeRedefinition() {
+    testClosureTypesMultipleWarnings(
+        "a={};/**@enum {string}*/ a.A = {ZOR:'b'};" + "/** @constructor */ a.A = function() {}",
+        ImmutableList.of(
+            // NOTE: "testcode" is the file name used by compiler.parseTestCode(code)
+            "variable a.A redefined with type (typeof a.A), "
+                + "original definition at testcode:1 with type enum{a.A}",
+            lines(
+                "assignment to property A of a", //
+                "found   : (typeof a.A)",
+                "required: enum{a.A}")));
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl5() {
-    newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "goog.foo = function(x) {};"
-                + "/** @return {undefined} */ goog.foo = function(x) {};")
-        .addDiagnostic("variable goog.foo redefined, " + "original definition at [testcode]:1")
-        .run();
+  public void testIn1() {
+    newTest().addSource("'foo' in Object").run();
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl6() {
-    // Make sure the CAST node doesn't interfere with the @suppress
-    // annotation.
-    newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "goog.foo = function(x) {};"
-                + "/**\n"
-                + " * @suppress {duplicate}\n"
-                + " * @return {undefined}\n"
-                + " */\n"
-                + "goog.foo = "
-                + "   /** @type {!Function} */ (function(x) {});")
-        .run();
+  public void testIn2() {
+    newTest().addSource("3 in Object").run();
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl7() {
+  public void testIn3() {
+    newTest().addSource("undefined in Object").run();
+  }
+
+  @Test
+  public void testIn4() {
     newTest()
-        .addSource("/** @type {string} */ var foo;\n" + "var z = function foo() {};\n")
-        .addDiagnostic(TypeCheck.FUNCTION_MASKS_VARIABLE)
+        .addSource("Date in Object")
+        .addDiagnostic(
+            "left side of 'in'\n"
+                + "found   : function(new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n"
+                + "required: (string|symbol)")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticMethodDecl8() {
+  public void testIn5() {
     newTest()
-        .addSource(
-            "/** @fileoverview @suppress {duplicate} */\n"
-                + "/** @type {string} */ var foo;\n"
-                + "var z = function foo() {};\n")
+        .addSource("'x' in null")
+        .addDiagnostic("'in' requires an object\n" + "found   : null\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl1() {
+  public void testIn6() {
     newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "/** @type {Foo} */ goog.foo;"
-                + "/** @type {Foo} */ goog.foo;"
-                + "/** @constructor */ function Foo() {}")
+        .addSource("/** @param {number} x */" + "function g(x) {}" + "g(1 in {});")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl2() {
+  public void testIn7() {
+    // Make sure we do inference in the 'in' expression.
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @type {Foo} */ goog.foo;"
-                + "/** @type {Foo} \n * @suppress {duplicate} */ goog.foo;"
-                + "/** @constructor */ function Foo() {}")
+            "/**",
+            " * @param {number} x",
+            " * @return {number}",
+            " */",
+            "function g(x) { return 5; }",
+            "function f() {",
+            "  var x = {};",
+            "  x.foo = '3';",
+            "  return g(x.foo) in {};",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl3() {
+  public void testInWithThis_narrowsPropertyType() {
+    // TODO(lharker): should we stop doing this narrowing? this code would break under property
+    // renaming.
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @type {!Foo} */ goog.foo;"
-                + "/** @type {string} */ goog.foo;"
-                + "/** @constructor */ function Foo() {}")
-        .addDiagnostic(
-            "variable goog.foo redefined with type string, "
-                + "original definition at [testcode]:1 with type Foo")
+            "/** @constructor */",
+            "function Foo() {}",
+            "Foo.prototype.method = function() {",
+            "  if ('x' in this) {",
+            "    return this.x;", // this access is allowed
+            "  }",
+            "  return this.y;", // this access causes a warning
+            "}")
+        .addDiagnostic("Property y never defined on Foo")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl4() {
-    testClosureTypesMultipleWarnings(
-        "/** @type {!Foo} */ goog.foo;"
-            + "/** @type {string} */ goog.foo = 'x';"
-            + "/** @constructor */ function Foo() {}",
-        ImmutableList.of(
-            "assignment to property foo of goog\n" + "found   : string\n" + "required: Foo",
-            "variable goog.foo redefined with type string, "
-                + "original definition at [testcode]:1 with type Foo"));
+  public void testInWithWellKnownSymbol() {
+    newTest().addSource("Symbol.iterator in Object").includeDefaultExterns().run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl5() {
-    testClosureTypesMultipleWarnings(
-        "var goog = goog || {};"
-            + "/** @type {!Foo} */ goog.foo;"
-            + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';"
-            + "/** @constructor */ function Foo() {}",
-        ImmutableList.of(
-            "assignment to property foo of goog\n" + "found   : string\n" + "required: Foo"));
+  public void testInWithUniqueSymbol() {
+    newTest().addSource("Symbol('foo') in Object").run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl6() {
-    newTest()
-        .addSource(
-            "var goog = goog || {};"
-                + "/** @type {string} */ goog.foo = 'y';"
-                + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';")
-        .run();
+  public void testInWithSymbol() {
+    newTest().addSource("function f(/** symbol */ s) { return s in {}; }").run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl7() {
+  public void testForIn1() {
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @param {string} x */ goog.foo;"
-                + "/** @type {function(string)} */ goog.foo;")
+            "/** @param {boolean} x */ function f(x) {}" + "for (var k in {}) {" + "  f(k);" + "}")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: boolean")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl8() {
+  public void testForIn2() {
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @return {EventCopy} */ goog.foo;"
-                + "/** @constructor */ function EventCopy() {}"
-                + "/** @return {EventCopy} */ goog.foo;")
+            "/** @param {boolean} x */ function f(x) {}"
+                + "/** @enum {string} */ var E = {FOO: 'bar'};"
+                + "/** @type {Object<E, string>} */ var obj = {};"
+                + "var k = null;"
+                + "for (k in obj) {"
+                + "  f(k);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : E<string>\n"
+                + "required: boolean")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDecl9() {
+  public void testForIn3() {
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @return {EventCopy} */ goog.foo;"
-                + "/** @return {EventCopy} */ goog.foo;"
-                + "/** @constructor */ function EventCopy() {}")
+            "/** @param {boolean} x */ function f(x) {}"
+                + "/** @type {Object<number>} */ var obj = {};"
+                + "for (var k in obj) {"
+                + "  f(obj[k]);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: boolean")
         .run();
   }
 
   @Test
-  public void testDuplicateStaticPropertyDec20() {
+  public void testForIn4() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @fileoverview\n"
-                + " * @suppress {duplicate}\n"
-                + " */"
-                + "var goog = goog || {};"
-                + "/** @type {string} */ goog.foo = 'y';"
-                + "/** @type {string} */ goog.foo = 'x';")
+            "/** @param {boolean} x */ function f(x) {}"
+                + "/** @enum {string} */ var E = {FOO: 'bar'};"
+                + "/** @type {Object<E, Array>} */ var obj = {};"
+                + "for (var k in obj) {"
+                + "  f(obj[k]);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (Array|null)\n"
+                + "required: boolean")
         .run();
   }
 
   @Test
-  public void testDuplicateLocalVarDecl() {
-    testClosureTypesMultipleWarnings(
-        "/** @param {number} x */\n" + "function f(x) { /** @type {string} */ var x = ''; }",
-        ImmutableList.of(
-            "variable x redefined with type string, original definition"
-                + " at [testcode]:2 with type number",
-            "initializing variable\n" + "found   : string\n" + "required: number"));
-  }
-
-  @Test
-  public void testDuplicateLocalVarDeclSuppressed() {
-    // We can't just leave this to VarCheck since otherwise if that warning is suppressed, we'll end
-    // up redeclaring it as undefined in the function block, which can cause spurious errors.
+  public void testForIn5() {
     newTest()
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @suppress {duplicate} */", //
-            "function f(x) {",
-            "  var x = x;",
-            "  x.y = true;",
+            "/** @param {boolean} x */ function f(x) {}",
+            "/** @constructor */ var E = function(){};",
+            "/** @override */ E.prototype.toString = function() { return ''; };",
+            "/** @type {Object<!E, number>} */ var obj = {};",
+            "for (var k in obj) {",
+            "  f(k);",
             "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : string",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testShadowBleedingFunctionName() {
-    // This is allowed and creates a new binding inside the function shadowing the bled name.
+  public void testForOf1() {
     newTest()
         .addSource(
-            "var f = function x() {", //
-            "  var x;",
-            "  var /** undefined */ y = x;",
-            "};")
+            "/** @type {!Iterable<number>} */ var it = [1, 2, 3]; for (let x of it) { alert(x); }")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod1() {
-    // If there's no jsdoc on the methods, then we treat them like
-    // any other inferred properties.
+  public void testForOf2() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.bar = function() {};"
-                + "F.prototype.bar = function() {};")
+            "/** @param {boolean} x */ function f(x) {}",
+            "/** @type {!Iterable<number>} */ var it = [1, 2, 3];",
+            "for (let x of it) { f(x); }")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : number",
+                "required: boolean"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod2() {
+  public void testForOf3() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** jsdoc */ F.prototype.bar = function() {};"
-                + "/** jsdoc */ F.prototype.bar = function() {};")
+            "/** @type {?Iterable<number>} */ var it = [1, 2, 3];", //
+            "for (let x of it) {}")
+        .addDiagnostic(
+            lines(
+                "Can only iterate over a (non-null) Iterable type",
+                "found   : (Iterable<number>|null)",
+                "required: Iterable"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod3() {
+  public void testForOf4() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.bar = function() {};"
-                + "/** jsdoc */ F.prototype.bar = function() {};")
+            "function f(/** !Iterator<number> */ it) {", //
+            "  for (let x of it) {}",
+            "}")
+        .addDiagnostic(
+            lines(
+                "Can only iterate over a (non-null) Iterable type",
+                "found   : Iterator<number,?,?>",
+                "required: Iterable"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod4() {
+  public void testForOf5() {
+    // 'string' is an Iterable<string> so it can be used in a for/of.
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** jsdoc */ F.prototype.bar = function() {};"
-                + "F.prototype.bar = function() {};")
+            "function f(/** string */ ch, /** string */ str) {", //
+            "  for (ch of str) {}",
+            "}")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod5() {
+  public void testForOf6() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {"
-                + "  return 3;"
-                + "};"
-                + "/** jsdoc \n * @suppress {duplicate} */ "
-                + "F.prototype.bar = function() { return ''; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
+            "function f(/** !Array<number> */ a) {", //
+            "  for (let elem of a) {}",
+            "}")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateInstanceMethod6() {
+  public void testForOf7() {
+    newTest().addSource("for (let elem of ['array', 'literal']) {}").includeDefaultExterns().run();
+  }
+
+  // TODO(tbreisacher): This should produce a warning: Expected 'null' but got 'string|number'
+  @Test
+  public void testForOf8() {
+    // Union of different types of Iterables.
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {"
-                + "  return 3;"
-                + "};"
-                + "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ "
-                + "F.prototype.bar = function() { return ''; };")
-        .addDiagnostic(
-            "assignment to property bar of F.prototype\n"
-                + "found   : function(this:F): string\n"
-                + "required: function(this:F): number")
+            "function f(/** null */ x) {}",
+            "(function(/** !Array<string>|!Iterable<number> */ it) {",
+            "  for (let elem of it) {",
+            "    f(elem);",
+            "  }",
+            "})(['']);")
+        .includeDefaultExterns()
         .run();
   }
 
+  // TODO(nicksantos): change this to something that makes sense.
   @Test
-  public void testStubFunctionDeclaration1() {
-    testFunctionType(
-        "/** @constructor */ function f() {};"
-            + "/** @param {number} x \n * @param {string} y \n"
-            + "  * @return {number} */ f.prototype.foo;",
-        "(new f).foo",
-        "function(this:f, number, string): number");
+  @Ignore
+  public void testComparison1() {
+    newTest()
+        .addSource("/**@type null */var a;" + "/**@type !Date */var b;" + "if (a==b) {}")
+        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: Date")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration2() {
-    testExternFunctionType(
-        // externs
-        "/** @constructor */ function f() {};"
-            + "/** @constructor \n * @extends {f} */ f.subclass;",
-        "f.subclass",
-        "function(new:f.subclass): ?");
+  public void testComparison2() {
+    newTest()
+        .addSource("/**@type {number}*/var a;" + "/**@type {!Date} */var b;" + "if (a!==b) {}")
+        .addDiagnostic("condition always evaluates to true\n" + "left : number\n" + "right: Date")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration_static_onEs5Class() {
-    testFunctionType(
-        lines(
-            "/** @constructor */ function f() {};", //
-            "/** @return {undefined} */ f.foo;"),
-        "f.foo",
-        "function(): undefined");
+  public void testComparison3() {
+    // Since null == undefined in JavaScript, this code is reasonable.
+    newTest().addSource("/** @type {(Object|undefined)} */var a;" + "var b = a == null").run();
   }
 
   @Test
-  public void testStubFunctionDeclaration4() {
-    testFunctionType(
-        "/** @constructor */ function f() { " + "  /** @return {number} */ this.foo;" + "}",
-        "(new f).foo",
-        "function(this:f): number");
+  public void testComparison4() {
+    newTest()
+        .addSource(
+            "/** @type {(!Object|undefined)} */var a;"
+                + "/** @type {!Object} */var b;"
+                + "var c = a == b")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration5() {
-    testFunctionType(
-        lines(
-            "/** @constructor */ function f() { ", //
-            "  /** @type {Function} */ this.foo;",
-            "}"),
-        "(new f).foo",
-        createNullableType(getNativeFunctionType()).toString());
+  public void testComparison5() {
+    newTest()
+        .addSource("/** @type {null} */var a;" + "/** @type {null} */var b;" + "a == b")
+        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration6() {
-    testFunctionType(
-        lines(
-            "/** @constructor */ function f() {} ", //
-            "/** @type {Function} */ f.prototype.foo;"),
-        "(new f).foo",
-        createNullableType(getNativeFunctionType()).toString());
+  public void testComparison6() {
+    newTest()
+        .addSource("/** @type {null} */var a;" + "/** @type {null} */var b;" + "a != b")
+        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: null")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration7() {
-    testFunctionType(
-        lines(
-            "/** @constructor */ function f() {} ",
-            "/** @type {Function} */ f.prototype.foo = function() {};"),
-        "(new f).foo",
-        createNullableType(getNativeFunctionType()).toString());
+  public void testComparison7() {
+    newTest()
+        .addSource("var a;" + "var b;" + "a == b")
+        .addDiagnostic(
+            "condition always evaluates to true\n" + "left : undefined\n" + "right: undefined")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration8() {
-    testFunctionType(
-        "/** @type {Function} */ var f = function() {}; ",
-        "f",
-        createNullableType(getNativeFunctionType()).toString());
+  public void testComparison8() {
+    newTest()
+        .addSource("/** @type {Array<string>} */ var a = [];" + "a[0] == null || a[1] == undefined")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration9() {
-    testFunctionType("/** @type {function():number} */ var f; ", "f", "function(): number");
+  public void testComparison9() {
+    newTest()
+        .addSource("/** @type {Array<undefined>} */ var a = [];" + "a[0] == null")
+        .addDiagnostic(
+            "condition always evaluates to true\n" + "left : undefined\n" + "right: null")
+        .run();
   }
 
   @Test
-  public void testStubFunctionDeclaration10() {
-    testFunctionType(
-        "/** @type {function(number):number} */ var f = function(x) {};",
-        "f",
-        "function(number): number");
+  public void testComparison10() {
+    newTest().addSource("/** @type {Array<undefined>} */ var a = [];" + "a[0] === null").run();
   }
 
   @Test
-  public void testStubMethodDeclarationDoesntBlockTypechecking_1() {
+  public void testComparison11() {
     newTest()
-        .addSource(
-            "/** @interface */",
-            "function Foo() {}",
-            "/** @return {number} */",
-            "Foo.prototype.method = function() {};",
-            "/**",
-            " * @constructor",
-            " * @implements {Foo}",
-            " */",
-            "function Bar() {}",
-            "Bar.prototype.method;",
-            "var /** null */ n = (new Bar).method();")
+        .addSource("(function(){}) == 'x'")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "condition always evaluates to false\n"
+                + "left : function(): undefined\n"
+                + "right: string")
         .run();
   }
 
   @Test
-  public void testStubMethodDeclarationDoesntBlockTypechecking_2() {
+  public void testComparison12() {
     newTest()
-        .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @return {number} */",
-            "Foo.prototype.method = function() {};",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo}",
-            " */",
-            "function Bar() {}",
-            "Bar.prototype.method;",
-            "var /** null */ n = (new Bar).method();")
+        .addSource("(function(){}) == 3")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "condition always evaluates to false\n"
+                + "left : function(): undefined\n"
+                + "right: number")
         .run();
   }
 
   @Test
-  public void testStubMethodDeclarationDoesntBlockTypechecking_3() {
+  public void testComparison13() {
     newTest()
-        .addSource(
-            "/** @interface */",
-            "var Foo = function() {};",
-            "/** @type {number} */",
-            "Foo.prototype.num;",
-            "/**",
-            " * @constructor",
-            " * @implements {Foo}",
-            " */",
-            "var Bar = function() {};",
-            "/** @type {?} */",
-            "Bar.prototype.num;",
-            "var /** string */ x = (new Bar).num;")
+        .addSource("(function(){}) == false")
+        .addDiagnostic(
+            "condition always evaluates to false\n"
+                + "left : function(): undefined\n"
+                + "right: boolean")
         .run();
   }
 
   @Test
-  public void testNestedFunctionInference1() {
-    String nestedAssignOfFooAndBar =
-        "/** @constructor */ function f() {};"
-            + "f.prototype.foo = f.prototype.bar = function(){};";
-    testFunctionType(nestedAssignOfFooAndBar, "(new f).bar", "function(this:f): undefined");
+  public void testComparison14() {
+    newTest()
+        .addSource(
+            "/** @type {function((Array|string), Object): number} */"
+                + "function f(x, y) { return x === y; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
-  /**
-   * Tests the type of a function definition. The function defined by {@code functionDef} should be
-   * named {@code "f"}.
-   */
-  private void testFunctionType(String functionDef, String functionType) {
-    testFunctionType(functionDef, "f", functionType);
+  @Test
+  public void testComparison15() {
+    testClosureTypes(
+        "/** @constructor */ function F() {}"
+            + "/**\n"
+            + " * @param {number} x\n"
+            + " * @constructor\n"
+            + " * @extends {F}\n"
+            + " */\n"
+            + "function G(x) {}\n"
+            + "goog.inherits(G, F);\n"
+            + "/**\n"
+            + " * @param {number} x\n"
+            + " * @constructor\n"
+            + " * @extends {G}\n"
+            + " */\n"
+            + "function H(x) {}\n"
+            + "goog.inherits(H, G);\n"
+            + "/** @param {G} x */"
+            + "function f(x) { return x.constructor === H; }",
+        null);
   }
 
-  /**
-   * Tests the type of a function definition. The function defined by {@code functionDef} should be
-   * named {@code functionName}.
-   */
-  private void testFunctionType(String functionDef, String functionName, String functionType) {
-    // using the variable initialization check to verify the function's type
+  @Test
+  public void testDeleteOperator1() {
     newTest()
-        .addSource(functionDef + "/** @type {number} */var a=" + functionName + ";")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : " + functionType + "\n" + "required: number")
+        .addSource("var x = {};" + "/** @return {string} */ function f() { return delete x['a']; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: string")
         .run();
   }
 
-  /**
-   * Tests the type of a function definition in externs. The function defined by {@code functionDef}
-   * should be named {@code functionName}.
-   */
-  private void testExternFunctionType(
-      String functionDef, String functionName, String functionType) {
+  @Test
+  public void testDeleteOperator2() {
     newTest()
-        .addExterns(functionDef)
-        .addSource("/** @type {number} */var a=" + functionName + ";")
+        .addSource(
+            "var obj = {};"
+                + "/** \n"
+                + " * @param {string} x\n"
+                + " * @return {Object} */ function f(x) { return obj; }"
+                + "/** @param {?number} x */ function g(x) {"
+                + "  if (x) { delete f(x)['a']; }"
+                + "}")
         .addDiagnostic(
-            "initializing variable\n" + "found   : " + functionType + "\n" + "required: number")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testTypeRedefinition() {
-    testClosureTypesMultipleWarnings(
-        "a={};/**@enum {string}*/ a.A = {ZOR:'b'};" + "/** @constructor */ a.A = function() {}",
-        ImmutableList.of(
-            "variable a.A redefined with type (typeof a.A), "
-                + "original definition at [testcode]:1 with type enum{a.A}",
-            lines(
-                "assignment to property A of a", //
-                "found   : (typeof a.A)",
-                "required: enum{a.A}")));
+  public void testEnumStaticMethod1() {
+    newTest()
+        .addSource(
+            "/** @enum */ var Foo = {AAA: 1};"
+                + "/** @param {number} x */ Foo.method = function(x) {};"
+                + "Foo.method(true);")
+        .addDiagnostic(
+            "actual parameter 1 of Foo.method does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
   }
 
   @Test
-  public void testIn1() {
-    newTest().addSource("'foo' in Object").run();
+  public void testEnumStaticMethod2() {
+    newTest()
+        .addSource(
+            "/** @enum */ var Foo = {AAA: 1};"
+                + "/** @param {number} x */ Foo.method = function(x) {};"
+                + "function f() { Foo.method(true); }")
+        .addDiagnostic(
+            "actual parameter 1 of Foo.method does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
   }
 
   @Test
-  public void testIn2() {
-    newTest().addSource("3 in Object").run();
+  public void testEnum1() {
+    newTest().addSource("/**@enum*/var a={BB:1,CC:2};\n" + "/**@type {a}*/var d;d=a.BB;").run();
   }
 
   @Test
-  public void testIn3() {
-    newTest().addSource("undefined in Object").run();
+  public void testEnum3() {
+    newTest()
+        .addSource("/**@enum*/var a={BB:1,BB:2}")
+        .addDiagnostic("variable a.BB redefined, original definition at [testcode]:1")
+        .run();
   }
 
   @Test
-  public void testIn4() {
+  public void testEnum4() {
     newTest()
-        .addSource("Date in Object")
+        .addSource("/**@enum*/var a={BB:'string'}")
         .addDiagnostic(
-            "left side of 'in'\n"
-                + "found   : function(new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n"
-                + "required: (string|symbol)")
+            "assignment to property BB of enum{a}\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testIn5() {
+  public void testEnum5() {
     newTest()
-        .addSource("'x' in null")
-        .addDiagnostic("'in' requires an object\n" + "found   : null\n" + "required: Object")
+        .addSource("/**@enum {?String}*/var a={BB:'string'}")
+        .addDiagnostic(
+            "assignment to property BB of enum{a}\n"
+                + "found   : string\n"
+                + "required: (String|null)")
         .run();
   }
 
   @Test
-  public void testIn6() {
+  public void testEnum6() {
     newTest()
-        .addSource("/** @param {number} x */" + "function g(x) {}" + "g(1 in {});")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+        .addSource("/**@enum*/var a={BB:1,CC:2};\n/**@type {!Array}*/var d;d=a.BB;")
+        .addDiagnostic("assignment\n" + "found   : a<number>\n" + "required: Array")
         .run();
   }
 
   @Test
-  public void testIn7() {
-    // Make sure we do inference in the 'in' expression.
+  public void testEnum7() {
     newTest()
-        .addSource(
-            "/**",
-            " * @param {number} x",
-            " * @return {number}",
-            " */",
-            "function g(x) { return 5; }",
-            "function f() {",
-            "  var x = {};",
-            "  x.foo = '3';",
-            "  return g(x.foo) in {};",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : string",
-                "required: number"))
+        .addSource("/** @enum */var a={AA:1,BB:2,CC:3};" + "/** @type {a} */var b=a.D;")
+        .addDiagnostic("element D does not exist on this enum")
         .run();
   }
 
   @Test
-  public void testInWithThis_narrowsPropertyType() {
-    // TODO(lharker): should we stop doing this narrowing? this code would break under property
-    // renaming.
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "Foo.prototype.method = function() {",
-            "  if ('x' in this) {",
-            "    return this.x;", // this access is allowed
-            "  }",
-            "  return this.y;", // this access causes a warning
-            "}")
-        .addDiagnostic("Property y never defined on Foo")
-        .run();
+  public void testEnum8() {
+    testClosureTypesMultipleWarnings(
+        "/** @enum */var a=8;",
+        ImmutableList.of(
+            "enum initializer must be an object literal or an enum",
+            "initializing variable\n" + "found   : number\n" + "required: enum{a}"));
   }
 
   @Test
-  public void testInWithWellKnownSymbol() {
-    newTest().addSource("Symbol.iterator in Object").includeDefaultExterns().run();
+  public void testEnum9() {
+    testClosureTypesMultipleWarnings(
+        "/** @enum */ goog.a=8;",
+        ImmutableList.of(
+            "assignment to property a of goog\n" + "found   : number\n" + "required: enum{goog.a}",
+            "enum initializer must be an object literal or an enum"));
   }
 
   @Test
-  public void testInWithUniqueSymbol() {
-    newTest().addSource("Symbol('foo') in Object").run();
+  public void testEnum10() {
+    newTest().addSource("/** @enum {number} */" + "goog.K = { A : 3 };").run();
   }
 
   @Test
-  public void testInWithSymbol() {
-    newTest().addSource("function f(/** symbol */ s) { return s in {}; }").run();
+  public void testEnum11() {
+    newTest().addSource("/** @enum {number} */" + "goog.K = { 502 : 3 };").run();
   }
 
   @Test
-  public void testForIn1() {
-    newTest()
-        .addSource(
-            "/** @param {boolean} x */ function f(x) {}" + "for (var k in {}) {" + "  f(k);" + "}")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: boolean")
-        .run();
+  public void testEnum12() {
+    newTest().addSource("/** @enum {number} */ var a = {};" + "/** @enum */ var b = a;").run();
   }
 
   @Test
-  public void testForIn2() {
+  public void testEnum13a() {
     newTest()
-        .addSource(
-            "/** @param {boolean} x */ function f(x) {}"
-                + "/** @enum {string} */ var E = {FOO: 'bar'};"
-                + "/** @type {Object<E, string>} */ var obj = {};"
-                + "var k = null;"
-                + "for (k in obj) {"
-                + "  f(k);"
-                + "}")
+        .addSource("/** @enum {number} */ var a = {};" + "/** @enum {string} */ var b = a;")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : E<string>\n"
-                + "required: boolean")
+            "incompatible enum element types\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testForIn3() {
+  public void testEnum13b() {
     newTest()
         .addSource(
-            "/** @param {boolean} x */ function f(x) {}"
-                + "/** @type {Object<number>} */ var obj = {};"
-                + "for (var k in obj) {"
-                + "  f(obj[k]);"
-                + "}")
+            "/** @enum {number} */ var a = {};",
+            "/** @const */ var ns = {};",
+            "/** @enum {string} */ ns.b = a;")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: boolean")
+            lines(
+                "incompatible enum element types", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testForIn4() {
+  public void testEnum14() {
     newTest()
         .addSource(
-            "/** @param {boolean} x */ function f(x) {}"
-                + "/** @enum {string} */ var E = {FOO: 'bar'};"
-                + "/** @type {Object<E, Array>} */ var obj = {};"
-                + "for (var k in obj) {"
-                + "  f(obj[k]);"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (Array|null)\n"
-                + "required: boolean")
+            "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.FOO;")
         .run();
   }
 
   @Test
-  public void testForIn5() {
+  public void testEnum15() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @param {boolean} x */ function f(x) {}",
-            "/** @constructor */ var E = function(){};",
-            "/** @override */ E.prototype.toString = function() { return ''; };",
-            "/** @type {Object<!E, number>} */ var obj = {};",
-            "for (var k in obj) {",
-            "  f(k);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : string",
-                "required: boolean"))
+            "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.BAR;")
+        .addDiagnostic("element BAR does not exist on this enum")
         .run();
   }
 
   @Test
-  public void testForOf1() {
+  public void testEnum16() {
     newTest()
-        .addSource(
-            "/** @type {!Iterable<number>} */ var it = [1, 2, 3]; for (let x of it) { alert(x); }")
-        .includeDefaultExterns()
+        .addSource("var goog = {};" + "/**@enum*/goog .a={BB:1,BB:2}")
+        .addDiagnostic("variable goog.a.BB redefined, original definition at [testcode]:1")
         .run();
   }
 
   @Test
-  public void testForOf2() {
+  public void testEnum17() {
     newTest()
-        .addSource(
-            "/** @param {boolean} x */ function f(x) {}",
-            "/** @type {!Iterable<number>} */ var it = [1, 2, 3];",
-            "for (let x of it) { f(x); }")
+        .addSource("var goog = {};" + "/**@enum*/goog.a={BB:'string'}")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : number",
-                "required: boolean"))
-        .includeDefaultExterns()
+            "assignment to property BB of enum{goog.a}\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testForOf3() {
+  public void testEnum18() {
     newTest()
         .addSource(
-            "/** @type {?Iterable<number>} */ var it = [1, 2, 3];", //
-            "for (let x of it) {}")
-        .addDiagnostic(
-            lines(
-                "Can only iterate over a (non-null) Iterable type",
-                "found   : (Iterable<number>|null)",
-                "required: Iterable"))
-        .includeDefaultExterns()
+            "/**@enum*/ var E = {A: 1, B: 2};"
+                + "/** @param {!E} x\n@return {number} */\n"
+                + "var f = function(x) { return x; };")
         .run();
   }
 
   @Test
-  public void testForOf4() {
+  public void testEnum19() {
     newTest()
         .addSource(
-            "function f(/** !Iterator<number> */ it) {", //
-            "  for (let x of it) {}",
-            "}")
-        .addDiagnostic(
-            lines(
-                "Can only iterate over a (non-null) Iterable type",
-                "found   : Iterator<number,?,?>",
-                "required: Iterable"))
-        .includeDefaultExterns()
+            "/**@enum*/ var E = {A: 1, B: 2};"
+                + "/** @param {number} x\n@return {!E} */\n"
+                + "var f = function(x) { return x; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: E<number>")
         .run();
   }
 
   @Test
-  public void testForOf5() {
-    // 'string' is an Iterable<string> so it can be used in a for/of.
+  public void testEnum20() {
+    newTest().addSource("/**@enum*/ var E = {A: 1, B: 2}; var x = []; x[E.A] = 0;").run();
+  }
+
+  @Test
+  public void testEnum21() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @enum {string} */ var E = {A : 'a', B : 'b'};\n"
+                + "/** @param {!E} x\n@return {!E} */ function f(x) { return x; }");
+    Node nodeX = n.getLastChild().getLastChild().getLastChild().getLastChild();
+    JSType typeE = nodeX.getJSType();
+    assertThat(typeE.isObject()).isFalse();
+    assertThat(typeE.isNullable()).isFalse();
+  }
+
+  @Test
+  public void testEnum22() {
     newTest()
         .addSource(
-            "function f(/** string */ ch, /** string */ str) {", //
-            "  for (ch of str) {}",
-            "}")
-        .includeDefaultExterns()
+            "/**@enum*/ var E = {A: 1, B: 2};"
+                + "/** @param {E} x \n* @return {number} */ function f(x) {return x}")
         .run();
   }
 
   @Test
-  public void testForOf6() {
+  public void testEnum23() {
     newTest()
         .addSource(
-            "function f(/** !Array<number> */ a) {", //
-            "  for (let elem of a) {}",
-            "}")
-        .includeDefaultExterns()
+            "/**@enum*/ var E = {A: 1, B: 2};"
+                + "/** @param {E} x \n* @return {string} */ function f(x) {return x}")
+        .addDiagnostic("inconsistent return type\n" + "found   : E<number>\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testForOf7() {
-    newTest().addSource("for (let elem of ['array', 'literal']) {}").includeDefaultExterns().run();
+  public void testEnum24() {
+    newTest()
+        .addSource(
+            "/**@enum {?Object} */ var E = {A: {}};"
+                + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : E<(Object|null)>\n" + "required: Object")
+        .run();
   }
 
-  // TODO(tbreisacher): This should produce a warning: Expected 'null' but got 'string|number'
   @Test
-  public void testForOf8() {
-    // Union of different types of Iterables.
+  public void testEnum25() {
     newTest()
         .addSource(
-            "function f(/** null */ x) {}",
-            "(function(/** !Array<string>|!Iterable<number> */ it) {",
-            "  for (let elem of it) {",
-            "    f(elem);",
-            "  }",
-            "})(['']);")
-        .includeDefaultExterns()
+            "/**@enum {!Object} */ var E = {A: {}};"
+                + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}")
         .run();
   }
 
-  // TODO(nicksantos): change this to something that makes sense.
   @Test
-  @Ignore
-  public void testComparison1() {
+  public void testEnum26() {
     newTest()
-        .addSource("/**@type null */var a;" + "/**@type !Date */var b;" + "if (a==b) {}")
-        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: Date")
+        .addSource(
+            "var a = {}; /**@enum*/ a.B = {A: 1, B: 2};"
+                + "/** @param {a.B} x \n* @return {number} */ function f(x) {return x}")
         .run();
   }
 
   @Test
-  public void testComparison2() {
+  public void testEnum27() {
+    // x is unknown
     newTest()
-        .addSource("/**@type {number}*/var a;" + "/**@type {!Date} */var b;" + "if (a!==b) {}")
-        .addDiagnostic("condition always evaluates to true\n" + "left : number\n" + "right: Date")
+        .addSource("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A == x; }")
         .run();
   }
 
   @Test
-  public void testComparison3() {
-    // Since null == undefined in JavaScript, this code is reasonable.
-    newTest().addSource("/** @type {(Object|undefined)} */var a;" + "var b = a == null").run();
+  public void testEnum28() {
+    // x is unknown
+    newTest()
+        .addSource("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A.B == x; }")
+        .run();
   }
 
   @Test
-  public void testComparison4() {
+  public void testEnum29() {
     newTest()
         .addSource(
-            "/** @type {(!Object|undefined)} */var a;"
-                + "/** @type {!Object} */var b;"
-                + "var c = a == b")
+            "/** @enum */ var A = {B: 1, C: 2}; "
+                + "/** @return {number} */ function f() { return A; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : enum{A}\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testComparison5() {
+  public void testEnum30() {
     newTest()
-        .addSource("/** @type {null} */var a;" + "/** @type {null} */var b;" + "a == b")
-        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
+        .addSource(
+            "/** @enum */ var A = {B: 1, C: 2}; "
+                + "/** @return {number} */ function f() { return A.B; }")
         .run();
   }
 
   @Test
-  public void testComparison6() {
+  public void testEnum31() {
     newTest()
-        .addSource("/** @type {null} */var a;" + "/** @type {null} */var b;" + "a != b")
-        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: null")
+        .addSource(
+            "/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : enum{A}\n" + "required: A<number>")
         .run();
   }
 
   @Test
-  public void testComparison7() {
+  public void testEnum32() {
     newTest()
-        .addSource("var a;" + "var b;" + "a == b")
-        .addDiagnostic(
-            "condition always evaluates to true\n" + "left : undefined\n" + "right: undefined")
+        .addSource(
+            "/** @enum */ var A = {B: 1, C: 2}; "
+                + "/** @return {A} */ function f() { return A.B; }")
         .run();
   }
 
   @Test
-  public void testComparison8() {
+  public void testEnum34() {
     newTest()
-        .addSource("/** @type {Array<string>} */ var a = [];" + "a[0] == null || a[1] == undefined")
+        .addSource(
+            "/** @enum */ var A = {B: 1, C: 2}; "
+                + "/** @param {number} x */ function f(x) { return x == A.B; }")
         .run();
   }
 
   @Test
-  public void testComparison9() {
+  public void testEnum35() {
     newTest()
-        .addSource("/** @type {Array<undefined>} */ var a = [];" + "a[0] == null")
-        .addDiagnostic(
-            "condition always evaluates to true\n" + "left : undefined\n" + "right: null")
+        .addSource(
+            "var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};"
+                + "/** @return {a.b} */ function f() { return a.b.C; }")
         .run();
   }
 
   @Test
-  public void testComparison10() {
-    newTest().addSource("/** @type {Array<undefined>} */ var a = [];" + "a[0] === null").run();
+  public void testEnum36() {
+    newTest()
+        .addSource(
+            "var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};"
+                + "/** @return {!a.b} */ function f() { return 1; }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : number\n" + "required: a.b<number>")
+        .run();
   }
 
   @Test
-  public void testComparison11() {
+  public void testEnum37() {
     newTest()
-        .addSource("(function(){}) == 'x'")
-        .addDiagnostic(
-            "condition always evaluates to false\n"
-                + "left : function(): undefined\n"
-                + "right: string")
-        .run();
-  }
-
-  @Test
-  public void testComparison12() {
-    newTest()
-        .addSource("(function(){}) == 3")
-        .addDiagnostic(
-            "condition always evaluates to false\n"
-                + "left : function(): undefined\n"
-                + "right: number")
+        .addSource(
+            "var goog = goog || {};"
+                + "/** @enum {number} */ goog.a = {};"
+                + "/** @enum */ var b = goog.a;")
         .run();
   }
 
   @Test
-  public void testComparison13() {
+  public void testEnum38() {
     newTest()
-        .addSource("(function(){}) == false")
-        .addDiagnostic(
-            "condition always evaluates to false\n"
-                + "left : function(): undefined\n"
-                + "right: boolean")
+        .addSource(
+            "/** @enum {MyEnum} */ var MyEnum = {};" + "/** @param {MyEnum} x */ function f(x) {}")
+        .addDiagnostic("Cycle detected in inheritance chain of type MyEnum")
         .run();
   }
 
   @Test
-  public void testComparison14() {
+  public void testEnum39() {
     newTest()
         .addSource(
-            "/** @type {function((Array|string), Object): number} */"
-                + "function f(x, y) { return x === y; }")
+            "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};"
+                + "/** @param {MyEnum} x \n * @return {number} */"
+                + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }")
         .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testComparison15() {
-    testClosureTypes(
-        "/** @constructor */ function F() {}"
-            + "/**\n"
-            + " * @param {number} x\n"
-            + " * @constructor\n"
-            + " * @extends {F}\n"
-            + " */\n"
-            + "function G(x) {}\n"
-            + "goog.inherits(G, F);\n"
-            + "/**\n"
-            + " * @param {number} x\n"
-            + " * @constructor\n"
-            + " * @extends {G}\n"
-            + " */\n"
-            + "function H(x) {}\n"
-            + "goog.inherits(H, G);\n"
-            + "/** @param {G} x */"
-            + "function f(x) { return x.constructor === H; }",
-        null);
-  }
-
-  @Test
-  public void testDeleteOperator1() {
+  public void testEnum40() {
     newTest()
-        .addSource("var x = {};" + "/** @return {string} */ function f() { return delete x['a']; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: string")
+        .addSource(
+            "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};"
+                + "/** @param {number} x \n * @return {number} */"
+                + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testDeleteOperator2() {
+  public void testEnum41() {
     newTest()
         .addSource(
-            "var obj = {};"
-                + "/** \n"
-                + " * @param {string} x\n"
-                + " * @return {Object} */ function f(x) { return obj; }"
-                + "/** @param {?number} x */ function g(x) {"
-                + "  if (x) { delete f(x)['a']; }"
-                + "}")
+            "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};"
+                + "/** @return {string} */"
+                + "function f() { return MyEnum.FOO; }")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "inconsistent return type\n" + "found   : MyEnum<number>\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testEnumStaticMethod1() {
+  public void testEnum42a() {
     newTest()
         .addSource(
-            "/** @enum */ var Foo = {AAA: 1};"
-                + "/** @param {number} x */ Foo.method = function(x) {};"
-                + "Foo.method(true);")
-        .addDiagnostic(
-            "actual parameter 1 of Foo.method does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @param {number} x */ function f(x) {}",
+            "/** @enum {Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
+            "f(MyEnum.FOO.a);")
+        .addDiagnostic("Property a never defined on MyEnum<Object>")
         .run();
   }
 
   @Test
-  public void testEnumStaticMethod2() {
+  public void testEnum42b() {
     newTest()
         .addSource(
-            "/** @enum */ var Foo = {AAA: 1};"
-                + "/** @param {number} x */ Foo.method = function(x) {};"
-                + "function f() { Foo.method(true); }")
-        .addDiagnostic(
-            "actual parameter 1 of Foo.method does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @param {number} x */ function f(x) {}",
+            "/** @enum {!Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
+            "f(MyEnum.FOO.a);")
+        .addDiagnostic("Property a never defined on MyEnum<Object>")
         .run();
   }
 
   @Test
-  public void testEnum1() {
-    newTest().addSource("/**@enum*/var a={BB:1,CC:2};\n" + "/**@type {a}*/var d;d=a.BB;").run();
-  }
+  public void testEnum42c() {
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testEnum3() {
     newTest()
-        .addSource("/**@enum*/var a={BB:1,BB:2}")
-        .addDiagnostic("variable a.BB redefined, original definition at [testcode]:1")
+        .addSource(
+            "/** @param {number} x */ function f(x) {}",
+            "/** @enum {Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
+            "f(MyEnum.FOO.a);")
         .run();
   }
 
   @Test
-  public void testEnum4() {
+  public void testEnum43() {
     newTest()
-        .addSource("/**@enum*/var a={BB:'string'}")
-        .addDiagnostic(
-            "assignment to property BB of enum{a}\n" + "found   : string\n" + "required: number")
+        .addSource(
+            "/** @param {number} x */ function f(x) {}",
+            "/** @enum {{a:number, b:number}} */ var MyEnum = {FOO: {a: 1, b: 2}};",
+            "f(MyEnum.FOO.a);")
         .run();
   }
 
   @Test
-  public void testEnum5() {
+  public void testEnumDefinedInObjectLiteral() {
     newTest()
-        .addSource("/**@enum {?String}*/var a={BB:'string'}")
-        .addDiagnostic(
-            "assignment to property BB of enum{a}\n"
-                + "found   : string\n"
-                + "required: (String|null)")
+        .addSource(
+            "var ns = {",
+            "  /** @enum {number} */",
+            "  Enum: {A: 1, B: 2},",
+            "};",
+            "/** @param {!ns.Enum} arg */",
+            "function f(arg) {}")
         .run();
   }
 
   @Test
-  public void testEnum6() {
+  public void testAliasedEnum1() {
     newTest()
-        .addSource("/**@enum*/var a={BB:1,CC:2};\n/**@type {!Array}*/var d;d=a.BB;")
-        .addDiagnostic("assignment\n" + "found   : a<number>\n" + "required: Array")
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};"
+                + "/** @enum */ var MyEnum = YourEnum;"
+                + "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum7() {
+  public void testAliasedEnum2() {
     newTest()
-        .addSource("/** @enum */var a={AA:1,BB:2,CC:3};" + "/** @type {a} */var b=a.D;")
-        .addDiagnostic("element D does not exist on this enum")
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};"
+                + "/** @enum */ var MyEnum = YourEnum;"
+                + "/** @param {YourEnum} x */ function f(x) {} f(MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum8() {
-    testClosureTypesMultipleWarnings(
-        "/** @enum */var a=8;",
-        ImmutableList.of(
-            "enum initializer must be an object literal or an enum",
-            "initializing variable\n" + "found   : number\n" + "required: enum{a}"));
-  }
-
-  @Test
-  public void testEnum9() {
-    testClosureTypesMultipleWarnings(
-        "/** @enum */ goog.a=8;",
-        ImmutableList.of(
-            "assignment to property a of goog\n" + "found   : number\n" + "required: enum{goog.a}",
-            "enum initializer must be an object literal or an enum"));
-  }
-
-  @Test
-  public void testEnum10() {
-    newTest().addSource("/** @enum {number} */" + "goog.K = { A : 3 };").run();
+  public void testAliasedEnum3() {
+    newTest()
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};"
+                + "/** @enum */ var MyEnum = YourEnum;"
+                + "/** @param {MyEnum} x */ function f(x) {} f(YourEnum.FOO);")
+        .run();
   }
 
   @Test
-  public void testEnum11() {
-    newTest().addSource("/** @enum {number} */" + "goog.K = { 502 : 3 };").run();
+  public void testAliasedEnum4() {
+    newTest()
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};"
+                + "/** @enum */ var MyEnum = YourEnum;"
+                + "/** @param {YourEnum} x */ function f(x) {} f(YourEnum.FOO);")
+        .run();
   }
 
   @Test
-  public void testEnum12() {
-    newTest().addSource("/** @enum {number} */ var a = {};" + "/** @enum */ var b = a;").run();
+  public void testAliasedEnum5() {
+    newTest()
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};"
+                + "/** @enum */ var MyEnum = YourEnum;"
+                + "/** @param {string} x */ function f(x) {} f(MyEnum.FOO);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : YourEnum<number>\n"
+                + "required: string")
+        .run();
   }
 
   @Test
-  public void testEnum13a() {
+  public void testAliasedEnum_rhsIsStubDeclaration() {
     newTest()
-        .addSource("/** @enum {number} */ var a = {};" + "/** @enum {string} */ var b = a;")
+        .addSource(
+            "let YourEnum;", //
+            "/** @enum */ const MyEnum = YourEnum;")
         .addDiagnostic(
-            "incompatible enum element types\n" + "found   : number\n" + "required: string")
+            lines(
+                "initializing variable", //
+                "found   : undefined",
+                "required: enum{MyEnum}"))
         .run();
   }
 
   @Test
-  public void testEnum13b() {
+  public void testAliasedEnum_rhsIsNonEnum() {
     newTest()
         .addSource(
-            "/** @enum {number} */ var a = {};",
-            "/** @const */ var ns = {};",
-            "/** @enum {string} */ ns.b = a;")
+            "let YourEnum = 0;", //
+            "/** @enum */ const MyEnum = YourEnum;")
         .addDiagnostic(
             lines(
-                "incompatible enum element types", //
+                "initializing variable", //
                 "found   : number",
-                "required: string"))
+                "required: enum{MyEnum}"))
         .run();
   }
 
   @Test
-  public void testEnum14() {
+  public void testConstAliasedEnum() {
     newTest()
         .addSource(
-            "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.FOO;")
+            "/** @enum */ var YourEnum = {FOO: 3};",
+            "const MyEnum = YourEnum;",
+            "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum15() {
+  public void testConstAliasedEnum_constJSDoc() {
     newTest()
         .addSource(
-            "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.BAR;")
-        .addDiagnostic("element BAR does not exist on this enum")
+            "/** @enum */ var YourEnum = {FOO: 3};",
+            "/** @const */ var MyEnum = YourEnum;",
+            "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum16() {
+  public void testConstAliasedEnum_qnameConstJSDoc() {
     newTest()
-        .addSource("var goog = {};" + "/**@enum*/goog .a={BB:1,BB:2}")
-        .addDiagnostic("variable goog.a.BB redefined, original definition at [testcode]:1")
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};",
+            "const ns = {};",
+            "/** @const */",
+            "ns.MyEnum = YourEnum;",
+            "/** @param {ns.MyEnum} x */ function f(x) {} f(ns.MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum17() {
+  public void testConstAliasedEnum_inObjectLit() {
     newTest()
-        .addSource("var goog = {};" + "/**@enum*/goog.a={BB:'string'}")
-        .addDiagnostic(
-            "assignment to property BB of enum{goog.a}\n"
-                + "found   : string\n"
-                + "required: number")
+        .addSource(
+            "/** @enum */ var YourEnum = {FOO: 3};",
+            "const ns = {/** @const */ MyEnum: YourEnum}",
+            "/** @param {ns.MyEnum} x */ function f(x) {} f(ns.MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum18() {
+  public void testConstAliasedEnum_nestedInObjectLit() {
     newTest()
         .addSource(
-            "/**@enum*/ var E = {A: 1, B: 2};"
-                + "/** @param {!E} x\n@return {number} */\n"
-                + "var f = function(x) { return x; };")
+            "/** @enum */ var YourEnum = {FOO: 3};",
+            "const ns = {/** @const */ x: {/** @const */ MyEnum: YourEnum}}",
+            "/** @param {ns.x.MyEnum} x */ function f(x) {} f(ns.x.MyEnum.FOO);")
         .run();
   }
 
   @Test
-  public void testEnum19() {
+  public void testBackwardsEnumUse1() {
     newTest()
         .addSource(
-            "/**@enum*/ var E = {A: 1, B: 2};"
-                + "/** @param {number} x\n@return {!E} */\n"
-                + "var f = function(x) { return x; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: E<number>")
+            "/** @return {string} */ function f() { return MyEnum.FOO; }"
+                + "/** @enum {string} */ var MyEnum = {FOO: 'x'};")
         .run();
   }
 
   @Test
-  public void testEnum20() {
-    newTest().addSource("/**@enum*/ var E = {A: 1, B: 2}; var x = []; x[E.A] = 0;").run();
-  }
-
-  @Test
-  public void testEnum21() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @enum {string} */ var E = {A : 'a', B : 'b'};\n"
-                + "/** @param {!E} x\n@return {!E} */ function f(x) { return x; }");
-    Node nodeX = n.getLastChild().getLastChild().getLastChild().getLastChild();
-    JSType typeE = nodeX.getJSType();
-    assertThat(typeE.isObject()).isFalse();
-    assertThat(typeE.isNullable()).isFalse();
-  }
-
-  @Test
-  public void testEnum22() {
+  public void testBackwardsEnumUse2() {
     newTest()
         .addSource(
-            "/**@enum*/ var E = {A: 1, B: 2};"
-                + "/** @param {E} x \n* @return {number} */ function f(x) {return x}")
+            "/** @return {number} */ function f() { return MyEnum.FOO; }"
+                + "/** @enum {string} */ var MyEnum = {FOO: 'x'};")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : MyEnum<string>\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testEnum23() {
+  public void testBackwardsEnumUse3() {
     newTest()
         .addSource(
-            "/**@enum*/ var E = {A: 1, B: 2};"
-                + "/** @param {E} x \n* @return {string} */ function f(x) {return x}")
-        .addDiagnostic("inconsistent return type\n" + "found   : E<number>\n" + "required: string")
+            "/** @return {string} */ function f() { return MyEnum.FOO; }"
+                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
+                + "/** @enum {string} */ var MyEnum = YourEnum;")
         .run();
   }
 
   @Test
-  public void testEnum24() {
+  public void testBackwardsEnumUse4() {
     newTest()
         .addSource(
-            "/**@enum {?Object} */ var E = {A: {}};"
-                + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}")
+            "/** @return {number} */ function f() { return MyEnum.FOO; }"
+                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
+                + "/** @enum {string} */ var MyEnum = YourEnum;")
         .addDiagnostic(
-            "inconsistent return type\n" + "found   : E<(Object|null)>\n" + "required: Object")
+            "inconsistent return type\n" + "found   : YourEnum<string>\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testEnum25() {
+  public void testBackwardsEnumUse5() {
     newTest()
         .addSource(
-            "/**@enum {!Object} */ var E = {A: {}};"
-                + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}")
+            "/** @return {string} */ function f() { return MyEnum.BAR; }"
+                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
+                + "/** @enum {string} */ var MyEnum = YourEnum;")
+        .addDiagnostic("element BAR does not exist on this enum")
         .run();
   }
 
   @Test
-  public void testEnum26() {
+  public void testBackwardsTypedefUse2() {
     newTest()
         .addSource(
-            "var a = {}; /**@enum*/ a.B = {A: 1, B: 2};"
-                + "/** @param {a.B} x \n* @return {number} */ function f(x) {return x}")
+            "/** @this {MyTypedef} */ function f() {}"
+                + "/** @typedef {!(Date|Array)} */ var MyTypedef;")
         .run();
   }
 
   @Test
-  public void testEnum27() {
-    // x is unknown
+  public void testBackwardsTypedefUse4() {
     newTest()
-        .addSource("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A == x; }")
+        .addSource(
+            "/** @return {MyTypedef} */ function f() { return null; }"
+                + "/** @typedef {string} */ var MyTypedef;")
+        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testEnum28() {
-    // x is unknown
+  public void testBackwardsTypedefUse6() {
     newTest()
-        .addSource("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A.B == x; }")
+        .addSource(
+            "/** @return {goog.MyTypedef} */ function f() { return null; }"
+                + "var goog = {};"
+                + "/** @typedef {string} */ goog.MyTypedef;")
+        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testEnum29() {
+  public void testBackwardsTypedefUse7() {
     newTest()
         .addSource(
-            "/** @enum */ var A = {B: 1, C: 2}; "
-                + "/** @return {number} */ function f() { return A; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : enum{A}\n" + "required: number")
+            "/** @return {goog.MyTypedef} */ function f() { return null; }"
+                + "var goog = {};"
+                + "/** @typedef {Object} */ goog.MyTypedef;")
         .run();
   }
 
   @Test
-  public void testEnum30() {
+  public void testBackwardsTypedefUse8() {
+    // Technically, this isn't quite right, because the JS runtime
+    // will coerce null -> the global object. But we'll punt on that for now.
     newTest()
         .addSource(
-            "/** @enum */ var A = {B: 1, C: 2}; "
-                + "/** @return {number} */ function f() { return A.B; }")
+            "/** @param {!Array} x */ function g(x) {}"
+                + "/** @this {goog.MyTypedef} */ function f() { g(this); }"
+                + "var goog = {};"
+                + "/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;")
         .run();
   }
 
   @Test
-  public void testEnum31() {
+  public void testBackwardsTypedefUse9() {
     newTest()
         .addSource(
-            "/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : enum{A}\n" + "required: A<number>")
+            "/** @param {!Array} x */ function g(x) {}",
+            "/** @this {goog.MyTypedef} */ function f() { g(this); }",
+            "var goog = {};",
+            "/** @typedef {(RegExp|null|undefined)} */ goog.MyTypedef;")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : RegExp",
+                "required: Array"))
         .run();
   }
 
   @Test
-  public void testEnum32() {
+  public void testBackwardsTypedefUse10() {
     newTest()
         .addSource(
-            "/** @enum */ var A = {B: 1, C: 2}; "
-                + "/** @return {A} */ function f() { return A.B; }")
+            "/** @param {goog.MyEnum} x */ function g(x) {}"
+                + "var goog = {};"
+                + "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};"
+                + "/** @typedef {number} */ goog.MyTypedef;"
+                + "g(1);")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: goog.MyEnum<number>")
         .run();
   }
 
   @Test
-  public void testEnum34() {
+  public void testBackwardsConstructor1() {
     newTest()
         .addSource(
-            "/** @enum */ var A = {B: 1, C: 2}; "
-                + "/** @param {number} x */ function f(x) { return x == A.B; }")
+            "function f() { (new Foo(true)); }"
+                + "/** \n * @constructor \n * @param {number} x */"
+                + "var Foo = function(x) {};")
+        .addDiagnostic(
+            "actual parameter 1 of Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testEnum35() {
+  public void testBackwardsConstructor2() {
     newTest()
         .addSource(
-            "var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};"
-                + "/** @return {a.b} */ function f() { return a.b.C; }")
+            "function f() { (new Foo(true)); }"
+                + "/** \n * @constructor \n * @param {number} x */"
+                + "var YourFoo = function(x) {};"
+                + "/** \n * @constructor \n * @param {number} x */"
+                + "var Foo = YourFoo;")
+        .addDiagnostic(
+            "actual parameter 1 of Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testEnum36() {
+  public void testMinimalConstructorAnnotation() {
+    newTest().addSource("/** @constructor */function Foo(){}").run();
+  }
+
+  @Test
+  public void testGoodExtends1() {
+    // A minimal @extends example
     newTest()
         .addSource(
-            "var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};"
-                + "/** @return {!a.b} */ function f() { return 1; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : number\n" + "required: a.b<number>")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n")
         .run();
   }
 
   @Test
-  public void testEnum37() {
+  public void testGoodExtends2() {
     newTest()
         .addSource(
-            "var goog = goog || {};"
-                + "/** @enum {number} */ goog.a = {};"
-                + "/** @enum */ var b = goog.a;")
+            "/** @constructor\n * @extends base */function derived() {}\n"
+                + "/** @constructor */function base() {}\n")
         .run();
   }
 
   @Test
-  public void testEnum38() {
+  public void testGoodExtends3() {
     newTest()
         .addSource(
-            "/** @enum {MyEnum} */ var MyEnum = {};" + "/** @param {MyEnum} x */ function f(x) {}")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain " + "of type MyEnum")
+            "/** @constructor\n * @extends {Object} */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n")
         .run();
   }
 
   @Test
-  public void testEnum39() {
+  public void testGoodExtends4() {
+    // Ensure that @extends actually sets the base type of a constructor
+    // correctly. Because this isn't part of the human-readable Function
+    // definition, we need to crawl the prototype chain (eww).
+    Node n =
+        parseAndTypeCheck(
+            "var goog = {};\n"
+                + "/** @constructor */goog.Base = function(){};\n"
+                + "/** @constructor\n"
+                + "  * @extends {goog.Base} */goog.Derived = function(){};\n");
+    Node subTypeName = n.getLastChild().getLastChild().getFirstChild();
+    assertThat(subTypeName.getQualifiedName()).isEqualTo("goog.Derived");
+
+    FunctionType subCtorType = (FunctionType) subTypeName.getNext().getJSType();
+    assertThat(subCtorType.getInstanceType().toString()).isEqualTo("goog.Derived");
+
+    JSType superType = subCtorType.getPrototype().getImplicitPrototype();
+    assertThat(superType.toString()).isEqualTo("goog.Base");
+  }
+
+  @Test
+  public void testGoodExtends5() {
+    // we allow for the extends annotation to be placed first
     newTest()
         .addSource(
-            "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};"
-                + "/** @param {MyEnum} x \n * @return {number} */"
-                + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/** @constructor */function base() {}\n"
+                + "/** @extends {base}\n * @constructor */function derived() {}\n")
         .run();
   }
 
   @Test
-  public void testEnum40() {
+  public void testGoodExtends6() {
+    testFunctionType(
+        CLOSURE_DEFS
+            + "/** @constructor */function base() {}\n"
+            + "/** @return {number} */ "
+            + "  base.prototype.foo = function() { return 1; };\n"
+            + "/** @extends {base}\n * @constructor */function derived() {}\n"
+            + "goog.inherits(derived, base);",
+        "derived.superClass_.foo",
+        "function(this:base): number");
+  }
+
+  @Test
+  public void testGoodExtends7() {
     newTest()
         .addSource(
-            "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};"
-                + "/** @param {number} x \n * @return {number} */"
-                + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }")
+            "/** @constructor \n @extends {Base} */ function Sub() {}"
+                + "/** @return {number} */ function f() { return (new Sub()).foo; }"
+                + "/** @constructor */ function Base() {}"
+                + "/** @type {boolean} */ Base.prototype.foo = true;")
         .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testEnum41() {
+  public void testGoodExtends8() {
     newTest()
         .addSource(
-            "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};"
-                + "/** @return {string} */"
-                + "function f() { return MyEnum.FOO; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : MyEnum<number>\n" + "required: string")
+            "/** @constructor */ function Super() {}"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
+                + "Sub.prototype = new Super();"
+                + "/** @override */ Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testEnum42a() {
+  public void testGoodExtends9() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}",
-            "/** @enum {Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
-            "f(MyEnum.FOO.a);")
-        .addDiagnostic("Property a never defined on MyEnum<Object>")
+            "/** @constructor */ function Super() {}"
+                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
+                + "Sub.prototype = new Super();"
+                + "/** @return {Super} */ function foo() { return new Sub(); }")
         .run();
   }
 
   @Test
-  public void testEnum42b() {
+  public void testGoodExtends10() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}",
-            "/** @enum {!Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
-            "f(MyEnum.FOO.a);")
-        .addDiagnostic("Property a never defined on MyEnum<Object>")
+            "/** @constructor */ function Super() {}"
+                + "/** @param {boolean} x */ Super.prototype.foo = function(x) {};"
+                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
+                + "Sub.prototype = new Super();"
+                + "(new Sub()).foo(0);")
+        .addDiagnostic(
+            "actual parameter 1 of Super.prototype.foo "
+                + "does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: boolean")
         .run();
   }
 
   @Test
-  public void testEnum42c() {
-    disableStrictMissingPropertyChecks();
-
+  public void testGoodExtends11() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}",
-            "/** @enum {Object} */ var MyEnum = {FOO: {a: 1, b: 2}};",
-            "f(MyEnum.FOO.a);")
+            "/** @constructor \n * @extends {Super} */ function Sub() {}"
+                + "/** @constructor \n * @extends {Sub} */ function Sub2() {}"
+                + "/** @constructor */ function Super() {}"
+                + "/** @param {Super} x */ function foo(x) {}"
+                + "foo(new Sub2());")
         .run();
   }
 
   @Test
-  public void testEnum43() {
+  public void testGoodExtends12() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}",
-            "/** @enum {{a:number, b:number}} */ var MyEnum = {FOO: {a: 1, b: 2}};",
-            "f(MyEnum.FOO.a);")
+            "/** @constructor \n * @extends {B}  */ function C() {}"
+                + "/** @constructor \n * @extends {D}  */ function E() {}"
+                + "/** @constructor \n * @extends {C}  */ function D() {}"
+                + "/** @constructor \n * @extends {A} */ function B() {}"
+                + "/** @constructor */ function A() {}"
+                + "/** @param {number} x */ function f(x) {} f(new E());")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : E\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testEnumDefinedInObjectLiteral() {
+  public void testGoodExtends13() {
     newTest()
         .addSource(
-            "var ns = {",
-            "  /** @enum {number} */",
-            "  Enum: {A: 1, B: 2},",
-            "};",
-            "/** @param {!ns.Enum} arg */",
-            "function f(arg) {}")
+            CLOSURE_DEFS
+                + "/** @param {Function} f */ function g(f) {"
+                + "  /** @constructor */ function NewType() {};"
+                + "  goog.inherits(NewType, f);"
+                + "  (new NewType());"
+                + "}")
         .run();
   }
 
   @Test
-  public void testAliasedEnum1() {
+  public void testGoodExtends14() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};"
-                + "/** @enum */ var MyEnum = YourEnum;"
-                + "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
+            CLOSURE_DEFS
+                + "/** @constructor */ function OldType() {}"
+                + "/** @param {?function(new:OldType)} f */ function g(f) {"
+                + "  /**\n"
+                + "    * @constructor\n"
+                + "    * @extends {OldType}\n"
+                + "    */\n"
+                + "  function NewType() {};"
+                + "  goog.inherits(NewType, f);"
+                + "  NewType.prototype.method = function() {"
+                + "    NewType.superClass_.foo.call(this);"
+                + "  };"
+                + "}")
+        .addDiagnostic("Property foo never defined on OldType.prototype")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testAliasedEnum2() {
+  public void testGoodExtends_withAliasOfSuperclass() {
     newTest()
+        .includeDefaultExterns()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};"
-                + "/** @enum */ var MyEnum = YourEnum;"
-                + "/** @param {YourEnum} x */ function f(x) {} f(MyEnum.FOO);")
+            CLOSURE_DEFS,
+            "/** @constructor */ const OldType = function () {};",
+            "const OldTypeAlias = OldType;",
+            "",
+            "/**",
+            "  * @constructor",
+            "  * @extends {OldTypeAlias}",
+            "  */",
+            "function NewType() {};",
+            // Verify that we recognize the inheritance even when goog.inherits references
+            // OldTypeAlias, not OldType.
+            "goog.inherits(NewType, OldTypeAlias);",
+            "NewType.prototype.method = function() {",
+            "  NewType.superClass_.foo.call(this);",
+            "};")
+        .addDiagnostic("Property foo never defined on OldType.prototype")
         .run();
   }
 
   @Test
-  public void testAliasedEnum3() {
+  public void testBadExtends_withAliasOfSuperclass() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};"
-                + "/** @enum */ var MyEnum = YourEnum;"
-                + "/** @param {MyEnum} x */ function f(x) {} f(YourEnum.FOO);")
+            CLOSURE_DEFS,
+            "const ns = {};",
+            "/** @constructor */ ns.OldType = function () {};",
+            "const nsAlias = ns;",
+            "",
+            "/**",
+            "  * @constructor",
+            "  * // no @extends here, NewType should not have a goog.inherits",
+            "  */",
+            "function NewType() {};",
+            // Verify that we recognize the inheritance even when goog.inherits references
+            // nsAlias.OldType, not ns.OldType.
+            "goog.inherits(NewType, ns.OldType);")
+        .addDiagnostic("Missing @extends tag on type NewType")
         .run();
   }
 
   @Test
-  public void testAliasedEnum4() {
+  public void testBadExtends_withNamespacedAliasOfSuperclass() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};"
-                + "/** @enum */ var MyEnum = YourEnum;"
-                + "/** @param {YourEnum} x */ function f(x) {} f(YourEnum.FOO);")
+            CLOSURE_DEFS,
+            "const ns = {};",
+            "/** @constructor */ ns.OldType = function () {};",
+            "const nsAlias = ns;",
+            "",
+            "/**",
+            "  * @constructor",
+            "  * // no @extends here, NewType should not have a goog.inhertis",
+            "  */",
+            "function NewType() {};",
+            // Verify that we recognize the inheritance even when goog.inherits references
+            // nsAlias.OldType, not ns.OldType.
+            "goog.inherits(NewType, nsAlias.OldType);")
+        .addDiagnostic("Missing @extends tag on type NewType")
         .run();
   }
 
   @Test
-  public void testAliasedEnum5() {
+  public void testBadExtends_withUnionType() {
+    // Regression test for b/146562659, crash when extending a union type.
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};"
-                + "/** @enum */ var MyEnum = YourEnum;"
-                + "/** @param {string} x */ function f(x) {} f(MyEnum.FOO);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : YourEnum<number>\n"
-                + "required: string")
+            "/** @interface */",
+            "class Foo {}",
+            "/** @interface */",
+            "class Bar {}",
+            "/** @typedef {!Foo|!Bar} */",
+            "let Baz;",
+            "/**",
+            " * @interface",
+            " * @extends {Baz}",
+            " */",
+            "class Blah {}")
+        .addDiagnostic("Blah @extends non-object type (Bar|Foo)")
         .run();
   }
 
   @Test
-  public void testAliasedEnum_rhsIsStubDeclaration() {
+  public void testGoodExtends_withNamespacedAliasOfSuperclass() {
     newTest()
         .addSource(
-            "let YourEnum;", //
-            "/** @enum */ const MyEnum = YourEnum;")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : undefined",
-                "required: enum{MyEnum}"))
+            CLOSURE_DEFS,
+            "const ns = {};",
+            "/** @constructor */ ns.OldType = function () {};",
+            "const nsAlias = ns;",
+            "",
+            "/**",
+            "  * @constructor",
+            "  * @extends {nsAlias.OldType}",
+            "  */",
+            "function NewType() {};",
+            // Verify that we recognize the inheritance even when goog.inherits references
+            // nsAlias.OldType, not ns.OldType.
+            "goog.inherits(NewType, nsAlias.OldType);",
+            "NewType.prototype.method = function() {",
+            "  NewType.superClass_.foo.call(this);",
+            "};")
+        .includeDefaultExterns()
+        .addDiagnostic("Property foo never defined on ns.OldType.prototype")
         .run();
   }
 
   @Test
-  public void testAliasedEnum_rhsIsNonEnum() {
+  public void testGoodExtends15() {
     newTest()
         .addSource(
-            "let YourEnum = 0;", //
-            "/** @enum */ const MyEnum = YourEnum;")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: enum{MyEnum}"))
+            CLOSURE_DEFS
+                + "/** @param {Function} f */ function g(f) {"
+                + "  /** @constructor */ function NewType() {};"
+                + "  goog.inherits(f, NewType);"
+                + "  (new NewType());"
+                + "}")
         .run();
   }
 
   @Test
-  public void testConstAliasedEnum() {
+  public void testGoodExtends16() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};",
-            "const MyEnum = YourEnum;",
-            "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
+            CLOSURE_DEFS
+                + "/** @constructor\n"
+                + " * @template T */\n"
+                + "function C() {}\n"
+                + "/** @constructor\n"
+                + " * @extends {C<string>} */\n"
+                + "function D() {};\n"
+                + "goog.inherits(D, C);\n"
+                + "(new D())")
         .run();
   }
 
   @Test
-  public void testConstAliasedEnum_constJSDoc() {
+  public void testGoodExtends17() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};",
-            "/** @const */ var MyEnum = YourEnum;",
-            "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);")
+            CLOSURE_DEFS
+                + "/** @constructor */\n"
+                + "function C() {}\n"
+                + ""
+                + "/** @interface\n"
+                + " * @template T */\n"
+                + "function D() {}\n"
+                + "/** @param {T} t */\n"
+                + "D.prototype.method;\n"
+                + ""
+                + "/** @constructor\n"
+                + " * @template T\n"
+                + " * @extends {C}\n"
+                + " * @implements {D<T>} */\n"
+                + "function E() {};\n"
+                + "goog.inherits(E, C);\n"
+                + "/** @override */\n"
+                + "E.prototype.method = function(t) {};\n"
+                + ""
+                + "var e = /** @type {E<string>} */ (new E());\n"
+                + "e.method(3);")
+        .addDiagnostic(
+            "actual parameter 1 of E.prototype.method does not match formal "
+                + "parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testConstAliasedEnum_qnameConstJSDoc() {
+  public void testGoodExtends18() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};",
-            "const ns = {};",
-            "/** @const */",
-            "ns.MyEnum = YourEnum;",
-            "/** @param {ns.MyEnum} x */ function f(x) {} f(ns.MyEnum.FOO);")
+            ""
+                + "/** @interface */\n"
+                + "var MyInterface = function() {};\n"
+                + "MyInterface.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @extends {MyInterface}\n * @interface */\n"
+                + "var MyOtherInterface = function() {};\n"
+                + "MyOtherInterface.prototype = {\n"
+                + "  /** @return {number} \n @override */\n"
+                + "  method: function() {}\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testConstAliasedEnum_inObjectLit() {
+  public void testGoodExtends19() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};",
-            "const ns = {/** @const */ MyEnum: YourEnum}",
-            "/** @param {ns.MyEnum} x */ function f(x) {} f(ns.MyEnum.FOO);")
+            ""
+                + "/** @constructor */\n"
+                + "var MyType = function() {};\n"
+                + "MyType.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @constructor \n"
+                + " *  @extends {MyType}\n"
+                + " */\n"
+                + "var MyOtherType = function() {};\n"
+                + "MyOtherType.prototype = {\n"
+                + "  /** @return {number}\n"
+                + "   * @override */\n"
+                + "  method: function() {}\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testConstAliasedEnum_nestedInObjectLit() {
+  public void testBadExtends1() {
     newTest()
         .addSource(
-            "/** @enum */ var YourEnum = {FOO: 3};",
-            "const ns = {/** @const */ x: {/** @const */ MyEnum: YourEnum}}",
-            "/** @param {ns.x.MyEnum} x */ function f(x) {} f(ns.x.MyEnum.FOO);")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {not_base} */function derived() {}\n")
+        .addDiagnostic("Bad type annotation. Unknown type not_base")
         .run();
   }
 
   @Test
-  public void testBackwardsEnumUse1() {
+  public void testBadExtends2() {
     newTest()
         .addSource(
-            "/** @return {string} */ function f() { return MyEnum.FOO; }"
-                + "/** @enum {string} */ var MyEnum = {FOO: 'x'};")
+            "/** @constructor */function base() {\n"
+                + "/** @type {!Number}*/\n"
+                + "this.baseMember = new Number(4);\n"
+                + "}\n"
+                + "/** @constructor\n"
+                + "  * @extends {base} */function derived() {}\n"
+                + "/** @param {!String} x*/\n"
+                + "function foo(x){ }\n"
+                + "/** @type {!derived}*/var y;\n"
+                + "foo(y.baseMember);\n")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : Number\n"
+                + "required: String")
         .run();
   }
 
   @Test
-  public void testBackwardsEnumUse2() {
+  public void testBadExtends3() {
     newTest()
-        .addSource(
-            "/** @return {number} */ function f() { return MyEnum.FOO; }"
-                + "/** @enum {string} */ var MyEnum = {FOO: 'x'};")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : MyEnum<string>\n" + "required: number")
+        .addSource("/** @extends {Object} */function base() {}")
+        .addDiagnostic("@extends used without @constructor or @interface for base")
         .run();
   }
 
   @Test
-  public void testBackwardsEnumUse3() {
+  public void testBadExtends4() {
+    // If there's a subclass of a class with a bad extends,
+    // we only want to warn about the first one.
     newTest()
         .addSource(
-            "/** @return {string} */ function f() { return MyEnum.FOO; }"
-                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
-                + "/** @enum {string} */ var MyEnum = YourEnum;")
+            "/** @constructor \n * @extends {bad} */ function Sub() {}"
+                + "/** @constructor \n * @extends {Sub} */ function Sub2() {}"
+                + "/** @param {Sub} x */ function foo(x) {}"
+                + "foo(new Sub2());")
+        .addDiagnostic("Bad type annotation. Unknown type bad")
         .run();
   }
 
   @Test
-  public void testBackwardsEnumUse4() {
+  public void testBadExtends5() {
     newTest()
         .addSource(
-            "/** @return {number} */ function f() { return MyEnum.FOO; }"
-                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
-                + "/** @enum {string} */ var MyEnum = YourEnum;")
+            "/** @interface */",
+            "var MyInterface = function() {};",
+            "MyInterface.prototype = {",
+            "  /** @return {number} */",
+            "  method: function() {}",
+            "}",
+            "/** @extends {MyInterface}\n * @interface */",
+            "var MyOtherInterface = function() {};",
+            "MyOtherInterface.prototype = {",
+            "  /** @return {string} \n @override */",
+            "  method: function() {}",
+            "}")
         .addDiagnostic(
-            "inconsistent return type\n" + "found   : YourEnum<string>\n" + "required: number")
+            lines(
+                "mismatch of the method property on type MyOtherInterface and the type of the"
+                    + " property it overrides from interface MyInterface",
+                "original: function(this:MyInterface): number",
+                "override: function(this:MyOtherInterface): string"))
         .run();
   }
 
   @Test
-  public void testBackwardsEnumUse5() {
+  public void testBadExtends6() {
     newTest()
         .addSource(
-            "/** @return {string} */ function f() { return MyEnum.BAR; }"
-                + "/** @enum {string} */ var YourEnum = {FOO: 'x'};"
-                + "/** @enum {string} */ var MyEnum = YourEnum;")
-        .addDiagnostic("element BAR does not exist on this enum")
+            ""
+                + "/** @constructor */\n"
+                + "var MyType = function() {};\n"
+                + "MyType.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @constructor \n"
+                + " *  @extends {MyType}\n"
+                + " */\n"
+                + "var MyOtherType = function() {};\n"
+                + "MyOtherType.prototype = {\n"
+                + "  /** @return {string}\n"
+                + "   * @override */\n"
+                + "  method: function() { return ''; }\n"
+                + "}")
+        .addDiagnostic(
+            ""
+                + "mismatch of the method property type and the type of the property "
+                + "it overrides from superclass MyType\n"
+                + "original: function(this:MyType): number\n"
+                + "override: function(this:MyOtherType): string")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse2() {
+  public void testLateExtends() {
     newTest()
         .addSource(
-            "/** @this {MyTypedef} */ function f() {}"
-                + "/** @typedef {!(Date|Array)} */ var MyTypedef;")
+            CLOSURE_DEFS
+                + "/** @constructor */ function Foo() {}\n"
+                + "Foo.prototype.foo = function() {};\n"
+                + "/** @constructor */function Bar() {}\n"
+                + "goog.inherits(Foo, Bar);\n")
+        .addDiagnostic("Missing @extends tag on type Foo")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse4() {
+  public void testSuperclassMatch() {
+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());
     newTest()
         .addSource(
-            "/** @return {MyTypedef} */ function f() { return null; }"
-                + "/** @typedef {string} */ var MyTypedef;")
-        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: string")
+            "/** @constructor */ var Foo = function() {};\n"
+                + "/** @constructor \n @extends Foo */ var Bar = function() {};\n"
+                + "Bar.inherits = function(x){};"
+                + "Bar.inherits(Foo);\n")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse6() {
+  public void testSuperclassMatchWithMixin() {
+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());
     newTest()
         .addSource(
-            "/** @return {goog.MyTypedef} */ function f() { return null; }"
-                + "var goog = {};"
-                + "/** @typedef {string} */ goog.MyTypedef;")
-        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: string")
+            "/** @constructor */ var Foo = function() {};\n"
+                + "/** @constructor */ var Baz = function() {};\n"
+                + "/** @constructor \n @extends Foo */ var Bar = function() {};\n"
+                + "Bar.inherits = function(x){};"
+                + "Bar.mixin = function(y){};"
+                + "Bar.inherits(Foo);\n"
+                + "Bar.mixin(Baz);\n")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse7() {
+  public void testSuperClassDefinedAfterSubClass1() {
     newTest()
         .addSource(
-            "/** @return {goog.MyTypedef} */ function f() { return null; }"
-                + "var goog = {};"
-                + "/** @typedef {Object} */ goog.MyTypedef;")
+            "/** @constructor \n * @extends {Base} */ function A() {}"
+                + "/** @constructor \n * @extends {Base} */ function B() {}"
+                + "/** @constructor */ function Base() {}"
+                + "/** @param {A|B} x \n * @return {B|A} */ "
+                + "function foo(x) { return x; }")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse8() {
-    // Technically, this isn't quite right, because the JS runtime
-    // will coerce null -> the global object. But we'll punt on that for now.
+  public void testSuperClassDefinedAfterSubClass2() {
     newTest()
         .addSource(
-            "/** @param {!Array} x */ function g(x) {}"
-                + "/** @this {goog.MyTypedef} */ function f() { g(this); }"
-                + "var goog = {};"
-                + "/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;")
+            "/** @constructor \n * @extends {Base} */ function A() {}"
+                + "/** @constructor \n * @extends {Base} */ function B() {}"
+                + "/** @param {A|B} x \n * @return {B|A} */ "
+                + "function foo(x) { return x; }"
+                + "/** @constructor */ function Base() {}")
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse9() {
+  public void testGoodSuperCall() {
     newTest()
         .addSource(
-            "/** @param {!Array} x */ function g(x) {}",
-            "/** @this {goog.MyTypedef} */ function f() { g(this); }",
-            "var goog = {};",
-            "/** @typedef {(RegExp|null|undefined)} */ goog.MyTypedef;")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : RegExp",
-                "required: Array"))
+            "class A {",
+            "  /**",
+            "   * @param {string} a",
+            "   */",
+            "  constructor(a) {",
+            "    this.a = a;",
+            "  }",
+            "}",
+            "class B extends A {",
+            "  constructor() {",
+            "    super('b');",
+            "  }",
+            "}",
+            "")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBackwardsTypedefUse10() {
+  public void testBadSuperCall() {
     newTest()
         .addSource(
-            "/** @param {goog.MyEnum} x */ function g(x) {}"
-                + "var goog = {};"
-                + "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};"
-                + "/** @typedef {number} */ goog.MyTypedef;"
-                + "g(1);")
+            "class A {",
+            "  /**",
+            "   * @param {string} a",
+            "   */",
+            "  constructor(a) {",
+            "    this.a = a;",
+            "  }",
+            "}",
+            "class B extends A {",
+            "  constructor() {",
+            "    super(5);",
+            "  }",
+            "}")
         .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: goog.MyEnum<number>")
+            lines(
+                "actual parameter 1 of super does not match formal parameter",
+                "found   : number",
+                "required: string"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBackwardsConstructor1() {
+  public void testDirectPrototypeAssignment1() {
     newTest()
         .addSource(
-            "function f() { (new Foo(true)); }"
-                + "/** \n * @constructor \n * @param {number} x */"
-                + "var Foo = function(x) {};")
-        .addDiagnostic(
-            "actual parameter 1 of Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @constructor */ function Base() {}"
+                + "Base.prototype.foo = 3;"
+                + "/** @constructor \n * @extends {Base} */ function A() {}"
+                + "A.prototype = new Base();"
+                + "/** @return {string} */ function foo() { return (new A).foo; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testBackwardsConstructor2() {
+  public void testDirectPrototypeAssignment2() {
+    // This ensures that we don't attach property 'foo' onto the Base
+    // instance object.
     newTest()
         .addSource(
-            "function f() { (new Foo(true)); }"
-                + "/** \n * @constructor \n * @param {number} x */"
-                + "var YourFoo = function(x) {};"
-                + "/** \n * @constructor \n * @param {number} x */"
-                + "var Foo = YourFoo;")
-        .addDiagnostic(
-            "actual parameter 1 of Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testMinimalConstructorAnnotation() {
-    newTest().addSource("/** @constructor */function Foo(){}").run();
+            "/** @constructor */ function Base() {}"
+                + "/** @constructor \n * @extends {Base} */ function A() {}"
+                + "A.prototype = new Base();"
+                + "A.prototype.foo = 3;"
+                + "/** @return {string} */ function foo() { return (new Base).foo; }")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run(); // exists on subtypes, so only reported for strict props
   }
 
   @Test
-  public void testGoodExtends1() {
-    // A minimal @extends example
+  public void testDirectPrototypeAssignment3() {
+    // This verifies that the compiler doesn't crash if the user
+    // overwrites the prototype of a global variable in a local scope.
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n")
+            "/** @constructor */ var MainWidgetCreator = function() {};"
+                + "/** @param {Function} ctor */"
+                + "function createMainWidget(ctor) {"
+                + "  /** @constructor */ function tempCtor() {};"
+                + "  tempCtor.prototype = ctor.prototype;"
+                + "  MainWidgetCreator.superClass_ = ctor.prototype;"
+                + "  MainWidgetCreator.prototype = new tempCtor();"
+                + "}")
         .run();
   }
 
   @Test
-  public void testGoodExtends2() {
+  public void testGoodImplements1() {
     newTest()
         .addSource(
-            "/** @constructor\n * @extends base */function derived() {}\n"
-                + "/** @constructor */function base() {}\n")
+            "/** @interface */function Disposable() {}\n"
+                + "/** @implements {Disposable}\n * @constructor */function f() {}")
         .run();
   }
 
   @Test
-  public void testGoodExtends3() {
+  public void testGoodImplements2() {
     newTest()
         .addSource(
-            "/** @constructor\n * @extends {Object} */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n")
-        .run();
-  }
-
-  @Test
-  public void testGoodExtends4() {
-    // Ensure that @extends actually sets the base type of a constructor
-    // correctly. Because this isn't part of the human-readable Function
-    // definition, we need to crawl the prototype chain (eww).
-    Node n =
-        parseAndTypeCheck(
-            "var goog = {};\n"
-                + "/** @constructor */goog.Base = function(){};\n"
+            "/** @interface */function Base1() {}\n"
+                + "/** @interface */function Base2() {}\n"
                 + "/** @constructor\n"
-                + "  * @extends {goog.Base} */goog.Derived = function(){};\n");
-    Node subTypeName = n.getLastChild().getLastChild().getFirstChild();
-    assertThat(subTypeName.getQualifiedName()).isEqualTo("goog.Derived");
-
-    FunctionType subCtorType = (FunctionType) subTypeName.getNext().getJSType();
-    assertThat(subCtorType.getInstanceType().toString()).isEqualTo("goog.Derived");
-
-    JSType superType = subCtorType.getPrototype().getImplicitPrototype();
-    assertThat(superType.toString()).isEqualTo("goog.Base");
+                + " * @implements {Base1}\n"
+                + " * @implements {Base2}\n"
+                + " */ function derived() {}")
+        .run();
   }
 
   @Test
-  public void testGoodExtends5() {
-    // we allow for the extends annotation to be placed first
+  public void testGoodImplements3() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @extends {base}\n * @constructor */function derived() {}\n")
+            "/** @interface */function Disposable() {}\n"
+                + "/** @constructor \n @implements {Disposable} */function f() {}")
         .run();
   }
 
   @Test
-  public void testGoodExtends6() {
-    testFunctionType(
-        CLOSURE_DEFS
-            + "/** @constructor */function base() {}\n"
-            + "/** @return {number} */ "
-            + "  base.prototype.foo = function() { return 1; };\n"
-            + "/** @extends {base}\n * @constructor */function derived() {}\n"
-            + "goog.inherits(derived, base);",
-        "derived.superClass_.foo",
-        "function(this:base): number");
+  public void testGoodImplements4() {
+    newTest()
+        .addSource(
+            "var goog = {};",
+            "/** @type {!Function} */",
+            "goog.abstractMethod = function() {};",
+            "/** @interface */",
+            "goog.Disposable = function() {};",
+            "goog.Disposable.prototype.dispose = goog.abstractMethod;",
+            "/** @implements {goog.Disposable}\n * @constructor */",
+            "goog.SubDisposable = function() {};",
+            "/** @inheritDoc */",
+            "goog.SubDisposable.prototype.dispose = function() {};")
+        .run();
   }
 
   @Test
-  public void testGoodExtends7() {
+  public void testGoodImplements5() {
     newTest()
         .addSource(
-            "/** @constructor \n @extends {Base} */ function Sub() {}"
-                + "/** @return {number} */ function f() { return (new Sub()).foo; }"
-                + "/** @constructor */ function Base() {}"
-                + "/** @type {boolean} */ Base.prototype.foo = true;")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/** @interface */\n"
+                + "goog.Disposable = function() {};"
+                + "/** @type {Function} */"
+                + "goog.Disposable.prototype.dispose = function() {};"
+                + "/** @implements {goog.Disposable}\n * @constructor */"
+                + "goog.SubDisposable = function() {};"
+                + "/** @param {number} key \n @override */ "
+                + "goog.SubDisposable.prototype.dispose = function(key) {};")
         .run();
   }
 
   @Test
-  public void testGoodExtends8() {
+  public void testGoodImplements6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Super() {}"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
-                + "Sub.prototype = new Super();"
-                + "/** @override */ Sub.prototype.foo = function() {};")
+            "var myNullFunction = function() {};"
+                + "/** @interface */\n"
+                + "goog.Disposable = function() {};"
+                + "/** @return {number} */"
+                + "goog.Disposable.prototype.dispose = myNullFunction;"
+                + "/** @implements {goog.Disposable}\n * @constructor */"
+                + "goog.SubDisposable = function() {};"
+                + "/** @return {number} \n @override */ "
+                + "goog.SubDisposable.prototype.dispose = function() { return 0; };")
         .run();
   }
 
   @Test
-  public void testGoodExtends9() {
+  public void testGoodImplements7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Super() {}"
-                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
-                + "Sub.prototype = new Super();"
-                + "/** @return {Super} */ function foo() { return new Sub(); }")
+            "var myNullFunction = function() {};"
+                + "/** @interface */\n"
+                + "goog.Disposable = function() {};"
+                + "/** @return {number} */"
+                + "goog.Disposable.prototype.dispose = function() {};"
+                + "/** @implements {goog.Disposable}\n * @constructor */"
+                + "goog.SubDisposable = function() {};"
+                + "/** @return {number} \n @override */ "
+                + "goog.SubDisposable.prototype.dispose = function() { return 0; };")
         .run();
   }
 
   @Test
-  public void testGoodExtends10() {
+  public void testGoodImplements8() {
     newTest()
         .addSource(
-            "/** @constructor */ function Super() {}"
-                + "/** @param {boolean} x */ Super.prototype.foo = function(x) {};"
-                + "/** @constructor \n * @extends {Super} */ function Sub() {}"
-                + "Sub.prototype = new Super();"
-                + "(new Sub()).foo(0);")
-        .addDiagnostic(
-            "actual parameter 1 of Super.prototype.foo "
-                + "does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: boolean")
+            ""
+                + "/** @interface */\n"
+                + "MyInterface = function() {};\n"
+                + "MyInterface.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @implements {MyInterface}\n * @constructor */\n"
+                + "MyClass = function() {};\n"
+                + "MyClass.prototype = {\n"
+                + "  /** @return {number} \n @override */\n"
+                + "  method: function() { return 0; }\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testGoodExtends11() {
+  public void testBadImplements1() {
     newTest()
         .addSource(
-            "/** @constructor \n * @extends {Super} */ function Sub() {}"
-                + "/** @constructor \n * @extends {Sub} */ function Sub2() {}"
-                + "/** @constructor */ function Super() {}"
-                + "/** @param {Super} x */ function foo(x) {}"
-                + "foo(new Sub2());")
+            "/** @interface */function Base1() {}\n"
+                + "/** @interface */function Base2() {}\n"
+                + "/** @constructor\n"
+                + " * @implements {nonExistent}\n"
+                + " * @implements {Base2}\n"
+                + " */ function derived() {}")
+        .addDiagnostic("Bad type annotation. Unknown type nonExistent")
         .run();
   }
 
   @Test
-  public void testGoodExtends12() {
+  public void testBadImplements2() {
     newTest()
         .addSource(
-            "/** @constructor \n * @extends {B}  */ function C() {}"
-                + "/** @constructor \n * @extends {D}  */ function E() {}"
-                + "/** @constructor \n * @extends {C}  */ function D() {}"
-                + "/** @constructor \n * @extends {A} */ function B() {}"
-                + "/** @constructor */ function A() {}"
-                + "/** @param {number} x */ function f(x) {} f(new E());")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : E\n"
-                + "required: number")
+            "/** @interface */function Disposable() {}\n"
+                + "/** @implements {Disposable}\n */function f() {}")
+        .addDiagnostic("@implements used without @constructor for f")
         .run();
   }
 
   @Test
-  public void testGoodExtends13() {
+  public void testBadImplements3() {
     newTest()
         .addSource(
-            CLOSURE_DEFS
-                + "/** @param {Function} f */ function g(f) {"
-                + "  /** @constructor */ function NewType() {};"
-                + "  goog.inherits(NewType, f);"
-                + "  (new NewType());"
-                + "}")
+            "var goog = {};",
+            "/** @type {!Function} */ goog.abstractMethod = function(){};",
+            "/** @interface */ var Disposable = function() {};",
+            "Disposable.prototype.method = goog.abstractMethod;",
+            "/** @implements {Disposable}\n * @constructor */function f() {}")
+        .addDiagnostic("property method on interface Disposable is not implemented by type f")
         .run();
   }
 
   @Test
-  public void testGoodExtends14() {
+  public void testBadImplements4() {
     newTest()
         .addSource(
-            CLOSURE_DEFS
-                + "/** @constructor */ function OldType() {}"
-                + "/** @param {?function(new:OldType)} f */ function g(f) {"
-                + "  /**\n"
-                + "    * @constructor\n"
-                + "    * @extends {OldType}\n"
-                + "    */\n"
-                + "  function NewType() {};"
-                + "  goog.inherits(NewType, f);"
-                + "  NewType.prototype.method = function() {"
-                + "    NewType.superClass_.foo.call(this);"
-                + "  };"
-                + "}")
-        .addDiagnostic("Property foo never defined on OldType.prototype")
-        .includeDefaultExterns()
+            "/** @interface */function Disposable() {}\n"
+                + "/** @implements {Disposable}\n * @interface */function f() {}")
+        .addDiagnostic(
+            "f cannot implement this type; an interface can only extend, "
+                + "but not implement interfaces")
         .run();
   }
 
   @Test
-  public void testGoodExtends_withAliasOfSuperclass() {
+  public void testBadImplements5() {
     newTest()
-        .includeDefaultExterns()
         .addSource(
-            CLOSURE_DEFS,
-            "/** @constructor */ const OldType = function () {};",
-            "const OldTypeAlias = OldType;",
-            "",
-            "/**",
-            "  * @constructor",
-            "  * @extends {OldTypeAlias}",
-            "  */",
-            "function NewType() {};",
-            // Verify that we recognize the inheritance even when goog.inherits references
-            // OldTypeAlias, not OldType.
-            "goog.inherits(NewType, OldTypeAlias);",
-            "NewType.prototype.method = function() {",
-            "  NewType.superClass_.foo.call(this);",
-            "};")
-        .addDiagnostic("Property foo never defined on OldType.prototype")
+            "/** @interface */function Disposable() {}\n"
+                + "/** @type {number} */ Disposable.prototype.bar = function() {};")
+        .addDiagnostic(
+            "assignment to property bar of Disposable.prototype\n"
+                + "found   : function(): undefined\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testBadExtends_withAliasOfSuperclass() {
-    newTest()
-        .addSource(
-            CLOSURE_DEFS,
-            "const ns = {};",
-            "/** @constructor */ ns.OldType = function () {};",
-            "const nsAlias = ns;",
-            "",
-            "/**",
-            "  * @constructor",
-            "  * // no @extends here, NewType should not have a goog.inherits",
-            "  */",
-            "function NewType() {};",
-            // Verify that we recognize the inheritance even when goog.inherits references
-            // nsAlias.OldType, not ns.OldType.
-            "goog.inherits(NewType, ns.OldType);")
-        .addDiagnostic("Missing @extends tag on type NewType")
-        .run();
+  public void testBadImplements6() {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */function Disposable() {}\n"
+            + "/** @type {function()} */ Disposable.prototype.bar = 3;",
+        ImmutableList.of(
+            "assignment to property bar of Disposable.prototype\n"
+                + "found   : number\n"
+                + "required: function(): ?",
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod"));
   }
 
   @Test
-  public void testBadExtends_withNamespacedAliasOfSuperclass() {
+  public void testBadImplements7() {
     newTest()
         .addSource(
-            CLOSURE_DEFS,
-            "const ns = {};",
-            "/** @constructor */ ns.OldType = function () {};",
-            "const nsAlias = ns;",
-            "",
-            "/**",
-            "  * @constructor",
-            "  * // no @extends here, NewType should not have a goog.inhertis",
-            "  */",
-            "function NewType() {};",
-            // Verify that we recognize the inheritance even when goog.inherits references
-            // nsAlias.OldType, not ns.OldType.
-            "goog.inherits(NewType, nsAlias.OldType);")
-        .addDiagnostic("Missing @extends tag on type NewType")
+            ""
+                + "/** @interface */\n"
+                + "MyInterface = function() {};\n"
+                + "MyInterface.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @implements {MyInterface}\n * @constructor */\n"
+                + "MyClass = function() {};\n"
+                + "MyClass.prototype = {\n"
+                + "  /** @return {string} \n @override */\n"
+                + "  method: function() { return ''; }\n"
+                + "}")
+        .addDiagnostic(
+            ""
+                + "mismatch of the method property on type MyClass and the type of the property "
+                + "it overrides from interface MyInterface\n"
+                + "original: function(): number\n"
+                + "override: function(): string")
         .run();
   }
 
   @Test
-  public void testBadExtends_withUnionType() {
-    // Regression test for b/146562659, crash when extending a union type.
+  public void testBadImplements8() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "class Foo {}",
-            "/** @interface */",
-            "class Bar {}",
-            "/** @typedef {!Foo|!Bar} */",
-            "let Baz;",
-            "/**",
-            " * @interface",
-            " * @extends {Baz}",
-            " */",
-            "class Blah {}")
-        .addDiagnostic("Blah @extends non-object type (Bar|Foo)")
+            ""
+                + "/** @interface */\n"
+                + "MyInterface = function() {};\n"
+                + "MyInterface.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() {}\n"
+                + "}\n"
+                + "/** @implements {MyInterface}\n * @constructor */\n"
+                + "MyClass = function() {};\n"
+                + "MyClass.prototype = {\n"
+                + "  /** @return {number} */\n"
+                + "  method: function() { return 0; }\n"
+                + "}")
+        .addDiagnostic(
+            ""
+                + "property method already defined on interface MyInterface; "
+                + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testGoodExtends_withNamespacedAliasOfSuperclass() {
+  public void testProtoDoesNotRequireOverrideFromInterface() {
     newTest()
-        .addSource(
-            CLOSURE_DEFS,
-            "const ns = {};",
-            "/** @constructor */ ns.OldType = function () {};",
-            "const nsAlias = ns;",
-            "",
-            "/**",
-            "  * @constructor",
-            "  * @extends {nsAlias.OldType}",
-            "  */",
-            "function NewType() {};",
-            // Verify that we recognize the inheritance even when goog.inherits references
-            // nsAlias.OldType, not ns.OldType.
-            "goog.inherits(NewType, nsAlias.OldType);",
-            "NewType.prototype.method = function() {",
-            "  NewType.superClass_.foo.call(this);",
-            "};")
         .includeDefaultExterns()
-        .addDiagnostic("Property foo never defined on ns.OldType.prototype")
+        .addExterns("/** @type {Object} */ Object.prototype.__proto__;")
+        .addSource(
+            "/** @interface */\n"
+                + "var MyInterface = function() {};\n"
+                + "/** @constructor\n @implements {MyInterface} */\n"
+                + "var MySuper = function() {};\n"
+                + "/** @constructor\n @extends {MySuper} */\n"
+                + "var MyClass = function() {};\n"
+                + "MyClass.prototype = {\n"
+                + "  __proto__: MySuper.prototype\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testGoodExtends15() {
-    newTest()
-        .addSource(
-            CLOSURE_DEFS
-                + "/** @param {Function} f */ function g(f) {"
-                + "  /** @constructor */ function NewType() {};"
-                + "  goog.inherits(f, NewType);"
-                + "  (new NewType());"
-                + "}")
-        .run();
+  public void testConstructorClassTemplate() {
+    newTest().addSource("/** @constructor \n @template S,T */ function A() {}\n").run();
   }
 
   @Test
-  public void testGoodExtends16() {
+  public void testGenericBoundExplicitUnknown() {
+    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
+
     newTest()
         .addSource(
-            CLOSURE_DEFS
-                + "/** @constructor\n"
-                + " * @template T */\n"
-                + "function C() {}\n"
-                + "/** @constructor\n"
-                + " * @extends {C<string>} */\n"
-                + "function D() {};\n"
-                + "goog.inherits(D, C);\n"
-                + "(new D())")
+            "/**", //
+            " * @param {T} x",
+            " * @template {?} T",
+            " */",
+            "function f(x) {}")
+        .addDiagnostic("Illegal upper bound '?' on template type parameter T")
+        .diagnosticsAreErrors()
         .run();
   }
 
   @Test
-  public void testGoodExtends17() {
+  public void testGenericBoundArgAppError() {
     newTest()
         .addSource(
-            CLOSURE_DEFS
-                + "/** @constructor */\n"
-                + "function C() {}\n"
-                + ""
-                + "/** @interface\n"
-                + " * @template T */\n"
-                + "function D() {}\n"
-                + "/** @param {T} t */\n"
-                + "D.prototype.method;\n"
-                + ""
-                + "/** @constructor\n"
-                + " * @template T\n"
-                + " * @extends {C}\n"
-                + " * @implements {D<T>} */\n"
-                + "function E() {};\n"
-                + "goog.inherits(E, C);\n"
-                + "/** @override */\n"
-                + "E.prototype.method = function(t) {};\n"
-                + ""
-                + "var e = /** @type {E<string>} */ (new E());\n"
-                + "e.method(3);")
+            "/**",
+            " * @param {T} x",
+            " * @template {number} T",
+            " */",
+            "function f(x) {}",
+            "var a = f('a');")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
-            "actual parameter 1 of E.prototype.method does not match formal "
-                + "parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testGoodExtends18() {
+  public void testGenericBoundArgApp() {
     newTest()
         .addSource(
-            ""
-                + "/** @interface */\n"
-                + "var MyInterface = function() {};\n"
-                + "MyInterface.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @extends {MyInterface}\n * @interface */\n"
-                + "var MyOtherInterface = function() {};\n"
-                + "MyOtherInterface.prototype = {\n"
-                + "  /** @return {number} \n @override */\n"
-                + "  method: function() {}\n"
-                + "}")
+            "/**",
+            " * @param {T} x",
+            " * @template {number} T",
+            " */",
+            "function f(x) {}",
+            "var a = f(3);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodExtends19() {
+  public void testGenericBoundReturnError() {
+    // NOTE: This signature is unsafe, but it's an effective minimal test case.
     newTest()
         .addSource(
-            ""
-                + "/** @constructor */\n"
-                + "var MyType = function() {};\n"
-                + "MyType.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @constructor \n"
-                + " *  @extends {MyType}\n"
-                + " */\n"
-                + "var MyOtherType = function() {};\n"
-                + "MyOtherType.prototype = {\n"
-                + "  /** @return {number}\n"
-                + "   * @override */\n"
-                + "  method: function() {}\n"
-                + "}")
+            "/**",
+            " * @return {T}",
+            " * @template {number} T",
+            " */",
+            "function f(x) { return 'a'; }",
+            "var a = f(0);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : string",
+                "required: T extends number"))
         .run();
   }
 
   @Test
-  public void testBadExtends1() {
+  public void testGenericBoundArgAppNullError() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {not_base} */function derived() {}\n")
-        .addDiagnostic("Bad type annotation. Unknown type not_base")
+            "/**",
+            " * @param {T} x",
+            " * @template {number} T",
+            " */",
+            "function f(x) { return x; }",
+            "var a = f(null);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : null",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testBadExtends2() {
+  public void testGenericBoundArgAppNullable() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {\n"
-                + "/** @type {!Number}*/\n"
-                + "this.baseMember = new Number(4);\n"
-                + "}\n"
-                + "/** @constructor\n"
-                + "  * @extends {base} */function derived() {}\n"
-                + "/** @param {!String} x*/\n"
-                + "function foo(x){ }\n"
-                + "/** @type {!derived}*/var y;\n"
-                + "foo(y.baseMember);\n")
-        .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : Number\n"
-                + "required: String")
+            "/**",
+            " * @param {T} x",
+            " * @template {?number} T",
+            " */",
+            "function f(x) { return x; }",
+            "var a = f(null);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testBadExtends3() {
+  public void testGenericBoundArgInnerCallAppError() {
     newTest()
-        .addSource("/** @extends {Object} */function base() {}")
-        .addDiagnostic("@extends used without @constructor or @interface for base")
+        .addSource(
+            "/**",
+            " * @param {string} x",
+            " */",
+            "function stringID(x) { return x; }",
+            "/**",
+            " * @param {T} x",
+            " * @template {number|boolean} T",
+            " */",
+            "function foo(x) { return stringID(x); }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of stringID does not match formal parameter",
+                "found   : T extends (boolean|number)",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testBadExtends4() {
-    // If there's a subclass of a class with a bad extends,
-    // we only want to warn about the first one.
+  public void testGenericBoundArgInnerCallApp() {
     newTest()
         .addSource(
-            "/** @constructor \n * @extends {bad} */ function Sub() {}"
-                + "/** @constructor \n * @extends {Sub} */ function Sub2() {}"
-                + "/** @param {Sub} x */ function foo(x) {}"
-                + "foo(new Sub2());")
-        .addDiagnostic("Bad type annotation. Unknown type bad")
+            "/**",
+            " * @param {number} x",
+            " */",
+            "function numID(x) { return x; }",
+            "/**",
+            " * @param {T} x",
+            " * @template {number} T",
+            " */",
+            "function foo(x) { return numID(x); }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testBadExtends5() {
+  public void testGenericBoundArgInnerCallAppSubtypeError() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "var MyInterface = function() {};",
-            "MyInterface.prototype = {",
-            "  /** @return {number} */",
-            "  method: function() {}",
-            "}",
-            "/** @extends {MyInterface}\n * @interface */",
-            "var MyOtherInterface = function() {};",
-            "MyOtherInterface.prototype = {",
-            "  /** @return {string} \n @override */",
-            "  method: function() {}",
-            "}")
+            "/**",
+            " * @param {number} x",
+            " */",
+            "function numID(x) { return x; }",
+            "/**",
+            " * @param {T} x",
+            " * @template {number|boolean|string} T",
+            " */",
+            "function foo(x) { return numID(x); }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
             lines(
-                "mismatch of the method property on type MyOtherInterface and the type of the"
-                    + " property it overrides from interface MyInterface",
-                "original: function(this:MyInterface): number",
-                "override: function(this:MyOtherInterface): string"))
+                "actual parameter 1 of numID does not match formal parameter",
+                "found   : T extends (boolean|number|string)",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testBadExtends6() {
+  public void testGenericBoundArgInnerAssignSubtype() {
     newTest()
         .addSource(
-            ""
-                + "/** @constructor */\n"
-                + "var MyType = function() {};\n"
-                + "MyType.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @constructor \n"
-                + " *  @extends {MyType}\n"
-                + " */\n"
-                + "var MyOtherType = function() {};\n"
-                + "MyOtherType.prototype = {\n"
-                + "  /** @return {string}\n"
-                + "   * @override */\n"
-                + "  method: function() { return ''; }\n"
-                + "}")
-        .addDiagnostic(
-            ""
-                + "mismatch of the method property type and the type of the property "
-                + "it overrides from superclass MyType\n"
-                + "original: function(this:MyType): number\n"
-                + "override: function(this:MyOtherType): string")
+            "/**",
+            " * @param {T} x",
+            " * @param {number|string|boolean} y",
+            " * @template {number|string} T",
+            " */",
+            "function foo(x,y) { y=x; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testLateExtends() {
+  public void testGenericBoundArgInnerAssignBoundedInvariantError() {
     newTest()
         .addSource(
-            CLOSURE_DEFS
-                + "/** @constructor */ function Foo() {}\n"
-                + "Foo.prototype.foo = function() {};\n"
-                + "/** @constructor */function Bar() {}\n"
-                + "goog.inherits(Foo, Bar);\n")
-        .addDiagnostic("Missing @extends tag on type Foo")
+            "/**",
+            " * @param {number} x",
+            " * @param {T} y",
+            " * @template {number|string} T",
+            " */",
+            "function foo(x,y) { y=x; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : number",
+                "required: T extends (number|string)"))
         .run();
   }
 
   @Test
-  public void testSuperclassMatch() {
-    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());
+  public void testGenericBoundArgInnerAssignSubtypeError() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {};\n"
-                + "/** @constructor \n @extends Foo */ var Bar = function() {};\n"
-                + "Bar.inherits = function(x){};"
-                + "Bar.inherits(Foo);\n")
+            "/**",
+            " * @param {number} x",
+            " * @param {T} y",
+            " * @template {number|string} T",
+            " */",
+            "function foo(x,y) { x=y; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : T extends (number|string)",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testSuperclassMatchWithMixin() {
-    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());
+  public void testDoubleGenericBoundArgInnerAssignSubtype() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {};\n"
-                + "/** @constructor */ var Baz = function() {};\n"
-                + "/** @constructor \n @extends Foo */ var Bar = function() {};\n"
-                + "Bar.inherits = function(x){};"
-                + "Bar.mixin = function(y){};"
-                + "Bar.inherits(Foo);\n"
-                + "Bar.mixin(Baz);\n")
+            "/**",
+            " * @param {T} x",
+            " * @param {T} y",
+            " * @template {number|string} T",
+            " */",
+            "function foo(x,y) { x=y; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testSuperClassDefinedAfterSubClass1() {
+  public void testBoundedGenericForwardDeclaredParameterError() {
     newTest()
         .addSource(
-            "/** @constructor \n * @extends {Base} */ function A() {}"
-                + "/** @constructor \n * @extends {Base} */ function B() {}"
-                + "/** @constructor */ function Base() {}"
-                + "/** @param {A|B} x \n * @return {B|A} */ "
-                + "function foo(x) { return x; }")
+            "/**",
+            " * @template {number} T",
+            " */",
+            "class Foo {}",
+            "var /** !Foo<Str> */ a;",
+            "/** @typedef {string} */",
+            "let Str;")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            "Bounded generic type error. string assigned to template type T is not a subtype of"
+                + " bound number")
         .run();
   }
 
   @Test
-  public void testSuperClassDefinedAfterSubClass2() {
+  public void testBoundedGenericParametrizedTypeVarError() {
     newTest()
         .addSource(
-            "/** @constructor \n * @extends {Base} */ function A() {}"
-                + "/** @constructor \n * @extends {Base} */ function B() {}"
-                + "/** @param {A|B} x \n * @return {B|A} */ "
-                + "function foo(x) { return x; }"
-                + "/** @constructor */ function Base() {}")
+            "/**",
+            " * @constructor",
+            " * @template {number|boolean} T",
+            " */",
+            "function F() {}",
+            "var /** F<string> */ a;")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            "Bounded generic type error. string assigned to template type T is not a subtype of"
+                + " bound (boolean|number)")
         .run();
   }
 
-  // https://github.com/google/closure-compiler/issues/2458
   @Test
-  public void testAbstractSpread() {
+  public void testBoundedGenericParametrizedTypeVar() {
     newTest()
         .addSource(
-            "/** @abstract */",
-            "class X {",
-            "  /** @abstract */",
-            "  m1() {}",
-            "",
-            "  m2() {",
-            "    return () => this.m1(...[]);",
-            "  }",
-            "}")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testGoodSuperCall() {
-    newTest()
-        .addSource(
-            "class A {",
-            "  /**",
-            "   * @param {string} a",
-            "   */",
-            "  constructor(a) {",
-            "    this.a = a;",
-            "  }",
-            "}",
-            "class B extends A {",
-            "  constructor() {",
-            "    super('b');",
-            "  }",
-            "}",
-            "")
-        .includeDefaultExterns()
+            "/**",
+            " * @constructor",
+            " * @param {T} x",
+            " * @template {number|boolean} T",
+            " */",
+            "function F(x) {}",
+            "var /** F<number> */ a;")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testBadSuperCall() {
+  public void testDoubleGenericBoundArgInnerAssignSubtypeError() {
     newTest()
         .addSource(
-            "class A {",
-            "  /**",
-            "   * @param {string} a",
-            "   */",
-            "  constructor(a) {",
-            "    this.a = a;",
-            "  }",
-            "}",
-            "class B extends A {",
-            "  constructor() {",
-            "    super(5);",
-            "  }",
-            "}")
+            "/**",
+            " * @param {T} x",
+            " * @param {U} y",
+            " * @template {number|string} T",
+            " * @template {number|string} U",
+            " */",
+            "function foo(x,y) { x=y; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
             lines(
-                "actual parameter 1 of super does not match formal parameter",
-                "found   : number",
-                "required: string"))
-        .includeDefaultExterns()
+                "assignment",
+                "found   : U extends (number|string)",
+                "required: T extends (number|string)"))
         .run();
   }
 
   @Test
-  public void testDirectPrototypeAssignment1() {
+  public void testGenericBoundBivariantTemplatized() {
     newTest()
         .addSource(
-            "/** @constructor */ function Base() {}"
-                + "Base.prototype.foo = 3;"
-                + "/** @constructor \n * @extends {Base} */ function A() {}"
-                + "A.prototype = new Base();"
-                + "/** @return {string} */ function foo() { return (new A).foo; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "/**",
+            " * @param {!Array<T>} x",
+            " * @param {!Array<number|boolean>} y",
+            " * @template {number} T",
+            " */",
+            "function foo(x,y) {",
+            "  var /** !Array<T> */ z = y;",
+            "  y = x;",
+            "}")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testDirectPrototypeAssignment2() {
-    // This ensures that we don't attach property 'foo' onto the Base
-    // instance object.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Base() {}"
-                + "/** @constructor \n * @extends {Base} */ function A() {}"
-                + "A.prototype = new Base();"
-                + "A.prototype.foo = 3;"
-                + "/** @return {string} */ function foo() { return (new Base).foo; }")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run(); // exists on subtypes, so only reported for strict props
-  }
-
-  @Test
-  public void testDirectPrototypeAssignment3() {
-    // This verifies that the compiler doesn't crash if the user
-    // overwrites the prototype of a global variable in a local scope.
+  public void testConstructGenericBoundGenericBound() {
     newTest()
         .addSource(
-            "/** @constructor */ var MainWidgetCreator = function() {};"
-                + "/** @param {Function} ctor */"
-                + "function createMainWidget(ctor) {"
-                + "  /** @constructor */ function tempCtor() {};"
-                + "  tempCtor.prototype = ctor.prototype;"
-                + "  MainWidgetCreator.superClass_ = ctor.prototype;"
-                + "  MainWidgetCreator.prototype = new tempCtor();"
-                + "}")
+            "/**",
+            " * @param {T} x",
+            " * @param {U} y",
+            " * @template {boolean|string} T",
+            " * @template {T} U",
+            " */",
+            "function foo(x,y) { x=y; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodImplements1() {
+  public void testConstructGenericBoundGenericBoundError() {
     newTest()
         .addSource(
-            "/** @interface */function Disposable() {}\n"
-                + "/** @implements {Disposable}\n * @constructor */function f() {}")
+            "/**",
+            " * @param {T} x",
+            " * @param {U} y",
+            " * @template {boolean|string} T",
+            " * @template {T} U",
+            " */",
+            "function foo(x,y) {",
+            "  var /** U */ z = x;",
+            "  x = y;",
+            "}")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : T extends (boolean|string)",
+                "required: U extends T extends (boolean|string)"))
         .run();
   }
 
   @Test
-  public void testGoodImplements2() {
+  public void testDoubleDeclareTemplateNameInFunctions() {
     newTest()
         .addSource(
-            "/** @interface */function Base1() {}\n"
-                + "/** @interface */function Base2() {}\n"
-                + "/** @constructor\n"
-                + " * @implements {Base1}\n"
-                + " * @implements {Base2}\n"
-                + " */ function derived() {}")
+            "/**",
+            " * @param {T} x",
+            " * @template {boolean} T",
+            " */",
+            "function foo(x) { return x; }",
+            "/**",
+            " * @param {T} x",
+            " * @template {string} T",
+            " */",
+            "function bar(x) { return x; }",
+            "foo(true);",
+            "bar('Hi');")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodImplements3() {
+  public void testDoubleDeclareTemplateNameInFunctionsError() {
     newTest()
         .addSource(
-            "/** @interface */function Disposable() {}\n"
-                + "/** @constructor \n @implements {Disposable} */function f() {}")
+            "/**",
+            " * @param {T} x",
+            " * @template {boolean} T",
+            " */",
+            "function foo(x) { return x; }",
+            "/**",
+            " * @param {T} x",
+            " * @template {string} T",
+            " */",
+            "function bar(x) { return x; }",
+            "foo('Hi');",
+            "bar(true);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of foo does not match formal parameter",
+                "found   : string",
+                "required: boolean"))
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of bar does not match formal parameter",
+                "found   : boolean",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testGoodImplements4() {
+  public void testShadowTemplateNameInFunctionAndClass() {
     newTest()
         .addSource(
-            "var goog = {};",
-            "/** @type {!Function} */",
-            "goog.abstractMethod = function() {};",
-            "/** @interface */",
-            "goog.Disposable = function() {};",
-            "goog.Disposable.prototype.dispose = goog.abstractMethod;",
-            "/** @implements {goog.Disposable}\n * @constructor */",
-            "goog.SubDisposable = function() {};",
-            "/** @inheritDoc */",
-            "goog.SubDisposable.prototype.dispose = function() {};")
+            "/**",
+            " * @param {T} x",
+            " * @template {boolean} T",
+            " */",
+            "function foo(x) { return x; }",
+            "class Foo {",
+            "  /**",
+            "   * @param {T} x",
+            "   * @template {string} T",
+            "   */",
+            "  foo(x) { return x; }",
+            "}",
+            "var F = new Foo();",
+            "F.foo('Hi');",
+            "foo(true);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodImplements5() {
+  public void testShadowTemplateNameInFunctionAndClassError() {
     newTest()
         .addSource(
-            "/** @interface */\n"
-                + "goog.Disposable = function() {};"
-                + "/** @type {Function} */"
-                + "goog.Disposable.prototype.dispose = function() {};"
-                + "/** @implements {goog.Disposable}\n * @constructor */"
-                + "goog.SubDisposable = function() {};"
-                + "/** @param {number} key \n @override */ "
-                + "goog.SubDisposable.prototype.dispose = function(key) {};")
+            "/**",
+            " * @param {T} x",
+            " * @template {boolean} T",
+            " */",
+            "function foo(x) { return x; }",
+            "class Foo {",
+            "  /**",
+            "   * @param {T} x",
+            "   * @template {string} T",
+            "   */",
+            "  foo(x) { return x; }",
+            "}",
+            "var F = new Foo();",
+            "F.foo(true);",
+            "foo('Hi');")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
+                "found   : boolean",
+                "required: string"))
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of foo does not match formal parameter",
+                "found   : string",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testGoodImplements6() {
+  public void testTemplateTypeBounds_passingBoundedTemplateType_toTemplatedFunction() {
     newTest()
         .addSource(
-            "var myNullFunction = function() {};"
-                + "/** @interface */\n"
-                + "goog.Disposable = function() {};"
-                + "/** @return {number} */"
-                + "goog.Disposable.prototype.dispose = myNullFunction;"
-                + "/** @implements {goog.Disposable}\n * @constructor */"
-                + "goog.SubDisposable = function() {};"
-                + "/** @return {number} \n @override */ "
-                + "goog.SubDisposable.prototype.dispose = function() { return 0; };")
+            "/** @constructor */",
+            "function Foo() { }",
+            "",
+            "/**",
+            " * @template {!Foo} X",
+            " * @param {X} x",
+            " * @return {X}",
+            " */",
+            "function clone(x) {",
+            // The focus of this test is that `X` (already a template variable) is bound to `Y` at
+            // this callsite. We confirm that by ensuring an `X` is returned from `cloneInternal`.
+            "  return cloneInternal(x);",
+            "}",
+            "",
+            "/**",
+            " * @template {!Foo} Y",
+            " * @param {Y} x",
+            " * @return {Y}",
+            " */",
+            "function cloneInternal(x) {",
+            "  return x;",
+            "}")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodImplements7() {
+  public void testTemplateTypeBounds_onFreeFunctions_areAlwaysSpecialized() {
     newTest()
         .addSource(
-            "var myNullFunction = function() {};"
-                + "/** @interface */\n"
-                + "goog.Disposable = function() {};"
-                + "/** @return {number} */"
-                + "goog.Disposable.prototype.dispose = function() {};"
-                + "/** @implements {goog.Disposable}\n * @constructor */"
-                + "goog.SubDisposable = function() {};"
-                + "/** @return {number} \n @override */ "
-                + "goog.SubDisposable.prototype.dispose = function() { return 0; };")
+            "/** @constructor */",
+            "function Foo() { }",
+            "",
+            "/**",
+            " * @template {!Foo} X",
+            " * @param {X} x",
+            " * @return {X}",
+            " */",
+            "function identity(x) {",
+            "  return x;",
+            "}",
+            "",
+            "var /** function(!Foo): !Foo */ y = identity;")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGoodImplements8() {
+  // TODO(b/139192655): The function template should shadow the class template type and not error
+  public void testFunctionTemplateShadowClassTemplate() {
     newTest()
         .addSource(
-            ""
-                + "/** @interface */\n"
-                + "MyInterface = function() {};\n"
-                + "MyInterface.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @implements {MyInterface}\n * @constructor */\n"
-                + "MyClass = function() {};\n"
-                + "MyClass.prototype = {\n"
-                + "  /** @return {number} \n @override */\n"
-                + "  method: function() { return 0; }\n"
-                + "}")
+            "/**",
+            " * @template T",
+            " */",
+            "class Foo {",
+            "  /**",
+            "   * @param {T} x",
+            "   * @template T",
+            "   */",
+            "  foo(x) { return x; }",
+            "}",
+            "const /** !Foo<string> */ f = new Foo();",
+            "f.foo(3);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testBadImplements1() {
+  // TODO(b/139192655): The function template should shadow the class template type and not error
+  public void testFunctionTemplateShadowClassTemplateBounded() {
     newTest()
         .addSource(
-            "/** @interface */function Base1() {}\n"
-                + "/** @interface */function Base2() {}\n"
-                + "/** @constructor\n"
-                + " * @implements {nonExistent}\n"
-                + " * @implements {Base2}\n"
-                + " */ function derived() {}")
-        .addDiagnostic("Bad type annotation. Unknown type nonExistent")
+            "/**",
+            " * @template {string} T",
+            " */",
+            "class Foo {",
+            "  /**",
+            "   * @param {T} x",
+            "   * @template {number} T",
+            "   */",
+            "  foo(x) { return x; }",
+            "}",
+            "const /** !Foo<string> */ f = new Foo();",
+            "f.foo(3);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testBadImplements2() {
+  public void testCyclicGenericBoundGenericError() {
+    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
+
     newTest()
         .addSource(
-            "/** @interface */function Disposable() {}\n"
-                + "/** @implements {Disposable}\n */function f() {}")
-        .addDiagnostic("@implements used without @constructor for f")
+            "/**",
+            " * @template {S} T",
+            " * @template {T} U",
+            " * @template {U} S",
+            " */",
+            "class Foo { }")
+        .addDiagnostic("Cycle detected in inheritance chain of type S")
+        .addDiagnostic("Cycle detected in inheritance chain of type T")
+        .addDiagnostic("Cycle detected in inheritance chain of type U")
         .run();
   }
 
   @Test
-  public void testBadImplements3() {
+  public void testUnitCyclicGenericBoundGenericError() {
+    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
+
     newTest()
         .addSource(
-            "var goog = {};",
-            "/** @type {!Function} */ goog.abstractMethod = function(){};",
-            "/** @interface */ var Disposable = function() {};",
-            "Disposable.prototype.method = goog.abstractMethod;",
-            "/** @implements {Disposable}\n * @constructor */function f() {}")
-        .addDiagnostic("property method on interface Disposable is not implemented by type f")
+            "/**", //
+            " * @template {T} T",
+            " */",
+            "class Foo { }")
+        .addDiagnostic("Cycle detected in inheritance chain of type T")
         .run();
   }
 
   @Test
-  public void testBadImplements4() {
+  public void testSecondUnitCyclicGenericBoundGenericError() {
+    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
+
     newTest()
         .addSource(
-            "/** @interface */function Disposable() {}\n"
-                + "/** @implements {Disposable}\n * @interface */function f() {}")
-        .addDiagnostic(
-            "f cannot implement this type; an interface can only extend, "
-                + "but not implement interfaces")
+            "/**", //
+            " * @template {T} T",
+            " * @template {T} U",
+            " */",
+            "class Foo { }")
+        .addDiagnostic("Cycle detected in inheritance chain of type T")
+        .addDiagnostic("Cycle detected in inheritance chain of type U")
         .run();
   }
 
   @Test
-  public void testBadImplements5() {
+  public void testConstructCyclicGenericBoundGenericBoundGraph() {
     newTest()
         .addSource(
-            "/** @interface */function Disposable() {}\n"
-                + "/** @type {number} */ Disposable.prototype.bar = function() {};")
-        .addDiagnostic(
-            "assignment to property bar of Disposable.prototype\n"
-                + "found   : function(): undefined\n"
-                + "required: number")
+            "/**",
+            " * @template V, E",
+            " */",
+            "class Vertex {}",
+            "/**",
+            " * @template V, E",
+            " */",
+            "class Edge {}",
+            "/**",
+            " * @template {Vertex<V, E>} V",
+            " * @template {Edge<V, E>} E",
+            " */",
+            "class Graph {}")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testBadImplements6() {
-    testClosureTypesMultipleWarnings(
-        "/** @interface */function Disposable() {}\n"
-            + "/** @type {function()} */ Disposable.prototype.bar = 3;",
-        ImmutableList.of(
-            "assignment to property bar of Disposable.prototype\n"
-                + "found   : number\n"
-                + "required: function(): ?",
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod"));
+  public void testBoundedGenericParametrizedTypeReturnError() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "function C(x) {}",
+            "/**",
+            " * @template {number|string} U",
+            " * @param {C<boolean>} x",
+            " * @return {C<U>}",
+            " */",
+            "function f(x) { return x; }")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "inconsistent return type",
+                "found   : (C<boolean>|null)",
+                "required: (C<U extends (number|string)>|null)"))
+        .run();
   }
 
   @Test
-  public void testBadImplements7() {
+  public void testBoundedGenericParametrizedTypeError() {
     newTest()
         .addSource(
-            ""
-                + "/** @interface */\n"
-                + "MyInterface = function() {};\n"
-                + "MyInterface.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @implements {MyInterface}\n * @constructor */\n"
-                + "MyClass = function() {};\n"
-                + "MyClass.prototype = {\n"
-                + "  /** @return {string} \n @override */\n"
-                + "  method: function() { return ''; }\n"
-                + "}")
+            "/**",
+            " * @constructor",
+            " * @param {T} x",
+            " * @template T",
+            " */",
+            "function C(x) {}",
+            "/**",
+            " * @template {number|string} U",
+            " * @param {C<U>} x",
+            " */",
+            "function f(x) {}",
+            "var /** C<boolean> */ c;",
+            "f(c);")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
-            ""
-                + "mismatch of the method property on type MyClass and the type of the property "
-                + "it overrides from interface MyInterface\n"
-                + "original: function(): number\n"
-                + "override: function(): string")
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : (C<boolean>|null)",
+                "required: (C<(number|string)>|null)"))
         .run();
   }
 
   @Test
-  public void testBadImplements8() {
+  public void testPartialNarrowingBoundedGenericParametrizedTypeError() {
     newTest()
         .addSource(
-            ""
-                + "/** @interface */\n"
-                + "MyInterface = function() {};\n"
-                + "MyInterface.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() {}\n"
-                + "}\n"
-                + "/** @implements {MyInterface}\n * @constructor */\n"
-                + "MyClass = function() {};\n"
-                + "MyClass.prototype = {\n"
-                + "  /** @return {number} */\n"
-                + "  method: function() { return 0; }\n"
-                + "}")
-        .addDiagnostic(
-            ""
-                + "property method already defined on interface MyInterface; "
-                + "use @override to override it")
-        .run();
-  }
-
-  @Test
-  public void testProtoDoesNotRequireOverrideFromInterface() {
-    newTest()
-        .includeDefaultExterns()
-        .addExterns("/** @type {Object} */ Object.prototype.__proto__;")
-        .addSource(
-            "/** @interface */\n"
-                + "var MyInterface = function() {};\n"
-                + "/** @constructor\n @implements {MyInterface} */\n"
-                + "var MySuper = function() {};\n"
-                + "/** @constructor\n @extends {MySuper} */\n"
-                + "var MyClass = function() {};\n"
-                + "MyClass.prototype = {\n"
-                + "  __proto__: MySuper.prototype\n"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testConstructorClassTemplate() {
-    newTest().addSource("/** @constructor \n @template S,T */ function A() {}\n").run();
-  }
-
-  @Test
-  public void testGenericBoundExplicitUnknown() {
-    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
-
-    newTest()
-        .addSource(
-            "/**", //
+            "/**",
+            " * @constructor",
             " * @param {T} x",
-            " * @template {?} T",
+            " * @template T",
             " */",
-            "function f(x) {}")
-        .addDiagnostic("Illegal upper bound '?' on template type parameter T")
-        .diagnosticsAreErrors()
-        .run();
-  }
-
-  @Test
-  public void testGenericBoundArgAppError() {
-    newTest()
-        .addSource(
+            "function C(x) {}",
             "/**",
-            " * @param {T} x",
-            " * @template {number} T",
+            " * @template {number|string} U",
+            " * @param {C<U>} x",
+            " * @param {U} y",
             " */",
-            "function f(x) {}",
-            "var a = f('a');")
+            "function f(x,y) {}",
+            "var /** C<string> */ c;",
+            "f(c,false);")
         .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
             lines(
                 "actual parameter 1 of f does not match formal parameter",
-                "found   : string",
-                "required: number"))
+                "found   : (C<string>|null)",
+                "required: (C<(number|string)>|null)"))
+        .addDiagnostic(
+            lines(
+                "actual parameter 2 of f does not match formal parameter",
+                "found   : boolean",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testGenericBoundArgApp() {
+  public void testPartialNarrowingBoundedGenericParametrizedType() {
     newTest()
         .addSource(
             "/**",
+            " * @constructor",
             " * @param {T} x",
-            " * @template {number} T",
+            " * @template T",
             " */",
-            "function f(x) {}",
-            "var a = f(3);")
+            "function C(x) {}",
+            "/**",
+            " * @template {number|string} U",
+            " * @param {C<U>} x",
+            " * @param {U} y",
+            " */",
+            "function f(x,y) {}",
+            "var /** C<number|string> */ c;",
+            "f(c,0);")
         .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .run();
   }
 
   @Test
-  public void testGenericBoundReturnError() {
-    // NOTE: This signature is unsafe, but it's an effective minimal test case.
+  public void testUnmappedBoundedGenericTypeError() {
     newTest()
         .addSource(
             "/**",
-            " * @return {T}",
-            " * @template {number} T",
+            " * @template {number|string} T",
+            " * @template {number|null} S",
             " */",
-            "function f(x) { return 'a'; }",
-            "var a = f(0);")
+            "class Foo {",
+            "  /**",
+            "   * @param {T} x",
+            "   */",
+            "  bar(x) { }",
+            "  /**",
+            "   * @param {S} x",
+            "   */",
+            "  baz(x) { }",
+            "}",
+            "var /** Foo<number> */ foo;",
+            "foo.baz(3);",
+            "foo.baz(null);",
+            "foo.baz('3');")
+        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
             lines(
-                "inconsistent return type", //
+                "actual parameter 1 of Foo.prototype.baz does not match formal parameter",
                 "found   : string",
-                "required: T extends number"))
+                "required: S extends (null|number)"))
         .run();
   }
 
   @Test
-  public void testGenericBoundArgAppNullError() {
+  public void testFunctionBodyBoundedGenericError() {
     newTest()
         .addSource(
+            "class C {}",
             "/**",
-            " * @param {T} x",
-            " * @template {number} T",
+            " * @template {C} T",
+            " * @param {T} t",
             " */",
-            "function f(x) { return x; }",
-            "var a = f(null);")
+            "function f(t) { t = new C(); }")
         .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
         .addDiagnostic(
             lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : null",
-                "required: number"))
+                "assignment", //
+                "found   : C",
+                "required: T extends (C|null)"))
         .run();
   }
 
   @Test
-  public void testGenericBoundArgAppNullable() {
+  public void testFunctionBodyBoundedPropertyGenericError() {
     newTest()
         .addSource(
             "/**",
-            " * @param {T} x",
-            " * @template {?number} T",
+            " * @template {number|string} T",
             " */",
-            "function f(x) { return x; }",
-            "var a = f(null);")
+            "class Foo {",
+            "  constructor() {",
+            "    /** @type {T} */",
+            "    this.x;",
+            "  }",
+            "  m() {",
+            "  this.x = 0;",
+            "  }",
+            "}",
+            "function f(t) { t = new C(); }")
         .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addDiagnostic(
+            lines(
+                "assignment to property x of Foo",
+                "found   : number",
+                "required: T extends (number|string)"))
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerCallAppError() {
+  public void testInterfaceExtends() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {string} x",
-            " */",
-            "function stringID(x) { return x; }",
-            "/**",
-            " * @param {T} x",
-            " * @template {number|boolean} T",
-            " */",
-            "function foo(x) { return stringID(x); }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of stringID does not match formal parameter",
-                "found   : T extends (boolean|number)",
-                "required: string"))
+            "/** @interface */function A() {}\n"
+                + "/** @interface \n * @extends {A} */function B() {}\n"
+                + "/** @constructor\n"
+                + " * @implements {B}\n"
+                + " */ function derived() {}")
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerCallApp() {
+  public void testDontCrashOnDupPropDefinition() {
     newTest()
         .addSource(
+            "/** @const */",
+            "var ns = {};",
+            "/** @interface */",
+            "ns.I = function() {};",
+            "/** @interface */",
+            "ns.A = function() {};",
             "/**",
-            " * @param {number} x",
-            " */",
-            "function numID(x) { return x; }",
-            "/**",
-            " * @param {T} x",
-            " * @template {number} T",
+            " * @constructor",
+            " * @implements {ns.I}",
             " */",
-            "function foo(x) { return numID(x); }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "ns.A = function() {};")
+        .addDiagnostic("variable ns.A redefined, original definition at [testcode]:6")
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerCallAppSubtypeError() {
+  public void testBadInterfaceExtends1() {
     newTest()
-        .addSource(
-            "/**",
-            " * @param {number} x",
-            " */",
-            "function numID(x) { return x; }",
-            "/**",
-            " * @param {T} x",
-            " * @template {number|boolean|string} T",
-            " */",
-            "function foo(x) { return numID(x); }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of numID does not match formal parameter",
-                "found   : T extends (boolean|number|string)",
-                "required: number"))
+        .addSource("/** @interface \n * @extends {nonExistent} */function A() {}")
+        .addDiagnostic("Bad type annotation. Unknown type nonExistent")
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerAssignSubtype() {
+  public void testBadInterfaceExtendsNonExistentInterfaces() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @param {number|string|boolean} y",
-            " * @template {number|string} T",
-            " */",
-            "function foo(x,y) { y=x; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface \n"
+                + " * @extends {nonExistent1} \n"
+                + " * @extends {nonExistent2} \n"
+                + " */function A() {}")
+        .addDiagnostic("Bad type annotation. Unknown type nonExistent1")
+        .addDiagnostic("Bad type annotation. Unknown type nonExistent2")
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerAssignBoundedInvariantError() {
+  public void testBadInterfaceExtends2() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {number} x",
-            " * @param {T} y",
-            " * @template {number|string} T",
-            " */",
-            "function foo(x,y) { y=x; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : number",
-                "required: T extends (number|string)"))
+            "/** @constructor */function A() {}\n"
+                + "/** @interface \n * @extends {A} */function B() {}")
+        .addDiagnostic("B cannot extend this type; interfaces can only extend interfaces")
         .run();
   }
 
   @Test
-  public void testGenericBoundArgInnerAssignSubtypeError() {
+  public void testBadInterfaceExtends3() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {number} x",
-            " * @param {T} y",
-            " * @template {number|string} T",
-            " */",
-            "function foo(x,y) { x=y; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : T extends (number|string)",
-                "required: number"))
+            "/** @interface */function A() {}\n"
+                + "/** @constructor \n * @extends {A} */function B() {}")
+        .addDiagnostic("B cannot extend this type; constructors can only extend constructors")
         .run();
   }
 
   @Test
-  public void testDoubleGenericBoundArgInnerAssignSubtype() {
+  public void testBadInterfaceExtends4() {
+    // TODO(user): This should be detected as an error. Even if we enforce
+    // that A cannot be used in the assignment, we should still detect the
+    // inheritance chain as invalid.
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @param {T} y",
-            " * @template {number|string} T",
-            " */",
-            "function foo(x,y) { x=y; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */function A() {}",
+            "/** @constructor */function B() {}",
+            "B.prototype = A;")
         .run();
   }
 
   @Test
-  public void testBoundedGenericForwardDeclaredParameterError() {
+  public void testBadInterfaceExtends5() {
+    // TODO(user): This should be detected as an error. Even if we enforce
+    // that A cannot be used in the assignment, we should still detect the
+    // inheritance chain as invalid.
     newTest()
         .addSource(
-            "/**",
-            " * @template {number} T",
-            " */",
-            "class Foo {}",
-            "var /** !Foo<Str> */ a;",
-            "/** @typedef {string} */",
-            "let Str;")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            "Bounded generic type error. string assigned to template type T is not a subtype of"
-                + " bound number")
+            "/** @constructor */function A() {}",
+            "/** @interface */function B() {}",
+            "B.prototype = A;")
         .run();
   }
 
   @Test
-  public void testBoundedGenericParametrizedTypeVarError() {
+  public void testBadImplementsAConstructor() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @template {number|boolean} T",
-            " */",
-            "function F() {}",
-            "var /** F<string> */ a;")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            "Bounded generic type error. string assigned to template type T is not a subtype of"
-                + " bound (boolean|number)")
+            "/** @constructor */function A() {}\n"
+                + "/** @constructor \n * @implements {A} */function B() {}")
+        .addDiagnostic("can only implement interfaces")
         .run();
   }
 
   @Test
-  public void testBoundedGenericParametrizedTypeVar() {
+  public void testBadImplementsAConstructorWithSubclass() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @param {T} x",
-            " * @template {number|boolean} T",
-            " */",
-            "function F(x) {}",
-            "var /** F<number> */ a;")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @constructor */",
+            "function A() {}",
+            "/** @implements {A} */",
+            "class B {}",
+            "class C extends B {}")
+        .addDiagnostic("can only implement interfaces")
         .run();
   }
 
   @Test
-  public void testDoubleGenericBoundArgInnerAssignSubtypeError() {
+  public void testBadImplementsNonInterfaceType() {
     newTest()
-        .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @param {U} y",
-            " * @template {number|string} T",
-            " * @template {number|string} U",
-            " */",
-            "function foo(x,y) { x=y; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : U extends (number|string)",
-                "required: T extends (number|string)"))
+        .addSource("/** @constructor \n * @implements {Boolean} */function B() {}")
+        .addDiagnostic("can only implement interfaces")
         .run();
   }
 
   @Test
-  public void testGenericBoundBivariantTemplatized() {
+  public void testBadImplementsNonObjectType() {
     newTest()
-        .addSource(
-            "/**",
-            " * @param {!Array<T>} x",
-            " * @param {!Array<number|boolean>} y",
-            " * @template {number} T",
-            " */",
-            "function foo(x,y) {",
-            "  var /** !Array<T> */ z = y;",
-            "  y = x;",
-            "}")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addSource("/** @constructor \n * @implements {string} */function S() {}")
+        .addDiagnostic("can only implement interfaces")
         .run();
   }
 
   @Test
-  public void testConstructGenericBoundGenericBound() {
+  public void testBadImplementsDuplicateInterface1() {
+    // verify that the same base (not templatized) interface cannot be
+    // @implemented more than once.
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @param {U} y",
-            " * @template {boolean|string} T",
-            " * @template {T} U",
-            " */",
-            "function foo(x,y) { x=y; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor \n"
+                + " * @implements {Foo<?>}\n"
+                + " * @implements {Foo}\n"
+                + " */\n"
+                + "function A() {}\n")
+        .addDiagnostic(
+            "Cannot @implement the same interface more than once\n" + "Repeated interface: Foo")
         .run();
   }
 
   @Test
-  public void testConstructGenericBoundGenericBoundError() {
+  public void testBadImplementsDuplicateInterface2() {
+    // verify that the same base (not templatized) interface cannot be
+    // @implemented more than once.
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @param {U} y",
-            " * @template {boolean|string} T",
-            " * @template {T} U",
-            " */",
-            "function foo(x,y) {",
-            "  var /** U */ z = x;",
-            "  x = y;",
-            "}")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor \n"
+                + " * @implements {Foo<string>}\n"
+                + " * @implements {Foo<number>}\n"
+                + " */\n"
+                + "function A() {}\n")
         .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : T extends (boolean|string)",
-                "required: U extends T extends (boolean|string)"))
+            "Cannot @implement the same interface more than once\n" + "Repeated interface: Foo")
         .run();
   }
 
   @Test
-  public void testDoubleDeclareTemplateNameInFunctions() {
+  public void testInterfaceAssignment1() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @template {boolean} T",
-            " */",
-            "function foo(x) { return x; }",
-            "/**",
-            " * @param {T} x",
-            " * @template {string} T",
-            " */",
-            "function bar(x) { return x; }",
-            "foo(true);",
-            "bar('Hi');")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I = function() {};\n"
+                + "/** @constructor\n@implements {I} */var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {!I} */var i = t;")
         .run();
   }
 
   @Test
-  public void testDoubleDeclareTemplateNameInFunctionsError() {
+  public void testInterfaceAssignment2() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @template {boolean} T",
-            " */",
-            "function foo(x) { return x; }",
-            "/**",
-            " * @param {T} x",
-            " * @template {string} T",
-            " */",
-            "function bar(x) { return x; }",
-            "foo('Hi');",
-            "bar(true);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of foo does not match formal parameter",
-                "found   : string",
-                "required: boolean"))
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of bar does not match formal parameter",
-                "found   : boolean",
-                "required: string"))
+            "/** @interface */var I = function() {};\n"
+                + "/** @constructor */var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {!I} */var i = t;")
+        .addDiagnostic("initializing variable\n" + "found   : T\n" + "required: I")
         .run();
   }
 
   @Test
-  public void testShadowTemplateNameInFunctionAndClass() {
+  public void testInterfaceAssignment3() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @template {boolean} T",
-            " */",
-            "function foo(x) { return x; }",
-            "class Foo {",
-            "  /**",
-            "   * @param {T} x",
-            "   * @template {string} T",
-            "   */",
-            "  foo(x) { return x; }",
-            "}",
-            "var F = new Foo();",
-            "F.foo('Hi');",
-            "foo(true);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I = function() {};\n"
+                + "/** @constructor\n@implements {I} */var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I|number} */var i = t;")
         .run();
   }
 
   @Test
-  public void testShadowTemplateNameInFunctionAndClassError() {
+  public void testInterfaceAssignment4() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {T} x",
-            " * @template {boolean} T",
-            " */",
-            "function foo(x) { return x; }",
-            "class Foo {",
-            "  /**",
-            "   * @param {T} x",
-            "   * @template {string} T",
-            "   */",
-            "  foo(x) { return x; }",
-            "}",
-            "var F = new Foo();",
-            "F.foo(true);",
-            "foo('Hi');")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
-                "found   : boolean",
-                "required: string"))
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of foo does not match formal parameter",
-                "found   : string",
-                "required: boolean"))
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */var I2 = function() {};\n"
+                + "/** @constructor\n@implements {I1} */var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I1|I2} */var i = t;")
         .run();
   }
 
   @Test
-  public void testTemplateTypeBounds_passingBoundedTemplateType_toTemplatedFunction() {
+  public void testInterfaceAssignment5() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() { }",
-            "",
-            "/**",
-            " * @template {!Foo} X",
-            " * @param {X} x",
-            " * @return {X}",
-            " */",
-            "function clone(x) {",
-            // The focus of this test is that `X` (already a template variable) is bound to `Y` at
-            // this callsite. We confirm that by ensuring an `X` is returned from `cloneInternal`.
-            "  return cloneInternal(x);",
-            "}",
-            "",
-            "/**",
-            " * @template {!Foo} Y",
-            " * @param {Y} x",
-            " * @return {Y}",
-            " */",
-            "function cloneInternal(x) {",
-            "  return x;",
-            "}")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */var I2 = function() {};\n"
+                + "/** @constructor\n@implements {I1}\n@implements {I2}*/"
+                + "var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I1} */var i1 = t;\n"
+                + "/** @type {I2} */var i2 = t;\n")
         .run();
   }
 
   @Test
-  public void testTemplateTypeBounds_onFreeFunctions_areAlwaysSpecialized() {
+  public void testInterfaceAssignment6() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() { }",
-            "",
-            "/**",
-            " * @template {!Foo} X",
-            " * @param {X} x",
-            " * @return {X}",
-            " */",
-            "function identity(x) {",
-            "  return x;",
-            "}",
-            "",
-            "var /** function(!Foo): !Foo */ y = identity;")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */var I2 = function() {};\n"
+                + "/** @constructor\n@implements {I1} */var T = function() {};\n"
+                + "/** @type {!I1} */var i1 = new T();\n"
+                + "/** @type {!I2} */var i2 = i1;\n")
+        .addDiagnostic("initializing variable\n" + "found   : I1\n" + "required: I2")
         .run();
   }
 
   @Test
-  // TODO(b/139192655): The function template should shadow the class template type and not error
-  public void testFunctionTemplateShadowClassTemplate() {
+  public void testInterfaceAssignment7() {
     newTest()
         .addSource(
-            "/**",
-            " * @template T",
-            " */",
-            "class Foo {",
-            "  /**",
-            "   * @param {T} x",
-            "   * @template T",
-            "   */",
-            "  foo(x) { return x; }",
-            "}",
-            "const /** !Foo<string> */ f = new Foo();",
-            "f.foo(3);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
-                "found   : number",
-                "required: string"))
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface\n@extends {I1}*/var I2 = function() {};\n"
+                + "/** @constructor\n@implements {I2}*/var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I1} */var i1 = t;\n"
+                + "/** @type {I2} */var i2 = t;\n"
+                + "i1 = i2;\n")
         .run();
   }
 
   @Test
-  // TODO(b/139192655): The function template should shadow the class template type and not error
-  public void testFunctionTemplateShadowClassTemplateBounded() {
+  public void testInterfaceAssignment8() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/**",
-            " * @template {string} T",
-            " */",
-            "class Foo {",
-            "  /**",
-            "   * @param {T} x",
-            "   * @template {number} T",
-            "   */",
-            "  foo(x) { return x; }",
-            "}",
-            "const /** !Foo<string> */ f = new Foo();",
-            "f.foo(3);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of Foo.prototype.foo does not match formal parameter",
-                "found   : number",
-                "required: string"))
+            "/** @interface */var I = function() {};\n"
+                + "/** @type {I} */var i;\n"
+                + "/** @type {Object} */var o = i;\n"
+                + "new Object().prototype = i.prototype;")
         .run();
   }
 
   @Test
-  public void testCyclicGenericBoundGenericError() {
-    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
-
+  public void testInterfaceAssignment9() {
     newTest()
         .addSource(
-            "/**",
-            " * @template {S} T",
-            " * @template {T} U",
-            " * @template {U} S",
-            " */",
-            "class Foo { }")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type S")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type T")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type U")
-        .diagnosticsAreErrors()
+            "/** @interface */var I = function() {};\n"
+                + "/** @return {I?} */function f() { return null; }\n"
+                + "/** @type {!I} */var i = f();\n")
+        .addDiagnostic("initializing variable\n" + "found   : (I|null)\n" + "required: I")
         .run();
   }
 
   @Test
-  public void testUnitCyclicGenericBoundGenericError() {
-    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
-
+  public void testInterfaceAssignment10() {
     newTest()
         .addSource(
-            "/**", //
-            " * @template {T} T",
-            " */",
-            "class Foo { }")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type T")
-        .diagnosticsAreErrors()
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */var I2 = function() {};\n"
+                + "/** @constructor\n@implements {I2} */var T = function() {};\n"
+                + "/** @return {!I1|!I2} */function f() { return new T(); }\n"
+                + "/** @type {!I1} */var i1 = f();\n")
+        .addDiagnostic("initializing variable\n" + "found   : (I1|I2)\n" + "required: I1")
         .run();
   }
 
   @Test
-  public void testSecondUnitCyclicGenericBoundGenericError() {
-    compiler.getOptions().setWarningLevel(DiagnosticGroups.BOUNDED_GENERICS, CheckLevel.OFF);
-
+  public void testInterfaceAssignment11() {
     newTest()
         .addSource(
-            "/**", //
-            " * @template {T} T",
-            " * @template {T} U",
-            " */",
-            "class Foo { }")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type T")
-        .addDiagnostic("Parse error. Cycle detected in inheritance chain of type U")
-        .diagnosticsAreErrors()
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */var I2 = function() {};\n"
+                + "/** @constructor */var T = function() {};\n"
+                + "/** @return {!I1|!I2|!T} */function f() { return new T(); }\n"
+                + "/** @type {!I1} */var i1 = f();\n")
+        .addDiagnostic("initializing variable\n" + "found   : (I1|I2|T)\n" + "required: I1")
         .run();
   }
 
   @Test
-  public void testConstructCyclicGenericBoundGenericBoundGraph() {
+  public void testInterfaceAssignment12() {
     newTest()
         .addSource(
-            "/**",
-            " * @template V, E",
-            " */",
-            "class Vertex {}",
-            "/**",
-            " * @template V, E",
-            " */",
-            "class Edge {}",
-            "/**",
-            " * @template {Vertex<V, E>} V",
-            " * @template {Edge<V, E>} E",
-            " */",
-            "class Graph {}")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I = function() {};\n"
+                + "/** @constructor\n@implements{I}*/var T1 = function() {};\n"
+                + "/** @constructor\n@extends {T1}*/var T2 = function() {};\n"
+                + "/** @return {I} */function f() { return new T2(); }")
         .run();
   }
 
   @Test
-  public void testBoundedGenericParametrizedTypeReturnError() {
+  public void testInterfaceAssignment13() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function C(x) {}",
-            "/**",
-            " * @template {number|string} U",
-            " * @param {C<boolean>} x",
-            " * @return {C<U>}",
-            " */",
-            "function f(x) { return x; }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+            "/** @interface */var I = function() {};\n"
+                + "/** @constructor\n@implements {I}*/var T = function() {};\n"
+                + "/** @constructor */function Super() {};\n"
+                + "/** @return {I} */Super.prototype.foo = "
+                + "function() { return new T(); };\n"
+                + "/** @constructor\n@extends {Super} */function Sub() {}\n"
+                + "/** @override\n@return {T} */Sub.prototype.foo = "
+                + "function() { return new T(); };\n")
+        .run();
+  }
+
+  @Test
+  public void testGetprop1() {
+    newTest()
+        .addSource("/** @return {void}*/function foo(){foo().bar;}")
         .addDiagnostic(
-            lines(
-                "inconsistent return type",
-                "found   : (C<boolean>|null)",
-                "required: (C<U extends (number|string)>|null)"))
+            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testBoundedGenericParametrizedTypeError() {
+  public void testGetprop2() {
     newTest()
-        .addSource(
-            "/**",
-            " * @constructor",
-            " * @param {T} x",
-            " * @template T",
-            " */",
-            "function C(x) {}",
-            "/**",
-            " * @template {number|string} U",
-            " * @param {C<U>} x",
-            " */",
-            "function f(x) {}",
-            "var /** C<boolean> */ c;",
-            "f(c);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addSource("var x = null; x.alert();")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : (C<boolean>|null)",
-                "required: (C<(number|string)>|null)"))
+            "No properties on this expression\n" + "found   : null\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testPartialNarrowingBoundedGenericParametrizedTypeError() {
+  public void testGetprop3() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @param {T} x",
-            " * @template T",
-            " */",
-            "function C(x) {}",
-            "/**",
-            " * @template {number|string} U",
-            " * @param {C<U>} x",
-            " * @param {U} y",
-            " */",
-            "function f(x,y) {}",
-            "var /** C<string> */ c;",
-            "f(c,false);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : (C<string>|null)",
-                "required: (C<(number|string)>|null)"))
-        .addDiagnostic(
-            lines(
-                "actual parameter 2 of f does not match formal parameter",
-                "found   : boolean",
-                "required: (number|string)"))
+            "/** @constructor */ "
+                + "function Foo() { /** @type {?Object} */ this.x = null; }"
+                + "Foo.prototype.initX = function() { this.x = {foo: 1}; };"
+                + "Foo.prototype.bar = function() {"
+                + "  if (this.x == null) { this.initX(); alert(this.x.foo); }"
+                + "};")
         .run();
   }
 
   @Test
-  public void testPartialNarrowingBoundedGenericParametrizedType() {
+  public void testGetprop4() {
     newTest()
-        .addSource(
-            "/**",
-            " * @constructor",
-            " * @param {T} x",
-            " * @template T",
-            " */",
-            "function C(x) {}",
-            "/**",
-            " * @template {number|string} U",
-            " * @param {C<U>} x",
-            " * @param {U} y",
-            " */",
-            "function f(x,y) {}",
-            "var /** C<number|string> */ c;",
-            "f(c,0);")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
+        .addSource("var x = null; x.prop = 3;")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : null\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testUnmappedBoundedGenericTypeError() {
+  public void testGetrop_interfaceWithoutTypeDeclaration() {
     newTest()
         .addSource(
-            "/**",
-            " * @template {number|string} T",
-            " * @template {number|null} S",
-            " */",
-            "class Foo {",
-            "  /**",
-            "   * @param {T} x",
-            "   */",
-            "  bar(x) { }",
-            "  /**",
-            "   * @param {S} x",
-            "   */",
-            "  baz(x) { }",
-            "}",
-            "var /** Foo<number> */ foo;",
-            "foo.baz(3);",
-            "foo.baz(null);",
-            "foo.baz('3');")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of Foo.prototype.baz does not match formal parameter",
-                "found   : string",
-                "required: S extends (null|number)"))
+            "/** @interface */var I = function() {};",
+            // Note that we didn't declare the type but we still expect JsCompiler to recognize the
+            // property.
+            "I.prototype.foo;",
+            "var v = /** @type {I} */ (null); ",
+            "v.foo = 5;")
         .run();
   }
 
   @Test
-  public void testFunctionBodyBoundedGenericError() {
+  public void testGetrop_interfaceEs6WithoutTypeDeclaration() {
     newTest()
         .addSource(
-            "class C {}",
-            "/**",
-            " * @template {C} T",
-            " * @param {T} t",
-            " */",
-            "function f(t) { t = new C(); }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : C",
-                "required: T extends (C|null)"))
+            "/** @interface */",
+            "class I {",
+            "  constructor() {",
+            "    this.foo;",
+            "  }",
+            "}",
+            "var v = /** @type {I} */ (null); ",
+            "v.foo = 5;")
+        // TODO(b/131257037): Support ES6 style instance properties on interfaces.
+        .addDiagnostic("Property foo never defined on I")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
         .run();
   }
 
   @Test
-  public void testFunctionBodyBoundedPropertyGenericError() {
+  public void testGetrop_interfaceEs6WithTypeDeclaration() {
     newTest()
         .addSource(
-            "/**",
-            " * @template {number|string} T",
-            " */",
-            "class Foo {",
+            "/** @interface */",
+            "class I {",
             "  constructor() {",
-            "    /** @type {T} */",
-            "    this.x;",
-            "  }",
-            "  m() {",
-            "  this.x = 0;",
+            "    /** @type {number} */ this.foo;",
             "  }",
             "}",
-            "function f(t) { t = new C(); }")
-        .addDiagnostic(BOUNDED_GENERICS_USE_MSG)
-        .addDiagnostic(
-            lines(
-                "assignment to property x of Foo",
-                "found   : number",
-                "required: T extends (number|string)"))
+            "var v = /** @type {I} */ (null); ",
+            "v.foo = 5;")
         .run();
   }
 
   @Test
-  public void testInterfaceExtends() {
+  public void testSetprop1() {
+    // Create property on struct in the constructor
     newTest()
         .addSource(
-            "/** @interface */function A() {}\n"
-                + "/** @interface \n * @extends {A} */function B() {}\n"
-                + "/** @constructor\n"
-                + " * @implements {B}\n"
-                + " */ function derived() {}")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() { this.x = 123; }")
         .run();
   }
 
   @Test
-  public void testDontCrashOnDupPropDefinition() {
+  public void testSetprop2() {
+    // Create property on struct outside the constructor
     newTest()
         .addSource(
-            "/** @const */",
-            "var ns = {};",
-            "/** @interface */",
-            "ns.I = function() {};",
-            "/** @interface */",
-            "ns.A = function() {};",
-            "/**",
-            " * @constructor",
-            " * @implements {ns.I}",
-            " */",
-            "ns.A = function() {};")
-        .addDiagnostic("variable ns.A redefined, original definition at [testcode]:6")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "(new Foo()).x = 123;")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtends1() {
+  public void testSetprop3() {
+    // Create property on struct outside the constructor
     newTest()
-        .addSource("/** @interface \n * @extends {nonExistent} */function A() {}")
-        .addDiagnostic("Bad type annotation. Unknown type nonExistent")
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "(function() { (new Foo()).x = 123; })();")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtendsNonExistentInterfaces() {
+  public void testSetprop4() {
+    // Assign to existing property of struct outside the constructor
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @extends {nonExistent1} \n"
-                + " * @extends {nonExistent2} \n"
-                + " */function A() {}")
-        .addDiagnostic("Bad type annotation. Unknown type nonExistent1")
-        .addDiagnostic("Bad type annotation. Unknown type nonExistent2")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() { this.x = 123; }\n"
+                + "(new Foo()).x = \"asdf\";")
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtends2() {
+  public void testSetprop5() {
+    // Create a property on union that includes a struct
     newTest()
         .addSource(
-            "/** @constructor */function A() {}\n"
-                + "/** @interface \n * @extends {A} */function B() {}")
-        .addDiagnostic("B cannot extend this type; interfaces can only extend interfaces")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "(true ? new Foo() : {}).x = 123;")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE)
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtends3() {
+  public void testSetprop6() {
+    // Create property on struct in another constructor
     newTest()
         .addSource(
-            "/** @interface */function A() {}\n"
-                + "/** @constructor \n * @extends {A} */function B() {}")
-        .addDiagnostic("B cannot extend this type; constructors can only extend constructors")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @param{Foo} f\n"
+                + " */\n"
+                + "function Bar(f) { f.x = 123; }")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtends4() {
-    // TODO(user): This should be detected as an error. Even if we enforce
-    // that A cannot be used in the assignment, we should still detect the
-    // inheritance chain as invalid.
+  public void testSetprop7() {
+    // Bug b/c we require THIS when creating properties on structs for simplicity
     newTest()
         .addSource(
-            "/** @interface */function A() {}",
-            "/** @constructor */function B() {}",
-            "B.prototype = A;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {\n"
+                + "  var t = this;\n"
+                + "  t.x = 123;\n"
+                + "}")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
         .run();
   }
 
   @Test
-  public void testBadInterfaceExtends5() {
-    // TODO(user): This should be detected as an error. Even if we enforce
-    // that A cannot be used in the assignment, we should still detect the
-    // inheritance chain as invalid.
+  public void testSetprop8() {
+    // Create property on struct using DEC
     newTest()
         .addSource(
-            "/** @constructor */function A() {}",
-            "/** @interface */function B() {}",
-            "B.prototype = A;")
-        .run();
-  }
-
-  @Test
-  public void testBadImplementsAConstructor() {
-    newTest()
-        .addSource(
-            "/** @constructor */function A() {}\n"
-                + "/** @constructor \n * @implements {A} */function B() {}")
-        .addDiagnostic("can only implement interfaces")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "(new Foo()).x--;")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+        .addDiagnostic("Property x never defined on Foo")
         .run();
   }
 
   @Test
-  public void testBadImplementsAConstructorWithSubclass() {
+  public void testSetprop9() {
+    // Create property on struct using ASSIGN_ADD
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function A() {}",
-            "/** @implements {A} */",
-            "class B {}",
-            "class C extends B {}")
-        .addDiagnostic("can only implement interfaces")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "(new Foo()).x += 123;")
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+        .addDiagnostic("Property x never defined on Foo")
         .run();
   }
 
   @Test
-  public void testBadImplementsNonInterfaceType() {
+  public void testSetprop10() {
+    // Create property on object literal that is a struct
     newTest()
-        .addSource("/** @constructor \n * @implements {Boolean} */function B() {}")
-        .addDiagnostic("can only implement interfaces")
+        .addSource(
+            "/** \n"
+                + " * @constructor \n"
+                + " * @struct \n"
+                + " */ \n"
+                + "function Square(side) { \n"
+                + "  this.side = side; \n"
+                + "} \n"
+                + "Square.prototype = /** @struct */ {\n"
+                + "  area: function() { return this.side * this.side; }\n"
+                + "};\n"
+                + "Square.prototype.id = function(x) { return x; };")
         .run();
   }
 
   @Test
-  public void testBadImplementsNonObjectType() {
+  public void testSetprop11() {
     newTest()
-        .addSource("/** @constructor \n * @implements {string} */function S() {}")
-        .addDiagnostic("can only implement interfaces")
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor */\n"
+                + "function Bar() {}\n"
+                + "Bar.prototype = new Foo();\n"
+                + "Bar.prototype.someprop = 123;")
         .run();
   }
 
   @Test
-  public void testBadImplementsDuplicateInterface1() {
-    // verify that the same base (not templatized) interface cannot be
-    // @implemented more than once.
+  public void testSetprop12() {
+    // Create property on a constructor of structs (which isn't itself a struct)
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
                 + " */\n"
                 + "function Foo() {}\n"
-                + "/** @constructor \n"
-                + " * @implements {Foo<?>}\n"
-                + " * @implements {Foo}\n"
-                + " */\n"
-                + "function A() {}\n")
-        .addDiagnostic(
-            "Cannot @implement the same interface more than once\n" + "Repeated interface: Foo")
+                + "Foo.someprop = 123;")
         .run();
   }
 
   @Test
-  public void testBadImplementsDuplicateInterface2() {
-    // verify that the same base (not templatized) interface cannot be
-    // @implemented more than once.
+  public void testSetprop13() {
+    // Create static property on struct
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
                 + " */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor \n"
-                + " * @implements {Foo<string>}\n"
-                + " * @implements {Foo<number>}\n"
+                + "function Parent() {}\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Parent}\n"
                 + " */\n"
-                + "function A() {}\n")
-        .addDiagnostic(
-            "Cannot @implement the same interface more than once\n" + "Repeated interface: Foo")
+                + "function Kid() {}\n"
+                + "Kid.prototype.foo = 123;\n"
+                + "var x = (new Kid()).foo;")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment1() {
+  public void testSetprop14() {
+    // Create static property on struct
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @constructor\n@implements {I} */var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {!I} */var i = t;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Top() {}\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Top}\n"
+                + " */\n"
+                + "function Mid() {}\n"
+                + "/** blah blah */\n"
+                + "Mid.prototype.foo = function() { return 1; };\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " * @extends {Mid}\n"
+                + " */\n"
+                + "function Bottom() {}\n"
+                + "/** @override */\n"
+                + "Bottom.prototype.foo = function() { return 3; };")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment2() {
+  public void testSetprop15() {
+    // Create static property on struct
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @constructor */var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {!I} */var i = t;")
-        .addDiagnostic("initializing variable\n" + "found   : T\n" + "required: I")
+            "/** @interface */\n"
+                + "function Peelable() {};\n"
+                + "/** @return {undefined} */\n"
+                + "Peelable.prototype.peel;\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Fruit() {};\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Fruit}\n"
+                + " * @implements {Peelable}\n"
+                + " */\n"
+                + "function Banana() { };\n"
+                + "function f() {};\n"
+                + "/** @override */\n"
+                + "Banana.prototype.peel = f;")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment3() {
+  public void testGetpropDict1() {
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @constructor\n@implements {I} */var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I|number} */var i = t;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1(){ this['prop'] = 123; }"
+                + "/** @param{Dict1} x */"
+                + "function takesDict(x) { return x.prop; }")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment4() {
+  public void testGetpropDict2() {
     newTest()
         .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */var I2 = function() {};\n"
-                + "/** @constructor\n@implements {I1} */var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I1|I2} */var i = t;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1(){ this['prop'] = 123; }"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Dict1}\n"
+                + " */"
+                + "function Dict1kid(){ this['prop'] = 123; }"
+                + "/** @param{Dict1kid} x */"
+                + "function takesDict(x) { return x.prop; }")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment5() {
+  public void testGetpropDict3() {
     newTest()
         .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */var I2 = function() {};\n"
-                + "/** @constructor\n@implements {I1}\n@implements {I2}*/"
-                + "var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I1} */var i1 = t;\n"
-                + "/** @type {I2} */var i2 = t;\n")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1() { this['prop'] = 123; }"
+                + "/** @constructor */"
+                + "function NonDict() { this.prop = 321; }"
+                + "/** @param{(NonDict|Dict1)} x */"
+                + "function takesDict(x) { return x.prop; }")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment6() {
+  public void testGetpropDict4() {
     newTest()
         .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */var I2 = function() {};\n"
-                + "/** @constructor\n@implements {I1} */var T = function() {};\n"
-                + "/** @type {!I1} */var i1 = new T();\n"
-                + "/** @type {!I2} */var i2 = i1;\n")
-        .addDiagnostic("initializing variable\n" + "found   : I1\n" + "required: I2")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1() { this['prop'] = 123; }"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1() { this.prop = 123; }"
+                + "/** @param{(Struct1|Dict1)} x */"
+                + "function takesNothing(x) { return x.prop; }")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment7() {
+  public void testGetpropDict5() {
     newTest()
         .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface\n@extends {I1}*/var I2 = function() {};\n"
-                + "/** @constructor\n@implements {I2}*/var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I1} */var i1 = t;\n"
-                + "/** @type {I2} */var i2 = t;\n"
-                + "i1 = i2;\n")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1(){ this.prop = 123; }")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment8() {
-    disableStrictMissingPropertyChecks();
-
+  public void testGetpropDict6() {
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @type {I} */var i;\n"
-                + "/** @type {Object} */var o = i;\n"
-                + "new Object().prototype = i.prototype;")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceAssignment9() {
-    newTest()
-        .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @return {I?} */function f() { return null; }\n"
-                + "/** @type {!I} */var i = f();\n")
-        .addDiagnostic("initializing variable\n" + "found   : (I|null)\n" + "required: I")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceAssignment10() {
-    newTest()
-        .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */var I2 = function() {};\n"
-                + "/** @constructor\n@implements {I2} */var T = function() {};\n"
-                + "/** @return {!I1|!I2} */function f() { return new T(); }\n"
-                + "/** @type {!I1} */var i1 = f();\n")
-        .addDiagnostic("initializing variable\n" + "found   : (I1|I2)\n" + "required: I1")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceAssignment11() {
-    newTest()
-        .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */var I2 = function() {};\n"
-                + "/** @constructor */var T = function() {};\n"
-                + "/** @return {!I1|!I2|!T} */function f() { return new T(); }\n"
-                + "/** @type {!I1} */var i1 = f();\n")
-        .addDiagnostic("initializing variable\n" + "found   : (I1|I2|T)\n" + "required: I1")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + "function Bar() {}\n"
+                + "Bar.prototype = new Foo();\n"
+                + "Bar.prototype.someprop = 123;\n")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment12() {
+  public void testGetpropDict7() {
     newTest()
-        .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @constructor\n@implements{I}*/var T1 = function() {};\n"
-                + "/** @constructor\n@extends {T1}*/var T2 = function() {};\n"
-                + "/** @return {I} */function f() { return new T2(); }")
+        .addSource("(/** @dict */ {'x': 123}).x = 321;")
+        .addDiagnostic("Cannot do '.' access on a dict")
         .run();
   }
 
   @Test
-  public void testInterfaceAssignment13() {
+  public void testGetelemStruct1() {
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};\n"
-                + "/** @constructor\n@implements {I}*/var T = function() {};\n"
-                + "/** @constructor */function Super() {};\n"
-                + "/** @return {I} */Super.prototype.foo = "
-                + "function() { return new T(); };\n"
-                + "/** @constructor\n@extends {Super} */function Sub() {}\n"
-                + "/** @override\n@return {T} */Sub.prototype.foo = "
-                + "function() { return new T(); };\n")
-        .run();
-  }
-
-  @Test
-  public void testGetprop1() {
-    newTest()
-        .addSource("/** @return {void}*/function foo(){foo().bar;}")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testGetprop2() {
-    newTest()
-        .addSource("var x = null; x.alert();")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1(){ this.prop = 123; }"
+                + "/** @param{Struct1} x */"
+                + "function takesStruct(x) {"
+                + "  var z = x;"
+                + "  return z['prop'];"
+                + "}")
+        .addDiagnostic("Cannot do '[]' access on a struct")
         .run();
   }
 
   @Test
-  public void testGetprop3() {
+  public void testGetelemStruct2() {
     newTest()
         .addSource(
-            "/** @constructor */ "
-                + "function Foo() { /** @type {?Object} */ this.x = null; }"
-                + "Foo.prototype.initX = function() { this.x = {foo: 1}; };"
-                + "Foo.prototype.bar = function() {"
-                + "  if (this.x == null) { this.initX(); alert(this.x.foo); }"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testGetprop4() {
-    newTest()
-        .addSource("var x = null; x.prop = 3;")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1(){ this.prop = 123; }"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Struct1}"
+                + " */"
+                + "function Struct1kid(){ this.prop = 123; }"
+                + "/** @param{Struct1kid} x */"
+                + "function takesStruct2(x) { return x['prop']; }")
+        .addDiagnostic("Cannot do '[]' access on a struct")
         .run();
   }
 
   @Test
-  public void testGetrop_interfaceWithoutTypeDeclaration() {
+  public void testGetelemStruct3() {
     newTest()
         .addSource(
-            "/** @interface */var I = function() {};",
-            // Note that we didn't declare the type but we still expect JsCompiler to recognize the
-            // property.
-            "I.prototype.foo;",
-            "var v = /** @type {I} */ (null); ",
-            "v.foo = 5;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1(){ this.prop = 123; }"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Struct1}\n"
+                + " */"
+                + "function Struct1kid(){ this.prop = 123; }"
+                + "var x = (new Struct1kid())['prop'];")
+        .addDiagnostic("Cannot do '[]' access on a struct")
         .run();
   }
 
   @Test
-  public void testGetrop_interfaceEs6WithoutTypeDeclaration() {
+  public void testGetelemStruct4() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "class I {",
-            "  constructor() {",
-            "    this.foo;",
-            "  }",
-            "}",
-            "var v = /** @type {I} */ (null); ",
-            "v.foo = 5;")
-        // TODO(b/131257037): Support ES6 style instance properties on interfaces.
-        .addDiagnostic("Property foo never defined on I")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1() { this.prop = 123; }"
+                + "/** @constructor */"
+                + "function NonStruct() { this.prop = 321; }"
+                + "/** @param{(NonStruct|Struct1)} x */"
+                + "function takesStruct(x) { return x['prop']; }")
+        .addDiagnostic("Cannot do '[]' access on a struct")
         .run();
   }
 
   @Test
-  public void testGetrop_interfaceEs6WithTypeDeclaration() {
+  public void testGetelemStruct5() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "class I {",
-            "  constructor() {",
-            "    /** @type {number} */ this.foo;",
-            "  }",
-            "}",
-            "var v = /** @type {I} */ (null); ",
-            "v.foo = 5;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */"
+                + "function Struct1() { this.prop = 123; }"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " */"
+                + "function Dict1() { this['prop'] = 123; }"
+                + "/** @param{(Struct1|Dict1)} x */"
+                + "function takesNothing(x) { return x['prop']; }")
+        .addDiagnostic("Cannot do '[]' access on a struct")
         .run();
   }
 
   @Test
-  public void testSetprop1() {
-    // Create property on struct in the constructor
+  public void testGetelemStruct6() {
+    // By casting Bar to Foo, the illegal bracket access is not detected
     newTest()
         .addSource(
-            "/**\n"
+            "/** @interface */ function Foo(){}\n"
+                + "/**\n"
                 + " * @constructor\n"
                 + " * @struct\n"
-                + " */\n"
-                + "function Foo() { this.x = 123; }")
+                + " * @implements {Foo}\n"
+                + " */"
+                + "function Bar(){ this.x = 123; }\n"
+                + "var z = /** @type {Foo} */(new Bar())['x'];")
         .run();
   }
 
   @Test
-  public void testSetprop2() {
-    // Create property on struct outside the constructor
+  public void testGetelemStruct7() {
     newTest()
         .addSource(
             "/**\n"
@@ -8071,14 +7931,15 @@ public final class TypeCheckTest extends TypeCheckTestCase {
                 + " * @struct\n"
                 + " */\n"
                 + "function Foo() {}\n"
-                + "(new Foo()).x = 123;")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+                + "/** @constructor */\n"
+                + "function Bar() {}\n"
+                + "Bar.prototype = new Foo();\n"
+                + "Bar.prototype['someprop'] = 123;\n")
         .run();
   }
 
   @Test
-  public void testSetprop3() {
-    // Create property on struct outside the constructor
+  public void testGetelemStruct_noErrorForSettingWellKnownSymbol() {
     newTest()
         .addSource(
             "/**\n"
@@ -8086,18679 +7947,12951 @@ public final class TypeCheckTest extends TypeCheckTestCase {
                 + " * @struct\n"
                 + " */\n"
                 + "function Foo() {}\n"
-                + "(function() { (new Foo()).x = 123; })();")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+                + "Foo.prototype[Symbol.iterator] = 123;\n")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop4() {
-    // Assign to existing property of struct outside the constructor
+  public void testGetelemStruct_noErrorForGettingWellKnownSymbol() {
     newTest()
         .addSource(
             "/**\n"
                 + " * @constructor\n"
                 + " * @struct\n"
                 + " */\n"
-                + "function Foo() { this.x = 123; }\n"
-                + "(new Foo()).x = \"asdf\";")
+                + "function Foo() {}\n"
+                + "/** @param {!Foo} foo */\n"
+                + "function getIterator(foo) { return foo[Symbol.iterator](); }\n")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop5() {
-    // Create a property on union that includes a struct
+  public void testInOnStruct() {
     newTest()
         .addSource(
             "/**\n"
                 + " * @constructor\n"
                 + " * @struct\n"
-                + " */\n"
+                + " */"
                 + "function Foo() {}\n"
-                + "(true ? new Foo() : {}).x = 123;")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+                + "if ('prop' in (new Foo())) {}")
+        .addDiagnostic("Cannot use the IN operator with structs")
         .run();
   }
 
   @Test
-  public void testSetprop6() {
-    // Create property on struct in another constructor
+  public void testForinOnStruct() {
     newTest()
         .addSource(
             "/**\n"
                 + " * @constructor\n"
                 + " * @struct\n"
-                + " */\n"
+                + " */"
                 + "function Foo() {}\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @param{Foo} f\n"
-                + " */\n"
-                + "function Bar(f) { f.x = 123; }")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+                + "for (var prop in (new Foo())) {}")
+        .addDiagnostic("Cannot use the IN operator with structs")
         .run();
   }
 
   @Test
-  public void testSetprop7() {
-    // Bug b/c we require THIS when creating properties on structs for simplicity
+  public void testIArrayLikeAccess1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {\n"
-                + "  var t = this;\n"
-                + "  t.x = 123;\n"
-                + "}")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+            "/** ",
+            " * @param {!IArrayLike<T>} x",
+            " * @return {T}",
+            " * @template T",
+            "*/",
+            "function f(x) { return x[0]; }",
+            "function g(/** !Array<string> */ x) {",
+            "  var /** null */ y = f(x);",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop8() {
-    // Create property on struct using DEC
+  public void testIArrayLikeAccess2() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "(new Foo()).x--;")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
-        .addDiagnostic("Property x never defined on Foo")
+            "/** ",
+            " * @param {!IArrayLike<T>} x",
+            " * @return {T}",
+            " * @template T",
+            "*/",
+            "function f(x) { return x[0]; }",
+            "function g(/** !IArrayLike<string> */ x) {",
+            "  var /** null */ y = f(x);",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .includeDefaultExterns()
         .run();
   }
 
+  // These test the template types in the built-in Iterator/Iterable/Generator are set up correctly
   @Test
-  public void testSetprop9() {
-    // Create property on struct using ASSIGN_ADD
+  public void testIteratorAccess1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "(new Foo()).x += 123;")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
-        .addDiagnostic("Property x never defined on Foo")
+            "/** ",
+            " * @param {!Iterator<T>} x",
+            " * @return {T}",
+            " * @template T",
+            "*/",
+            "function f(x) { return x[0]; }",
+            "function g(/** !Generator<string> */ x) {",
+            "  var /** null */ y = f(x);",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop10() {
-    // Create property on object literal that is a struct
+  public void testIterableAccess1() {
     newTest()
         .addSource(
-            "/** \n"
-                + " * @constructor \n"
-                + " * @struct \n"
-                + " */ \n"
-                + "function Square(side) { \n"
-                + "  this.side = side; \n"
-                + "} \n"
-                + "Square.prototype = /** @struct */ {\n"
-                + "  area: function() { return this.side * this.side; }\n"
-                + "};\n"
-                + "Square.prototype.id = function(x) { return x; };")
+            "/** ",
+            " * @param {!Iterable<T>} x",
+            " * @return {T}",
+            " * @template T",
+            "*/",
+            "function f(x) { return x[0]; }",
+            "function g(/** !Generator<string> */ x) {",
+            "  var /** null */ y = f(x);",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop11() {
+  public void testIteratorIterableAccess1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor */\n"
-                + "function Bar() {}\n"
-                + "Bar.prototype = new Foo();\n"
-                + "Bar.prototype.someprop = 123;")
+            "/** ",
+            " * @param {!IteratorIterable<T>} x",
+            " * @return {T}",
+            " * @template T",
+            "*/",
+            "function f(x) { return x[0]; }",
+            "function g(/** !Generator<string> */ x) {",
+            "  var /** null */ y = f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : string",
+                "required: null"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop12() {
-    // Create property on a constructor of structs (which isn't itself a struct)
+  public void testArrayAccess1() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "Foo.someprop = 123;")
+        .addSource("var a = []; var b = a['hi'];")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop13() {
-    // Create static property on struct
+  public void testArrayAccess2() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Parent() {}\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Parent}\n"
-                + " */\n"
-                + "function Kid() {}\n"
-                + "Kid.prototype.foo = 123;\n"
-                + "var x = (new Kid()).foo;")
+        .addSource("var a = []; var b = a[[1,2]];")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : Array<?>",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop14() {
-    // Create static property on struct
+  public void testArrayAccess3() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Top() {}\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Top}\n"
-                + " */\n"
-                + "function Mid() {}\n"
-                + "/** blah blah */\n"
-                + "Mid.prototype.foo = function() { return 1; };\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @extends {Mid}\n"
-                + " */\n"
-                + "function Bottom() {}\n"
-                + "/** @override */\n"
-                + "Bottom.prototype.foo = function() { return 3; };")
+            "var bar = [];" + "/** @return {void} */function baz(){};" + "var foo = bar[baz()];")
+        .addDiagnostic("restricted index type\n" + "found   : undefined\n" + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSetprop15() {
-    // Create static property on struct
+  public void testArrayAccess4() {
     newTest()
-        .addSource(
-            "/** @interface */\n"
-                + "function Peelable() {};\n"
-                + "/** @return {undefined} */\n"
-                + "Peelable.prototype.peel;\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Fruit() {};\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Fruit}\n"
-                + " * @implements {Peelable}\n"
-                + " */\n"
-                + "function Banana() { };\n"
-                + "function f() {};\n"
-                + "/** @override */\n"
-                + "Banana.prototype.peel = f;")
+        .addSource("/**@return {!Array}*/function foo(){};var bar = foo()[foo()];")
+        .addDiagnostic("restricted index type\n" + "found   : Array\n" + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testGetpropDict1() {
+  public void testArrayAccess6() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1(){ this['prop'] = 123; }"
-                + "/** @param{Dict1} x */"
-                + "function takesDict(x) { return x.prop; }")
-        .addDiagnostic("Cannot do '.' access on a dict")
+        .addSource("var bar = null[1];")
+        .addDiagnostic(
+            "only arrays or objects can be accessed\n" + "found   : null\n" + "required: Object")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testGetpropDict2() {
+  public void testArrayAccess7() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1(){ this['prop'] = 123; }"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Dict1}\n"
-                + " */"
-                + "function Dict1kid(){ this['prop'] = 123; }"
-                + "/** @param{Dict1kid} x */"
-                + "function takesDict(x) { return x.prop; }")
-        .addDiagnostic("Cannot do '.' access on a dict")
+        .addSource("var bar = void 0; bar[0];")
+        .addDiagnostic(
+            "only arrays or objects can be accessed\n"
+                + "found   : undefined\n"
+                + "required: Object")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testGetpropDict3() {
+  public void testArrayAccess8() {
+    // Verifies that we don't emit two warnings, because
+    // the var has been dereferenced after the first one.
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1() { this['prop'] = 123; }"
-                + "/** @constructor */"
-                + "function NonDict() { this.prop = 321; }"
-                + "/** @param{(NonDict|Dict1)} x */"
-                + "function takesDict(x) { return x.prop; }")
-        .addDiagnostic("Cannot do '.' access on a dict")
+        .addSource("var bar = void 0; bar[0]; bar[1];")
+        .addDiagnostic(
+            "only arrays or objects can be accessed\n"
+                + "found   : undefined\n"
+                + "required: Object")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testGetpropDict4() {
+  public void testArrayAccess9() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1() { this['prop'] = 123; }"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1() { this.prop = 123; }"
-                + "/** @param{(Struct1|Dict1)} x */"
-                + "function takesNothing(x) { return x.prop; }")
-        .addDiagnostic("Cannot do '.' access on a dict")
+        .addSource("/** @return {?Array} */ function f() { return []; }" + "f()[{}]")
+        .addDiagnostic("restricted index type\n" + "found   : {}\n" + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testGetpropDict5() {
+  public void testPropAccess() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1(){ this.prop = 123; }")
-        .addDiagnostic("Cannot do '.' access on a dict")
+            "/** @param {*} x */var f = function(x) {\n"
+                + "var o = String(x);\n"
+                + "if (typeof o['a'] != 'undefined') { return o['a']; }\n"
+                + "return null;\n"
+                + "};")
         .run();
   }
 
   @Test
-  public void testGetpropDict6() {
+  public void testPropAccess2() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "function Bar() {}\n"
-                + "Bar.prototype = new Foo();\n"
-                + "Bar.prototype.someprop = 123;\n")
+        .addSource("var bar = void 0; bar.baz;")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testGetpropDict7() {
+  public void testPropAccess3() {
+    // Verifies that we don't emit two warnings, because
+    // the var has been dereferenced after the first one.
     newTest()
-        .addSource("(/** @dict */ {'x': 123}).x = 321;")
-        .addDiagnostic("Cannot do '.' access on a dict")
+        .addSource("var bar = void 0; bar.baz; bar.bax;")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testGetelemStruct1() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1(){ this.prop = 123; }"
-                + "/** @param{Struct1} x */"
-                + "function takesStruct(x) {"
-                + "  var z = x;"
-                + "  return z['prop'];"
-                + "}")
-        .addDiagnostic("Cannot do '[]' access on a struct")
-        .run();
+  public void testPropAccess4() {
+    newTest().addSource("/** @param {*} x */ function f(x) { return x['hi']; }").run();
   }
 
   @Test
-  public void testGetelemStruct2() {
+  public void testSwitchCase1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1(){ this.prop = 123; }"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Struct1}"
-                + " */"
-                + "function Struct1kid(){ this.prop = 123; }"
-                + "/** @param{Struct1kid} x */"
-                + "function takesStruct2(x) { return x['prop']; }")
-        .addDiagnostic("Cannot do '[]' access on a struct")
+            "/**@type {number}*/var a;" + "/**@type {string}*/var b;" + "switch(a){case b:;}")
+        .addDiagnostic(
+            "case expression doesn't match switch\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testGetelemStruct3() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1(){ this.prop = 123; }"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Struct1}\n"
-                + " */"
-                + "function Struct1kid(){ this.prop = 123; }"
-                + "var x = (new Struct1kid())['prop'];")
-        .addDiagnostic("Cannot do '[]' access on a struct")
-        .run();
+  public void testSwitchCase2() {
+    newTest().addSource("var a = null; switch (typeof a) { case 'foo': }").run();
   }
 
   @Test
-  public void testGetelemStruct4() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1() { this.prop = 123; }"
-                + "/** @constructor */"
-                + "function NonStruct() { this.prop = 321; }"
-                + "/** @param{(NonStruct|Struct1)} x */"
-                + "function takesStruct(x) { return x['prop']; }")
-        .addDiagnostic("Cannot do '[]' access on a struct")
-        .run();
+  public void testVar1() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("/** @type {(string|null)} */var a = null");
+
+    assertTypeEquals(
+        createUnionType(getNativeStringType(), getNativeNullType()), p.scope.getVar("a").getType());
   }
 
   @Test
-  public void testGetelemStruct5() {
+  public void testVar2() {
+    newTest().addSource("/** @type {Function} */ var a = function(){}").run();
+  }
+
+  @Test
+  public void testVar3() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3;");
+
+    assertTypeEquals(getNativeNumberType(), p.scope.getVar("a").getType());
+  }
+
+  @Test
+  public void testVar4() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3; a = 'string';");
+
+    assertTypeEquals(
+        createUnionType(getNativeStringType(), getNativeNumberType()),
+        p.scope.getVar("a").getType());
+  }
+
+  @Test
+  public void testVar5() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Struct1() { this.prop = 123; }"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " */"
-                + "function Dict1() { this['prop'] = 123; }"
-                + "/** @param{(Struct1|Dict1)} x */"
-                + "function takesNothing(x) { return x['prop']; }")
-        .addDiagnostic("Cannot do '[]' access on a struct")
+            "var goog = {};"
+                + "/** @type {string} */goog.foo = 'hello';"
+                + "/** @type {number} */var a = goog.foo;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testGetelemStruct6() {
-    // By casting Bar to Foo, the illegal bracket access is not detected
+  public void testVar6() {
     newTest()
         .addSource(
-            "/** @interface */ function Foo(){}\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @implements {Foo}\n"
-                + " */"
-                + "function Bar(){ this.x = 123; }\n"
-                + "var z = /** @type {Foo} */(new Bar())['x'];")
+            "function f() {"
+                + "  return function() {"
+                + "    /** @type {!Date} */"
+                + "    var a = 7;"
+                + "  };"
+                + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Date")
         .run();
   }
 
   @Test
-  public void testGetelemStruct7() {
+  public void testVar7() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor */\n"
-                + "function Bar() {}\n"
-                + "Bar.prototype = new Foo();\n"
-                + "Bar.prototype['someprop'] = 123;\n")
+        .addSource("/** @type {number} */var a, b;")
+        .addDiagnostic("declaration of multiple variables with shared type information")
         .run();
   }
 
   @Test
-  public void testGetelemStruct_noErrorForSettingWellKnownSymbol() {
+  public void testVar8() {
+    newTest().addSource("var a, b;").run();
+  }
+
+  @Test
+  public void testVar9() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "Foo.prototype[Symbol.iterator] = 123;\n")
-        .includeDefaultExterns()
+        .addSource("/** @enum */var a;")
+        .addDiagnostic("enum initializer must be an object literal or an enum")
         .run();
   }
 
   @Test
-  public void testGetelemStruct_noErrorForGettingWellKnownSymbol() {
+  public void testVar10() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + "/** @param {!Foo} foo */\n"
-                + "function getIterator(foo) { return foo[Symbol.iterator](); }\n")
-        .includeDefaultExterns()
+        .addSource("/** @type {!Number} */var foo = 'abc';")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Number")
         .run();
   }
 
   @Test
-  public void testInOnStruct() {
+  public void testVar11() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Foo() {}\n"
-                + "if ('prop' in (new Foo())) {}")
-        .addDiagnostic("Cannot use the IN operator with structs")
+        .addSource("var /** @type {!Date} */foo = 'abc';")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Date")
         .run();
   }
 
   @Test
-  public void testForinOnStruct() {
+  public void testVar12() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */"
-                + "function Foo() {}\n"
-                + "for (var prop in (new Foo())) {}")
-        .addDiagnostic("Cannot use the IN operator with structs")
+        .addSource("var /** @type {!Date} */foo = 'abc', " + "/** @type {!RegExp} */bar = 5;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Date")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: RegExp")
         .run();
   }
 
   @Test
-  public void testIArrayLikeAccess1() {
-    newTest()
-        .addSource(
-            "/** ",
-            " * @param {!IArrayLike<T>} x",
-            " * @return {T}",
-            " * @template T",
-            "*/",
-            "function f(x) { return x[0]; }",
-            "function g(/** !Array<string> */ x) {",
-            "  var /** null */ y = f(x);",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
-        .includeDefaultExterns()
-        .run();
+  public void testVar13() {
+    // this caused an NPE
+    newTest().addSource("var /** @type {number} */a,a;").run();
   }
 
   @Test
-  public void testIArrayLikeAccess2() {
+  public void testVar14() {
     newTest()
-        .addSource(
-            "/** ",
-            " * @param {!IArrayLike<T>} x",
-            " * @return {T}",
-            " * @template T",
-            "*/",
-            "function f(x) { return x[0]; }",
-            "function g(/** !IArrayLike<string> */ x) {",
-            "  var /** null */ y = f(x);",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
-        .includeDefaultExterns()
+        .addSource("/** @return {number} */ function f() { var x; return x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : undefined\n" + "required: number")
         .run();
   }
 
-  // These test the template types in the built-in Iterator/Iterable/Generator are set up correctly
   @Test
-  public void testIteratorAccess1() {
+  public void testVar15() {
     newTest()
-        .addSource(
-            "/** ",
-            " * @param {!Iterator<T>} x",
-            " * @return {T}",
-            " * @template T",
-            "*/",
-            "function f(x) { return x[0]; }",
-            "function g(/** !Generator<string> */ x) {",
-            "  var /** null */ y = f(x);",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
-        .includeDefaultExterns()
+        .addSource("/** @return {number} */" + "function f() { var x = x || {}; return x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : {}\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testIterableAccess1() {
+  public void testVar15NullishCoalesce() {
     newTest()
         .addSource(
-            "/** ",
-            " * @param {!Iterable<T>} x",
-            " * @return {T}",
-            " * @template T",
-            "*/",
-            "function f(x) { return x[0]; }",
-            "function g(/** !Generator<string> */ x) {",
-            "  var /** null */ y = f(x);",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
-        .includeDefaultExterns()
+            "/** @return {number} */", //
+            "function f() { var x = x ?? {}; return x; }")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : {}",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testIteratorIterableAccess1() {
+  public void testAssign1() {
     newTest()
-        .addSource(
-            "/** ",
-            " * @param {!IteratorIterable<T>} x",
-            " * @return {T}",
-            " * @template T",
-            "*/",
-            "function f(x) { return x[0]; }",
-            "function g(/** !Generator<string> */ x) {",
-            "  var /** null */ y = f(x);",
-            "}")
+        .addSource("var goog = {};" + "/** @type {number} */goog.foo = 'hello';")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : string",
-                "required: null"))
-        .includeDefaultExterns()
+            "assignment to property foo of goog\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testArrayAccess1() {
+  public void testAssign2() {
     newTest()
-        .addSource("var a = []; var b = a['hi'];")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
-        .includeDefaultExterns()
+        .addSource("var goog = {};" + "/** @type {number}  */goog.foo = 3;" + "goog.foo = 'hello';")
+        .addDiagnostic(
+            "assignment to property foo of goog\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testArrayAccess2() {
+  public void testAssign3() {
     newTest()
-        .addSource("var a = []; var b = a[[1,2]];")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : Array<?>",
-                "required: number"))
-        .includeDefaultExterns()
+        .addSource("var goog = {};" + "/** @type {number}  */goog.foo = 3;" + "goog.foo = 4;")
         .run();
   }
 
   @Test
-  public void testArrayAccess3() {
+  public void testAssign4() {
+    newTest().addSource("var goog = {};" + "goog.foo = 3;" + "goog.foo = 'hello';").run();
+  }
+
+  @Test
+  public void testAssignInference() {
     newTest()
         .addSource(
-            "var bar = [];" + "/** @return {void} */function baz(){};" + "var foo = bar[baz()];")
-        .addDiagnostic("restricted index type\n" + "found   : undefined\n" + "required: number")
-        .includeDefaultExterns()
+            "/**"
+                + " * @param {Array} x"
+                + " * @return {number}"
+                + " */"
+                + "function f(x) {"
+                + "  var y = null;"
+                + "  y = x[0];"
+                + "  if (y == null) { return 4; } else { return 6; }"
+                + "}")
         .run();
   }
 
   @Test
-  public void testArrayAccess4() {
+  public void testOr1() {
     newTest()
-        .addSource("/**@return {!Array}*/function foo(){};var bar = foo()[foo()];")
-        .addDiagnostic("restricted index type\n" + "found   : Array\n" + "required: number")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @type {number}  */var a;" + "/** @type {number}  */var b;" + "a + b || undefined;")
         .run();
   }
 
   @Test
-  public void testArrayAccess6() {
+  public void testNullishCoalesceNumber() {
     newTest()
-        .addSource("var bar = null[1];")
-        .addDiagnostic(
-            "only arrays or objects can be accessed\n" + "found   : null\n" + "required: Object")
-        .includeDefaultExterns()
+        .addSource("/** @type {number}  */var a; /** @type {number}  */var b; a + b ?? undefined;")
         .run();
   }
 
   @Test
-  public void testArrayAccess7() {
+  public void testOr2() {
     newTest()
-        .addSource("var bar = void 0; bar[0];")
+        .addSource(
+            "/** @type {number}  */var a;"
+                + "/** @type {number}  */var b;"
+                + "/** @type {number}  */var c = a + b || undefined;")
         .addDiagnostic(
-            "only arrays or objects can be accessed\n"
-                + "found   : undefined\n"
-                + "required: Object")
-        .includeDefaultExterns()
+            "initializing variable\n" + "found   : (number|undefined)\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testArrayAccess8() {
-    // Verifies that we don't emit two warnings, because
-    // the var has been dereferenced after the first one.
+  public void testNullishCoalesceNumberVar() {
+    // Making sure that ?? returns LHS as long as it is not null/undefined
+    // 0 is falsy but not null/undefined so c should always be a
     newTest()
-        .addSource("var bar = void 0; bar[0]; bar[1];")
-        .addDiagnostic(
-            "only arrays or objects can be accessed\n"
-                + "found   : undefined\n"
-                + "required: Object")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @type {number}  */var a;", //
+            "/** @type {number}  */var c = a ?? undefined;")
         .run();
   }
 
   @Test
-  public void testArrayAccess9() {
+  public void testOr3() {
     newTest()
-        .addSource("/** @return {?Array} */ function f() { return []; }" + "f()[{}]")
-        .addDiagnostic("restricted index type\n" + "found   : {}\n" + "required: number")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @type {(number|undefined)} */var a;" + "/** @type {number}  */var c = a || 3;")
         .run();
   }
 
   @Test
-  public void testPropAccess() {
+  public void testNullishCoalesceNumberUndefined() {
     newTest()
-        .addSource(
-            "/** @param {*} x */var f = function(x) {\n"
-                + "var o = String(x);\n"
-                + "if (typeof o['a'] != 'undefined') { return o['a']; }\n"
-                + "return null;\n"
-                + "};")
+        .addSource("/** @type {(number|undefined)} */var a; /** @type {number}  */var c = a ?? 3;")
         .run();
   }
 
+  /**
+   * Test that type inference continues with the right side, when no short-circuiting is possible.
+   * See bugid 1205387 for more details.
+   */
   @Test
-  public void testPropAccess2() {
+  public void testOr4() {
     newTest()
-        .addSource("var bar = void 0; bar.baz;")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+        .addSource("/**@type {number} */var x;x=null || \"a\";")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
         .run();
   }
 
+  /** @see #testOr4() */
   @Test
-  public void testPropAccess3() {
-    // Verifies that we don't emit two warnings, because
-    // the var has been dereferenced after the first one.
+  public void testOr5() {
     newTest()
-        .addSource("var bar = void 0; bar.baz; bar.bax;")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+        .addSource("/**@type {number} */var x;x=undefined || \"a\";")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testPropAccess4() {
-    newTest().addSource("/** @param {*} x */ function f(x) { return x['hi']; }").run();
+  public void testNullishCoalesceAssignment2() {
+    newTest()
+        .addSource("/**@type {number} */var x;x=undefined ?? \"a\";")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : string",
+                "required: number"))
+        .run();
   }
 
   @Test
-  public void testSwitchCase1() {
+  public void testOr6() {
     newTest()
         .addSource(
-            "/**@type {number}*/var a;" + "/**@type {string}*/var b;" + "switch(a){case b:;}")
+            "/** @param {!Array=} opt_x */",
+            "function removeDuplicates(opt_x) {",
+            "  var x = opt_x || [];",
+            "  var /** undefined */ y = x;",
+            "}")
         .addDiagnostic(
-            "case expression doesn't match switch\n" + "found   : string\n" + "required: number")
+            lines(
+                "initializing variable", //
+                "found   : Array",
+                "required: undefined"))
         .run();
   }
 
   @Test
-  public void testSwitchCase2() {
-    newTest().addSource("var a = null; switch (typeof a) { case 'foo': }").run();
+  public void testNullishCoaleceAssignment3() {
+    newTest()
+        .addSource(
+            "/** @param {!Array=} opt_x */",
+            "function removeDuplicates(opt_x) {",
+            "  var x = opt_x ?? [];",
+            "  var /** undefined */ y = x;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : Array",
+                "required: undefined"))
+        .run();
   }
 
   @Test
-  public void testVar1() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("/** @type {(string|null)} */var a = null");
-
-    assertTypeEquals(
-        createUnionType(getNativeStringType(), getNativeNullType()), p.scope.getVar("a").getType());
+  public void testAnd1() {
+    newTest()
+        .addSource(
+            "/** @type {number}  */var a;" + "/** @type {number}  */var b;" + "a + b && undefined;")
+        .run();
   }
 
   @Test
-  public void testVar2() {
-    newTest().addSource("/** @type {Function} */ var a = function(){}").run();
-  }
-
-  @Test
-  public void testVar3() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3;");
-
-    assertTypeEquals(getNativeNumberType(), p.scope.getVar("a").getType());
-  }
-
-  @Test
-  public void testVar4() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3; a = 'string';");
-
-    assertTypeEquals(
-        createUnionType(getNativeStringType(), getNativeNumberType()),
-        p.scope.getVar("a").getType());
-  }
-
-  @Test
-  public void testVar5() {
+  public void testAnd2() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @type {string} */goog.foo = 'hello';"
-                + "/** @type {number} */var a = goog.foo;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+            "/** @type {number}  */var a;"
+                + "/** @type {number}  */var b;"
+                + "/** @type {number}  */var c = a + b && undefined;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (number|undefined)\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testVar6() {
+  public void testAnd3() {
     newTest()
         .addSource(
-            "function f() {"
-                + "  return function() {"
-                + "    /** @type {!Date} */"
-                + "    var a = 7;"
-                + "  };"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Date")
+            "/** @type {(!Array|undefined)} */var a;"
+                + "/** @type {number}  */var c = a && undefined;")
+        .addDiagnostic("initializing variable\n" + "found   : undefined\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testVar7() {
+  public void testAnd4() {
     newTest()
-        .addSource("/** @type {number} */var a, b;")
-        .addDiagnostic("declaration of multiple variables with shared type information")
+        .addSource(
+            "/** @param {number} x */function f(x){};\n"
+                + "/** @type {null}  */var x; /** @type {number?} */var y;\n"
+                + "if (x && y) { f(y) }")
         .run();
   }
 
   @Test
-  public void testVar8() {
-    newTest().addSource("var a, b;").run();
-  }
-
-  @Test
-  public void testVar9() {
+  public void testAnd5() {
     newTest()
-        .addSource("/** @enum */var a;")
-        .addDiagnostic("enum initializer must be an object literal or an enum")
+        .addSource(
+            "/** @param {number} x\n@param {string} y*/function f(x,y){};\n"
+                + "/** @type {number?} */var x; /** @type {string?} */var y;\n"
+                + "if (x && y) { f(x, y) }")
         .run();
   }
 
   @Test
-  public void testVar10() {
+  public void testAnd6() {
     newTest()
-        .addSource("/** @type {!Number} */var foo = 'abc';")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Number")
+        .addSource(
+            "/** @param {number} x */function f(x){};\n"
+                + "/** @type {number|undefined} */var x;\n"
+                + "if (x && f(x)) { f(x) }")
         .run();
   }
 
   @Test
-  public void testVar11() {
-    newTest()
-        .addSource("var /** @type {!Date} */foo = 'abc';")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Date")
-        .run();
+  public void testAnd7() {
+    // TODO(user): a deterministic warning should be generated for this
+    // case since x && x is always false. The implementation of this requires
+    // a more precise handling of a null value within a variable's type.
+    // Currently, a null value defaults to ? which passes every check.
+    newTest().addSource("/** @type {null} */var x; if (x && x) {}").run();
   }
 
   @Test
-  public void testVar12() {
+  public void testAnd8() {
     newTest()
-        .addSource("var /** @type {!Date} */foo = 'abc', " + "/** @type {!RegExp} */bar = 5;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: Date")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: RegExp")
+        .addSource(
+            "function f(/** (null | number | string) */ x) {\n"
+                + "  (x && (typeof x === 'number')) && takesNum(x);\n"
+                + "}\n"
+                + "function takesNum(/** number */ n) {}")
         .run();
   }
 
   @Test
-  public void testVar13() {
-    // this caused an NPE
-    newTest().addSource("var /** @type {number} */a,a;").run();
+  public void testAnd9() {
+    newTest()
+        .addSource(
+            "function f(/** (number|string|null) */ x) {\n"
+                + "  if (x && typeof x === 'number') {\n"
+                + "    takesNum(x);\n"
+                + "  }\n"
+                + "}\n"
+                + "function takesNum(/** number */ x) {}")
+        .run();
   }
 
   @Test
-  public void testVar14() {
+  public void testAnd10() {
     newTest()
-        .addSource("/** @return {number} */ function f() { var x; return x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : undefined\n" + "required: number")
+        .addSource(
+            "function f(/** (null | number | string) */ x) {\n"
+                + "  (x && (typeof x === 'string')) && takesNum(x);\n"
+                + "}\n"
+                + "function takesNum(/** number */ n) {}")
+        .addDiagnostic(
+            "actual parameter 1 of takesNum does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testVar15() {
-    newTest()
-        .addSource("/** @return {number} */" + "function f() { var x = x || {}; return x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : {}\n" + "required: number")
-        .run();
+  public void testHook() {
+    newTest().addSource("/**@return {void}*/function foo(){ var x=foo()?a:b; }").run();
   }
 
   @Test
-  public void testVar15NullishCoalesce() {
+  public void testHookRestrictsType1() {
     newTest()
         .addSource(
-            "/** @return {number} */", //
-            "function f() { var x = x ?? {}; return x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : {}",
-                "required: number"))
+            "/** @return {(string|null)} */"
+                + "function f() { return null;}"
+                + "/** @type {(string|null)} */ var a = f();"
+                + "/** @type {string} */"
+                + "var b = a ? a : 'default';")
         .run();
   }
 
   @Test
-  public void testAssign1() {
+  public void testHookRestrictsType2() {
     newTest()
-        .addSource("var goog = {};" + "/** @type {number} */goog.foo = 'hello';")
-        .addDiagnostic(
-            "assignment to property foo of goog\n" + "found   : string\n" + "required: number")
+        .addSource(
+            "/** @type {String} */"
+                + "var a = null;"
+                + "/** @type {null} */"
+                + "var b = a ? null : a;")
         .run();
   }
 
   @Test
-  public void testAssign2() {
+  public void testHookRestrictsType3() {
     newTest()
-        .addSource("var goog = {};" + "/** @type {number}  */goog.foo = 3;" + "goog.foo = 'hello';")
-        .addDiagnostic(
-            "assignment to property foo of goog\n" + "found   : string\n" + "required: number")
+        .addSource(
+            "/** @type {String} */" + "var a;" + "/** @type {null} */" + "var b = (!a) ? a : null;")
         .run();
   }
 
   @Test
-  public void testAssign3() {
+  public void testHookRestrictsType4() {
     newTest()
-        .addSource("var goog = {};" + "/** @type {number}  */goog.foo = 3;" + "goog.foo = 4;")
+        .addSource(
+            "/** @type {(boolean|undefined)} */"
+                + "var a;"
+                + "/** @type {boolean} */"
+                + "var b = a != null ? a : true;")
         .run();
   }
 
   @Test
-  public void testAssign4() {
-    newTest().addSource("var goog = {};" + "goog.foo = 3;" + "goog.foo = 'hello';").run();
-  }
-
-  @Test
-  public void testAssignInference() {
+  public void testHookRestrictsType5() {
     newTest()
         .addSource(
-            "/**"
-                + " * @param {Array} x"
-                + " * @return {number}"
-                + " */"
-                + "function f(x) {"
-                + "  var y = null;"
-                + "  y = x[0];"
-                + "  if (y == null) { return 4; } else { return 6; }"
-                + "}")
+            "/** @type {(boolean|undefined)} */"
+                + "var a;"
+                + "/** @type {(undefined)} */"
+                + "var b = a == null ? a : undefined;")
         .run();
   }
 
   @Test
-  public void testOr1() {
+  public void testHookRestrictsType6() {
     newTest()
         .addSource(
-            "/** @type {number}  */var a;" + "/** @type {number}  */var b;" + "a + b || undefined;")
+            "/** @type {(number|null|undefined)} */"
+                + "var a;"
+                + "/** @type {number} */"
+                + "var b = a == null ? 5 : a;")
         .run();
   }
 
   @Test
-  public void testNullishCoalesceNumber() {
+  public void testHookRestrictsType7() {
     newTest()
-        .addSource("/** @type {number}  */var a; /** @type {number}  */var b; a + b ?? undefined;")
+        .addSource(
+            "/** @type {(number|null|undefined)} */"
+                + "var a;"
+                + "/** @type {number} */"
+                + "var b = a == undefined ? 5 : a;")
         .run();
   }
 
   @Test
-  public void testOr2() {
+  public void testWhileRestrictsType1() {
     newTest()
         .addSource(
-            "/** @type {number}  */var a;"
-                + "/** @type {number}  */var b;"
-                + "/** @type {number}  */var c = a + b || undefined;")
+            "/** @param {null} x */ function g(x) {}"
+                + "/** @param {number?} x */\n"
+                + "function f(x) {\n"
+                + "while (x) {\n"
+                + "if (g(x)) { x = 1; }\n"
+                + "x = x-1;\n}\n}")
         .addDiagnostic(
-            "initializing variable\n" + "found   : (number|undefined)\n" + "required: number")
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: null")
         .run();
   }
 
   @Test
-  public void testNullishCoalesceNumberVar() {
-    // Making sure that ?? returns LHS as long as it is not null/undefined
-    // 0 is falsy but not null/undefined so c should always be a
+  public void testWhileRestrictsType2() {
     newTest()
         .addSource(
-            "/** @type {number}  */var a;", //
-            "/** @type {number}  */var c = a ?? undefined;")
+            "/** @param {number?} x\n@return {number}*/\n"
+                + "function f(x) {\n/** @type {number} */var y = 0;"
+                + "while (x) {\n"
+                + "y = x;\n"
+                + "x = x-1;\n}\n"
+                + "return y;}")
         .run();
   }
 
   @Test
-  public void testOr3() {
+  public void testHigherOrderFunctions1() {
     newTest()
-        .addSource(
-            "/** @type {(number|undefined)} */var a;" + "/** @type {number}  */var c = a || 3;")
+        .addSource("/** @type {function(number)} */var f;" + "f(true);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testNullishCoalesceNumberUndefined() {
+  public void testHigherOrderFunctions2() {
     newTest()
-        .addSource("/** @type {(number|undefined)} */var a; /** @type {number}  */var c = a ?? 3;")
+        .addSource("/** @type {function():!Date} */var f;" + "/** @type {boolean} */var a = f();")
+        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: boolean")
         .run();
   }
 
-  /**
-   * Test that type inference continues with the right side, when no short-circuiting is possible.
-   * See bugid 1205387 for more details.
-   */
   @Test
-  public void testOr4() {
+  public void testHigherOrderFunctions3() {
     newTest()
-        .addSource("/**@type {number} */var x;x=null || \"a\";")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
+        .addSource("/** @type {function(this:Array):Date} */var f; new f")
+        .addDiagnostic("cannot instantiate non-constructor")
         .run();
   }
 
-  /** @see #testOr4() */
   @Test
-  public void testOr5() {
+  public void testHigherOrderFunctions4() {
     newTest()
-        .addSource("/**@type {number} */var x;x=undefined || \"a\";")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
+        .addSource("/** @type {function(this:Array, ...number):Date} */var f; new f")
+        .addDiagnostic("cannot instantiate non-constructor")
         .run();
   }
 
   @Test
-  public void testNullishCoalesceAssignment2() {
-    newTest()
-        .addSource("/**@type {number} */var x;x=undefined ?? \"a\";")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : string",
-                "required: number"))
-        .run();
-  }
-
-  @Test
-  public void testOr6() {
+  public void testHigherOrderFunctions5() {
     newTest()
         .addSource(
-            "/** @param {!Array=} opt_x */",
-            "function removeDuplicates(opt_x) {",
-            "  var x = opt_x || [];",
-            "  var /** undefined */ y = x;",
-            "}")
+            "/** @param {number} x */ function g(x) {}",
+            "/** @type {function(new:Array, ...number):Date} */ var f;",
+            "g(new f());")
         .addDiagnostic(
             lines(
-                "initializing variable", //
+                "actual parameter 1 of g does not match formal parameter",
                 "found   : Array",
-                "required: undefined"))
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testNullishCoaleceAssignment3() {
+  public void testConstructorAlias1() {
     newTest()
         .addSource(
-            "/** @param {!Array=} opt_x */",
-            "function removeDuplicates(opt_x) {",
-            "  var x = opt_x ?? [];",
-            "  var /** undefined */ y = x;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : Array",
-                "required: undefined"))
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @type {number} */ Foo.prototype.bar = 3;"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @return {string} */ function foo() { "
+                + "  return (new FooAlias()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAnd1() {
+  public void testConstructorAlias2() {
     newTest()
         .addSource(
-            "/** @type {number}  */var a;" + "/** @type {number}  */var b;" + "a + b && undefined;")
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @type {number} */ FooAlias.prototype.bar = 3;"
+                + "/** @return {string} */ function foo() { "
+                + "  return (new Foo()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAnd2() {
+  public void testConstructorAlias3() {
     newTest()
         .addSource(
-            "/** @type {number}  */var a;"
-                + "/** @type {number}  */var b;"
-                + "/** @type {number}  */var c = a + b && undefined;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (number|undefined)\n" + "required: number")
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @type {number} */ Foo.prototype.bar = 3;"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @return {string} */ function foo() { "
+                + "  return (new FooAlias()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAnd3() {
+  public void testConstructorAlias4() {
     newTest()
         .addSource(
-            "/** @type {(!Array|undefined)} */var a;"
-                + "/** @type {number}  */var c = a && undefined;")
-        .addDiagnostic("initializing variable\n" + "found   : undefined\n" + "required: number")
+            "/** @constructor */ var Foo = function() {};"
+                + "var FooAlias = Foo;"
+                + "/** @type {number} */ FooAlias.prototype.bar = 3;"
+                + "/** @return {string} */ function foo() { "
+                + "  return (new Foo()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAnd4() {
+  public void testConstructorAlias5() {
     newTest()
         .addSource(
-            "/** @param {number} x */function f(x){};\n"
-                + "/** @type {null}  */var x; /** @type {number?} */var y;\n"
-                + "if (x && y) { f(y) }")
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @return {FooAlias} */ function foo() { "
+                + "  return new Foo(); }")
         .run();
   }
 
   @Test
-  public void testAnd5() {
+  public void testConstructorAlias6() {
     newTest()
         .addSource(
-            "/** @param {number} x\n@param {string} y*/function f(x,y){};\n"
-                + "/** @type {number?} */var x; /** @type {string?} */var y;\n"
-                + "if (x && y) { f(x, y) }")
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @return {Foo} */ function foo() { "
+                + "  return new FooAlias(); }")
         .run();
   }
 
   @Test
-  public void testAnd6() {
+  public void testConstructorAlias7() {
     newTest()
         .addSource(
-            "/** @param {number} x */function f(x){};\n"
-                + "/** @type {number|undefined} */var x;\n"
-                + "if (x && f(x)) { f(x) }")
+            "var goog = {};"
+                + "/** @constructor */ goog.Foo = function() {};"
+                + "/** @constructor */ goog.FooAlias = goog.Foo;"
+                + "/** @return {number} */ function foo() { "
+                + "  return new goog.FooAlias(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testAnd7() {
-    // TODO(user): a deterministic warning should be generated for this
-    // case since x && x is always false. The implementation of this requires
-    // a more precise handling of a null value within a variable's type.
-    // Currently, a null value defaults to ? which passes every check.
-    newTest().addSource("/** @type {null} */var x; if (x && x) {}").run();
-  }
-
-  @Test
-  public void testAnd8() {
+  public void testConstructorAlias8() {
     newTest()
         .addSource(
-            "function f(/** (null | number | string) */ x) {\n"
-                + "  (x && (typeof x === 'number')) && takesNum(x);\n"
-                + "}\n"
-                + "function takesNum(/** number */ n) {}")
+            "var goog = {};"
+                + "/**\n * @param {number} x \n * @constructor */ "
+                + "goog.Foo = function(x) {};"
+                + "/**\n * @param {number} x \n * @constructor */ "
+                + "goog.FooAlias = goog.Foo;"
+                + "/** @return {number} */ function foo() { "
+                + "  return new goog.FooAlias(1); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testAnd9() {
+  public void testConstructorAlias9() {
     newTest()
         .addSource(
-            "function f(/** (number|string|null) */ x) {\n"
-                + "  if (x && typeof x === 'number') {\n"
-                + "    takesNum(x);\n"
-                + "  }\n"
-                + "}\n"
-                + "function takesNum(/** number */ x) {}")
+            "var goog = {};"
+                + "/**\n * @param {number} x \n * @constructor */ "
+                + "goog.Foo = function(x) {};"
+                + "/** @constructor */ goog.FooAlias = goog.Foo;"
+                + "/** @return {number} */ function foo() { "
+                + "  return new goog.FooAlias(1); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testAnd10() {
+  public void testConstructorAlias10() {
     newTest()
         .addSource(
-            "function f(/** (null | number | string) */ x) {\n"
-                + "  (x && (typeof x === 'string')) && takesNum(x);\n"
-                + "}\n"
-                + "function takesNum(/** number */ n) {}")
-        .addDiagnostic(
-            "actual parameter 1 of takesNum does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            "/**\n * @param {number} x \n * @constructor */ "
+                + "var Foo = function(x) {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "/** @return {number} */ function foo() { "
+                + "  return new FooAlias(1); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : Foo\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testHook() {
-    newTest().addSource("/**@return {void}*/function foo(){ var x=foo()?a:b; }").run();
-  }
-
-  @Test
-  public void testHookRestrictsType1() {
+  public void testConstructorAlias11() {
     newTest()
         .addSource(
-            "/** @return {(string|null)} */"
-                + "function f() { return null;}"
-                + "/** @type {(string|null)} */ var a = f();"
-                + "/** @type {string} */"
-                + "var b = a ? a : 'default';")
+            "/**\n * @param {number} x \n * @constructor */ "
+                + "var Foo = function(x) {};"
+                + "/** @const */ var FooAlias = Foo;"
+                + "/** @const */ var FooAlias2 = FooAlias;"
+                + "/** @return {FooAlias2} */ function foo() { "
+                + "  return 1; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: (Foo|null)")
         .run();
   }
 
   @Test
-  public void testHookRestrictsType2() {
+  public void testConstructorAliasWithBadAnnotation1() {
     newTest()
         .addSource(
-            "/** @type {String} */"
-                + "var a = null;"
-                + "/** @type {null} */"
-                + "var b = a ? null : a;")
+            "/** @constructor */ function Foo() {}", //
+            "/** @record */ var Bar = Foo;")
+        .addDiagnostic("Annotation @record on Bar incompatible with aliased type.")
         .run();
   }
 
   @Test
-  public void testHookRestrictsType3() {
+  public void testConstructorAliasWithBadAnnotation2() {
     newTest()
         .addSource(
-            "/** @type {String} */" + "var a;" + "/** @type {null} */" + "var b = (!a) ? a : null;")
+            "/** @constructor */ function Foo() {}", //
+            "/** @interface */ var Bar = Foo;")
+        .addDiagnostic("Annotation @interface on Bar incompatible with aliased type.")
         .run();
   }
 
   @Test
-  public void testHookRestrictsType4() {
+  public void testConstructorAliasWithBadAnnotation3() {
     newTest()
         .addSource(
-            "/** @type {(boolean|undefined)} */"
-                + "var a;"
-                + "/** @type {boolean} */"
-                + "var b = a != null ? a : true;")
+            "/** @interface */ function Foo() {}", //
+            "/** @record */ var Bar = Foo;")
+        .addDiagnostic("Annotation @record on Bar incompatible with aliased type.")
         .run();
   }
 
   @Test
-  public void testHookRestrictsType5() {
+  public void testConstructorAliasWithBadAnnotation4() {
     newTest()
         .addSource(
-            "/** @type {(boolean|undefined)} */"
-                + "var a;"
-                + "/** @type {(undefined)} */"
-                + "var b = a == null ? a : undefined;")
+            "/** @interface */ function Foo() {}", //
+            "/** @constructor */ var Bar = Foo;")
+        .addDiagnostic("Annotation @constructor on Bar incompatible with aliased type.")
         .run();
   }
 
   @Test
-  public void testHookRestrictsType6() {
+  public void testConstAliasedTypeCastInferredCorrectly1() {
     newTest()
         .addSource(
-            "/** @type {(number|null|undefined)} */"
-                + "var a;"
-                + "/** @type {number} */"
-                + "var b = a == null ? 5 : a;")
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @return {number} */",
+            "Foo.prototype.foo = function() {};",
+            "",
+            "/** @const */ var FooAlias = Foo;",
+            "",
+            "var x = /** @type {!FooAlias} */ ({});",
+            "var /** null */ n = x.foo();")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testHookRestrictsType7() {
+  public void testConstAliasedTypeCastInferredCorrectly2() {
     newTest()
         .addSource(
-            "/** @type {(number|null|undefined)} */"
-                + "var a;"
-                + "/** @type {number} */"
-                + "var b = a == undefined ? 5 : a;")
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @return {number} */",
+            "Foo.prototype.foo = function() {};",
+            "",
+            "var ns = {};",
+            "/** @const */ ns.FooAlias = Foo;",
+            "",
+            "var x = /** @type {!ns.FooAlias} */ ({});",
+            "var /** null */ n = x.foo();")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testWhileRestrictsType1() {
+  public void testConstructorAliasedTypeCastInferredCorrectly() {
     newTest()
         .addSource(
-            "/** @param {null} x */ function g(x) {}"
-                + "/** @param {number?} x */\n"
-                + "function f(x) {\n"
-                + "while (x) {\n"
-                + "if (g(x)) { x = 1; }\n"
-                + "x = x-1;\n}\n}")
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @return {number} */",
+            "Foo.prototype.foo = function() {};",
+            "",
+            "/** @constructor */ var FooAlias = Foo;",
+            "",
+            "var x = /** @type {!FooAlias} */ ({});",
+            "var /** null */ n = x.foo();")
         .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: null")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testWhileRestrictsType2() {
+  public void testAliasedTypedef1() {
     newTest()
         .addSource(
-            "/** @param {number?} x\n@return {number}*/\n"
-                + "function f(x) {\n/** @type {number} */var y = 0;"
-                + "while (x) {\n"
-                + "y = x;\n"
-                + "x = x-1;\n}\n"
-                + "return y;}")
+            "/** @typedef {string} */ var original;",
+            "/** @const */ var alias = original;",
+            "/** @type {alias} */ var x;")
         .run();
   }
 
   @Test
-  public void testHigherOrderFunctions1() {
+  public void testAliasedTypedef2() {
     newTest()
-        .addSource("/** @type {function(number)} */var f;" + "f(true);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @typedef {string} */ var original;",
+            "/** @const */ ns.alias = original;",
+            "/** @type {ns.alias} */ var x;")
         .run();
   }
 
   @Test
-  public void testHigherOrderFunctions2() {
+  public void testAliasedTypedef3() {
     newTest()
-        .addSource("/** @type {function():!Date} */var f;" + "/** @type {boolean} */var a = f();")
-        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: boolean")
+        .addSource(
+            "/** @typedef {string} */ var original;",
+            "/** @const */ var alias = original;",
+            "/** @return {number} */ var f = function(/** alias */ x) { return x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testHigherOrderFunctions3() {
+  public void testAliasedTypedef4() {
     newTest()
-        .addSource("/** @type {function(this:Array):Date} */var f; new f")
-        .addDiagnostic("cannot instantiate non-constructor")
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @typedef {string} */ var original;",
+            "/** @const */ ns.alias = original;",
+            "/** @return {number} */ var f = function(/** ns.alias */ x) { return x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testHigherOrderFunctions4() {
+  public void testAliasedNonTypedef() {
     newTest()
-        .addSource("/** @type {function(this:Array, ...number):Date} */var f; new f")
-        .addDiagnostic("cannot instantiate non-constructor")
+        .addSource(
+            "/** @type {string} */ var notTypeName;",
+            "/** @const */ var alias = notTypeName;",
+            "/** @type {alias} */ var x;")
+        .addDiagnostic("Bad type annotation. Unknown type alias")
         .run();
   }
 
   @Test
-  public void testHigherOrderFunctions5() {
+  public void testConstStringKeyDoesntCrash() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function g(x) {}",
-            "/** @type {function(new:Array, ...number):Date} */ var f;",
-            "g(new f());")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : Array",
-                "required: number"))
+            "/** @constructor */",
+            "function Foo() {}",
+            "var ns = {",
+            "  /** @const */ FooAlias: Foo",
+            "};")
         .run();
   }
 
   @Test
-  public void testConstructorAlias1() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @type {number} */ Foo.prototype.bar = 3;"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @return {string} */ function foo() { "
-                + "  return (new FooAlias()).bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testClosure7() {
+    testClosureTypes(
+        "/** @type {string|null|undefined} */ var a = foo();"
+            + "/** @type {number} */"
+            + "var b = goog.asserts.assert(a);",
+        "initializing variable\n" + "found   : string\n" + "required: number");
   }
 
+  private static final String PRIMITIVE_ASSERT_DEFS =
+      lines(
+          "/**",
+          " * @param {T} p",
+          " * @return {U}",
+          " * @template T",
+          " * @template U :=",
+          "       mapunion(T, (E) => cond(sub(E, union('null', 'undefined')), none(), E)) =:",
+          " * @closurePrimitive {asserts.truthy}",
+          " */",
+          "function assertTruthy(p) { return p; }",
+          "/**",
+          " * @param {*} p",
+          " * @return {string}",
+          " * @closurePrimitive {asserts.matchesReturn}",
+          " */",
+          "function assertString(p) { return /** @type {string} */ (p); }");
+
   @Test
-  public void testConstructorAlias2() {
+  public void testPrimitiveAssertTruthy_removesNullAndUndefinedFromString() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @type {number} */ FooAlias.prototype.bar = 3;"
-                + "/** @return {string} */ function foo() { "
-                + "  return (new Foo()).bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            PRIMITIVE_ASSERT_DEFS
+                + lines(
+                    "function f(/** ?string|undefined */ str) {",
+                    "  assertTruthy(str);",
+                    "  const /** number */ n = str;",
+                    "}"))
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testConstructorAlias3() {
+  public void testPrimitiveAssertString_narrowsAllTypeToString() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @type {number} */ Foo.prototype.bar = 3;"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @return {string} */ function foo() { "
-                + "  return (new FooAlias()).bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            PRIMITIVE_ASSERT_DEFS
+                + lines(
+                    "function f(/** * */ str) {",
+                    "  assertString(str);",
+                    "  const /** number */ n = str;",
+                    "}"))
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testConstructorAlias4() {
+  public void testReturn1() {
     newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "var FooAlias = Foo;"
-                + "/** @type {number} */ FooAlias.prototype.bar = 3;"
-                + "/** @return {string} */ function foo() { "
-                + "  return (new Foo()).bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .addSource("/**@return {void}*/function foo(){ return 3; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
         .run();
   }
 
   @Test
-  public void testConstructorAlias5() {
+  public void testReturn2() {
     newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @return {FooAlias} */ function foo() { "
-                + "  return new Foo(); }")
+        .addSource("/**@return {!Number}*/function foo(){ return; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : undefined\n" + "required: Number")
         .run();
   }
 
   @Test
-  public void testConstructorAlias6() {
+  public void testReturn3() {
     newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @return {Foo} */ function foo() { "
-                + "  return new FooAlias(); }")
+        .addSource("/**@return {!Number}*/function foo(){ return 'abc'; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: Number")
         .run();
   }
 
   @Test
-  public void testConstructorAlias7() {
+  public void testReturn4() {
     newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.Foo = function() {};"
-                + "/** @constructor */ goog.FooAlias = goog.Foo;"
-                + "/** @return {number} */ function foo() { "
-                + "  return new goog.FooAlias(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
+        .addSource("/**@return {!Number}\n*/\n function a(){return new Array();}")
+        .addDiagnostic("inconsistent return type\n" + "found   : Array<?>\n" + "required: Number")
         .run();
   }
 
   @Test
-  public void testConstructorAlias8() {
+  public void testReturn5() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/**\n * @param {number} x \n * @constructor */ "
-                + "goog.Foo = function(x) {};"
-                + "/**\n * @param {number} x \n * @constructor */ "
-                + "goog.FooAlias = goog.Foo;"
-                + "/** @return {number} */ function foo() { "
-                + "  return new goog.FooAlias(1); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
+            "/**", //
+            " * @param {number} n",
+            " * @constructor",
+            " */",
+            "function fn(n){ return }")
         .run();
   }
 
   @Test
-  public void testConstructorAlias9() {
+  public void testReturn6() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/**\n * @param {number} x \n * @constructor */ "
-                + "goog.Foo = function(x) {};"
-                + "/** @constructor */ goog.FooAlias = goog.Foo;"
-                + "/** @return {number} */ function foo() { "
-                + "  return new goog.FooAlias(1); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : goog.Foo\n" + "required: number")
+            "/** @param {number} opt_a\n@return {string} */" + "function a(opt_a) { return opt_a }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|undefined)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testConstructorAlias10() {
+  public void testReturn7() {
     newTest()
         .addSource(
-            "/**\n * @param {number} x \n * @constructor */ "
-                + "var Foo = function(x) {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "/** @return {number} */ function foo() { "
-                + "  return new FooAlias(1); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : Foo\n" + "required: number")
+            "/** @constructor */var A = function() {};\n"
+                + "/** @constructor */var B = function() {};\n"
+                + "/** @return {!B} */A.f = function() { return 1; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: B")
         .run();
   }
 
   @Test
-  public void testConstructorAlias11() {
+  public void testReturn8() {
     newTest()
         .addSource(
-            "/**\n * @param {number} x \n * @constructor */ "
-                + "var Foo = function(x) {};"
-                + "/** @const */ var FooAlias = Foo;"
-                + "/** @const */ var FooAlias2 = FooAlias;"
-                + "/** @return {FooAlias2} */ function foo() { "
-                + "  return 1; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: (Foo|null)")
+            "/** @constructor */var A = function() {};\n"
+                + "/** @constructor */var B = function() {};\n"
+                + "/** @return {!B} */A.prototype.f = function() { return 1; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: B")
         .run();
   }
 
   @Test
-  public void testConstructorAliasWithBadAnnotation1() {
+  public void testInferredReturn1() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "/** @record */ var Bar = Foo;")
-        .addDiagnostic("Annotation @record on Bar incompatible with aliased type.")
+        .addSource("function f() {} /** @param {number} x */ function g(x) {}" + "g(f());")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : undefined\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testConstructorAliasWithBadAnnotation2() {
+  public void testInferredReturn2() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "/** @interface */ var Bar = Foo;")
-        .addDiagnostic("Annotation @interface on Bar incompatible with aliased type.")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() {}; "
+                + "/** @param {number} x */ function g(x) {}"
+                + "g((new Foo()).bar());")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : undefined\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testConstructorAliasWithBadAnnotation3() {
+  public void testInferredReturn3() {
     newTest()
         .addSource(
-            "/** @interface */ function Foo() {}", //
-            "/** @record */ var Bar = Foo;")
-        .addDiagnostic("Annotation @record on Bar incompatible with aliased type.")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() {}; "
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @return {number} \n * @override  */ "
+                + "SubFoo.prototype.bar = function() { return 3; }; ")
+        .addDiagnostic(
+            "mismatch of the bar property type and the type of the property "
+                + "it overrides from superclass Foo\n"
+                + "original: function(this:Foo): undefined\n"
+                + "override: function(this:SubFoo): number")
         .run();
   }
 
   @Test
-  public void testConstructorAliasWithBadAnnotation4() {
+  public void testInferredReturn4() {
+    // By design, this throws a warning. if you want global x to be
+    // defined to some other type of function, then you need to declare it
+    // as a greater type.
     newTest()
         .addSource(
-            "/** @interface */ function Foo() {}", //
-            "/** @constructor */ var Bar = Foo;")
-        .addDiagnostic("Annotation @constructor on Bar incompatible with aliased type.")
+            "var x = function() {};"
+                + "x = /** @type {function(): number} */ (function() { return 3; });")
+        .addDiagnostic(
+            "assignment\n" + "found   : function(): number\n" + "required: function(): undefined")
         .run();
   }
 
   @Test
-  public void testConstAliasedTypeCastInferredCorrectly1() {
+  public void testInferredReturn5() {
+    // If x is local, then the function type is not declared.
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @return {number} */",
-            "Foo.prototype.foo = function() {};",
-            "",
-            "/** @const */ var FooAlias = Foo;",
-            "",
-            "var x = /** @type {!FooAlias} */ ({});",
-            "var /** null */ n = x.foo();")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "/** @return {string} */"
+                + "function f() {"
+                + "  var x = function() {};"
+                + "  x = /** @type {function(): number} */ (function() { return 3; });"
+                + "  return x();"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testConstAliasedTypeCastInferredCorrectly2() {
+  public void testInferredReturn6() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @return {number} */",
-            "Foo.prototype.foo = function() {};",
-            "",
-            "var ns = {};",
-            "/** @const */ ns.FooAlias = Foo;",
-            "",
-            "var x = /** @type {!ns.FooAlias} */ ({});",
-            "var /** null */ n = x.foo();")
+            "/** @return {string} */"
+                + "function f() {"
+                + "  var x = function() {};"
+                + "  if (f()) "
+                + "    x = /** @type {function(): number} */ "
+                + "        (function() { return 3; });"
+                + "  return x();"
+                + "}")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "inconsistent return type\n" + "found   : (number|undefined)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testConstructorAliasedTypeCastInferredCorrectly() {
+  public void testInferredReturn7() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @return {number} */",
-            "Foo.prototype.foo = function() {};",
-            "",
-            "/** @constructor */ var FooAlias = Foo;",
-            "",
-            "var x = /** @type {!FooAlias} */ ({});",
-            "var /** null */ n = x.foo();")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "Foo.prototype.bar = function(x) { return 3; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
         .run();
   }
 
   @Test
-  public void testAliasedTypedef1() {
+  public void testInferredReturn8() {
     newTest()
         .addSource(
-            "/** @typedef {string} */ var original;",
-            "/** @const */ var alias = original;",
-            "/** @type {alias} */ var x;")
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @override @param {number} x */ SubFoo.prototype.bar = "
+                + "    function(x) { return 3; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
         .run();
   }
 
   @Test
-  public void testAliasedTypedef2() {
+  public void testInferredReturn9() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @typedef {string} */ var original;",
-            "/** @const */ ns.alias = original;",
-            "/** @type {ns.alias} */ var x;")
+            "/** @param {function():string} x */",
+            "function f(x) {}",
+            "f(/** asdf */ function() { return 123; });")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testAliasedTypedef3() {
+  public void testInferredParam1() {
     newTest()
         .addSource(
-            "/** @typedef {string} */ var original;",
-            "/** @const */ var alias = original;",
-            "/** @return {number} */ var f = function(/** alias */ x) { return x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @param {string} x */ function f(x) {}"
+                + "Foo.prototype.bar = function(y) { f(y); };")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testAliasedTypedef4() {
+  public void testInferredParam2() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @typedef {string} */ var original;",
-            "/** @const */ ns.alias = original;",
-            "/** @return {number} */ var f = function(/** ns.alias */ x) { return x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
+            "/** @param {string} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @override @return {void} */ SubFoo.prototype.bar = "
+                + "    function(x) { f(x); }")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testAliasedNonTypedef() {
+  public void testInferredParam3() {
     newTest()
         .addSource(
-            "/** @type {string} */ var notTypeName;",
-            "/** @const */ var alias = notTypeName;",
-            "/** @type {alias} */ var x;")
-        .addDiagnostic("Bad type annotation. Unknown type alias")
+            "/** @param {string} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @override @return {void} */ SubFoo.prototype.bar = "
+                + "    function(x) { f(x); }; (new SubFoo()).bar();")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (number|undefined)\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testConstStringKeyDoesntCrash() {
+  public void testInferredParam4() {
     newTest()
         .addSource(
+            "/** @param {string} x */ function f(x) {}",
+            "",
             "/** @constructor */",
             "function Foo() {}",
-            "var ns = {",
-            "  /** @const */ FooAlias: Foo",
-            "};")
+            "/** @param {...number} x */",
+            "Foo.prototype.bar = function(x) {};",
+            "",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo}",
+            " */",
+            "function SubFoo() {}",
+            "/**",
+            " * @override",
+            " * @return {void}",
+            " */",
+            "SubFoo.prototype.bar = function(x) { f(x); };",
+            "(new SubFoo()).bar();")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testClosure7() {
-    testClosureTypes(
-        "/** @type {string|null|undefined} */ var a = foo();"
-            + "/** @type {number} */"
-            + "var b = goog.asserts.assert(a);",
-        "initializing variable\n" + "found   : string\n" + "required: number");
+  public void testInferredParam5() {
+    newTest()
+        .addSource(
+            "/** @param {string} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "/** @param {...number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @override @param {number=} x \n * @param {...number} y  */ "
+                + "SubFoo.prototype.bar = "
+                + "    function(x, y) { f(x); }; (new SubFoo()).bar();")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (number|undefined)\n"
+                + "required: string")
+        .run();
   }
 
-  private static final String PRIMITIVE_ASSERT_DEFS =
-      lines(
-          "/**",
-          " * @param {T} p",
-          " * @return {U}",
-          " * @template T",
-          " * @template U :=",
-          "       mapunion(T, (E) => cond(sub(E, union('null', 'undefined')), none(), E)) =:",
-          " * @closurePrimitive {asserts.truthy}",
-          " */",
-          "function assertTruthy(p) { return p; }",
-          "/**",
-          " * @param {*} p",
-          " * @return {string}",
-          " * @closurePrimitive {asserts.matchesReturn}",
-          " */",
-          "function assertString(p) { return /** @type {string} */ (p); }");
-
   @Test
-  public void testPrimitiveAssertTruthy_removesNullAndUndefinedFromString() {
+  public void testInferredParam6() {
     newTest()
         .addSource(
-            PRIMITIVE_ASSERT_DEFS
-                + lines(
-                    "function f(/** ?string|undefined */ str) {",
-                    "  assertTruthy(str);",
-                    "  const /** number */ n = str;",
-                    "}"))
+            "/** @param {string} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @override @param {number=} x \n * @param {number=} y */ "
+                + "SubFoo.prototype.bar = "
+                + "    function(x, y) { f(y); };")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : string",
-                "required: number"))
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (number|undefined)\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testPrimitiveAssertString_narrowsAllTypeToString() {
+  public void testInferredParam7() {
     newTest()
         .addSource(
-            PRIMITIVE_ASSERT_DEFS
-                + lines(
-                    "function f(/** * */ str) {",
-                    "  assertString(str);",
-                    "  const /** number */ n = str;",
-                    "}"))
+            "/** @param {string} x */ function f(x) {}"
+                + "/** @type {function(number=,number=)} */"
+                + "var bar = function(x, y) { f(y); };")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : string",
-                "required: number"))
-        .run();
-  }
-
-  @Test
-  public void testReturn1() {
-    newTest()
-        .addSource("/**@return {void}*/function foo(){ return 3; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (number|undefined)\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testReturn2() {
+  public void testInferredParam8() {
     newTest()
-        .addSource("/**@return {!Number}*/function foo(){ return; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : undefined\n" + "required: Number")
+        .addSource(
+            "/** @param {function(string)} callback */",
+            "function foo(callback) {}",
+            "foo(/** random JSDoc */ function(x) { var /** number */ n = x; });")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : string", // type of "x" is inferred to be string
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testReturn3() {
+  public void testFunctionLiteralParamWithInlineJSDocNotInferred() {
     newTest()
-        .addSource("/**@return {!Number}*/function foo(){ return 'abc'; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: Number")
+        .addSource(
+            "/** @param {function(string)} x */",
+            "function f(x) {}",
+            "f(function(/** number */ x) {});")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : function(number): undefined",
+                "required: function(string): ?"))
         .run();
   }
 
   @Test
-  public void testReturn4() {
+  public void testFunctionLiteralParamWithInlineJSDocNotInferredWithTwoParams() {
     newTest()
-        .addSource("/**@return {!Number}\n*/\n function a(){return new Array();}")
-        .addDiagnostic("inconsistent return type\n" + "found   : Array<?>\n" + "required: Number")
+        .addSource(
+            "/** @param {function(string, number)} x */",
+            "function f(x) {}",
+            "f((/** string */ str, num) => {",
+            // TODO(b/123583824): this should be a type mismatch warning.
+            //    found   : number
+            //    expected: string
+            //  but the JSDoc on `str` blocks inference of `num`.
+            "  const /** string */ newStr = num;",
+            "});")
         .run();
   }
 
   @Test
-  public void testReturn5() {
+  public void testJSDocOnNoParensArrowFnParameterIsIgnored() {
+    // This case is to document a potential bit of confusion: what happens when writing
+    // inline-like JSDoc on a 'naked' arrow function parameter (no parentheses)
+    // The actual behavior is that the JSDoc does nothing: this is equivalent to writing
+    //   /** number */ function(x) { ...
     newTest()
         .addSource(
-            "/**", //
-            " * @param {number} n",
-            " * @constructor",
-            " */",
-            "function fn(n){ return }")
+            "/** @param {function(string)} callback */",
+            "function foo(callback) {}",
+            // The `/** number */` JSDoc is attached to the entire arrow  function, not the
+            // parameter `x`
+            "foo(/** number */ x =>  { var /** number */ y = x; });")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : string", // type of "x" is inferred to be string
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testReturn6() {
+  public void testOverriddenParams1() {
     newTest()
         .addSource(
-            "/** @param {number} opt_a\n@return {string} */" + "function a(opt_a) { return opt_a }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|undefined)\n" + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {...?} var_args */"
+                + "Foo.prototype.bar = function(var_args) {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @param {number} x\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function(x) {};")
         .run();
   }
 
   @Test
-  public void testReturn7() {
+  public void testOverriddenParams2() {
     newTest()
         .addSource(
-            "/** @constructor */var A = function() {};\n"
-                + "/** @constructor */var B = function() {};\n"
-                + "/** @return {!B} */A.f = function() { return 1; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: B")
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {function(...?)} */"
+                + "Foo.prototype.bar = function(var_args) {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @type {function(number)}\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function(x) {};")
         .run();
   }
 
   @Test
-  public void testReturn8() {
+  public void testOverriddenParams3() {
     newTest()
         .addSource(
-            "/** @constructor */var A = function() {};\n"
-                + "/** @constructor */var B = function() {};\n"
-                + "/** @return {!B} */A.prototype.f = function() { return 1; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: B")
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {...number} var_args */"
+                + "Foo.prototype.bar = function(var_args) { };"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @param {number} x\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function(x) {};")
+        .addDiagnostic(
+            "mismatch of the bar property type and the type of the "
+                + "property it overrides from superclass Foo\n"
+                + "original: function(this:Foo, ...number): undefined\n"
+                + "override: function(this:SubFoo, number): undefined")
         .run();
   }
 
   @Test
-  public void testInferredReturn1() {
+  public void testOverriddenParams4() {
     newTest()
-        .addSource("function f() {} /** @param {number} x */ function g(x) {}" + "g(f());")
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {function(...number)} */"
+                + "Foo.prototype.bar = function(var_args) {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @type {function(number)}\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function(x) {};")
         .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : undefined\n"
-                + "required: number")
+            "mismatch of the bar property type and the type of the "
+                + "property it overrides from superclass Foo\n"
+                + "original: function(...number): ?\n"
+                + "override: function(number): ?")
         .run();
   }
 
   @Test
-  public void testInferredReturn2() {
+  public void testOverriddenParams5() {
     newTest()
         .addSource(
             "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() {}; "
-                + "/** @param {number} x */ function g(x) {}"
-                + "g((new Foo()).bar());")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : undefined\n"
-                + "required: number")
+                + "/** @param {number} x */"
+                + "Foo.prototype.bar = function(x) { };"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function() {};"
+                + "(new SubFoo()).bar();")
         .run();
   }
 
   @Test
-  public void testInferredReturn3() {
+  public void testOverriddenParams6() {
     newTest()
         .addSource(
             "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() {}; "
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @return {number} \n * @override  */ "
-                + "SubFoo.prototype.bar = function() { return 3; }; ")
+                + "/** @param {number} x */"
+                + "Foo.prototype.bar = function(x) { };"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = function() {};"
+                + "(new SubFoo()).bar(true);")
         .addDiagnostic(
-            "mismatch of the bar property type and the type of the property "
-                + "it overrides from superclass Foo\n"
-                + "original: function(this:Foo): undefined\n"
-                + "override: function(this:SubFoo): number")
+            "actual parameter 1 of SubFoo.prototype.bar "
+                + "does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testInferredReturn4() {
-    // By design, this throws a warning. if you want global x to be
-    // defined to some other type of function, then you need to declare it
-    // as a greater type.
+  public void testOverriddenParams7() {
     newTest()
         .addSource(
-            "var x = function() {};"
-                + "x = /** @type {function(): number} */ (function() { return 3; });")
+            "/** @interface */ function Foo() {}",
+            "/** @param {number} x */",
+            "Foo.prototype.bar = function(x) { };",
+            "/**",
+            " * @interface",
+            " * @extends {Foo}",
+            " */ function SubFoo() {}",
+            "/**",
+            " * @override",
+            " */",
+            "SubFoo.prototype.bar = function() {};",
+            "var subFoo = /** @type {SubFoo} */ (null);",
+            "subFoo.bar(true);")
         .addDiagnostic(
-            "assignment\n" + "found   : function(): number\n" + "required: function(): undefined")
+            lines(
+                "actual parameter 1 of SubFoo.prototype.bar does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testInferredReturn5() {
-    // If x is local, then the function type is not declared.
+  public void testOverriddenParams8() {
     newTest()
         .addSource(
-            "/** @return {string} */"
-                + "function f() {"
-                + "  var x = function() {};"
-                + "  x = /** @type {function(): number} */ (function() { return 3; });"
-                + "  return x();"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "/** @constructor\n * @template T */ function Foo() {}",
+            "/** @param {T} x */",
+            "Foo.prototype.bar = function(x) { };",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo<string>}",
+            " */ function SubFoo() {}",
+            "/**",
+            " * @param {number} x",
+            " * @override",
+            " */",
+            "SubFoo.prototype.bar = function(x) {};")
+        .addDiagnostic(
+            lines(
+                "mismatch of the bar property type and the type of the "
+                    + "property it overrides from superclass Foo",
+                "original: function(this:Foo, string): undefined",
+                "override: function(this:SubFoo, number): undefined"))
         .run();
   }
 
   @Test
-  public void testInferredReturn6() {
+  public void testOverriddenReturn1() {
     newTest()
         .addSource(
-            "/** @return {string} */"
-                + "function f() {"
-                + "  var x = function() {};"
-                + "  if (f()) "
-                + "    x = /** @type {function(): number} */ "
-                + "        (function() { return 3; });"
-                + "  return x();"
-                + "}")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|undefined)\n" + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "/** @return {Object} */ Foo.prototype.bar = "
+                + "    function() { return {}; };"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @return {SubFoo}\n * @override */ SubFoo.prototype.bar = "
+                + "    function() { return new Foo(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : Foo\n" + "required: (SubFoo|null)")
         .run();
   }
 
   @Test
-  public void testInferredReturn7() {
+  public void testOverriddenReturn2() {
     newTest()
         .addSource(
             "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "Foo.prototype.bar = function(x) { return 3; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
+                + "/** @return {SubFoo} */ Foo.prototype.bar = "
+                + "    function() { return new SubFoo(); };"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "/** @return {Foo} x\n * @override */ SubFoo.prototype.bar = "
+                + "    function() { return new SubFoo(); }")
+        .addDiagnostic(
+            "mismatch of the bar property type and the type of the "
+                + "property it overrides from superclass Foo\n"
+                + "original: function(this:Foo): (SubFoo|null)\n"
+                + "override: function(this:SubFoo): (Foo|null)")
         .run();
   }
 
   @Test
-  public void testInferredReturn8() {
+  public void testOverriddenReturn3() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @override @param {number} x */ SubFoo.prototype.bar = "
-                + "    function(x) { return 3; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: undefined")
+            "/** @constructor \n * @template T */ function Foo() {}"
+                + "/** @return {T} */ Foo.prototype.bar = "
+                + "    function() { return null; };"
+                + "/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}"
+                + "/** @override */ SubFoo.prototype.bar = "
+                + "    function() { return 3; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testInferredReturn9() {
+  public void testOverriddenReturn4() {
     newTest()
         .addSource(
-            "/** @param {function():string} x */",
-            "function f(x) {}",
-            "f(/** asdf */ function() { return 123; });")
+            "/** @constructor \n * @template T */ function Foo() {}"
+                + "/** @return {T} */ Foo.prototype.bar = "
+                + "    function() { return null; };"
+                + "/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}"
+                + "/** @return {number}\n * @override */ SubFoo.prototype.bar = "
+                + "    function() { return 3; }")
         .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
+            "mismatch of the bar property type and the type of the "
+                + "property it overrides from superclass Foo\n"
+                + "original: function(this:Foo): string\n"
+                + "override: function(this:SubFoo): number")
         .run();
   }
 
   @Test
-  public void testInferredParam1() {
+  public void testThis1() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @param {string} x */ function f(x) {}"
-                + "Foo.prototype.bar = function(y) { f(y); };")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){};"
+                + "/** @return {number} */"
+                + "goog.A.prototype.n = function() { return this };")
+        .addDiagnostic("inconsistent return type\n" + "found   : goog.A\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testInferredParam2() {
+  public void testOverriddenProperty1() {
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @override @return {void} */ SubFoo.prototype.bar = "
-                + "    function(x) { f(x); }")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {Object} */"
+                + "Foo.prototype.bar = {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @type {Array}\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = [];")
         .run();
   }
 
   @Test
-  public void testInferredParam3() {
+  public void testOverriddenProperty2() {
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @override @return {void} */ SubFoo.prototype.bar = "
-                + "    function(x) { f(x); }; (new SubFoo()).bar();")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (number|undefined)\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {"
+                + "  /** @type {Object} */"
+                + "  this.bar = {};"
+                + "}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/**\n"
+                + " * @type {Array}\n"
+                + " * @override\n"
+                + " */"
+                + "SubFoo.prototype.bar = [];")
         .run();
   }
 
   @Test
-  public void testInferredParam4() {
+  public void testOverriddenProperty3() {
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}",
-            "",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @param {...number} x */",
-            "Foo.prototype.bar = function(x) {};",
-            "",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo}",
-            " */",
-            "function SubFoo() {}",
-            "/**",
-            " * @override",
-            " * @return {void}",
-            " */",
-            "SubFoo.prototype.bar = function(x) { f(x); };",
-            "(new SubFoo()).bar();")
+            "/** @constructor */ function Foo() {"
+                + "}"
+                + "/** @type {string} */ Foo.prototype.data;"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/** @type {string|Object} \n @override */ "
+                + "SubFoo.prototype.data = null;")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : number",
-                "required: string"))
+            "mismatch of the data property type and the type "
+                + "of the property it overrides from superclass Foo\n"
+                + "original: string\n"
+                + "override: (Object|null|string)")
         .run();
   }
 
   @Test
-  public void testInferredParam5() {
+  public void testOverriddenProperty4() {
+    // These properties aren't declared, so there should be no warning.
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "/** @param {...number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @override @param {number=} x \n * @param {...number} y  */ "
-                + "SubFoo.prototype.bar = "
-                + "    function(x, y) { f(x); }; (new SubFoo()).bar();")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (number|undefined)\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = null;"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "SubFoo.prototype.bar = 3;")
         .run();
   }
 
   @Test
-  public void testInferredParam6() {
+  public void testOverriddenProperty5() {
+    // An override should be OK if the superclass property wasn't declared.
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @override @param {number=} x \n * @param {number=} y */ "
-                + "SubFoo.prototype.bar = "
-                + "    function(x, y) { f(y); };")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (number|undefined)\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = null;"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/** @override */ SubFoo.prototype.bar = 3;")
         .run();
   }
 
   @Test
-  public void testInferredParam7() {
+  public void testOverriddenProperty6() {
+    // The override keyword shouldn't be necessary if the subclass property
+    // is inferred.
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}"
-                + "/** @type {function(number=,number=)} */"
-                + "var bar = function(x, y) { f(y); };")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (number|undefined)\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {?number} */ Foo.prototype.bar = null;"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "SubFoo.prototype.bar = 3;")
         .run();
   }
 
   @Test
-  public void testInferredParam8() {
+  public void testOverriddenPropertyWithUnknown() {
+    // When overriding a declared property with a declared unknown property, we warn for a missing
+    // override but not a type mismatch.
     newTest()
         .addSource(
-            "/** @param {function(string)} callback */",
-            "function foo(callback) {}",
-            "foo(/** random JSDoc */ function(x) { var /** number */ n = x; });")
+            "/** @constructor */ function Foo() {}",
+            "/** @type {?number} */ Foo.prototype.bar = null;",
+            "",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo}",
+            " */",
+            "function SubFoo() {}",
+            "/** @type {?} */",
+            "SubFoo.prototype.bar = 'not a number';")
         .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : string", // type of "x" is inferred to be string
-                "required: number"))
+            "property bar already defined on superclass Foo; use @override to override it")
         .run();
   }
 
   @Test
-  public void testFunctionLiteralParamWithInlineJSDocNotInferred() {
+  public void testOverriddenPropertyWithUnknownInterfaceAncestor() {
     newTest()
         .addSource(
-            "/** @param {function(string)} x */",
-            "function f(x) {}",
-            "f(function(/** number */ x) {});")
+            "/** @interface @extends {Unknown}  */ function Foo() {}",
+            "/** @type {string} */ Foo.prototype.data;",
+            "/** @constructor @implements {Foo} */ function SubFoo() {}",
+            "/** @type {string|Object} */ ",
+            "SubFoo.prototype.data = null;")
+        .addDiagnostic("Bad type annotation. Unknown type Unknown")
         .addDiagnostic(
             lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : function(number): undefined",
-                "required: function(string): ?"))
+                "mismatch of the data property on type SubFoo and the type "
+                    + "of the property it overrides from interface Foo",
+                "original: string",
+                "override: (Object|null|string)"))
         .run();
   }
 
   @Test
-  public void testFunctionLiteralParamWithInlineJSDocNotInferredWithTwoParams() {
+  public void testThis2() {
     newTest()
         .addSource(
-            "/** @param {function(string, number)} x */",
-            "function f(x) {}",
-            "f((/** string */ str, num) => {",
-            // TODO(b/123583824): this should be a type mismatch warning.
-            //    found   : number
-            //    expected: string
-            //  but the JSDoc on `str` blocks inference of `num`.
-            "  const /** string */ newStr = num;",
-            "});")
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){"
+                + "  this.foo = null;"
+                + "};"
+                + "/** @return {number} */"
+                + "goog.A.prototype.n = function() { return this.foo };")
+        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testJSDocOnNoParensArrowFnParameterIsIgnored() {
-    // This case is to document a potential bit of confusion: what happens when writing
-    // inline-like JSDoc on a 'naked' arrow function parameter (no parentheses)
-    // The actual behavior is that the JSDoc does nothing: this is equivalent to writing
-    //   /** number */ function(x) { ...
+  public void testThis3() {
     newTest()
         .addSource(
-            "/** @param {function(string)} callback */",
-            "function foo(callback) {}",
-            // The `/** number */` JSDoc is attached to the entire arrow  function, not the
-            // parameter `x`
-            "foo(/** number */ x =>  { var /** number */ y = x; });")
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){"
+                + "  this.foo = null;"
+                + "  this.foo = 5;"
+                + "};")
+        .run();
+  }
+
+  @Test
+  public void testThis4() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){"
+                + "  /** @type {string?} */this.foo = null;"
+                + "};"
+                + "/** @return {number} */goog.A.prototype.n = function() {"
+                + "  return this.foo };")
         .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : string", // type of "x" is inferred to be string
-                "required: number"))
+            "inconsistent return type\n" + "found   : (null|string)\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenParams1() {
+  public void testThis5() {
+    newTest()
+        .addSource("/** @this {Date}\n@return {number}*/function h() { return this }")
+        .addDiagnostic("inconsistent return type\n" + "found   : Date\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testThis6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {...?} var_args */"
-                + "Foo.prototype.bar = function(var_args) {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @param {number} x\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function(x) {};")
+            "var goog = {};"
+                + "/** @constructor\n@return {!Date} */"
+                + "goog.A = function(){ return this };")
+        .addDiagnostic("inconsistent return type\n" + "found   : goog.A\n" + "required: Date")
         .run();
   }
 
   @Test
-  public void testOverriddenParams2() {
+  public void testThis7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {function(...?)} */"
-                + "Foo.prototype.bar = function(var_args) {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @type {function(number)}\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function(x) {};")
+            "/** @constructor */function A(){};"
+                + "/** @return {number} */A.prototype.n = function() { return this };")
+        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenParams3() {
+  public void testThis8() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {...number} var_args */"
-                + "Foo.prototype.bar = function(var_args) { };"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @param {number} x\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function(x) {};")
+            "/** @constructor */function A(){"
+                + "  /** @type {string?} */this.foo = null;"
+                + "};"
+                + "/** @return {number} */A.prototype.n = function() {"
+                + "  return this.foo };")
         .addDiagnostic(
-            "mismatch of the bar property type and the type of the "
-                + "property it overrides from superclass Foo\n"
-                + "original: function(this:Foo, ...number): undefined\n"
-                + "override: function(this:SubFoo, number): undefined")
+            "inconsistent return type\n" + "found   : (null|string)\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenParams4() {
+  public void testTypeOfThis_inStaticMethod_onEs5Ctor_isUnknown() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {function(...number)} */"
-                + "Foo.prototype.bar = function(var_args) {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @type {function(number)}\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function(x) {};")
-        .addDiagnostic(
-            "mismatch of the bar property type and the type of the "
-                + "property it overrides from superclass Foo\n"
-                + "original: function(...number): ?\n"
-                + "override: function(number): ?")
+            "/** @constructor */function A(){};",
+            "A.foo = 3;",
+            "/** @return {string} */ A.bar = function() { return this.foo; };")
         .run();
   }
 
   @Test
-  public void testOverriddenParams5() {
+  public void testThis10() {
+    // In A.bar, the type of {@code this} is inferred from the @this tag.
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */"
-                + "Foo.prototype.bar = function(x) { };"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function() {};"
-                + "(new SubFoo()).bar();")
+            "/** @constructor */function A(){};"
+                + "A.prototype.foo = 3;"
+                + "/** @this {A}\n@return {string} */"
+                + "A.bar = function() { return this.foo; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testOverriddenParams6() {
+  public void testThis11() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */"
-                + "Foo.prototype.bar = function(x) { };"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = function() {};"
-                + "(new SubFoo()).bar(true);")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */ function Ctor() {"
+                + "  /** @this {Date} */"
+                + "  this.method = function() {"
+                + "    f(this);"
+                + "  };"
+                + "}")
         .addDiagnostic(
-            "actual parameter 1 of SubFoo.prototype.bar "
-                + "does not match formal parameter\n"
-                + "found   : boolean\n"
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : Date\n"
                 + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenParams7() {
+  public void testThis12() {
     newTest()
         .addSource(
-            "/** @interface */ function Foo() {}",
-            "/** @param {number} x */",
-            "Foo.prototype.bar = function(x) { };",
-            "/**",
-            " * @interface",
-            " * @extends {Foo}",
-            " */ function SubFoo() {}",
-            "/**",
-            " * @override",
-            " */",
-            "SubFoo.prototype.bar = function() {};",
-            "var subFoo = /** @type {SubFoo} */ (null);",
-            "subFoo.bar(true);")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */ function Ctor() {}"
+                + "Ctor.prototype['method'] = function() {"
+                + "  f(this);"
+                + "}")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of SubFoo.prototype.bar does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : Ctor\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenParams8() {
+  public void testThis13() {
     newTest()
         .addSource(
-            "/** @constructor\n * @template T */ function Foo() {}",
-            "/** @param {T} x */",
-            "Foo.prototype.bar = function(x) { };",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo<string>}",
-            " */ function SubFoo() {}",
-            "/**",
-            " * @param {number} x",
-            " * @override",
-            " */",
-            "SubFoo.prototype.bar = function(x) {};")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */ function Ctor() {}"
+                + "Ctor.prototype = {"
+                + "  method: function() {"
+                + "    f(this);"
+                + "  }"
+                + "};")
         .addDiagnostic(
-            lines(
-                "mismatch of the bar property type and the type of the "
-                    + "property it overrides from superclass Foo",
-                "original: function(this:Foo, string): undefined",
-                "override: function(this:SubFoo, number): undefined"))
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : Ctor\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testOverriddenReturn1() {
+  public void testThis14() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @return {Object} */ Foo.prototype.bar = "
-                + "    function() { return {}; };"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @return {SubFoo}\n * @override */ SubFoo.prototype.bar = "
-                + "    function() { return new Foo(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : Foo\n" + "required: (SubFoo|null)")
+        .addSource("/** @param {number} x */ function f(x) {}" + "f(this.Object);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : (typeof Object)",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testOverriddenReturn2() {
+  public void testThisType_whichTypesSupport_freeCallsOfFunction() {
+    newTest().addSource("/** @type {function(this:*)} */ function f() {}; f();").run();
+    newTest().addSource("/** @type {function(this:?)} */ function f() {}; f();").run();
+    newTest().addSource("/** @type {function(this:undefined)} */ function f() {}; f();").run();
+    newTest().addSource("/** @type {function(this:Object)} */ function f() {}; f();").run();
+  }
+
+  @Test
+  public void testThisTypeOfFunction2() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @return {SubFoo} */ Foo.prototype.bar = "
-                + "    function() { return new SubFoo(); };"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "/** @return {Foo} x\n * @override */ SubFoo.prototype.bar = "
-                + "    function() { return new SubFoo(); }")
-        .addDiagnostic(
-            "mismatch of the bar property type and the type of the "
-                + "property it overrides from superclass Foo\n"
-                + "original: function(this:Foo): (SubFoo|null)\n"
-                + "override: function(this:SubFoo): (Foo|null)")
+            "/** @constructor */ function F() {}"
+                + "/** @type {function(this:F)} */ function f() {}"
+                + "f();")
+        .addDiagnostic("\"function(this:F): ?\" must be called with a \"this\" type")
         .run();
   }
 
   @Test
-  public void testOverriddenReturn3() {
+  public void testThisTypeOfFunction3() {
     newTest()
         .addSource(
-            "/** @constructor \n * @template T */ function Foo() {}"
-                + "/** @return {T} */ Foo.prototype.bar = "
-                + "    function() { return null; };"
-                + "/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}"
-                + "/** @override */ SubFoo.prototype.bar = "
-                + "    function() { return 3; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "/** @constructor */ function F() {}"
+                + "F.prototype.bar = function() {};"
+                + "var f = (new F()).bar; f();")
+        .addDiagnostic("\"function(this:F): undefined\" must be called with a \"this\" type")
         .run();
   }
 
   @Test
-  public void testOverriddenReturn4() {
+  public void testThisTypeOfFunction4() {
     newTest()
+        .addExterns(new TestExternsBuilder().addArray().addObject().build())
         .addSource(
-            "/** @constructor \n * @template T */ function Foo() {}"
-                + "/** @return {T} */ Foo.prototype.bar = "
-                + "    function() { return null; };"
-                + "/** @constructor \n * @extends {Foo<string>} */ function SubFoo() {}"
-                + "/** @return {number}\n * @override */ SubFoo.prototype.bar = "
-                + "    function() { return 3; }")
-        .addDiagnostic(
-            "mismatch of the bar property type and the type of the "
-                + "property it overrides from superclass Foo\n"
-                + "original: function(this:Foo): string\n"
-                + "override: function(this:SubFoo): number")
+            "/** @constructor */ function F() {}",
+            "F.prototype.moveTo = function(x, y) {};",
+            "F.prototype.lineTo = function(x, y) {};",
+            "function demo() {",
+            "  var path = new F();",
+            "  var points = [[1,1], [2,2]];",
+            "  for (var i = 0; i < points.length; i++) {",
+            "    (i == 0 ? path.moveTo : path.lineTo)(points[i][0], points[i][1]);",
+            "  }",
+            "}")
+        .addDiagnostic("\"function(this:F, ?, ?): undefined\" must be called with a \"this\" type")
         .run();
   }
 
   @Test
-  public void testOverriddenReturnOnAbstractClass() {
+  public void testThisTypeOfFunction5() {
     newTest()
         .addSource(
-            "/** @interface */ function IFoo() {}",
-            "/** @return {*} */ IFoo.prototype.foo = function() {}",
-            "/** @constructor */ function Foo() {}",
-            "/** @return {string} */ Foo.prototype.foo = function() {}",
-            "/** @constructor @extends {Foo} */ function Bar() {}",
-            "/**",
-            " * @constructor @abstract",
-            " * @extends {Bar} @implements {IFoo}",
-            " */",
-            "function Baz() {}",
-            // Even there is a closer definition in IFoo, Foo should be still the source of truth.
-            "/** @return {string} */",
-            "function test() { return (/** @type {Baz} */ (null)).foo(); }")
+            "/** @type {function(this:number)} */",
+            "function f() {",
+            "  var /** number */ n = this;",
+            "}")
         .run();
   }
 
   @Test
-  public void testOverriddenReturnDoesntMatchOnAbstractClass() {
+  public void testGlobalThis1() {
     newTest()
         .addSource(
-            "/** @interface */ function IFoo() {}",
-            "/** @return {number} */ IFoo.prototype.foo = function() {}",
-            "/** @constructor */ function Foo() {}",
-            "/** @return {string} */ Foo.prototype.foo = function() {}",
-            "/** @constructor @extends {Foo} */ function Bar() {}",
-            "/**",
-            " * @constructor @abstract",
-            " * @extends {Bar} @implements {IFoo}",
-            " */",
-            "function Baz() {}",
-            "/** @return {string} */",
-            "function test() { return (/** @type {Baz} */ (null)).foo(); }")
+            "/** @constructor */ function Window() {}"
+                + "/** @param {string} msg */ "
+                + "Window.prototype.alert = function(msg) {};"
+                + "this.alert(3);")
         .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Baz and the type of the property it overrides"
-                    + " from interface IFoo",
-                "original: function(this:IFoo): number",
-                "override: function(this:Foo): string"))
+            "actual parameter 1 of Window.prototype.alert "
+                + "does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testThis1() {
+  public void testGlobalThis2a() {
+    // this.alert = 3 doesn't count as a declaration, so this is a warning.
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){};"
-                + "/** @return {number} */"
-                + "goog.A.prototype.n = function() { return this };")
-        .addDiagnostic("inconsistent return type\n" + "found   : goog.A\n" + "required: number")
+            "/** @constructor */ function Bindow() {}",
+            "/** @param {string} msg */ ",
+            "Bindow.prototype.alert = function(msg) {};",
+            "this.alert = 3;",
+            "(new Bindow()).alert(this.alert)")
+        .addDiagnostic("Property alert never defined on global this")
+        .addDiagnostic("Property alert never defined on global this")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty1() {
+  public void testGlobalThis2b() {
+    // Only reported if strict property checks are enabled
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {Object} */"
-                + "Foo.prototype.bar = {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @type {Array}\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = [];")
+            "/** @constructor */ function Bindow() {}",
+            "/** @param {string} msg */ ",
+            "Bindow.prototype.alert = function(msg) {};",
+            "this.alert = 3;",
+            "(new Bindow()).alert(this.alert)")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty2() {
+  public void testGlobalThis2c() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {"
-                + "  /** @type {Object} */"
-                + "  this.bar = {};"
-                + "}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/**\n"
-                + " * @type {Array}\n"
-                + " * @override\n"
-                + " */"
-                + "SubFoo.prototype.bar = [];")
+            "/** @constructor */ function Bindow() {}"
+                + "/** @param {string} msg */ "
+                + "Bindow.prototype.alert = function(msg) {};"
+                + "/** @return {number} */ this.alert = function() { return 3; };"
+                + "(new Bindow()).alert(this.alert())")
+        .addDiagnostic(
+            "actual parameter 1 of Bindow.prototype.alert "
+                + "does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty3() {
+  public void testGlobalThis3() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {"
-                + "}"
-                + "/** @type {string} */ Foo.prototype.data;"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/** @type {string|Object} \n @override */ "
-                + "SubFoo.prototype.data = null;")
+        .addSource("/** @param {string} msg */ " + "function alert(msg) {};" + "this.alert(3);")
         .addDiagnostic(
-            "mismatch of the data property type and the type "
-                + "of the property it overrides from superclass Foo\n"
-                + "original: string\n"
-                + "override: (Object|null|string)")
+            "actual parameter 1 of global this.alert "
+                + "does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty4() {
-    // These properties aren't declared, so there should be no warning.
+  public void testGlobalThis4() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = null;"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "SubFoo.prototype.bar = 3;")
+            "/** @param {string} msg */ " + "var alert = function(msg) {};" + "this.alert(3);")
+        .addDiagnostic(
+            "actual parameter 1 of global this.alert "
+                + "does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty5() {
-    // An override should be OK if the superclass property wasn't declared.
+  public void testGlobalThis5() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = null;"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/** @override */ SubFoo.prototype.bar = 3;")
+            "function f() {"
+                + "  /** @param {string} msg */ "
+                + "  var alert = function(msg) {};"
+                + "}"
+                + "this.alert(3);")
+        .addDiagnostic("Property alert never defined on global this")
         .run();
   }
 
   @Test
-  public void testOverriddenProperty6() {
-    // The override keyword shouldn't be necessary if the subclass property
-    // is inferred.
+  public void testGlobalThis6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {?number} */ Foo.prototype.bar = null;"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "SubFoo.prototype.bar = 3;")
+            "/** @param {string} msg */ ",
+            "var alert = function(msg) {};",
+            "var x = 3;",
+            "x = 'msg';",
+            "this.alert(this.x);")
         .run();
   }
 
   @Test
-  public void testOverriddenPropertyWithUnknown() {
-    // When overriding a declared property with a declared unknown property, we warn for a missing
-    // override but not a type mismatch.
+  public void testGlobalThis7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "/** @type {?number} */ Foo.prototype.bar = null;",
-            "",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo}",
-            " */",
-            "function SubFoo() {}",
-            "/** @type {?} */",
-            "SubFoo.prototype.bar = 'not a number';")
-        .addDiagnostic(
-            "property bar already defined on superclass Foo; use @override to override it")
+            "/** @constructor */ function Window() {}"
+                + "/** @param {Window} msg */ "
+                + "var foo = function(msg) {};"
+                + "foo(this);")
         .run();
   }
 
   @Test
-  public void testOverriddenPropertyWithUnknownInterfaceAncestor() {
+  public void testGlobalThis8() {
     newTest()
         .addSource(
-            "/** @interface @extends {Unknown}  */ function Foo() {}",
-            "/** @type {string} */ Foo.prototype.data;",
-            "/** @constructor @implements {Foo} */ function SubFoo() {}",
-            "/** @type {string|Object} */ ",
-            "SubFoo.prototype.data = null;")
-        .addDiagnostic("Bad type annotation. Unknown type Unknown")
+            "/** @constructor */ function Window() {}"
+                + "/** @param {number} msg */ "
+                + "var foo = function(msg) {};"
+                + "foo(this);")
         .addDiagnostic(
-            lines(
-                "mismatch of the data property on type SubFoo and the type "
-                    + "of the property it overrides from interface Foo",
-                "original: string",
-                "override: (Object|null|string)"))
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : global this\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testThis2() {
+  public void testGlobalThis9() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){"
-                + "  this.foo = null;"
-                + "};"
-                + "/** @return {number} */"
-                + "goog.A.prototype.n = function() { return this.foo };")
-        .addDiagnostic("inconsistent return type\n" + "found   : null\n" + "required: number")
+            // Window is not marked as a constructor, so the
+            // inheritance doesn't happen.
+            "function Window() {}" + "Window.prototype.alert = function() {};" + "this.alert();")
+        .addDiagnostic("Property alert never defined on global this")
         .run();
   }
 
   @Test
-  public void testThis3() {
+  public void testGlobalThisDoesNotIncludeVarsDeclaredWithConst() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){"
-                + "  this.foo = null;"
-                + "  this.foo = 5;"
-                + "};")
+            "/** @param {string} msg */ ", //
+            "const alert = function(msg) {};",
+            "this.alert('boo');")
+        .addDiagnostic("Property alert never defined on global this")
         .run();
   }
 
   @Test
-  public void testThis4() {
+  public void testGlobalThisDoesNotIncludeVarsDeclaredWithLet() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){"
-                + "  /** @type {string?} */this.foo = null;"
-                + "};"
-                + "/** @return {number} */goog.A.prototype.n = function() {"
-                + "  return this.foo };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (null|string)\n" + "required: number")
+            "/** @param {string} msg */ ", //
+            "let alert = function(msg) {};",
+            "this.alert('boo');")
+        .addDiagnostic("Property alert never defined on global this")
         .run();
   }
 
   @Test
-  public void testThis5() {
+  public void testControlFlowRestrictsType1() {
     newTest()
-        .addSource("/** @this {Date}\n@return {number}*/function h() { return this }")
-        .addDiagnostic("inconsistent return type\n" + "found   : Date\n" + "required: number")
+        .addSource(
+            "/** @return {String?} */ function f() { return null; }"
+                + "/** @type {String?} */ var a = f();"
+                + "/** @type {String} */ var b = new String('foo');"
+                + "/** @type {null} */ var c = null;"
+                + "if (a) {"
+                + "  b = a;"
+                + "} else {"
+                + "  c = a;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testThis6() {
+  public void testControlFlowRestrictsType2() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor\n@return {!Date} */"
-                + "goog.A = function(){ return this };")
-        .addDiagnostic("inconsistent return type\n" + "found   : goog.A\n" + "required: Date")
+            "/** @return {(string|null)} */ function f() { return null; }"
+                + "/** @type {(string|null)} */ var a = f();"
+                + "/** @type {string} */ var b = 'foo';"
+                + "/** @type {null} */ var c = null;"
+                + "if (a) {"
+                + "  b = a;"
+                + "} else {"
+                + "  c = a;"
+                + "}")
+        .addDiagnostic("assignment\n" + "found   : (null|string)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testThis7() {
+  public void testControlFlowRestrictsType3() {
     newTest()
         .addSource(
-            "/** @constructor */function A(){};"
-                + "/** @return {number} */A.prototype.n = function() { return this };")
-        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: number")
+            "/** @type {(string|void)} */"
+                + "var a;"
+                + "/** @type {string} */"
+                + "var b = 'foo';"
+                + "if (a) {"
+                + "  b = a;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testThis8() {
+  public void testControlFlowRestrictsType4() {
     newTest()
         .addSource(
-            "/** @constructor */function A(){"
-                + "  /** @type {string?} */this.foo = null;"
-                + "};"
-                + "/** @return {number} */A.prototype.n = function() {"
-                + "  return this.foo };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (null|string)\n" + "required: number")
+            "/** @param {string} a */ function f(a){}"
+                + "/** @type {(string|undefined)} */ var a;"
+                + "a && f(a);")
         .run();
   }
 
   @Test
-  public void testTypeOfThis_inStaticMethod_onEs5Ctor_isUnknown() {
+  public void testControlFlowRestrictsType5() {
     newTest()
         .addSource(
-            "/** @constructor */function A(){};",
-            "A.foo = 3;",
-            "/** @return {string} */ A.bar = function() { return this.foo; };")
+            "/** @param {undefined} a */ function f(a){}"
+                + "/** @type {(!Array|undefined)} */ var a;"
+                + "a || f(a);")
         .run();
   }
 
   @Test
-  public void testThis10() {
-    // In A.bar, the type of {@code this} is inferred from the @this tag.
+  public void testControlFlowRestrictsType6() {
     newTest()
         .addSource(
-            "/** @constructor */function A(){};"
-                + "A.prototype.foo = 3;"
-                + "/** @this {A}\n@return {string} */"
-                + "A.bar = function() { return this.foo; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "/** @param {undefined} x */ function f(x) {}"
+                + "/** @type {(string|undefined)} */ var a;"
+                + "a && f(a);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: undefined")
         .run();
   }
 
   @Test
-  public void testThis11() {
+  public void testControlFlowRestrictsType7() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */ function Ctor() {"
-                + "  /** @this {Date} */"
-                + "  this.method = function() {"
-                + "    f(this);"
-                + "  };"
-                + "}")
+            "/** @param {undefined} x */ function f(x) {}"
+                + "/** @type {(string|undefined)} */ var a;"
+                + "a && f(a);")
         .addDiagnostic(
             "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : Date\n"
-                + "required: number")
+                + "found   : string\n"
+                + "required: undefined")
         .run();
   }
 
   @Test
-  public void testThis12() {
+  public void testControlFlowRestrictsType8() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */ function Ctor() {}"
-                + "Ctor.prototype['method'] = function() {"
-                + "  f(this);"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : Ctor\n"
-                + "required: number")
+            "/** @param {undefined} a */ function f(a){}"
+                + "/** @type {(!Array|undefined)} */ var a;"
+                + "if (a || f(a)) {}")
         .run();
   }
 
   @Test
-  public void testThis13() {
+  public void testControlFlowRestrictsType9() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */ function Ctor() {}"
-                + "Ctor.prototype = {"
-                + "  method: function() {"
-                + "    f(this);"
-                + "  }"
+            "/** @param {number?} x\n * @return {number}*/\n"
+                + "var f = function(x) {\n"
+                + "if (!x || x == 1) { return 1; } else { return x; }\n"
                 + "};")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : Ctor\n"
-                + "required: number")
         .run();
   }
 
   @Test
-  public void testThis14() {
+  public void testControlFlowRestrictsType10() {
+    // We should correctly infer that y will be (null|{}) because
+    // the loop wraps around.
     newTest()
-        .addSource("/** @param {number} x */ function f(x) {}" + "f(this.Object);")
+        .addSource(
+            "/** @param {number} x */ function f(x) {}"
+                + "function g() {"
+                + "  var y = null;"
+                + "  for (var i = 0; i < 10; i++) {"
+                + "    f(y);"
+                + "    if (y != null) {"
+                + "      // y is None the first time it goes through this branch\n"
+                + "    } else {"
+                + "      y = {};"
+                + "    }"
+                + "  }"
+                + "};")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : (typeof Object)",
-                "required: number"))
-        .includeDefaultExterns()
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (null|{})\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testThisType_whichTypesSupport_freeCallsOfFunction() {
-    newTest().addSource("/** @type {function(this:*)} */ function f() {}; f();").run();
-    newTest().addSource("/** @type {function(this:?)} */ function f() {}; f();").run();
-    newTest().addSource("/** @type {function(this:undefined)} */ function f() {}; f();").run();
-    newTest().addSource("/** @type {function(this:Object)} */ function f() {}; f();").run();
-  }
-
-  @Test
-  public void testThisTypeOfFunction2() {
+  public void testControlFlowRestrictsType11() {
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @type {function(this:F)} */ function f() {}"
-                + "f();")
-        .addDiagnostic("\"function(this:F): ?\" must be called with a \"this\" type")
+            "/** @param {boolean} x */ function f(x) {}"
+                + "function g() {"
+                + "  var y = null;"
+                + "  if (y != null) {"
+                + "    for (var i = 0; i < 10; i++) {"
+                + "      f(y);"
+                + "    }"
+                + "  }"
+                + "};")
+        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: null")
         .run();
   }
 
   @Test
-  public void testThisTypeOfFunction3() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "F.prototype.bar = function() {};"
-                + "var f = (new F()).bar; f();")
-        .addDiagnostic("\"function(this:F): undefined\" must be called with a \"this\" type")
-        .run();
-  }
-
-  @Test
-  public void testThisTypeOfFunction4() {
+  public void testSwitchCase_primitiveDoesNotAutobox() {
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().addObject().build())
         .addSource(
-            "/** @constructor */ function F() {}",
-            "F.prototype.moveTo = function(x, y) {};",
-            "F.prototype.lineTo = function(x, y) {};",
-            "function demo() {",
-            "  var path = new F();",
-            "  var points = [[1,1], [2,2]];",
-            "  for (var i = 0; i < points.length; i++) {",
-            "    (i == 0 ? path.moveTo : path.lineTo)(points[i][0], points[i][1]);",
-            "  }",
-            "}")
-        .addDiagnostic("\"function(this:F, ?, ?): undefined\" must be called with a \"this\" type")
+            "/** @type {!String} */", //
+            "var a = new String('foo');",
+            "switch (a) { case 'A': }")
+        .addDiagnostic(
+            lines(
+                "case expression doesn't match switch", //
+                "found   : string",
+                "required: String"))
         .run();
   }
 
   @Test
-  public void testThisTypeOfFunction5() {
+  public void testSwitchCase_unknownSwitchExprMatchesAnyCase() {
     newTest()
         .addSource(
-            "/** @type {function(this:number)} */",
-            "function f() {",
-            "  var /** number */ n = this;",
-            "}")
+            "var a = unknown;", //
+            "switch (a) { case 'A':break; case null:break; }")
         .run();
   }
 
   @Test
-  public void testGlobalThis1() {
+  public void testSwitchCase_doesNotAutoboxStringToMatchNullableUnion() {
     newTest()
         .addSource(
-            "/** @constructor */ function Window() {}"
-                + "/** @param {string} msg */ "
-                + "Window.prototype.alert = function(msg) {};"
-                + "this.alert(3);")
+            "/** @type {?String} */",
+            "var a = unknown;",
+            "switch (a) { case 'A':break; case null:break; }")
         .addDiagnostic(
-            "actual parameter 1 of Window.prototype.alert "
-                + "does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            lines(
+                "case expression doesn't match switch",
+                "found   : string",
+                "required: (String|null)"))
         .run();
   }
 
   @Test
-  public void testGlobalThis2a() {
-    // this.alert = 3 doesn't count as a declaration, so this is a warning.
+  public void testSwitchCase_doesNotAutoboxNumberToMatchNullableUnion() {
     newTest()
         .addSource(
-            "/** @constructor */ function Bindow() {}",
-            "/** @param {string} msg */ ",
-            "Bindow.prototype.alert = function(msg) {};",
-            "this.alert = 3;",
-            "(new Bindow()).alert(this.alert)")
-        .addDiagnostic("Property alert never defined on global this")
-        .addDiagnostic("Property alert never defined on global this")
+            "/** @type {?Number} */",
+            "var a = unknown;",
+            "switch (a) { case 5:break; case null:break; }")
+        .addDiagnostic(
+            lines(
+                "case expression doesn't match switch",
+                "found   : number",
+                "required: (Number|null)"))
         .run();
   }
 
   @Test
-  public void testGlobalThis2b() {
-    // Only reported if strict property checks are enabled
-    disableStrictMissingPropertyChecks();
-
+  public void testSwitchCase7() {
+    // This really tests the inference inside the case.
     newTest()
         .addSource(
-            "/** @constructor */ function Bindow() {}",
-            "/** @param {string} msg */ ",
-            "Bindow.prototype.alert = function(msg) {};",
-            "this.alert = 3;",
-            "(new Bindow()).alert(this.alert)")
+            "/**\n"
+                + " * @param {number} x\n"
+                + " * @return {number}\n"
+                + " */\n"
+                + "function g(x) { return 5; }"
+                + "function f() {"
+                + "  var x = {};"
+                + "  x.foo = '3';"
+                + "  switch (3) { case g(x.foo): return 3; }"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testGlobalThis2c() {
-    disableStrictMissingPropertyChecks();
+  public void testSwitchCase8() {
+    // This really tests the inference inside the switch clause.
     newTest()
         .addSource(
-            "/** @constructor */ function Bindow() {}"
-                + "/** @param {string} msg */ "
-                + "Bindow.prototype.alert = function(msg) {};"
-                + "/** @return {number} */ this.alert = function() { return 3; };"
-                + "(new Bindow()).alert(this.alert())")
+            "/**\n"
+                + " * @param {number} x\n"
+                + " * @return {number}\n"
+                + " */\n"
+                + "function g(x) { return 5; }"
+                + "function f() {"
+                + "  var x = {};"
+                + "  x.foo = '3';"
+                + "  switch (g(x.foo)) { case 3: return 3; }"
+                + "}")
         .addDiagnostic(
-            "actual parameter 1 of Bindow.prototype.alert "
-                + "does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testGlobalThis3() {
+  public void testSwitchCase_allowsStructuralMatching() {
     newTest()
-        .addSource("/** @param {string} msg */ " + "function alert(msg) {};" + "this.alert(3);")
-        .addDiagnostic(
-            "actual parameter 1 of global this.alert "
-                + "does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+        .addSource(
+            "/** @record */",
+            "class R {",
+            "  constructor() {",
+            "    /** @type {string} */",
+            "    this.str;",
+            "  }",
+            "}",
+            "/** @record */",
+            "class S {",
+            "  constructor() {",
+            "    /** @type {string} */",
+            "    this.str;",
+            "    /** @type {number} */",
+            "    this.num;",
+            "  }",
+            "}",
+            " /**",
+            " * @param {!R} r",
+            " * @param {!S} s",
+            " */",
+            "function f(r, s) {",
+            "  switch (r) {",
+            "    case s:",
+            "      return true;",
+            "  }",
+            "}")
         .run();
   }
 
   @Test
-  public void testGlobalThis4() {
+  public void testImplicitCast1() {
     newTest()
-        .addSource(
-            "/** @param {string} msg */ " + "var alert = function(msg) {};" + "this.alert(3);")
-        .addDiagnostic(
-            "actual parameter 1 of global this.alert "
-                + "does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+        .addExterns(
+            "/** @constructor */ function Element() {};\n"
+                + "/** @type {string}\n"
+                + "  * @implicitCast */"
+                + "Element.prototype.innerHTML;")
+        .addSource("(new Element).innerHTML = new Array();")
         .run();
   }
 
   @Test
-  public void testGlobalThis5() {
+  public void testImplicitCast2() {
     newTest()
+        .addExterns(
+            "/** @constructor */ function Element() {};\n"
+                + "/**\n"
+                + " * @type {string}\n"
+                + " * @implicitCast\n"
+                + " */\n"
+                + "Element.prototype.innerHTML;\n")
         .addSource(
-            "function f() {"
-                + "  /** @param {string} msg */ "
-                + "  var alert = function(msg) {};"
-                + "}"
-                + "this.alert(3);")
-        .addDiagnostic("Property alert never defined on global this")
+            "/** @constructor */ function C(e) {\n"
+                + "  /** @type {Element} */ this.el = e;\n"
+                + "}\n"
+                + "C.prototype.method = function() {\n"
+                + "  this.el.innerHTML = new Array();\n"
+                + "};\n")
         .run();
   }
 
   @Test
-  public void testGlobalThis6() {
+  public void testImplicitCast3() {
     newTest()
+        .addExterns(
+            "/** @constructor */ function Element() {};",
+            "/**",
+            " * @type {string}",
+            " * @implicitCast",
+            " */",
+            "Element.prototype.innerHTML;")
         .addSource(
-            "/** @param {string} msg */ ",
-            "var alert = function(msg) {};",
-            "var x = 3;",
-            "x = 'msg';",
-            "this.alert(this.x);")
+            "/** @param {?Element} element",
+            " * @param {string|number} text",
+            " */",
+            "function f(element, text) {",
+            "  element.innerHTML = text;",
+            "}",
+            "")
         .run();
   }
 
   @Test
-  public void testGlobalThis7() {
+  public void testImplicitCastSubclassAccess() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Window() {}"
-                + "/** @param {Window} msg */ "
-                + "var foo = function(msg) {};"
-                + "foo(this);")
+        .addExterns(
+            "/** @constructor */ function Element() {};\n"
+                + "/** @type {string}\n"
+                + "  * @implicitCast */"
+                + "Element.prototype.innerHTML;"
+                + "/** @constructor \n @extends Element */"
+                + "function DIVElement() {};")
+        .addSource("(new DIVElement).innerHTML = new Array();")
         .run();
   }
 
   @Test
-  public void testGlobalThis8() {
+  public void testImplicitCastNotInExterns() {
+    // We issue a warning in CheckJSDoc for @implicitCast not in externs
     newTest()
         .addSource(
-            "/** @constructor */ function Window() {}"
-                + "/** @param {number} msg */ "
-                + "var foo = function(msg) {};"
-                + "foo(this);")
+            "/** @constructor */ function Element() {};",
+            "/**",
+            " * @type {string}",
+            " * @implicitCast ",
+            " */",
+            "Element.prototype.innerHTML;",
+            "(new Element).innerHTML = new Array();")
         .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : global this\n"
-                + "required: number")
+            lines(
+                "assignment to property innerHTML of Element", // preserve new line
+                "found   : Array<?>",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testGlobalThis9() {
-    newTest()
-        .addSource(
-            // Window is not marked as a constructor, so the
-            // inheritance doesn't happen.
-            "function Window() {}" + "Window.prototype.alert = function() {};" + "this.alert();")
-        .addDiagnostic("Property alert never defined on global this")
-        .run();
+  public void testNumberNode() {
+    Node n = IR.number(0);
+    typeCheck(IR.exprResult(n));
+
+    assertTypeEquals(getNativeNumberType(), n.getJSType());
   }
 
   @Test
-  public void testGlobalThisDoesNotIncludeVarsDeclaredWithConst() {
-    newTest()
-        .addSource(
-            "/** @param {string} msg */ ", //
-            "const alert = function(msg) {};",
-            "this.alert('boo');")
-        .addDiagnostic("Property alert never defined on global this")
-        .run();
+  public void testStringNode() {
+    Node n = IR.string("hello");
+    typeCheck(IR.exprResult(n));
+
+    assertTypeEquals(getNativeStringType(), n.getJSType());
   }
 
   @Test
-  public void testGlobalThisDoesNotIncludeVarsDeclaredWithLet() {
-    newTest()
-        .addSource(
-            "/** @param {string} msg */ ", //
-            "let alert = function(msg) {};",
-            "this.alert('boo');")
-        .addDiagnostic("Property alert never defined on global this")
-        .run();
+  public void testBooleanNodeTrue() {
+    Node trueNode = IR.trueNode();
+    typeCheck(IR.exprResult(trueNode));
+
+    assertTypeEquals(getNativeBooleanType(), trueNode.getJSType());
   }
 
   @Test
-  public void testControlFlowRestrictsType1() {
-    newTest()
-        .addSource(
-            "/** @return {String?} */ function f() { return null; }"
-                + "/** @type {String?} */ var a = f();"
-                + "/** @type {String} */ var b = new String('foo');"
-                + "/** @type {null} */ var c = null;"
-                + "if (a) {"
-                + "  b = a;"
-                + "} else {"
-                + "  c = a;"
-                + "}")
-        .run();
+  public void testBooleanNodeFalse() {
+    Node falseNode = IR.falseNode();
+    typeCheck(IR.exprResult(falseNode));
+
+    assertTypeEquals(getNativeBooleanType(), falseNode.getJSType());
   }
 
   @Test
-  public void testControlFlowRestrictsType2() {
+  public void testUndefinedNode() {
+    Node p = new Node(Token.ADD);
+    Node n = Node.newString(Token.NAME, "undefined");
+    p.addChildToBack(n);
+    p.addChildToBack(Node.newNumber(5));
+    typeCheck(IR.exprResult(p));
+
+    assertTypeEquals(getNativeVoidType(), n.getJSType());
+  }
+
+  @Test
+  public void testNumberAutoboxing() {
     newTest()
-        .addSource(
-            "/** @return {(string|null)} */ function f() { return null; }"
-                + "/** @type {(string|null)} */ var a = f();"
-                + "/** @type {string} */ var b = 'foo';"
-                + "/** @type {null} */ var c = null;"
-                + "if (a) {"
-                + "  b = a;"
-                + "} else {"
-                + "  c = a;"
-                + "}")
-        .addDiagnostic("assignment\n" + "found   : (null|string)\n" + "required: null")
+        .addSource("/** @type {Number} */var a = 4;")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: (Number|null)")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType3() {
+  public void testNumberUnboxing() {
     newTest()
-        .addSource(
-            "/** @type {(string|void)} */"
-                + "var a;"
-                + "/** @type {string} */"
-                + "var b = 'foo';"
-                + "if (a) {"
-                + "  b = a;"
-                + "}")
+        .addSource("/** @type {number} */var a = new Number(4);")
+        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType4() {
+  public void testStringAutoboxing() {
     newTest()
-        .addSource(
-            "/** @param {string} a */ function f(a){}"
-                + "/** @type {(string|undefined)} */ var a;"
-                + "a && f(a);")
+        .addSource("/** @type {String} */var a = 'hello';")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: (String|null)")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType5() {
+  public void testStringUnboxing() {
     newTest()
-        .addSource(
-            "/** @param {undefined} a */ function f(a){}"
-                + "/** @type {(!Array|undefined)} */ var a;"
-                + "a || f(a);")
+        .addSource("/** @type {string} */var a = new String('hello');")
+        .addDiagnostic("initializing variable\n" + "found   : String\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType6() {
+  public void testBooleanAutoboxing() {
     newTest()
-        .addSource(
-            "/** @param {undefined} x */ function f(x) {}"
-                + "/** @type {(string|undefined)} */ var a;"
-                + "a && f(a);")
+        .addSource("/** @type {Boolean} */var a = true;")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: undefined")
+            "initializing variable\n" + "found   : boolean\n" + "required: (Boolean|null)")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType7() {
+  public void testBooleanUnboxing() {
     newTest()
-        .addSource(
-            "/** @param {undefined} x */ function f(x) {}"
-                + "/** @type {(string|undefined)} */ var a;"
-                + "a && f(a);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: undefined")
+        .addSource("/** @type {boolean} */var a = new Boolean(false);")
+        .addDiagnostic("initializing variable\n" + "found   : Boolean\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType8() {
+  public void testIIFE1() {
     newTest()
         .addSource(
-            "/** @param {undefined} a */ function f(a){}"
-                + "/** @type {(!Array|undefined)} */ var a;"
-                + "if (a || f(a)) {}")
+            "var namespace = {};"
+                + "/** @type {number} */ namespace.prop = 3;"
+                + "(function(ns) {"
+                + "  ns.prop = true;"
+                + "})(namespace);")
+        .addDiagnostic(
+            "assignment to property prop of ns\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType9() {
+  public void testIIFE2() {
     newTest()
         .addSource(
-            "/** @param {number?} x\n * @return {number}*/\n"
-                + "var f = function(x) {\n"
-                + "if (!x || x == 1) { return 1; } else { return x; }\n"
-                + "};")
+            "/** @constructor */ function Foo() {}"
+                + "(function(ctor) {"
+                + "  /** @type {boolean} */ ctor.prop = true;"
+                + "})(Foo);"
+                + "/** @return {number} */ function f() { return Foo.prop; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType10() {
-    // We should correctly infer that y will be (null|{}) because
-    // the loop wraps around.
+  public void testIIFE3() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "function g() {"
-                + "  var y = null;"
-                + "  for (var i = 0; i < 10; i++) {"
-                + "    f(y);"
-                + "    if (y != null) {"
-                + "      // y is None the first time it goes through this branch\n"
-                + "    } else {"
-                + "      y = {};"
-                + "    }"
-                + "  }"
-                + "};")
+            "/** @constructor */ function Foo() {}"
+                + "(function(ctor) {"
+                + "  /** @type {boolean} */ ctor.prop = true;"
+                + "})(Foo);"
+                + "/** @param {number} x */ function f(x) {}"
+                + "f(Foo.prop);")
         .addDiagnostic(
             "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (null|{})\n"
+                + "found   : boolean\n"
                 + "required: number")
         .run();
   }
 
   @Test
-  public void testControlFlowRestrictsType11() {
+  public void testIIFE4() {
     newTest()
         .addSource(
-            "/** @param {boolean} x */ function f(x) {}"
-                + "function g() {"
-                + "  var y = null;"
-                + "  if (y != null) {"
-                + "    for (var i = 0; i < 10; i++) {"
-                + "      f(y);"
-                + "    }"
-                + "  }"
-                + "};")
-        .addDiagnostic("condition always evaluates to false\n" + "left : null\n" + "right: null")
+            "/** @const */ var namespace = {};"
+                + "(function(ns) {"
+                + "  /**\n"
+                + "   * @constructor\n"
+                + "   * @param {number} x\n"
+                + "   */\n"
+                + "   ns.Ctor = function(x) {};"
+                + "})(namespace);"
+                + "new namespace.Ctor(true);")
+        .addDiagnostic(
+            "actual parameter 1 of namespace.Ctor "
+                + "does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testSwitchCase_primitiveDoesNotAutobox() {
+  public void testIIFE5() {
+    // TODO(nicksantos): This behavior is currently incorrect.
+    // To handle this case properly, we'll need to change how we handle
+    // type resolution.
     newTest()
         .addSource(
-            "/** @type {!String} */", //
-            "var a = new String('foo');",
-            "switch (a) { case 'A': }")
-        .addDiagnostic(
-            lines(
-                "case expression doesn't match switch", //
-                "found   : string",
-                "required: String"))
+            "/** @const */ var namespace = {};"
+                + "(function(ns) {"
+                + "  /**\n"
+                + "   * @constructor\n"
+                + "   */\n"
+                + "   ns.Ctor = function() {};"
+                + "   /** @type {boolean} */ ns.Ctor.prototype.bar = true;"
+                + "})(namespace);"
+                + "/** @param {namespace.Ctor} x\n"
+                + "  * @return {number} */ function f(x) { return x.bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testSwitchCase_unknownSwitchExprMatchesAnyCase() {
+  public void testNotIIFE1() {
     newTest()
         .addSource(
-            "var a = unknown;", //
-            "switch (a) { case 'A':break; case null:break; }")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @param {...?} x */ function g(x) {}"
+                + "g(function(y) { f(y); }, true);")
         .run();
   }
 
   @Test
-  public void testSwitchCase_doesNotAutoboxStringToMatchNullableUnion() {
+  public void testEnums() {
     newTest()
         .addSource(
-            "/** @type {?String} */",
-            "var a = unknown;",
-            "switch (a) { case 'A':break; case null:break; }")
-        .addDiagnostic(
-            lines(
-                "case expression doesn't match switch",
-                "found   : string",
-                "required: (String|null)"))
+            "var outer = function() {"
+                + "  /** @enum {number} */"
+                + "  var Level = {"
+                + "    NONE: 0,"
+                + "  };"
+                + "  /** @type {!Level} */"
+                + "  var l = Level.NONE;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testSwitchCase_doesNotAutoboxNumberToMatchNullableUnion() {
+  public void testStrictInterfaceCheck() {
     newTest()
         .addSource(
-            "/** @type {?Number} */",
-            "var a = unknown;",
-            "switch (a) { case 5:break; case null:break; }")
-        .addDiagnostic(
-            lines(
-                "case expression doesn't match switch",
-                "found   : number",
-                "required: (Number|null)"))
+            "/** @interface */",
+            "function EventTarget() {}",
+            "/** @constructor \n * @implements {EventTarget} */",
+            "function Node() {}",
+            "/** @type {number} */ Node.prototype.index;",
+            "/** @param {EventTarget} x \n * @return {string} */",
+            "function foo(x) { return x.index; }")
+        .addDiagnostic("Property index never defined on EventTarget")
         .run();
   }
 
   @Test
-  public void testSwitchCase7() {
-    // This really tests the inference inside the case.
+  public void testTemplateSubtyping_0() {
+    // TODO(b/145145406): This is testing that things work despite this bug.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {number} x\n"
-                + " * @return {number}\n"
-                + " */\n"
-                + "function g(x) { return 5; }"
-                + "function f() {"
-                + "  var x = {};"
-                + "  x.foo = '3';"
-                + "  switch (3) { case g(x.foo): return 3; }"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            // IFoo is a NamedType here.
+            "/** @implements {IFoo<number>} */",
+            "class Foo { }",
+            "",
+            "/**",
+            " * @template T",
+            " * @interface",
+            " */",
+            "class IFoo { }",
+            "",
+            "const /** !IFoo<number> */ x = new Foo();")
         .run();
   }
 
   @Test
-  public void testSwitchCase8() {
-    // This really tests the inference inside the switch clause.
+  public void testTemplateSubtyping_1() {
+    // TOOD(b/139230800): This is testing things work despite this bug.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {number} x\n"
-                + " * @return {number}\n"
-                + " */\n"
-                + "function g(x) { return 5; }"
-                + "function f() {"
-                + "  var x = {};"
-                + "  x.foo = '3';"
-                + "  switch (g(x.foo)) { case 3: return 3; }"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            "/**",
+            " * @template T",
+            " * @interface",
+            " */",
+            "class IFoo { }",
+            "",
+            "/** @implements {IFoo<number>} */",
+            "class FooA { }",
+            "",
+            "/** @implements {IFoo<string>} */",
+            "class FooB extends FooA { }",
+            "",
+            "const /** !IFoo<number> */ x = new FooB();",
+            "const /** !IFoo<string> */ y = new FooB();")
         .run();
   }
 
   @Test
-  public void testSwitchCase_allowsStructuralMatching() {
+  public void testTypedefBeforeUse() {
     newTest()
         .addSource(
-            "/** @record */",
-            "class R {",
-            "  constructor() {",
-            "    /** @type {string} */",
-            "    this.str;",
-            "  }",
-            "}",
-            "/** @record */",
-            "class S {",
-            "  constructor() {",
-            "    /** @type {string} */",
-            "    this.str;",
-            "    /** @type {number} */",
-            "    this.num;",
-            "  }",
-            "}",
-            " /**",
-            " * @param {!R} r",
-            " * @param {!S} s",
-            " */",
-            "function f(r, s) {",
-            "  switch (r) {",
-            "    case s:",
-            "      return true;",
-            "  }",
-            "}")
+            "/** @typedef {Object<string, number>} */"
+                + "var map;"
+                + "/** @param {(map|function())} isResult */"
+                + "var f = function(isResult) {"
+                + "    while (true)"
+                + "        isResult['t'];"
+                + "};")
         .run();
   }
 
   @Test
-  public void testImplicitCast1() {
+  public void testScopedConstructors1() {
     newTest()
-        .addExterns(
-            "/** @constructor */ function Element() {};\n"
-                + "/** @type {string}\n"
-                + "  * @implicitCast */"
-                + "Element.prototype.innerHTML;")
-        .addSource("(new Element).innerHTML = new Array();")
+        .addSource(
+            "function foo1() { "
+                + "  /** @constructor */ function Bar() { "
+                + "    /** @type {number} */ this.x = 3;"
+                + "  }"
+                + "}"
+                + "function foo2() { "
+                + "  /** @constructor */ function Bar() { "
+                + "    /** @type {string} */ this.x = 'y';"
+                + "  }"
+                + "  /** "
+                + "   * @param {Bar} b\n"
+                + "   * @return {number}\n"
+                + "   */"
+                + "  function baz(b) { return b.x; }"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testImplicitCast2() {
+  public void testScopedConstructors2() {
     newTest()
-        .addExterns(
-            "/** @constructor */ function Element() {};\n"
-                + "/**\n"
-                + " * @type {string}\n"
-                + " * @implicitCast\n"
-                + " */\n"
-                + "Element.prototype.innerHTML;\n")
         .addSource(
-            "/** @constructor */ function C(e) {\n"
-                + "  /** @type {Element} */ this.el = e;\n"
-                + "}\n"
-                + "C.prototype.method = function() {\n"
-                + "  this.el.innerHTML = new Array();\n"
-                + "};\n")
+            "/** @param {Function} f */"
+                + "function foo1(f) {"
+                + "  /** @param {Function} g */"
+                + "  f.prototype.bar = function(g) {};"
+                + "}")
         .run();
   }
 
   @Test
-  public void testImplicitCast3() {
+  public void testQualifiedNameInference1() {
     newTest()
-        .addExterns(
-            "/** @constructor */ function Element() {};",
-            "/**",
-            " * @type {string}",
-            " * @implicitCast",
-            " */",
-            "Element.prototype.innerHTML;")
         .addSource(
-            "/** @param {?Element} element",
-            " * @param {string|number} text",
-            " */",
-            "function f(element, text) {",
-            "  element.innerHTML = text;",
-            "}",
-            "")
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {number?} */ Foo.prototype.bar = null;"
+                + "/** @type {number?} */ Foo.prototype.baz = null;"
+                + "/** @param {Foo} foo */"
+                + "function f(foo) {"
+                + "  while (true) {"
+                + "    if (!foo.baz) break; "
+                + "    foo.bar = null;"
+                + "  }"
+                +
+                // Tests a bug where this condition always evaluated to true.
+                "  return foo.bar == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testImplicitCastSubclassAccess() {
+  public void testQualifiedNameInference2() {
     newTest()
-        .addExterns(
-            "/** @constructor */ function Element() {};\n"
-                + "/** @type {string}\n"
-                + "  * @implicitCast */"
-                + "Element.prototype.innerHTML;"
-                + "/** @constructor \n @extends Element */"
-                + "function DIVElement() {};")
-        .addSource("(new DIVElement).innerHTML = new Array();")
+        .addSource(
+            "var x = {};"
+                + "x.y = c;"
+                + "function f(a, b) {"
+                + "  if (a) {"
+                + "    if (b) "
+                + "      x.y = 2;"
+                + "    else "
+                + "      x.y = 1;"
+                + "  }"
+                + "  return x.y == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testImplicitCastNotInExterns() {
-    // We issue a warning in CheckJSDoc for @implicitCast not in externs
+  public void testQualifiedNameInference3() {
     newTest()
         .addSource(
-            "/** @constructor */ function Element() {};",
-            "/**",
-            " * @type {string}",
-            " * @implicitCast ",
-            " */",
-            "Element.prototype.innerHTML;",
-            "(new Element).innerHTML = new Array();")
-        .addDiagnostic(
-            lines(
-                "assignment to property innerHTML of Element", // preserve new line
-                "found   : Array<?>",
-                "required: string"))
+            "var x = {};"
+                + "x.y = c;"
+                + "function f(a, b) {"
+                + "  if (a) {"
+                + "    if (b) "
+                + "      x.y = 2;"
+                + "    else "
+                + "      x.y = 1;"
+                + "  }"
+                + "  return x.y == null;"
+                + "} function g() { x.y = null; }")
         .run();
   }
 
   @Test
-  public void testNumberNode() {
-    Node n = IR.number(0);
-    typeCheck(IR.exprResult(n));
-
-    assertTypeEquals(getNativeNumberType(), n.getJSType());
+  public void testQualifiedNameInference4() {
+    newTest()
+        .addSource(
+            "/** @param {string} x */ function f(x) {}\n"
+                + "/**\n"
+                + " * @param {?string} x \n"
+                + " * @constructor\n"
+                + " */"
+                + "function Foo(x) { this.x_ = x; }\n"
+                + "Foo.prototype.bar = function() {"
+                + "  if (this.x_) { f(this.x_); }"
+                + "};")
+        .run();
   }
 
   @Test
-  public void testStringNode() {
-    Node n = IR.string("hello");
-    typeCheck(IR.exprResult(n));
-
-    assertTypeEquals(getNativeStringType(), n.getJSType());
-  }
-
-  @Test
-  public void testBooleanNodeTrue() {
-    Node trueNode = IR.trueNode();
-    typeCheck(IR.exprResult(trueNode));
-
-    assertTypeEquals(getNativeBooleanType(), trueNode.getJSType());
-  }
-
-  @Test
-  public void testBooleanNodeFalse() {
-    Node falseNode = IR.falseNode();
-    typeCheck(IR.exprResult(falseNode));
-
-    assertTypeEquals(getNativeBooleanType(), falseNode.getJSType());
-  }
-
-  @Test
-  public void testUndefinedNode() {
-    Node p = new Node(Token.ADD);
-    Node n = Node.newString(Token.NAME, "undefined");
-    p.addChildToBack(n);
-    p.addChildToBack(Node.newNumber(5));
-    typeCheck(IR.exprResult(p));
-
-    assertTypeEquals(getNativeVoidType(), n.getJSType());
-  }
-
-  @Test
-  public void testNumberAutoboxing() {
-    newTest()
-        .addSource("/** @type {Number} */var a = 4;")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: (Number|null)")
-        .run();
-  }
-
-  @Test
-  public void testNumberUnboxing() {
-    newTest()
-        .addSource("/** @type {number} */var a = new Number(4);")
-        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testStringAutoboxing() {
-    newTest()
-        .addSource("/** @type {String} */var a = 'hello';")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: (String|null)")
-        .run();
-  }
-
-  @Test
-  public void testStringUnboxing() {
-    newTest()
-        .addSource("/** @type {string} */var a = new String('hello');")
-        .addDiagnostic("initializing variable\n" + "found   : String\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testBooleanAutoboxing() {
+  public void testQualifiedNameInference5() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource("/** @type {Boolean} */var a = true;")
+        .addSource(
+            "var ns = {}; "
+                + "(function() { "
+                + "    /** @param {number} x */ ns.foo = function(x) {}; })();"
+                + "(function() { ns.foo(true); })();")
         .addDiagnostic(
-            "initializing variable\n" + "found   : boolean\n" + "required: (Boolean|null)")
+            "actual parameter 1 of ns.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testBooleanUnboxing() {
+  public void testQualifiedNameInference6() {
     newTest()
-        .addSource("/** @type {boolean} */var a = new Boolean(false);")
-        .addDiagnostic("initializing variable\n" + "found   : Boolean\n" + "required: boolean")
+        .addSource(
+            "/** @const */ var ns = {}; "
+                + "/** @param {number} x */ ns.foo = function(x) {};"
+                + "(function() { "
+                + "    ns.foo = function(x) {};"
+                + "    ns.foo(true); "
+                + "})();")
+        .addDiagnostic(
+            "actual parameter 1 of ns.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIIFE1() {
+  public void testQualifiedNameInference7() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "var namespace = {};"
-                + "/** @type {number} */ namespace.prop = 3;"
-                + "(function(ns) {"
-                + "  ns.prop = true;"
-                + "})(namespace);")
+            "var ns = {}; "
+                + "(function() { "
+                + "  /** @constructor \n * @param {number} x */ "
+                + "  ns.Foo = function(x) {};"
+                + "  /** @param {ns.Foo} x */ function f(x) {}"
+                + "  f(new ns.Foo(true));"
+                + "})();")
         .addDiagnostic(
-            "assignment to property prop of ns\n" + "found   : boolean\n" + "required: number")
+            "actual parameter 1 of ns.Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIIFE2() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "(function(ctor) {"
-                + "  /** @type {boolean} */ ctor.prop = true;"
-                + "})(Foo);"
-                + "/** @return {number} */ function f() { return Foo.prop; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testQualifiedNameInference8() {
+    disableStrictMissingPropertyChecks();
+    testClosureTypesMultipleWarnings(
+        "var ns = {}; "
+            + "(function() { "
+            + "  /** @constructor \n * @param {number} x */ "
+            + "  ns.Foo = function(x) {};"
+            + "})();"
+            + "/** @param {ns.Foo} x */ function f(x) {}"
+            + "f(new ns.Foo(true));",
+        ImmutableList.of(
+            "actual parameter 1 of ns.Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number"));
   }
 
   @Test
-  public void testIIFE3() {
+  public void testQualifiedNameInference9() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "(function(ctor) {"
-                + "  /** @type {boolean} */ ctor.prop = true;"
-                + "})(Foo);"
-                + "/** @param {number} x */ function f(x) {}"
-                + "f(Foo.prop);")
+            "var ns = {}; "
+                + "ns.ns2 = {}; "
+                + "(function() { "
+                + "  /** @constructor \n * @param {number} x */ "
+                + "  ns.ns2.Foo = function(x) {};"
+                + "  /** @param {ns.ns2.Foo} x */ function f(x) {}"
+                + "  f(new ns.ns2.Foo(true));"
+                + "})();")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
+            "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n"
                 + "found   : boolean\n"
                 + "required: number")
         .run();
   }
 
   @Test
-  public void testIIFE4() {
+  public void testQualifiedNameInference10() {
     newTest()
         .addSource(
-            "/** @const */ var namespace = {};"
-                + "(function(ns) {"
-                + "  /**\n"
-                + "   * @constructor\n"
-                + "   * @param {number} x\n"
-                + "   */\n"
-                + "   ns.Ctor = function(x) {};"
-                + "})(namespace);"
-                + "new namespace.Ctor(true);")
-        .addDiagnostic(
-            "actual parameter 1 of namespace.Ctor "
-                + "does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "var ns = {}; "
+                + "ns.ns2 = {}; "
+                + "(function() { "
+                + "  /** @interface */ "
+                + "  ns.ns2.Foo = function() {};"
+                + "  /** @constructor \n * @implements {ns.ns2.Foo} */ "
+                + "  function F() {}"
+                + "  (new F());"
+                + "})();")
         .run();
   }
 
   @Test
-  public void testIIFE5() {
-    // TODO(nicksantos): This behavior is currently incorrect.
-    // To handle this case properly, we'll need to change how we handle
-    // type resolution.
+  public void testQualifiedNameInference11() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @const */ var namespace = {};"
-                + "(function(ns) {"
-                + "  /**\n"
-                + "   * @constructor\n"
-                + "   */\n"
-                + "   ns.Ctor = function() {};"
-                + "   /** @type {boolean} */ ns.Ctor.prototype.bar = true;"
-                + "})(namespace);"
-                + "/** @param {namespace.Ctor} x\n"
-                + "  * @return {number} */ function f(x) { return x.bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/** @constructor */ function Foo() {}"
+                + "function f() {"
+                + "  var x = new Foo();"
+                + "  x.onload = function() {"
+                + "    x.onload = null;"
+                + "  };"
+                + "}")
         .run();
   }
 
   @Test
-  public void testNotIIFE1() {
+  public void testQualifiedNameInference12() {
+    disableStrictMissingPropertyChecks();
+    // We should be able to tell that the two 'this' properties
+    // are different.
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @param {...?} x */ function g(x) {}"
-                + "g(function(y) { f(y); }, true);")
+            "/** @param {function(this:Object)} x */ function f(x) {}",
+            "/** @constructor */ function Foo() {",
+            "  /** @type {number} */ this.bar = 3;",
+            "  f(function() { this.bar = true; });",
+            "}")
         .run();
   }
 
   @Test
-  public void testIssue61a() {
+  public void testQualifiedNameInference13() {
     disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "var ns = {};"
-                + "(function() {"
-                + "  /** @param {string} b */"
-                + "  ns.a = function(b) {};"
-                + "})();"
-                + "function d() {"
-                + "  ns.a(123);"
+            "/** @constructor */ function Foo() {}"
+                + "function f(z) {"
+                + "  var x = new Foo();"
+                + "  if (z) {"
+                + "    x.onload = function() {};"
+                + "  } else {"
+                + "    x.onload = null;"
+                + "  };"
                 + "}")
-        .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
         .run();
   }
 
   @Test
-  public void testIssue61b() {
+  public void testQualifiedNameInference14() {
+    // Unconditional blocks don't cause functions to be treated as inferred.
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "(function() {",
-            "  /** @param {string} b */",
-            "  ns.a = function(b) {};",
-            "})();",
-            "ns.a(123);")
+            "/** @constructor */ function Foo() {}",
+            "function f(z) {",
+            "  var x = new Foo();",
+            "  {",
+            "    x.onload = function() {};",
+            "  }",
+            "  {",
+            "    x.onload = null;",
+            "  };",
+            "}")
         .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            lines(
+                "assignment", //
+                "found   : null",
+                "required: function(): undefined"))
         .run();
   }
 
   @Test
-  public void testIssue61c() {
+  public void testScopeQualifiedNamesOnThis() {
+    // Ensure that we don't flow-scope qualified names on 'this' too broadly.
     newTest()
         .addSource(
-            "var ns = {};",
-            "(function() {",
-            "  /** @param {string} b */",
-            "  ns.a = function(b) {};",
-            "})();",
-            "ns.a(123);")
-        .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testIssue86() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.get = function(){};"
-                + "/** @constructor \n * @implements {I} */ function F() {}"
-                + "/** @override */ F.prototype.get = function() { return true; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/** @constructor */ function Foo() {",
+            "  /** @type {!Bar} */",
+            "  this.baz = new Bar();",
+            "}",
+            "Foo.prototype.foo = function() {",
+            "  this.baz.bar();",
+            "};",
+            "/** @constructor */ function Bar() {",
+            "  /** @type {!Foo} */",
+            "  this.baz = new Foo();",
+            "}",
+            "Bar.prototype.bar = function() {",
+            "  this.baz.foo();",
+            "};")
         .run();
   }
 
   @Test
-  public void testIssue124() {
-    newTest()
-        .addSource(
-            "var t = null;"
-                + "function test() {"
-                + "  if (t != null) { t = null; }"
-                + "  t = 1;"
-                + "}")
-        .run();
+  public void testSheqRefinedScope() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */function A() {}\n"
+                + "/** @constructor \n @extends A */ function B() {}\n"
+                + "/** @return {number} */\n"
+                + "B.prototype.p = function() { return 1; }\n"
+                + "/** @param {A} a\n @param {B} b */\n"
+                + "function f(a, b) {\n"
+                + "  b.p();\n"
+                + "  if (a === b) {\n"
+                + "    b.p();\n"
+                + "  }\n"
+                + "}");
+    Node nodeC =
+        n.getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getLastChild();
+    JSType typeC = nodeC.getJSType();
+    assertThat(typeC.isNumber()).isTrue();
+
+    Node nodeB = nodeC.getFirstFirstChild();
+    JSType typeB = nodeB.getJSType();
+    assertThat(typeB.toString()).isEqualTo("B");
   }
 
   @Test
-  public void testIssue124b() {
-    newTest()
-        .addSource(
-            "var t = null;"
-                + "function test() {"
-                + "  if (t != null) { t = null; }"
-                + "  t = undefined;"
-                + "}")
-        .addDiagnostic(
-            "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null")
-        .run();
+  public void testAssignToUntypedVariable() {
+    Node n = parseAndTypeCheck("var z; z = 1;");
+
+    Node assign = n.getLastChild().getFirstChild();
+    Node node = assign.getFirstChild();
+    assertThat(node.getJSType().isUnknownType()).isFalse();
+    assertThat(node.getJSType().toString()).isEqualTo("number");
   }
 
   @Test
-  public void testIssue259() {
-    newTest()
-        .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */"
-                + "var Clock = function() {"
-                + "  /** @constructor */"
-                + "  this.Date = function() {};"
-                + "  f(new this.Date());"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : this.Date\n"
-                + "required: number")
-        .run();
+  public void testAssignToUntypedProperty() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;");
+
+    Node node = n.getLastChild().getFirstChild();
+    assertThat(node.getJSType().isUnknownType()).isFalse();
+    assertThat(node.getJSType().isNumber()).isTrue();
   }
 
   @Test
-  public void testIssue301() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addString().addArray().build())
-        .addSource(
-            "Array.indexOf = function() {};",
-            "var s = 'hello';",
-            "alert(s.toLowerCase.indexOf('1'));")
-        .addDiagnostic("Property indexOf never defined on String.prototype.toLowerCase")
-        .run();
+  public void testNew1() {
+    newTest().addSource("new 4").addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR).run();
   }
 
   @Test
-  public void testIssue368() {
+  public void testNew2() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo(){}"
-                + "/**\n"
-                + " * @param {number} one\n"
-                + " * @param {string} two\n"
-                + " */\n"
-                + "Foo.prototype.add = function(one, two) {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar(){}"
-                + "/** @override */\n"
-                + "Bar.prototype.add = function(ignored) {};"
-                + "(new Bar()).add(1, 2);")
-        .addDiagnostic(
-            "actual parameter 2 of Bar.prototype.add does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+        .addSource("var Math = {}; new Math()")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue380() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addArray().addObject().build())
-        .addSource(
-            "/** @type { function(string): {innerHTML: string} } */",
-            "document.getElementById;",
-            "var list = /** @type {!Array<string>} */ ['hello', 'you'];",
-            "list.push('?');",
-            "document.getElementById('node').innerHTML = list.toString();")
-        .run();
+  public void testNew3() {
+    newTest().addSource("new Date()").run();
   }
 
   @Test
-  public void testIssue483() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
-        .addSource(
-            "/** @constructor */ function C() {",
-            "  /** @type {?Array} */ this.a = [];",
-            "}",
-            "C.prototype.f = function() {",
-            "  if (this.a.length > 0) {",
-            "    g(this.a);",
-            "  }",
-            "};",
-            "/** @param {number} a */ function g(a) {}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : Array",
-                "required: number"))
-        .run();
+  public void testNew4() {
+    newTest().addSource("/** @constructor */function A(){}; new A();").run();
   }
 
   @Test
-  public void testIssue537a() {
+  public void testNew5() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {method: function() {}};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz()) this.method(1);"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
-                + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic(
-            "Function Foo.prototype.method: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
-        .includeDefaultExterns()
+        .addSource("function A(){}; new A();")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue537b() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {method: function() {}};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz(1)) this.method();"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
-                + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic(
-            "Function Bar.prototype.baz: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
-        .includeDefaultExterns()
-        .run();
+  public void testNew6() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();");
+
+    JSType aType = p.scope.getVar("a").getType();
+    assertThat(aType).isInstanceOf(ObjectType.class);
+    ObjectType aObjectType = (ObjectType) aType;
+    assertThat(aObjectType.getConstructor().getReferenceName()).isEqualTo("A");
   }
 
   @Test
-  public void testIssue537c() {
+  public void testNew7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz2()) alert(1);"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
-                + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic("Property baz2 never defined on Bar")
-        .includeDefaultExterns()
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "if (opt_constructor) { new opt_constructor; }"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue537d() {
+  public void testNew8() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {"
-                + "  /** @return {Bar} */ x: function() { new Bar(); },"
-                + "  /** @return {Foo} */ y: function() { new Bar(); }"
-                + "};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  this.xy = 3;"
-                + "}"
-                + "/** @return {Bar} */ function f() { return new Bar(); }"
-                + "/** @return {Foo} */ function g() { return new Bar(); }"
-                + "Bar.prototype = {"
-                + "  /** @override @return {Bar} */ x: function() { new Bar(); },"
-                + "  /** @override @return {Foo} */ y: function() { new Bar(); }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .includeDefaultExterns()
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "new opt_constructor;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue586() {
+  public void testNew9() {
     newTest()
         .addSource(
-            "/** @constructor */"
-                + "var MyClass = function() {};"
-                + "/** @param {boolean} success */"
-                + "MyClass.prototype.fn = function(success) {};"
-                + "MyClass.prototype.test = function() {"
-                + "  this.fn();"
-                + "  this.fn = function() {};"
-                + "};")
-        .addDiagnostic(
-            "Function MyClass.prototype.fn: called with 0 argument(s). "
-                + "Function requires at least 1 argument(s) "
-                + "and no more than 1 argument(s).")
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "new (opt_constructor || Array);"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue635() {
-    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+  public void testNew10() {
     newTest()
         .addSource(
-            "/** @constructor */"
-                + "function F() {}"
-                + "F.prototype.bar = function() { this.baz(); };"
-                + "F.prototype.baz = function() {};"
-                + "/** @constructor */"
-                + "function G() {}"
-                + "G.prototype.bar = F.prototype.bar;")
+            "var goog = {};"
+                + "/** @param {Function} opt_constructor */"
+                + "goog.Foo = function(opt_constructor) {"
+                + "new (opt_constructor || Array);"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue635b() {
+  public void testNew11() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function F() {}",
-            "/** @constructor */",
-            "function G() {}",
-            "/** @type {function(new:G)} */ var x = F;")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (typeof F)",
-                "required: function(new:G): ?"))
+            "/** @param {Function} c1 */"
+                + "function f(c1) {"
+                + "  var c2 = function(){};"
+                + "  c1.prototype = new c2;"
+                + "}")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue669() {
-    newTest()
-        .addSource(
-            "/** @return {{prop1: (Object|undefined)}} */"
-                + "function f(a) {"
-                + "  var results;"
-                + "  if (a) {"
-                + "    results = {};"
-                + "    results.prop1 = {a: 3};"
-                + "  } else {"
-                + "    results = {prop2: 3};"
-                + "  }"
-                + "  return results;"
-                + "}")
-        .run();
+  public void testNew12() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertTypeEquals(getNativeArrayType(), a.getType());
   }
 
   @Test
-  public void testIssue688() {
-    newTest()
-        .addSource(
-            "/** @const */ var SOME_DEFAULT =\n"
-                + "    /** @type {TwoNumbers} */ ({first: 1, second: 2});\n"
-                + "/**\n"
-                + "* Class defining an interface with two numbers.\n"
-                + "* @interface\n"
-                + "*/\n"
-                + "function TwoNumbers() {}\n"
-                + "/** @type {number} */\n"
-                + "TwoNumbers.prototype.first;\n"
-                + "/** @type {number} */\n"
-                + "TwoNumbers.prototype.second;\n"
-                + "/** @return {number} */ function f() { return SOME_DEFAULT; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (TwoNumbers|null)\n" + "required: number")
-        .run();
+  public void testNew13() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "/** @constructor */function FooBar(){};" + "var a = new FooBar();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("FooBar");
   }
 
   @Test
-  public void testTypeofBigInt() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @param {bigint|number} i",
-            " * @return {boolean}",
-            " */",
-            "function foo(i) {",
-            "  return typeof i === 'bigint';",
-            "}")
-        .run();
+  public void testNew14() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("FooBar");
   }
 
   @Test
-  public void testIssue700() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {{text: string}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp1(opt_data) {\n"
-                + "  return opt_data.text;\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp2(opt_data) {\n"
-                + "  /** @suppress {checkTypes} */\n"
-                + "  function __inner() {\n"
-                + "    return temp1(opt_data.activity);\n"
-                + "  }\n"
-                + "  return __inner();\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {{n: number, text: string, b: boolean}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp3(opt_data) {\n"
-                + "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n"
-                + "}\n"
-                + "\n"
-                + "function callee() {\n"
-                + "  var output = temp3({\n"
-                + "    n: 0,\n"
-                + "    text: 'a string',\n"
-                + "    b: true\n"
-                + "  })\n"
-                + "  alert(output);\n"
-                + "}\n"
-                + "\n"
-                + "callee();")
-        .run();
+  public void testNew15() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){};"
+                + "var a = new goog.A();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("goog.A");
   }
 
   @Test
-  public void testIssue725() {
+  public void testNew16() {
     newTest()
         .addSource(
-            "/** @typedef {{name: string}} */ var RecordType1;"
-                + "/** @typedef {{name2222: string}} */ var RecordType2;"
-                + "/** @param {RecordType1} rec */ function f(rec) {"
-                + "  alert(rec.name2222);"
-                + "}")
-        .addDiagnostic("Property name2222 never defined on rec")
+            "/** \n"
+                + " * @param {string} x \n"
+                + " * @constructor \n"
+                + " */"
+                + "function Foo(x) {}"
+                + "function g() { new Foo(1); }")
+        .addDiagnostic(
+            "actual parameter 1 of Foo does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testIssue726() {
+  public void testNew17() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @return {!Function} */ "
-                + "Foo.prototype.getDeferredBar = function() { "
-                + "  var self = this;"
-                + "  return function() {"
-                + "    self.bar(true);"
-                + "  };"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+        .addSource("var goog = {}; goog.x = 3; new goog.x")
+        .addDiagnostic("cannot instantiate non-constructor")
         .run();
   }
 
   @Test
-  public void testIssue765() {
+  public void testNew18() {
     newTest()
         .addSource(
-            "/** @constructor */"
-                + "var AnotherType = function(parent) {"
-                + "    /** @param {string} stringParameter Description... */"
-                + "    this.doSomething = function(stringParameter) {};"
-                + "};"
-                + "/** @constructor */"
-                + "var YetAnotherType = function() {"
-                + "    this.field = new AnotherType(self);"
-                + "    this.testfun=function(stringdata) {"
-                + "        this.field.doSomething(null);"
-                + "    };"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of AnotherType.doSomething "
-                + "does not match formal parameter\n"
-                + "found   : null\n"
-                + "required: string")
+            "var goog = {};"
+                + "/** @constructor */ goog.F = function() {};"
+                + "/** @constructor */ goog.G = goog.F;")
         .run();
   }
 
   @Test
-  public void testIssue783() {
+  public void testNew19() {
     newTest()
-        .addSource(
-            "/** @constructor */"
-                + "var Type = function() {"
-                + "  /** @type {Type} */"
-                + "  this.me_ = this;"
-                + "};"
-                + "Type.prototype.doIt = function() {"
-                + "  var me = this.me_;"
-                + "  for (var i = 0; i < me.unknownProp; i++) {}"
-                + "};")
-        .addDiagnostic("Property unknownProp never defined on Type")
+        .addSource("/** @constructor @abstract */ var Foo = function() {}; var foo = new Foo();")
+        .addDiagnostic(INSTANTIATE_ABSTRACT_CLASS)
         .run();
   }
 
   @Test
-  public void testIssue791() {
+  public void testNew20() {
     newTest()
         .addSource(
-            "/** @param {{func: function()}} obj */"
-                + "function test1(obj) {}"
-                + "var fnStruc1 = {};"
-                + "fnStruc1.func = function() {};"
-                + "test1(fnStruc1);")
+            "/** @constructor @abstract */",
+            "function Bar() {};",
+            "/** @return {function(new:Bar)} */",
+            "function foo() {}",
+            "var Foo = foo();",
+            "var f = new Foo;")
         .run();
   }
 
   @Test
-  public void testIssue810() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "var Type = function() {",
-            "  this.prop = x;",
-            "};",
-            "Type.prototype.doIt = function(obj) {",
-            "  this.prop = obj.unknownProp;",
-            "};")
-        .addDiagnostic(
-            "Property unknownProp never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
+  public void testName1() {
+    assertTypeEquals(getNativeVoidType(), testNameNode("undefined"));
   }
 
   @Test
-  public void testIssue1002() {
-    newTest()
-        .addSource(
-            "/** @interface */"
-                + "var I = function() {};"
-                + "/** @constructor @implements {I} */"
-                + "var A = function() {};"
-                + "/** @constructor @implements {I} */"
-                + "var B = function() {};"
-                + "var f = function() {"
-                + "  if (A === B) {"
-                + "    new B();"
-                + "  }"
-                + "};")
-        .run();
+  public void testName2() {
+    assertTypeEquals(getNativeObjectConstructorType(), testNameNode("Object"));
   }
 
   @Test
-  public void testIssue1023() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function F() {}"
-                + "(function() {"
-                + "  F.prototype = {"
-                + "    /** @param {string} x */"
-                + "    bar: function(x) {  }"
-                + "  };"
-                + "})();"
-                + "(new F()).bar(true)")
-        .addDiagnostic(
-            "actual parameter 1 of F.prototype.bar does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: string")
-        .run();
+  public void testName3() {
+    assertTypeEquals(getNativeArrayConstructorType(), testNameNode("Array"));
   }
 
   @Test
-  public void testIssue1047() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C2() {}\n"
-                + "\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C3(c2) {\n"
-                + "  /**\n"
-                + "   * @type {C2} \n"
-                + "   * @private\n"
-                + "   */\n"
-                + "  this.c2_;\n"
-                + "\n"
-                + "  var x = this.c2_.prop;\n"
-                + "}")
-        .addDiagnostic("Property prop never defined on C2")
-        .run();
+  public void testName4() {
+    assertTypeEquals(getNativeDateConstructorType(), testNameNode("Date"));
+  }
+
+  @Test
+  public void testName5() {
+    assertTypeEquals(getNativeRegexpConstructorType(), testNameNode("RegExp"));
+  }
+
+  /** Type checks a NAME node and retrieve its type. */
+  private JSType testNameNode(String name) {
+    Node node = Node.newString(Token.NAME, name);
+    Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
+
+    Node root = IR.root(IR.root(externs), IR.root(parent));
+
+    makeTypeCheck().processForTesting(root.getFirstChild(), root.getSecondChild());
+    return node.getJSType();
   }
 
   @Test
-  public void testIssue1056() {
+  public void testBitOperation1() {
     newTest()
-        .addSource("/** @type {Array} */ var x = null;" + "x.push('hi');")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+        .addSource("/**@return {void}*/function foo(){ ~foo(); }")
+        .addDiagnostic("operator ~ cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testIssue1072() {
+  public void testBitOperation2() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {string} x\n"
-                + " * @return {number}\n"
-                + " */\n"
-                + "var f1 = function(x) {\n"
-                + "  return 3;\n"
-                + "};\n"
-                + "\n"
-                + "/** Function */\n"
-                + "var f2 = function(x) {\n"
-                + "  if (!x) throw new Error()\n"
-                + "  return /** @type {number} */ (f1('x'))\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {string} x\n"
-                + " */\n"
-                + "var f3 = function(x) {};\n"
-                + "\n"
-                + "f1(f3);")
-        .addDiagnostic(
-            "actual parameter 1 of f1 does not match formal parameter\n"
-                + "found   : function(string): undefined\n"
-                + "required: string")
+        .addSource("/**@return {void}*/function foo(){var a = foo()<<3;}")
+        .addDiagnostic("operator << cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testIssue1123() {
+  public void testBitOperation3() {
     newTest()
-        .addSource("/** @param {function(number)} g */ function f(g) {}" + "f(function(a, b) {})")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : function(?, ?): undefined\n"
-                + "required: function(number): ?")
+        .addSource("/**@return {void}*/function foo(){var a = 3<<foo();}")
+        .addDiagnostic("operator << cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testIssue1201() {
+  public void testBitOperation4() {
     newTest()
-        .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "/** @constructor */ function F() {}"
-                + "/** desc */ F.prototype.bar = function() {};"
-                + "g(new F().bar);")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : function(this:F): undefined\n"
-                + "required: function(this:undefined): ?")
+        .addSource("/**@return {void}*/function foo(){var a = foo()>>>3;}")
+        .addDiagnostic("operator >>> cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testIssue1201b() {
+  public void testBitOperation5() {
     newTest()
-        .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "/** @constructor */ function F() {}"
-                + "/** desc */ F.prototype.bar = function() {};"
-                + "var f = new F();"
-                + "g(f.bar.bind(f));")
-        .includeDefaultExterns()
+        .addSource("/**@return {void}*/function foo(){var a = 3>>>foo();}")
+        .addDiagnostic("operator >>> cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testIssue1201c() {
+  public void testBitOperation6() {
     newTest()
-        .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "g(function() { this.alert() })")
+        .addSource("/**@return {!Object}*/function foo(){var a = foo()&3;}")
         .addDiagnostic(
-            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+            "bad left operand to bitwise operator\n"
+                + "found   : Object\n"
+                + "required: (boolean|null|number|string|undefined)")
         .run();
   }
 
   @Test
-  public void testIssue926a() {
-    newTest()
-        .addSource(
-            "/** x */ function error() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @param {string} error\n"
-                + " */\n"
-                + "function C(error) {\n"
-                + " /** @const */ this.e = error;\n"
-                + "}"
-                + "/** @type {number} */ var x = (new C('x')).e;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
-        .run();
+  public void testBitOperation7() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;").run();
   }
 
   @Test
-  public void testIssue926b() {
-    newTest()
-        .addSource(
-            "/** @constructor */\n"
-                + "function A() {\n"
-                + " /** @constructor */\n"
-                + " function B() {}\n"
-                + " /** @type {!B} */ this.foo = new B();"
-                + " /** @type {!B} */ var C = new B();"
-                + "}"
-                + "/** @type {number} */ var x = (new A()).foo;")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: number")
-        .run();
+  public void testBitOperation8() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("var x = void 0; x |= new Number(3);").run();
   }
 
   @Test
-  public void testEnums() {
+  public void testBitOperation9() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
-        .addSource(
-            "var outer = function() {"
-                + "  /** @enum {number} */"
-                + "  var Level = {"
-                + "    NONE: 0,"
-                + "  };"
-                + "  /** @type {!Level} */"
-                + "  var l = Level.NONE;"
-                + "}")
+        .addSource("var x = void 0; x |= {};")
+        .addDiagnostic(
+            "bad right operand to bitwise operator\n"
+                + "found   : {}\n"
+                + "required: (boolean|null|number|string|undefined)")
         .run();
   }
 
-  /**
-   * Tests that the || operator is type checked correctly, that is of the type of the first argument
-   * or of the second argument. See bugid 592170 for more details.
-   */
   @Test
-  public void testBug592170() {
-    newTest()
-        .addSource(
-            "/** @param {Function} opt_f ... */"
-                + "function foo(opt_f) {"
-                + "  /** @type {Function} */"
-                + "  return opt_f || function() {};"
-                + "}")
-        .run();
+  public void testCall1() {
+    newTest().addSource("3();").addDiagnostic("number expressions are not callable").run();
   }
 
   @Test
-  public void testNullishCoalesceTypeIsFirstOrSecondArgument() {
+  public void testCall2() {
     newTest()
-        .addSource(
-            "/** @param {Function} opt_f ... */",
-            "function foo(opt_f) {",
-            "  /** @type {Function} */",
-            "  return opt_f ?? function() {};",
-            "}")
+        .addSource("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: Number")
         .run();
   }
 
-  /**
-   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
-   * of the side on which the undefined value is.
-   */
   @Test
-  public void testBug901455a() {
+  public void testCall3() {
+    // We are checking that an unresolved named type can successfully
+    // meet with a functional type to produce a callable type.
     newTest()
         .addSource(
-            "/** @return {(number|undefined)} */ function a() { return 3; }"
-                + "var b = undefined === a()")
+            "/** @type {Function|undefined} */var opt_f;"
+                + "/** @type {some.unknown.type} */var f1;"
+                + "var f2 = opt_f || f1;"
+                + "f2();")
+        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
         .run();
   }
 
-  /**
-   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
-   * of the side on which the undefined value is.
-   */
   @Test
-  public void testBug901455b() {
+  public void testCall3NullishCoalesce() {
+    // We are checking that an unresolved named type can successfully
+    // meet with a functional type to produce a callable type.
     newTest()
         .addSource(
-            "/** @return {(number|undefined)} */ function a() { return 3; }"
-                + "var b = a() === undefined")
+            "/** @type {Function|undefined} */var opt_f;",
+            "/** @type {some.unknown.type} */var f1;",
+            "var f2 = opt_f ?? f1;",
+            "f2();")
+        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
         .run();
   }
 
-  /** Tests that the match method of strings returns nullable arrays. */
   @Test
-  public void testBug908701() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
-        .addSource(
-            "/** @type {String} */ var s = new String('foo');", //
-            "var b = s.match(/a/) != null;")
+  public void testCall4() {
+    newTest()
+        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
-  /** Tests that named types play nicely with subtyping. */
   @Test
-  public void testBug908625() {
+  public void testCall5() {
     newTest()
-        .addSource(
-            "/** @constructor */function A(){}"
-                + "/** @constructor\n * @extends A */function B(){}"
-                + "/** @param {B} b"
-                + "\n @return {(A|undefined)} */function foo(b){return b}")
+        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
-  /**
-   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
-   * this variable is legal.
-   */
   @Test
-  public void testBug911118a() {
-    // verifying the type assigned to function expressions assigned variables
-    TypedScope s = parseAndTypeCheckWithScope("var a = function(){};").scope;
-    JSType type = s.getVar("a").getType();
-    assertThat(type.toString()).isEqualTo("function(): undefined");
+  public void testCall6() {
+    newTest()
+        .addSource("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: Number")
+        .run();
   }
 
-  /**
-   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
-   * this variable is legal.
-   */
   @Test
-  public void testBug911118b() {
-    // verifying the bug example
+  public void testCall7() {
     newTest()
-        .addSource(
-            "function nullFunction() {};"
-                + "var foo = nullFunction;"
-                + "foo = function() {};"
-                + "foo();")
+        .addSource("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
   @Test
-  public void testBug909000() {
+  public void testCall8() {
     newTest()
-        .addSource(
-            "/** @constructor */function A(){}\n"
-                + "/** @param {!A} a\n"
-                + "@return {boolean}*/\n"
-                + "function y(a) { return a }")
-        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: boolean")
+        .addSource("/** @type {Function|number} */var f;f();")
+        .addDiagnostic("(Function|number) expressions are " + "not callable")
         .run();
   }
 
   @Test
-  public void testBug930117() {
+  public void testCall9() {
     newTest()
-        .addSource("/** @param {boolean} x */function f(x){}" + "f(null);")
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */ goog.Foo = function() {};"
+                + "/** @param {!goog.Foo} a */ var bar = function(a){};"
+                + "bar('abc');")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : null\n"
-                + "required: boolean")
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: goog.Foo")
         .run();
   }
 
   @Test
-  public void testBug1484445() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {number?} */ Foo.prototype.bar = null;"
-                + "/** @type {number?} */ Foo.prototype.baz = null;"
-                + "/** @param {Foo} foo */"
-                + "function f(foo) {"
-                + "  while (true) {"
-                + "    if (foo.bar == null && foo.baz == null) {"
-                + "      foo.bar;"
-                + "    }"
-                + "  }"
-                + "}")
-        .run();
+  public void testCall10() {
+    newTest().addSource("/** @type {Function} */var f;f();").run();
   }
 
   @Test
-  public void testBug1859535() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {Function} childCtor Child class.\n"
-                + " * @param {Function} parentCtor Parent class.\n"
-                + " */"
-                + "var inherits = function(childCtor, parentCtor) {"
-                + "  /** @constructor */"
-                + "  function tempCtor() {};"
-                + "  tempCtor.prototype = parentCtor.prototype;"
-                + "  childCtor.superClass_ = parentCtor.prototype;"
-                + "  childCtor.prototype = new tempCtor();"
-                + "  /** @override */ childCtor.prototype.constructor = childCtor;"
-                + "};"
-                + "/**"
-                + " * @param {Function} constructor\n"
-                + " * @param {Object} var_args\n"
-                + " * @return {Object}\n"
-                + " */"
-                + "var factory = function(constructor, var_args) {"
-                + "  /** @constructor */"
-                + "  var tempCtor = function() {};"
-                + "  tempCtor.prototype = constructor.prototype;"
-                + "  var obj = new tempCtor();"
-                + "  constructor.apply(obj, arguments);"
-                + "  return obj;"
-                + "};")
-        .includeDefaultExterns()
-        .run();
+  public void testCall11() {
+    newTest().addSource("var f = new Function(); f();").run();
   }
 
   @Test
-  public void testBug1940591() {
-    disableStrictMissingPropertyChecks();
+  public void testCall12() {
     newTest()
         .addSource(
-            "/** @type {Object} */"
-                + "var a = {};\n"
-                + "/** @type {number} */\n"
-                + "a.name = 0;\n"
-                + "/**\n"
-                + " * @param {Function} x anything.\n"
-                + " */\n"
-                + "a.g = function(x) { x.name = 'a'; }")
+            "/**",
+            " * @param {*} x",
+            " * @return {number}",
+            " */",
+            "function f(x, y) {",
+            "  return x && x.foo();",
+            "}")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", // preserve new line
+                "found   : *",
+                "required: number"))
+        .addDiagnostic("Property foo never defined on *" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testBug1942972() {
+  public void testCall13() {
+    // Test a case where we use inferred types across scopes.
     newTest()
         .addSource(
-            "var google = {\n"
-                + "  gears: {\n"
-                + "    factory: {},\n"
-                + "    workerPool: {}\n"
-                + "  }\n"
-                + "};\n"
-                + "\n"
-                + "google.gears = {factory: {}};\n")
+            "var x;",
+            "function useX() { var /** string */ str = x(); }",
+            "function setX() { x = /** @return {number} */ () => 3; }")
+        .addDiagnostic(
+            lines(
+                "initializing variable", // preserve new line
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testBug1943776() {
+  public void testFunctionCall1() {
     newTest()
-        .addSource(
-            "/** @return  {{foo: Array}} */" + "function bar() {" + "  return {foo: []};" + "}")
+        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug1987544() {
+  public void testFunctionCall2() {
     newTest()
-        .addSource(
-            "/** @param {string} x */ function foo(x) {}"
-                + "var duration;"
-                + "if (true && !(duration = 3)) {"
-                + " foo(duration);"
-                + "}")
+        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');")
         .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "actual parameter 2 of foo.call does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug1940769() {
+  public void testFunctionCall3() {
     newTest()
         .addSource(
-            "/** @return {!Object} */ "
-                + "function proto(obj) { return obj.prototype; }"
-                + "/** @constructor */ function Map() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Map}\n"
-                + " */"
-                + "function Map2() { Map.call(this); };"
-                + "Map2.prototype = proto(Map);")
+            "/** @param {number} x \n * @constructor */ "
+                + "var Foo = function(x) { this.bar.call(null, x); };"
+                + "/** @type {function(number)} */ Foo.prototype.bar;")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug2335992() {
-    disableStrictMissingPropertyChecks();
-
+  public void testFunctionCall4() {
     newTest()
         .addSource(
-            "/** @return {*} */ function f() { return 3; }"
-                + "var x = f();"
-                + "/** @type {string} */"
-                + "x.y = 3;")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+            "/** @param {string} x \n * @constructor */ "
+                + "var Foo = function(x) { this.bar.call(null, x); };"
+                + "/** @type {function(number)} */ Foo.prototype.bar;")
+        .addDiagnostic(
+            "actual parameter 2 of this.bar.call "
+                + "does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug2341812() {
-    disableStrictMissingPropertyChecks();
-
+  public void testFunctionCall5() {
     newTest()
         .addSource(
-            "/** @interface */"
-                + "function EventTarget() {}"
-                + "/** @constructor \n * @implements {EventTarget} */"
-                + "function Node() {}"
-                + "/** @type {number} */ Node.prototype.index;"
-                + "/** @param {EventTarget} x \n * @return {string} */"
-                + "function foo(x) { return x.index; }")
+            "/** @param {Function} handler \n * @constructor */ "
+                + "var Foo = function(handler) { handler.call(this, x); };")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testStrictInterfaceCheck() {
+  public void testFunctionCall6() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "function EventTarget() {}",
-            "/** @constructor \n * @implements {EventTarget} */",
-            "function Node() {}",
-            "/** @type {number} */ Node.prototype.index;",
-            "/** @param {EventTarget} x \n * @return {string} */",
-            "function foo(x) { return x.index; }")
-        .addDiagnostic("Property index never defined on EventTarget")
+            "/** @param {Function} handler \n * @constructor */ "
+                + "var Foo = function(handler) { handler.apply(this, x); };")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug7701884() {
+  public void testFunctionCall7() {
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "/**",
-            " * @param {Array<T>} x",
-            " * @param {function(T)} y",
-            " * @template T",
-            " */",
-            "var forEach = function(x, y) {",
-            "  for (var i = 0; i < x.length; i++) y(x[i]);",
-            "};",
-            "/** @param {number} x */",
-            "function f(x) {}",
-            "/** @param {?} x */",
-            "function h(x) {",
-            "  var top = null;",
-            "  forEach(x, function(z) { top = z; });",
-            "  if (top) f(top);",
-            "}")
+            "/** @param {Function} handler \n * @param {Object} opt_context */ "
+                + "var Foo = function(handler, opt_context) { "
+                + "  handler.call(opt_context, x);"
+                + "};")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug8017789() {
+  public void testFunctionCall8() {
     newTest()
         .addSource(
-            "/** @param {(map|function())} isResult */"
-                + "var f = function(isResult) {"
-                + "    while (true)"
-                + "        isResult['t'];"
-                + "};"
-                + "/** @typedef {Object<string, number>} */"
-                + "var map;")
+            "/** @param {Function} handler \n * @param {Object} opt_context */ "
+                + "var Foo = function(handler, opt_context) { "
+                + "  handler.apply(opt_context, x);"
+                + "};")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug12441160() {
+  public void testFunctionCall9() {
     newTest()
         .addSource(
-            "/** @param {string} a */ \n"
-                + "function use(a) {};\n"
-                + "/**\n"
-                + " * @param {function(this:THIS)} fn\n"
-                + " * @param {THIS} context \n"
-                + " * @constructor\n"
-                + " * @template THIS\n"
-                + " */\n"
-                + "var P = function(fn, context) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function C() { /** @type {number} */ this.a = 1; }\n"
-                + "\n"
-                + "/** @return {P} */ \n"
-                + "C.prototype.method = function() {\n"
-                + "   return new P(function() { use(this.a); }, this);\n"
-                + "};\n"
-                + "\n")
+            "/** @constructor\n * @template T\n **/ function Foo() {}\n"
+                + "/** @param {T} x */ Foo.prototype.bar = function(x) {}\n"
+                + "var foo = /** @type {Foo<string>} */ (new Foo());\n"
+                + "foo.bar(3);")
         .addDiagnostic(
-            "actual parameter 1 of use does not match formal parameter\n"
+            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
                 + "found   : number\n"
                 + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug13641083a() {
+  public void testFunctionBind1() {
     newTest()
-        .addSource("/** @constructor @struct */ function C() {};" + "new C().bar;")
-        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
+        .addSource(
+            "/** @type {function(string, number): boolean} */"
+                + "function f(x, y) { return true; }"
+                + "f.bind(null, 3);")
+        .addDiagnostic(
+            "actual parameter 2 of f.bind does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testBug13641083b() {
+  public void testFunctionBind2() {
     newTest()
-        .addSource("/** @type {?} */ var C;" + "C.bar + 1;")
-        .addDiagnostic(TypeCheck.POSSIBLE_INEXISTENT_PROPERTY)
+        .addSource(
+            "/** @type {function(number): boolean} */"
+                + "function f(x) { return true; }"
+                + "f(f.bind(null, 3)());")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testTemplateSubtyping_0() {
-    // TODO(b/145145406): This is testing that things work despite this bug.
+  public void testFunctionBind3() {
     newTest()
         .addSource(
-            // IFoo is a NamedType here.
-            "/** @implements {IFoo<number>} */",
-            "class Foo { }",
-            "",
-            "/**",
-            " * @template T",
-            " * @interface",
-            " */",
-            "class IFoo { }",
-            "",
-            "const /** !IFoo<number> */ x = new Foo();")
+            "/** @type {function(number, string): boolean} */"
+                + "function f(x, y) { return true; }"
+                + "f.bind(null, 3)(true);")
+        .addDiagnostic(
+            "actual parameter 1 of function does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testTemplateSubtyping_1() {
-    // TOOD(b/139230800): This is testing things work despite this bug.
-    newTest()
+  public void testFunctionBind4() {
+    this.newTest()
         .addSource(
-            "/**",
-            " * @template T",
-            " * @interface",
-            " */",
-            "class IFoo { }",
-            "",
-            "/** @implements {IFoo<number>} */",
-            "class FooA { }",
-            "",
-            "/** @implements {IFoo<string>} */",
-            "class FooB extends FooA { }",
-            "",
-            "const /** !IFoo<number> */ x = new FooB();",
-            "const /** !IFoo<string> */ y = new FooB();")
+            "/** @param {...number} x */", //
+            "function f(x) {}",
+            "f.bind(null, 3, 3, 3)(true);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of function does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testTypedefBeforeUse() {
-    newTest()
+  public void testFunctionBind5() {
+    this.newTest()
         .addSource(
-            "/** @typedef {Object<string, number>} */"
-                + "var map;"
-                + "/** @param {(map|function())} isResult */"
-                + "var f = function(isResult) {"
-                + "    while (true)"
-                + "        isResult['t'];"
-                + "};")
+            "/** @param {...number} x */", //
+            "function f(x) {}",
+            "f.bind(null, true)(3, 3, 3);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 2 of f.bind does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testScopedConstructors1() {
+  public void testFunctionBind6() {
     newTest()
         .addSource(
-            "function foo1() { "
-                + "  /** @constructor */ function Bar() { "
-                + "    /** @type {number} */ this.x = 3;"
-                + "  }"
-                + "}"
-                + "function foo2() { "
-                + "  /** @constructor */ function Bar() { "
-                + "    /** @type {string} */ this.x = 'y';"
-                + "  }"
-                + "  /** "
-                + "   * @param {Bar} b\n"
-                + "   * @return {number}\n"
-                + "   */"
-                + "  function baz(b) { return b.x; }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
+            "/** @constructor */",
+            "function MyType() {",
+            "  /** @type {number} */",
+            "  this.x = 0;",
+            "  var f = function() {",
+            "    this.x = 'str';",
+            "  }.bind(this);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property x of MyType", //
+                "found   : string",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testScopedConstructors2() {
+  public void testFunctionBind7() {
     newTest()
         .addSource(
-            "/** @param {Function} f */"
-                + "function foo1(f) {"
-                + "  /** @param {Function} g */"
-                + "  f.prototype.bar = function(g) {};"
-                + "}")
+            "/** @constructor */",
+            "function MyType() {",
+            "  /** @type {number} */",
+            "  this.x = 0;",
+            "}",
+            "var m = new MyType;",
+            "(function f() {this.x = 'str';}).bind(m);")
+        .addDiagnostic(
+            lines(
+                "assignment to property x of MyType", //
+                "found   : string",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference1() {
+  public void testFunctionBind8() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {number?} */ Foo.prototype.bar = null;"
-                + "/** @type {number?} */ Foo.prototype.baz = null;"
-                + "/** @param {Foo} foo */"
-                + "function f(foo) {"
-                + "  while (true) {"
-                + "    if (!foo.baz) break; "
-                + "    foo.bar = null;"
-                + "  }"
-                +
-                // Tests a bug where this condition always evaluated to true.
-                "  return foo.bar == null;"
-                + "}")
+            "/** @constructor */",
+            "function MyType() {}",
+            "",
+            "/** @constructor */",
+            "function AnotherType() {}",
+            "AnotherType.prototype.foo = function() {};",
+            "",
+            "/** @type {?} */",
+            "var m = new MyType;",
+            "(function f() {this.foo();}).bind(m);")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference2() {
+  public void testFunctionBind9() {
     newTest()
         .addSource(
-            "var x = {};"
-                + "x.y = c;"
-                + "function f(a, b) {"
-                + "  if (a) {"
-                + "    if (b) "
-                + "      x.y = 2;"
-                + "    else "
-                + "      x.y = 1;"
-                + "  }"
-                + "  return x.y == null;"
-                + "}")
+            "/** @constructor */",
+            "function MyType() {}",
+            "",
+            "/** @constructor */",
+            "function AnotherType() {}",
+            "AnotherType.prototype.foo = function() {};",
+            "",
+            "var m = new MyType;",
+            "(function f() {this.foo();}).bind(m);")
+        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference3() {
-    newTest()
-        .addSource(
-            "var x = {};"
-                + "x.y = c;"
-                + "function f(a, b) {"
-                + "  if (a) {"
-                + "    if (b) "
-                + "      x.y = 2;"
-                + "    else "
-                + "      x.y = 1;"
-                + "  }"
-                + "  return x.y == null;"
-                + "} function g() { x.y = null; }")
-        .run();
+  public void testGoogBind1() {
+    testClosureTypes(
+        "goog.bind = function(var_args) {};"
+            + "/** @type {function(number): boolean} */"
+            + "function f(x, y) { return true; }"
+            + "f(goog.bind(f, null, 'x')());",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : boolean\n"
+            + "required: number");
   }
 
   @Test
-  public void testQualifiedNameInference4() {
+  public void testGoogBind2() {
+    // TODO(nicksantos): We do not currently type-check the arguments
+    // of the goog.bind.
+    testClosureTypes(
+        "goog.bind = function(var_args) {};"
+            + "/** @type {function(boolean): boolean} */"
+            + "function f(x, y) { return true; }"
+            + "f(goog.bind(f, null, 'x')());",
+        null);
+  }
+
+  @Test
+  public void testCast2() {
+    // can upcast to a base type.
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}\n"
-                + "/**\n"
-                + " * @param {?string} x \n"
-                + " * @constructor\n"
-                + " */"
-                + "function Foo(x) { this.x_ = x; }\n"
-                + "Foo.prototype.bar = function() {"
-                + "  if (this.x_) { f(this.x_); }"
-                + "};")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n @extends {base} */function derived() {}\n"
+                + "/** @type {base} */ var baz = new derived();\n")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference5() {
-    disableStrictMissingPropertyChecks();
+  public void testCast3() {
+    // cannot downcast
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "(function() { "
-                + "    /** @param {number} x */ ns.foo = function(x) {}; })();"
-                + "(function() { ns.foo(true); })();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = new base();\n")
+        .addDiagnostic("initializing variable\n" + "found   : base\n" + "required: derived")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference6() {
+  public void testCast3a() {
+    // cannot downcast
     newTest()
         .addSource(
-            "/** @const */ var ns = {}; "
-                + "/** @param {number} x */ ns.foo = function(x) {};"
-                + "(function() { "
-                + "    ns.foo = function(x) {};"
-                + "    ns.foo(true); "
-                + "})();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @constructor */function Base() {}\n"
+                + "/** @constructor @extends {Base} */function Derived() {}\n"
+                + "var baseInstance = new Base();"
+                + "/** @type {!Derived} */ var baz = baseInstance;\n")
+        .addDiagnostic("initializing variable\n" + "found   : Base\n" + "required: Derived")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference7() {
-    disableStrictMissingPropertyChecks();
+  public void testCast4() {
+    // downcast must be explicit
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "(function() { "
-                + "  /** @constructor \n * @param {number} x */ "
-                + "  ns.Foo = function(x) {};"
-                + "  /** @param {ns.Foo} x */ function f(x) {}"
-                + "  f(new ns.Foo(true));"
-                + "})();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = "
+                + "/** @type {!derived} */(new base());\n")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference8() {
-    disableStrictMissingPropertyChecks();
-    testClosureTypesMultipleWarnings(
-        "var ns = {}; "
-            + "(function() { "
-            + "  /** @constructor \n * @param {number} x */ "
-            + "  ns.Foo = function(x) {};"
-            + "})();"
-            + "/** @param {ns.Foo} x */ function f(x) {}"
-            + "f(new ns.Foo(true));",
-        ImmutableList.of(
-            "actual parameter 1 of ns.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number"));
+  public void testCast4Types() {
+    // downcast must be explicit
+    Node root =
+        parseAndTypeCheck(
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = "
+                + "/** @type {!derived} */(new base());\n");
+    Node castedExprNode = root.getLastChild().getFirstFirstChild().getFirstChild();
+    assertThat(castedExprNode.getJSType().toString()).isEqualTo("derived");
+    assertThat(castedExprNode.getJSTypeBeforeCast().toString()).isEqualTo("base");
   }
 
   @Test
-  public void testQualifiedNameInference9() {
+  public void testCast5() {
+    // cannot explicitly cast to an unrelated type
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "ns.ns2 = {}; "
-                + "(function() { "
-                + "  /** @constructor \n * @param {number} x */ "
-                + "  ns.ns2.Foo = function(x) {};"
-                + "  /** @param {ns.ns2.Foo} x */ function f(x) {}"
-                + "  f(new ns.ns2.Foo(true));"
-                + "})();")
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor */function bar() {}\n"
+                + "var baz = /** @type {!foo} */(new bar);\n")
         .addDiagnostic(
-            "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference10() {
+  public void testCast5a() {
+    // cannot explicitly cast to an unrelated type
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "ns.ns2 = {}; "
-                + "(function() { "
-                + "  /** @interface */ "
-                + "  ns.ns2.Foo = function() {};"
-                + "  /** @constructor \n * @implements {ns.ns2.Foo} */ "
-                + "  function F() {}"
-                + "  (new F());"
-                + "})();")
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor */function bar() {}\n"
+                + "var barInstance = new bar;\n"
+                + "var baz = /** @type {!foo} */(barInstance);\n")
+        .addDiagnostic(
+            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference11() {
-    disableStrictMissingPropertyChecks();
+  public void testCast6() {
+    // can explicitly cast to a subtype or supertype
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "function f() {"
-                + "  var x = new Foo();"
-                + "  x.onload = function() {"
-                + "    x.onload = null;"
-                + "  };"
-                + "}")
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor \n @extends foo */function bar() {}\n"
+                + "var baz = /** @type {!bar} */(new bar);\n"
+                + "var baz = /** @type {!foo} */(new foo);\n"
+                + "var baz = /** @type {bar} */(new bar);\n"
+                + "var baz = /** @type {foo} */(new foo);\n"
+                + "var baz = /** @type {!foo} */(new bar);\n"
+                + "var baz = /** @type {!bar} */(new foo);\n"
+                + "var baz = /** @type {foo} */(new bar);\n"
+                + "var baz = /** @type {bar} */(new foo);\n")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference12() {
-    disableStrictMissingPropertyChecks();
-    // We should be able to tell that the two 'this' properties
-    // are different.
+  public void testCast7() {
     newTest()
-        .addSource(
-            "/** @param {function(this:Object)} x */ function f(x) {}",
-            "/** @constructor */ function Foo() {",
-            "  /** @type {number} */ this.bar = 3;",
-            "  f(function() { this.bar = true; });",
-            "}")
+        .addSource("var x = /** @type {foo} */ (new Object());")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference13() {
-    disableStrictMissingPropertyChecks();
+  public void testCast8() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "function f(z) {"
-                + "  var x = new Foo();"
-                + "  if (z) {"
-                + "    x.onload = function() {};"
-                + "  } else {"
-                + "    x.onload = null;"
-                + "  };"
-                + "}")
+        .addSource("function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference14() {
-    // Unconditional blocks don't cause functions to be treated as inferred.
-    disableStrictMissingPropertyChecks();
+  public void testCast9() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "function f(z) {",
-            "  var x = new Foo();",
-            "  {",
-            "    x.onload = function() {};",
-            "  }",
-            "  {",
-            "    x.onload = null;",
-            "  };",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : null",
-                "required: function(): undefined"))
+        .addSource("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testScopeQualifiedNamesOnThis() {
-    // Ensure that we don't flow-scope qualified names on 'this' too broadly.
+  public void testCast10() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {",
-            "  /** @type {!Bar} */",
-            "  this.baz = new Bar();",
-            "}",
-            "Foo.prototype.foo = function() {",
-            "  this.baz.bar();",
-            "};",
-            "/** @constructor */ function Bar() {",
-            "  /** @type {!Foo} */",
-            "  this.baz = new Foo();",
-            "}",
-            "Bar.prototype.bar = function() {",
-            "  this.baz.foo();",
-            "};")
+            "var foo = function() {};"
+                + "function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testSheqRefinedScope() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */function A() {}\n"
-                + "/** @constructor \n @extends A */ function B() {}\n"
-                + "/** @return {number} */\n"
-                + "B.prototype.p = function() { return 1; }\n"
-                + "/** @param {A} a\n @param {B} b */\n"
-                + "function f(a, b) {\n"
-                + "  b.p();\n"
-                + "  if (a === b) {\n"
-                + "    b.p();\n"
-                + "  }\n"
-                + "}");
-    Node nodeC =
-        n.getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getLastChild();
-    JSType typeC = nodeC.getJSType();
-    assertThat(typeC.isNumber()).isTrue();
-
-    Node nodeB = nodeC.getFirstFirstChild();
-    JSType typeB = nodeB.getJSType();
-    assertThat(typeB.toString()).isEqualTo("B");
+  public void testCast11() {
+    newTest()
+        .addSource(
+            "var goog = {}; goog.foo = {};"
+                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+        .run();
   }
 
   @Test
-  public void testAssignToUntypedVariable() {
-    Node n = parseAndTypeCheck("var z; z = 1;");
-
-    Node assign = n.getLastChild().getFirstChild();
-    Node node = assign.getFirstChild();
-    assertThat(node.getJSType().isUnknownType()).isFalse();
-    assertThat(node.getJSType().toString()).isEqualTo("number");
+  public void testCast12() {
+    newTest()
+        .addSource(
+            "var goog = {}; goog.foo = function() {};"
+                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+        .run();
   }
 
   @Test
-  public void testAssignToUntypedProperty() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;");
-
-    Node node = n.getLastChild().getFirstChild();
-    assertThat(node.getJSType().isUnknownType()).isFalse();
-    assertThat(node.getJSType().isNumber()).isTrue();
+  public void testCast13() {
+    // In a typespace world, types and values may collide on the same symbol.
+    testClosureTypes(
+        "goog.forwardDeclare('goog.foo');"
+            + "goog.foo = function() {};"
+            + "function f() { return /** @type {goog.foo} */ (new Object()); }",
+        null);
   }
 
   @Test
-  public void testNew1() {
-    newTest().addSource("new 4").addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR).run();
+  public void testCast14() {
+    // Test to make sure that the forward-declaration still prevents
+    // some warnings.
+    testClosureTypes(
+        "goog.forwardDeclare('goog.bar');"
+            + "function f() { return /** @type {goog.bar} */ (new Object()); }",
+        null);
   }
 
   @Test
-  public void testNew2() {
-    newTest()
-        .addSource("var Math = {}; new Math()")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
-        .run();
-  }
+  public void testCast15() {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a run-time cast exception if the node was visited
+    // more than once.
 
-  @Test
-  public void testNew3() {
-    newTest().addSource("new Date()").run();
-  }
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
 
-  @Test
-  public void testNew4() {
-    newTest().addSource("/** @constructor */function A(){}; new A();").run();
-  }
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testNew5() {
     newTest()
-        .addSource("function A(){}; new A();")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
+        .addSource(
+            "for (var i = 0; i < 10; i++) {",
+            "var x = /** @type {Object|number} */ ({foo: 3});",
+            "/** @param {number} x */ function f(x) {}",
+            "f(x.foo);",
+            "f([].foo);",
+            "}")
+        .addDiagnostic("Property foo never defined on Array<?>")
         .run();
   }
 
   @Test
-  public void testNew6() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();");
-
-    JSType aType = p.scope.getVar("a").getType();
-    assertThat(aType).isInstanceOf(ObjectType.class);
-    ObjectType aObjectType = (ObjectType) aType;
-    assertThat(aObjectType.getConstructor().getReferenceName()).isEqualTo("A");
-  }
+  public void testCast15b() {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a run-time cast exception if the node was visited
+    // more than once.
 
-  @Test
-  public void testNew7() {
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "if (opt_constructor) { new opt_constructor; }"
-                + "}")
+            "for (var i = 0; i < 10; i++) {",
+            "var x = /** @type {{foo:number}}|number} */ ({foo: 3});",
+            "/** @param {number} x */ function f(x) {}",
+            "f(x.foo);",
+            "f([].foo);",
+            "}")
+        .addDiagnostic("Property foo never defined on Array<?>")
         .run();
   }
 
   @Test
-  public void testNew8() {
+  public void testCast16() {
+    // A type cast should not invalidate the checks on the members
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "new opt_constructor;"
+            "for (var i = 0; i < 10; i++) {"
+                + "var x = /** @type {Object|number} */ ("
+                + "  {/** @type {string} */ foo: 3});"
                 + "}")
+        .addDiagnostic(
+            "assignment to property foo of {foo: string}\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testNew9() {
+  public void testCast17a() {
+    // Mostly verifying that rhino actually understands these JsDocs.
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "new (opt_constructor || Array);"
-                + "}")
+            "/** @constructor */ function Foo() {} \n"
+                + "/** @type {Foo} */ var x = /** @type {Foo} */ (y)")
         .run();
   }
 
   @Test
-  public void testNew10() {
+  public void testCast17b() {
+    // Mostly verifying that rhino actually understands these JsDocs.
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @param {Function} opt_constructor */"
-                + "goog.Foo = function(opt_constructor) {"
-                + "new (opt_constructor || Array);"
-                + "}")
+            "/** @constructor */ function Foo() {} \n"
+                + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})")
         .run();
   }
 
   @Test
-  public void testNew11() {
+  public void testCast19() {
     newTest()
         .addSource(
-            "/** @param {Function} c1 */"
-                + "function f(c1) {"
-                + "  var c2 = function(){};"
-                + "  c1.prototype = new c2;"
-                + "}")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
+            "var x = 'string';\n" + "/** @type {number} */\n" + "var y = /** @type {number} */(x);")
+        .addDiagnostic(
+            "invalid cast - must be a subtype or supertype\n" + "from: string\n" + "to  : number")
         .run();
   }
 
   @Test
-  public void testNew12() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertTypeEquals(getNativeArrayType(), a.getType());
+  public void testCast20() {
+    newTest()
+        .addSource(
+            "/** @enum {boolean|null} */\n"
+                + "var X = {"
+                + "  AA: true,"
+                + "  BB: false,"
+                + "  CC: null"
+                + "};\n"
+                + "var y = /** @type {X} */(true);")
+        .run();
   }
 
   @Test
-  public void testNew13() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "/** @constructor */function FooBar(){};" + "var a = new FooBar();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("FooBar");
+  public void testCast21() {
+    newTest()
+        .addSource(
+            "/** @enum {boolean|null} */\n"
+                + "var X = {"
+                + "  AA: true,"
+                + "  BB: false,"
+                + "  CC: null"
+                + "};\n"
+                + "var value = true;\n"
+                + "var y = /** @type {X} */(value);")
+        .run();
   }
 
   @Test
-  public void testNew14() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("FooBar");
+  public void testCast22() {
+    newTest()
+        .addSource("var x = null;\n" + "var y = /** @type {number} */(x);")
+        .addDiagnostic(
+            "invalid cast - must be a subtype or supertype\n" + "from: null\n" + "to  : number")
+        .run();
   }
 
   @Test
-  public void testNew15() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){};"
-                + "var a = new goog.A();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("goog.A");
+  public void testCast23() {
+    newTest().addSource("var x = null;\n" + "var y = /** @type {Number} */(x);").run();
   }
 
   @Test
-  public void testNew16() {
+  public void testCast24() {
     newTest()
-        .addSource(
-            "/** \n"
-                + " * @param {string} x \n"
-                + " * @constructor \n"
-                + " */"
-                + "function Foo(x) {}"
-                + "function g() { new Foo(1); }")
+        .addSource("var x = undefined;\n" + "var y = /** @type {number} */(x);")
         .addDiagnostic(
-            "actual parameter 1 of Foo does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "invalid cast - must be a subtype or supertype\n"
+                + "from: undefined\n"
+                + "to  : number")
         .run();
   }
 
   @Test
-  public void testNew17() {
+  public void testCast25() {
     newTest()
-        .addSource("var goog = {}; goog.x = 3; new goog.x")
-        .addDiagnostic("cannot instantiate non-constructor")
+        .addSource("var x = undefined;\n" + "var y = /** @type {number|undefined} */(x);")
         .run();
   }
 
   @Test
-  public void testNew18() {
+  public void testCast26() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.F = function() {};"
-                + "/** @constructor */ goog.G = goog.F;")
+            "function fn(dir) {\n"
+                + "  var node = dir ? 1 : 2;\n"
+                + "  fn(/** @type {number} */ (node));\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testNew19() {
+  public void testCast27() {
+    // C doesn't implement I but a subtype might.
     newTest()
-        .addSource("/** @constructor @abstract */ var Foo = function() {}; var foo = new Foo();")
-        .addDiagnostic(INSTANTIATE_ABSTRACT_CLASS)
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "var x = new C();\n"
+                + "var y = /** @type {I} */(x);")
         .run();
   }
 
   @Test
-  public void testNew20() {
+  public void testCast27a() {
+    // C doesn't implement I but a subtype might.
     newTest()
         .addSource(
-            "/** @constructor @abstract */",
-            "function Bar() {};",
-            "/** @return {function(new:Bar)} */",
-            "function foo() {}",
-            "var Foo = foo();",
-            "var f = new Foo;")
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {C} */ var x ;\n"
+                + "var y = /** @type {I} */(x);")
         .run();
   }
 
   @Test
-  public void testName1() {
-    assertTypeEquals(getNativeVoidType(), testNameNode("undefined"));
-  }
-
-  @Test
-  public void testName2() {
-    assertTypeEquals(getNativeObjectConstructorType(), testNameNode("Object"));
-  }
-
-  @Test
-  public void testName3() {
-    assertTypeEquals(getNativeArrayConstructorType(), testNameNode("Array"));
+  public void testCast28() {
+    // C doesn't implement I but a subtype might.
+    newTest()
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {!I} */ var x;\n"
+                + "var y = /** @type {C} */(x);")
+        .run();
   }
 
   @Test
-  public void testName4() {
-    assertTypeEquals(getNativeDateConstructorType(), testNameNode("Date"));
+  public void testCast28a() {
+    // C doesn't implement I but a subtype might.
+    newTest()
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {I} */ var x;\n"
+                + "var y = /** @type {C} */(x);")
+        .run();
   }
 
   @Test
-  public void testName5() {
-    assertTypeEquals(getNativeRegexpConstructorType(), testNameNode("RegExp"));
-  }
-
-  /** Type checks a NAME node and retrieve its type. */
-  private JSType testNameNode(String name) {
-    Node node = Node.newString(Token.NAME, name);
-    Node parent = new Node(Token.SCRIPT, node);
-    parent.setInputId(new InputId("code"));
-
-    Node externs = new Node(Token.SCRIPT);
-    externs.setInputId(new InputId("externs"));
-
-    Node root = IR.root(IR.root(externs), IR.root(parent));
-
-    makeTypeCheck().processForTesting(root.getFirstChild(), root.getSecondChild());
-    return node.getJSType();
+  public void testCast29a() {
+    // C doesn't implement the record type but a subtype might.
+    newTest()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "var x = new C();\n"
+                + "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);")
+        .run();
   }
 
   @Test
-  public void testBitOperation1() {
+  public void testCast29b() {
+    // C doesn't implement the record type but a subtype might.
     newTest()
-        .addSource("/**@return {void}*/function foo(){ ~foo(); }")
-        .addDiagnostic("operator ~ cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {C} */ var x;\n"
+                + "var y = /** @type {{prop1: Array, prop2: string}} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation2() {
+  public void testCast29c() {
+    // C doesn't implement the record type but a subtype might.
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = foo()<<3;}")
-        .addDiagnostic("operator << cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n"
+                + "var y = /** @type {C} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation3() {
+  public void testCast30() {
+    // Should be able to cast to a looser return type
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = 3<<foo();}")
-        .addDiagnostic("operator << cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {function():string} */ var x ;\n"
+                + "var y = /** @type {function():?} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation4() {
+  public void testCast31() {
+    // Should be able to cast to a tighter parameter type
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = foo()>>>3;}")
-        .addDiagnostic("operator >>> cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {function(*)} */ var x ;\n"
+                + "var y = /** @type {function(string)} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation5() {
+  public void testCast32() {
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = 3>>>foo();}")
-        .addDiagnostic("operator >>> cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Object} */ var x ;\n"
+                + "var y = /** @type {null|{length:number}} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation6() {
+  public void testCast33a() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
-        .addSource("/**@return {!Object}*/function foo(){var a = foo()&3;}")
-        .addDiagnostic(
-            "bad left operand to bitwise operator\n"
-                + "found   : Object\n"
-                + "required: (boolean|null|number|string|undefined)")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string?|undefined} */(x);")
         .run();
   }
 
   @Test
-  public void testBitOperation7() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;").run();
-  }
-
-  @Test
-  public void testBitOperation8() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("var x = void 0; x |= new Number(3);").run();
+  public void testCast33b() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
+    newTest()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string|undefined} */(x);")
+        .run();
   }
 
   @Test
-  public void testBitOperation9() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testCast33c() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
-        .addSource("var x = void 0; x |= {};")
-        .addDiagnostic(
-            "bad right operand to bitwise operator\n"
-                + "found   : {}\n"
-                + "required: (boolean|null|number|string|undefined)")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string?} */(x);")
         .run();
   }
 
   @Test
-  public void testCall1() {
-    newTest().addSource("3();").addDiagnostic("number expressions are not callable").run();
+  public void testCast33d() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
+    newTest()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {null} */(x);")
+        .run();
   }
 
   @Test
-  public void testCall2() {
+  public void testCast34a() {
     newTest()
-        .addSource("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: Number")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Object} */ var x ;\n"
+                + "var y = /** @type {Function} */(x);")
         .run();
   }
 
   @Test
-  public void testCall3() {
-    // We are checking that an unresolved named type can successfully
-    // meet with a functional type to produce a callable type.
+  public void testCast34b() {
     newTest()
         .addSource(
-            "/** @type {Function|undefined} */var opt_f;"
-                + "/** @type {some.unknown.type} */var f1;"
-                + "var f2 = opt_f || f1;"
-                + "f2();")
-        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Function} */ var x ;\n"
+                + "var y = /** @type {Object} */(x);")
         .run();
   }
 
   @Test
-  public void testCall3NullishCoalesce() {
-    // We are checking that an unresolved named type can successfully
-    // meet with a functional type to produce a callable type.
+  public void testCastToNameRequiringPropertyResolution() {
+    // regression test for correctly typing properties off of types in CASTs.
+    // The type JSDoc in a cast is currently evaluated during TypeInference. In the past any
+    // 'unresolved' types in cast JSDoc were not resolved until after type inference completed. This
+    // caused type inference to infer properties off of those unresolved types as unknown.
     newTest()
+        .addExterns("var unknownVar;")
         .addSource(
-            "/** @type {Function|undefined} */var opt_f;",
-            "/** @type {some.unknown.type} */var f1;",
-            "var f2 = opt_f ?? f1;",
-            "f2();")
-        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
+            "const foo = {bar: {}};",
+            "const bar = foo.bar;",
+            "bar.Class = class {",
+            "  /** @return {number} */",
+            "  id() { return 0; }",
+            "};",
+            // Because `foo.bar.Class = ...` was never directly assigned, the type 'foo.bar.Class'
+            // is not in the JSTypeRegistry. It's resolved through NamedType#resolveViaProperty.
+            // The same thing would have occurred if we assigned 'foo.bar.Class = ...' then
+            // referred to '!bar.Class' in the JSDoc.
+            // Verify that type inference correctly infers the id property's type.
+
+            "const /** null */ n = /** @type {!foo.bar.Class} */ (unknownVar).id;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : function(this:bar.Class): number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testCall4() {
+  public void testNestedCasts() {
     newTest()
-        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: RegExp")
+        .addSource(
+            "/** @constructor */var T = function() {};\n"
+                + "/** @constructor */var V = function() {};\n"
+                + "/**\n"
+                + "* @param {boolean} b\n"
+                + "* @return {T|V}\n"
+                + "*/\n"
+                + "function f(b) { return b ? new T() : new V(); }\n"
+                + "/**\n"
+                + "* @param {boolean} b\n"
+                + "* @return {boolean|undefined}\n"
+                + "*/\n"
+                + "function g(b) { return b ? true : undefined; }\n"
+                + "/** @return {T} */\n"
+                + "function h() {\n"
+                + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testCall5() {
+  public void testNativeCast1() {
     newTest()
-        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }")
+        .addSource("/** @param {number} x */ function f(x) {}" + "f(String(true));")
         .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
+            "actual parameter 1 of f does not match formal parameter\n"
                 + "found   : string\n"
-                + "required: RegExp")
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testCall6() {
+  public void testNativeCast2() {
     newTest()
-        .addSource("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');")
+        .addSource("/** @param {string} x */ function f(x) {}" + "f(Number(true));")
         .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: Number")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testCall7() {
+  public void testNativeCast3() {
     newTest()
-        .addSource("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');")
+        .addSource("/** @param {number} x */ function f(x) {}" + "f(Boolean(''));")
         .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: RegExp")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testCall8() {
+  public void testNativeCast4() {
     newTest()
-        .addSource("/** @type {Function|number} */var f;f();")
-        .addDiagnostic("(Function|number) expressions are " + "not callable")
+        .addSource(
+            "/** @param {number} x */ function f(x) {}", //
+            "f(Array(1));")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Array",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCall9() {
+  public void testBadConstructorCall() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.Foo = function() {};"
-                + "/** @param {!goog.Foo} a */ var bar = function(a){};"
-                + "bar('abc');")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: goog.Foo")
+            "/** @constructor */ function Foo() {}", //
+            "Foo();")
+        .addDiagnostic("Constructor (typeof Foo) should be called with the \"new\" keyword")
         .run();
   }
 
   @Test
-  public void testCall10() {
-    newTest().addSource("/** @type {Function} */var f;f();").run();
+  public void testTypeof() {
+    newTest().addSource("/**@return {void}*/function foo(){ var a = typeof foo(); }").run();
   }
 
   @Test
-  public void testCall11() {
-    newTest().addSource("var f = new Function(); f();").run();
+  public void testTypeof2() {
+    newTest()
+        .addSource("function f(){ if (typeof 123 == 'numbr') return 321; }")
+        .addDiagnostic("unknown type: numbr")
+        .run();
   }
 
   @Test
-  public void testCall12() {
+  public void testTypeof3() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {*} x",
-            " * @return {number}",
-            " */",
-            "function f(x, y) {",
-            "  return x && x.foo();",
-            "}")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", // preserve new line
-                "found   : *",
-                "required: number"))
-        .addDiagnostic("Property foo never defined on *" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "function f() {",
+            "  return (",
+            "      typeof 123 == 'number' ||",
+            "      typeof 123 == 'string' ||",
+            "      typeof 123 == 'boolean' ||",
+            "      typeof 123 == 'undefined' ||",
+            "      typeof 123 == 'function' ||",
+            "      typeof 123 == 'object' ||",
+            "      typeof 123 == 'symbol' ||",
+            "      typeof 123 == 'unknown'); }")
         .run();
   }
 
   @Test
-  public void testCall13() {
-    // Test a case where we use inferred types across scopes.
+  public void testConstDecl1() {
     newTest()
         .addSource(
-            "var x;",
-            "function useX() { var /** string */ str = x(); }",
-            "function setX() { x = /** @return {number} */ () => 3; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", // preserve new line
-                "found   : number",
-                "required: string"))
+            "/** @param {?number} x \n @return {boolean} */"
+                + "function f(x) { "
+                + "  if (x) { /** @const */ var y = x; return y } return true; "
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall1() {
-    // Converted from Closure style "goog.base" super call
+  public void testConstDecl2() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "B.superClass_ = A.prototype",
-            "/** @override */ B.prototype.foo = function() { B.superClass_.foo.call(this); };")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/** @param {?number} x */"
+                + "function f(x) { "
+                + "  if (x) {"
+                + "    /** @const */ var y = x; "
+                + "    /** @return {boolean} */ function g() { return y; } "
+                + "  }"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall2() {
-    // Converted from Closure style "goog.base" super call, with namespace
+  public void testConstructorType1() {
     newTest()
-        .addSource(
-            "/** @const */ var ns = {};",
-            "/** @constructor @abstract */ ns.A = function() {};",
-            "/** @abstract */ ns.A.prototype.foo = function() {};",
-            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
-            "ns.B.superClass_ = ns.A.prototype",
-            "/** @override */ ns.B.prototype.foo = function() {",
-            "  ns.B.superClass_.foo.call(this);",
-            "};")
-        .addDiagnostic("Abstract super method ns.A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+        .addSource("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();")
+        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: Foo")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall3() {
-    // Converted from ES6 super call
+  public void testConstructorType2() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() { A.prototype.foo.call(this); };")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/**@constructor*/function Foo(){\n"
+                + "/**@type{Number}*/this.bar = new Number(5);\n"
+                + "}\n"
+                + "/**@type{Foo}*/var f = new Foo();\n"
+                + "/**@type{Number}*/var n = f.bar;")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall4() {
+  public void testConstructorType3() {
+    // Reverse the declaration order so that we know that Foo is getting set
+    // even on an out-of-order declaration sequence.
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @constructor @abstract */ ns.A = function() {};",
-            "ns.A.prototype.foo = function() {};",
-            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
-            "ns.B.superClass_ = ns.A.prototype",
-            "/** @override */ ns.B.prototype.foo = function() {",
-            "  ns.B.superClass_.foo.call(this);",
-            "};")
-        .includeDefaultExterns()
+            "/**@type{Foo}*/var f = new Foo();\n"
+                + "/**@type{Number}*/var n = f.bar;"
+                + "/**@constructor*/function Foo(){\n"
+                + "/**@type{Number}*/this.bar = new Number(5);\n"
+                + "}\n")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall5() {
+  public void testConstructorType4() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() { A.prototype.foo.call(this); };")
-        .includeDefaultExterns()
+            "/**@constructor*/function Foo(){\n"
+                + "/**@type{!Number}*/this.bar = new Number(5);\n"
+                + "}\n"
+                + "/**@type{!Foo}*/var f = new Foo();\n"
+                + "/**@type{!String}*/var n = f.bar;")
+        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: String")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall6() {
+  public void testConstructorType5() {
+    newTest().addSource("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n").run();
+  }
+
+  @Test
+  public void testConstructorType6() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @constructor @abstract */ ns.A = function() {};",
-            "ns.A.prototype.foo = function() {};",
-            "ns.A.prototype.foo.bar = function() {};",
-            "/** @constructor @extends {ns.A} */ ns.B = function() {};",
-            "ns.B.superClass_ = ns.A.prototype",
-            "/** @override */ ns.B.prototype.foo = function() {",
-            "  ns.B.superClass_.foo.bar.call(this);",
-            "};")
-        .includeDefaultExterns()
+            "/** @constructor */\n"
+                + "function bar() {}\n"
+                + "function _foo() {\n"
+                + " /** @param {bar} x */\n"
+                + "  function f(x) {}\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall7() {
+  public void testConstructorType7() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};");
+
+    JSType type = p.scope.getVar("A").getType();
+    assertThat(type).isInstanceOf(FunctionType.class);
+    FunctionType fType = (FunctionType) type;
+    assertThat(fType.getReferenceName()).isEqualTo("A");
+  }
+
+  @Test
+  public void testConstructorType8() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "A.prototype.foo = function() {};",
-            "A.prototype.foo.bar = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() { A.prototype.foo.bar.call(this);"
-                + " };")
-        .includeDefaultExterns()
+            "var ns = {};"
+                + "ns.create = function() { return function() {}; };"
+                + "/** @constructor */ ns.Foo = ns.create();"
+                + "ns.Foo.prototype = {x: 0, y: 0};"
+                + "/**\n"
+                + " * @param {ns.Foo} foo\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function f(foo) {"
+                + "  return foo.x;"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall8() {
+  public void testConstructorType9() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() { A.prototype.foo['call'](this);"
-                + " };")
-        .includeDefaultExterns()
+            "var ns = {};"
+                + "ns.create = function() { return function() {}; };"
+                + "ns.extend = function(x) { return x; };"
+                + "/** @constructor */ ns.Foo = ns.create();"
+                + "ns.Foo.prototype = ns.extend({x: 0, y: 0});"
+                + "/**\n"
+                + " * @param {ns.Foo} foo\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function f(foo) {"
+                + "  return foo.x;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall9() {
+  public void testConstructorType10() {
     newTest()
         .addSource(
-            "/** @struct @constructor */ var A = function() {};",
-            "A.prototype.foo = function() {};",
-            "/** @struct @constructor @extends {A} */ var B = function() {};",
-            "/** @override */ B.prototype.foo = function() {",
-            "  (function() {",
-            "    return A.prototype.foo.call($jscomp$this);",
-            "  })();",
-            "};")
-        .includeDefaultExterns()
+            "/** @constructor */"
+                + "function NonStr() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " * @extends{NonStr}\n"
+                + " */"
+                + "function NonStrKid() {}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall10() {
+  public void testConstructorType11() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "A.prototype.foo.call(new Subtype);")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/** @constructor */"
+                + "function NonDict() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " * @extends{NonDict}\n"
+                + " */"
+                + "function NonDictKid() {}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall11() {
+  public void testConstructorType12() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ function A() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ function B() {};",
-            "/** @override */ B.prototype.foo = function() {};",
-            "var abstractMethod = A.prototype.foo;",
-            "abstractMethod.call(new B);")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "Bar.prototype = {};\n")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall12() {
+  public void testBadStruct() {
     newTest()
-        .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ var B = function() {};",
-            "B.superClass_ = A.prototype",
-            "/** @override */ B.prototype.foo = function() { B.superClass_.foo.apply(this);"
-                + " };")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+        .addSource("/** @struct */function Struct1() {}")
+        .addDiagnostic("@struct used without @constructor for Struct1")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall13() {
-    // Calling abstract @constructor is allowed
+  public void testBadDict() {
     newTest()
-        .addSource(
-            "/** @constructor @abstract */ var A = function() {};",
-            "/** @constructor @extends {A} */ var B = function() { A.call(this); };")
-        .includeDefaultExterns()
+        .addSource("/** @dict */function Dict1() {}")
+        .addDiagnostic("@dict used without @constructor for Dict1")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Indirect1() {
+  public void testAnonymousPrototype1() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ function A() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ function B() {};",
-            "/** @override */ B.prototype.foo = function() {};",
-            "var abstractMethod = A.prototype.foo;",
-            "(0, abstractMethod).call(new B);")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "var ns = {};"
+                + "/** @constructor */ ns.Foo = function() {"
+                + "  this.bar(3, 5);"
+                + "};"
+                + "ns.Foo.prototype = {"
+                + "  bar: function(x) {}"
+                + "};")
+        .addDiagnostic(
+            "Function ns.Foo.prototype.bar: called with 2 argument(s). "
+                + "Function requires at least 1 argument(s) and no more "
+                + "than 1 argument(s).")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Indirect2() {
+  public void testAnonymousPrototype2() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ function A() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "/** @constructor @extends {A} */ function B() {};",
-            "/** @override */ B.prototype.foo = function() {};",
-            "var abstractMethod = A.prototype.foo;",
-            "(abstractMethod = abstractMethod).call(new B);")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/** @interface */ var Foo = function() {};"
+                + "Foo.prototype = {"
+                + "  foo: function(x) {}"
+                + "};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @implements {Foo}\n"
+                + " */ var Bar = function() {};")
+        .addDiagnostic("property foo on interface Foo is not implemented by type Bar")
         .run();
   }
 
   @Test
-  public void testDefiningPropOnAbstractMethodForbidden() {
+  public void testAnonymousType1() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */ function A() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "A.prototype.foo.callFirst = true;")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "function f() { return {}; }", //
+            "/** @constructor */",
+            "f().bar = function() {};")
         .run();
   }
 
   @Test
-  public void testPassingAbstractMethodAsArgForbidden() {
+  public void testAnonymousType2() {
     newTest()
-        .addExterns("function externsFn(callback) {}")
         .addSource(
-            "/** @constructor @abstract */ function A() {};",
-            "/** @abstract */ A.prototype.foo = function() {};",
-            "externsFn(A.prototype.foo);")
-        .addDiagnostic("Abstract super method A.prototype.foo cannot be dereferenced")
+            "function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class() {
+  public void testAnonymousType3() {
     newTest()
-        .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "  bar() {",
-            "    this.foo();",
-            "  }",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  /** @override */",
-            "  bar() {",
-            "    this.foo();",
-            "  }",
-            "}")
-        .includeDefaultExterns()
+        .addSource("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_prototype() {
+  public void testBang1() {
     newTest()
-        .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  bar() {",
-            "    Sub.prototype.foo();",
-            "  }",
-            "}")
-        .includeDefaultExterns()
+        .addSource("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (Object|null)\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_prototype_warning() {
+  public void testBang2() {
     newTest()
         .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  bar() {",
-            "    Base.prototype.foo();",
-            "  }",
-            "}")
-        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/** @param {Object} x\n@return {!Object} */\n"
+                + "function f(x) { return x ? x : new Object(); }")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_abstractSubclass_warns() {
+  public void testBang3() {
     newTest()
         .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "/** @abstract */",
-            "class Sub extends Base {",
-            "  bar() {",
-            "    Sub.prototype.foo();",
-            "  }",
-            "}")
-        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/** @param {Object} x\n@return {!Object} */\n"
+                + "function f(x) { return /** @type {!Object} */ (x); }")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_onAbstractSubclassPrototype_warns() {
+  public void testBang4() {
     newTest()
         .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "/** @abstract */",
-            "class Sub extends Base {",
-            "  bar() {",
-            "    Base.prototype.foo();",
-            "  }",
-            "}")
-        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
+            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
+                + "function f(x, y) {\n"
+                + "if (typeof x != 'undefined') { return x == y; }\n"
+                + "else { return x != y; }\n}")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_concreteSubclassMissingImplementation_warns() {
+  public void testBang5() {
     newTest()
         .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends Base {",
-            "  bar() {",
-            "    Sub.prototype.foo();",
-            "  }",
-            "}")
-        .includeDefaultExterns()
-        .addDiagnostic("property foo on abstract class Base is not implemented by type Sub")
-        .addDiagnostic("Abstract super method Base.prototype.foo cannot be dereferenced")
+            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
+                + "function f(x, y) { return !!x && x == y; }")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_Es6Class_concreteSubclassWithImplementation_noWarning() {
+  public void testBang6() {
     newTest()
-        .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  bar() {",
-            "    Sub.prototype.foo();",
-            "  }",
-            "}")
-        .includeDefaultExterns()
+        .addSource("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }")
         .run();
   }
 
   @Test
-  public void testAbstractMethodCall_NamespacedEs6Class_prototype_warns() {
+  public void testBang7() {
     newTest()
         .addSource(
-            "const ns = {};",
-            "/** @abstract */",
-            "ns.Base = class {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends ns.Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  bar() {",
-            "    ns.Base.prototype.foo();",
-            "  }",
-            "}")
-        .addDiagnostic("Abstract super method ns.Base.prototype.foo cannot be dereferenced")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testNonAbstractMethodCall_Es6Class_prototype() {
-    newTest()
-        .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "  bar() {}",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  /** @override */",
-            "  bar() {",
-            "    Base.prototype.bar();",
-            "  }",
-            "}")
-        .includeDefaultExterns()
+            "/**@param {(Object|string|null)} x\n"
+                + "@return {(Object|string)}*/function f(x) { return x; }")
         .run();
   }
 
-  // GitHub issue #2262: https://github.com/google/closure-compiler/issues/2262
   @Test
-  public void testAbstractMethodCall_Es6ClassWithSpread() {
+  public void testDefinePropertyOnNullableObject1() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().addArray().addArguments().build())
         .addSource(
-            "/** @abstract */",
-            "class Base {",
-            "  /** @abstract */",
-            "  foo() {}",
-            "}",
-            "class Sub extends Base {",
-            "  /** @override */",
-            "  foo() {}",
-            "  /** @param {!Array} arr */",
-            "  bar(arr) {",
-            "    this.foo.apply(this, [].concat(arr));",
-            "  }",
-            "}")
-        .run();
-  }
-
-  @Test
-  public void testFunctionCall1() {
-    newTest()
-        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testFunctionCall2() {
-    newTest()
-        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');")
+            "/** @type {Object} */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */ function f() { return n.x; }")
         .addDiagnostic(
-            "actual parameter 2 of foo.call does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .includeDefaultExterns()
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testFunctionCall3() {
+  public void testDefinePropertyOnNullableObject1a() {
     newTest()
         .addSource(
-            "/** @param {number} x \n * @constructor */ "
-                + "var Foo = function(x) { this.bar.call(null, x); };"
-                + "/** @type {function(number)} */ Foo.prototype.bar;")
-        .includeDefaultExterns()
+            "/** @const */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */function f() { return n.x; }")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testFunctionCall4() {
+  public void testDefinePropertyOnObject() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @param {string} x \n * @constructor */ "
-                + "var Foo = function(x) { this.bar.call(null, x); };"
-                + "/** @type {function(number)} */ Foo.prototype.bar;")
+            "/** @type {!Object} */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */function f() { return n.x; }")
         .addDiagnostic(
-            "actual parameter 2 of this.bar.call "
-                + "does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .includeDefaultExterns()
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testFunctionCall5() {
+  public void testDefinePropertyOnNullableObject2() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @param {Function} handler \n * @constructor */ "
-                + "var Foo = function(handler) { handler.call(this, x); };")
-        .includeDefaultExterns()
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @param {T} t\n@return {boolean} */function f(t) {\n"
+                + "t.x = 1; return t.x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testFunctionCall6() {
+  public void testDefinePropertyOnNullableObject2b() {
     newTest()
         .addSource(
-            "/** @param {Function} handler \n * @constructor */ "
-                + "var Foo = function(handler) { handler.apply(this, x); };")
-        .includeDefaultExterns()
+            "/** @constructor */ var T = function() {};",
+            "/** @param {T} t */function f(t) { t.x = 1; }")
+        .addDiagnostic("Property x never defined on T")
         .run();
   }
 
   @Test
-  public void testFunctionCall7() {
-    newTest()
-        .addSource(
-            "/** @param {Function} handler \n * @param {Object} opt_context */ "
-                + "var Foo = function(handler, opt_context) { "
-                + "  handler.call(opt_context, x);"
-                + "};")
-        .includeDefaultExterns()
-        .run();
+  public void testUnknownConstructorInstanceType1() {
+    newTest().addSource("/** @return {Array} */ function g(f) { return new f(); }").run();
   }
 
   @Test
-  public void testFunctionCall8() {
-    newTest()
-        .addSource(
-            "/** @param {Function} handler \n * @param {Object} opt_context */ "
-                + "var Foo = function(handler, opt_context) { "
-                + "  handler.apply(opt_context, x);"
-                + "};")
-        .includeDefaultExterns()
-        .run();
+  public void testUnknownConstructorInstanceType2() {
+    newTest().addSource("function g(f) { return /** @type {Array} */(new f()); }").run();
   }
 
   @Test
-  public void testFunctionCall9() {
-    newTest()
-        .addSource(
-            "/** @constructor\n * @template T\n **/ function Foo() {}\n"
-                + "/** @param {T} x */ Foo.prototype.bar = function(x) {}\n"
-                + "var foo = /** @type {Foo<string>} */ (new Foo());\n"
-                + "foo.bar(3);")
-        .addDiagnostic(
-            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .includeDefaultExterns()
-        .run();
+  public void testUnknownConstructorInstanceType3() {
+    newTest().addSource("function g(f) { var x = new f(); x.a = 1; return x; }").run();
   }
 
   @Test
-  public void testFunctionBind1() {
+  public void testUnknownPrototypeChain1() {
     newTest()
         .addSource(
-            "/** @type {function(string, number): boolean} */"
-                + "function f(x, y) { return true; }"
-                + "f.bind(null, 3);")
-        .addDiagnostic(
-            "actual parameter 2 of f.bind does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .includeDefaultExterns()
+            "/**",
+            "* @param {Object} co",
+            " * @return {Object}",
+            " */",
+            "function inst(co) {",
+            " /** @constructor */",
+            " var c = function() {};",
+            " c.prototype = co.prototype;",
+            " return new c;",
+            "}")
+        .addDiagnostic("Property prototype never defined on Object")
         .run();
   }
 
   @Test
-  public void testFunctionBind2() {
+  public void testUnknownPrototypeChain2() {
     newTest()
         .addSource(
-            "/** @type {function(number): boolean} */"
-                + "function f(x) { return true; }"
-                + "f(f.bind(null, 3)());")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
-        .includeDefaultExterns()
+            "/**",
+            " * @param {Function} co",
+            " * @return {Object}",
+            " */",
+            "function inst(co) {",
+            " /** @constructor */",
+            " var c = function() {};",
+            " c.prototype = co.prototype;",
+            " return new c;",
+            "}")
         .run();
   }
 
   @Test
-  public void testFunctionBind3() {
-    newTest()
-        .addSource(
-            "/** @type {function(number, string): boolean} */"
-                + "function f(x, y) { return true; }"
-                + "f.bind(null, 3)(true);")
-        .addDiagnostic(
-            "actual parameter 1 of function does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: string")
-        .includeDefaultExterns()
-        .run();
-  }
+  public void testNamespacedConstructor() {
+    Node root =
+        parseAndTypeCheck(
+            "var goog = {};"
+                + "/** @constructor */ goog.MyClass = function() {};"
+                + "/** @return {!goog.MyClass} */ "
+                + "function foo() { return new goog.MyClass(); }");
 
-  @Test
-  public void testFunctionBind4() {
-    this.newTest()
-        .addSource(
-            "/** @param {...number} x */", //
-            "function f(x) {}",
-            "f.bind(null, 3, 3, 3)(true);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of function does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
-        .includeDefaultExterns()
-        .run();
-  }
+    JSType typeOfFoo = root.getLastChild().getJSType();
+    assertType(typeOfFoo).isInstanceOf(FunctionType.class);
 
-  @Test
-  public void testFunctionBind5() {
-    this.newTest()
-        .addSource(
-            "/** @param {...number} x */", //
-            "function f(x) {}",
-            "f.bind(null, true)(3, 3, 3);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 2 of f.bind does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
-        .includeDefaultExterns()
-        .run();
+    JSType retType = ((FunctionType) typeOfFoo).getReturnType();
+    assertType(retType).isInstanceOf(ObjectType.class);
+    assertThat(((ObjectType) retType).getReferenceName()).isEqualTo("goog.MyClass");
   }
 
   @Test
-  public void testFunctionBind6() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "function MyType() {",
-            "  /** @type {number} */",
-            "  this.x = 0;",
-            "  var f = function() {",
-            "    this.x = 'str';",
-            "  }.bind(this);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment to property x of MyType", //
-                "found   : string",
-                "required: number"))
-        .includeDefaultExterns()
-        .run();
-  }
+  public void testComplexNamespace() {
+    String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;";
 
-  @Test
-  public void testFunctionBind7() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "function MyType() {",
-            "  /** @type {number} */",
-            "  this.x = 0;",
-            "}",
-            "var m = new MyType;",
-            "(function f() {this.x = 'str';}).bind(m);")
-        .addDiagnostic(
-            lines(
-                "assignment to property x of MyType", //
-                "found   : string",
-                "required: number"))
-        .includeDefaultExterns()
-        .run();
-  }
+    TypeCheckResult p = parseAndTypeCheckWithScope(js);
 
-  @Test
-  public void testFunctionBind8() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "function MyType() {}",
-            "",
-            "/** @constructor */",
-            "function AnotherType() {}",
-            "AnotherType.prototype.foo = function() {};",
-            "",
-            "/** @type {?} */",
-            "var m = new MyType;",
-            "(function f() {this.foo();}).bind(m);")
-        .includeDefaultExterns()
-        .run();
+    // goog type in the scope
+    JSType googScopeType = p.scope.getVar("goog").getType();
+    assertThat(googScopeType).isInstanceOf(ObjectType.class);
+    assertWithMessage("foo property not present on goog type")
+        .that(googScopeType.hasProperty("foo"))
+        .isTrue();
+    assertWithMessage("bar property present on goog type")
+        .that(googScopeType.hasProperty("bar"))
+        .isFalse();
+
+    // goog type on the VAR node
+    Node varNode = p.root.getFirstChild();
+    assertNode(varNode).hasToken(Token.VAR);
+    JSType googNodeType = varNode.getFirstChild().getJSType();
+    assertThat(googNodeType).isInstanceOf(ObjectType.class);
+
+    // goog scope type and goog type on VAR node must be the same
+    assertThat(googScopeType).isSameInstanceAs(googNodeType);
+
+    // goog type on the left of the GETPROP node (under fist ASSIGN)
+    Node getpropFoo1 = varNode.getNext().getFirstFirstChild();
+    assertNode(getpropFoo1).hasToken(Token.GETPROP);
+    assertThat(getpropFoo1.getFirstChild().getString()).isEqualTo("goog");
+    JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType();
+    assertThat(googGetpropFoo1Type).isInstanceOf(ObjectType.class);
+
+    // still the same type as the one on the variable
+    assertThat(googGetpropFoo1Type).isSameInstanceAs(googScopeType);
+
+    // the foo property should be defined on goog
+    JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo");
+    assertThat(googFooType).isInstanceOf(ObjectType.class);
+
+    // goog type on the left of the GETPROP lower level node
+    // (under second ASSIGN)
+    Node getpropFoo2 = varNode.getNext().getNext().getFirstFirstChild().getFirstChild();
+    assertNode(getpropFoo2).hasToken(Token.GETPROP);
+    assertThat(getpropFoo2.getFirstChild().getString()).isEqualTo("goog");
+    JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType();
+    assertThat(googGetpropFoo2Type).isInstanceOf(ObjectType.class);
+
+    // still the same type as the one on the variable
+    assertThat(googGetpropFoo2Type).isSameInstanceAs(googScopeType);
+
+    // goog.foo type on the left of the top-level GETPROP node
+    // (under second ASSIGN)
+    JSType googFooGetprop2Type = getpropFoo2.getJSType();
+    assertWithMessage("goog.foo incorrectly annotated in goog.foo.bar selection")
+        .that(googFooGetprop2Type)
+        .isInstanceOf(ObjectType.class);
+    ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type;
+    assertWithMessage("foo property present on goog.foo type")
+        .that(googFooGetprop2ObjectType.hasProperty("foo"))
+        .isFalse();
+    assertWithMessage("bar property not present on goog.foo type")
+        .that(googFooGetprop2ObjectType.hasProperty("bar"))
+        .isTrue();
+    assertTypeEquals(
+        "bar property on goog.foo type incorrectly inferred",
+        getNativeNumberType(),
+        googFooGetprop2ObjectType.getPropertyType("bar"));
   }
 
   @Test
-  public void testFunctionBind9() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "function MyType() {}",
-            "",
-            "/** @constructor */",
-            "function AnotherType() {}",
-            "AnotherType.prototype.foo = function() {};",
-            "",
-            "var m = new MyType;",
-            "(function f() {this.foo();}).bind(m);")
-        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
-        .run();
+  public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() {
+    disableStrictMissingPropertyChecks();
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS, "/** @constructor */function A() {}" + "A.prototype.m1 = 5");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 1);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
   }
 
   @Test
-  public void testGoogBind1() {
-    testClosureTypes(
-        "goog.bind = function(var_args) {};"
-            + "/** @type {function(number): boolean} */"
-            + "function f(x, y) { return true; }"
-            + "f(goog.bind(f, null, 'x')());",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : boolean\n"
-            + "required: number");
+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            "var goog = {};"
+                + "goog.A = /** @constructor */function() {};"
+                + "/** @type {number} */goog.A.prototype.m1 = 5");
+
+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
   }
 
   @Test
-  public void testGoogBind2() {
-    // TODO(nicksantos): We do not currently type-check the arguments
-    // of the goog.bind.
-    testClosureTypes(
-        "goog.bind = function(var_args) {};"
-            + "/** @type {function(boolean): boolean} */"
-            + "function f(x, y) { return true; }"
-            + "f(goog.bind(f, null, 'x')());",
-        null);
+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            "var goog = {};"
+                + "/** @constructor */goog.A = function() {};"
+                + "/** @type {number} */goog.A.prototype.m1 = 5");
+
+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
   }
 
-  @Test
-  public void testCast2() {
-    // can upcast to a base type.
-    newTest()
-        .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n @extends {base} */function derived() {}\n"
-                + "/** @type {base} */ var baz = new derived();\n")
-        .run();
+  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(TypeCheckResult p) {
+    ObjectType goog = (ObjectType) p.scope.getVar("goog").getType();
+    assertHasXMorePropertiesThanNativeObject(goog, 1);
+    JSType googA = goog.getPropertyType("A");
+    assertThat(googA).isNotNull();
+    assertThat(googA).isInstanceOf(FunctionType.class);
+    FunctionType googAFunction = (FunctionType) googA;
+    ObjectType classA = googAFunction.getInstanceType();
+    assertHasXMorePropertiesThanNativeObject(classA, 1);
+    checkObjectType(classA, "m1", getNativeNumberType());
   }
 
   @Test
-  public void testCast3() {
-    // cannot downcast
-    newTest()
-        .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = new base();\n")
-        .addDiagnostic("initializing variable\n" + "found   : base\n" + "required: derived")
-        .run();
+  public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() {
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 2);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
+    checkObjectType(instanceType, "m2", getNativeBooleanType());
   }
 
   @Test
-  public void testCast3a() {
-    // cannot downcast
-    newTest()
-        .addSource(
-            "/** @constructor */function Base() {}\n"
-                + "/** @constructor @extends {Base} */function Derived() {}\n"
-                + "var baseInstance = new Base();"
-                + "/** @type {!Derived} */ var baz = baseInstance;\n")
-        .addDiagnostic("initializing variable\n" + "found   : Base\n" + "required: Derived")
-        .run();
+  public void testDontAddMethodsIfNoConstructor() {
+    Node js1Node = parseAndTypeCheck("function A() {}" + "A.prototype = {m1: 5, m2: true}");
+
+    JSType functionAType = js1Node.getFirstChild().getJSType();
+    assertThat(functionAType.toString()).isEqualTo("function(): undefined");
+    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m1"));
+    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m2"));
   }
 
   @Test
-  public void testCast4() {
-    // downcast must be explicit
+  public void testFunctionAssignement() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = "
-                + "/** @type {!derived} */(new base());\n")
+            "/**"
+                + "* @param {string} ph0"
+                + "* @param {string} ph1"
+                + "* @return {string}"
+                + "*/"
+                + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}"
+                + "/** @type {Function} */"
+                + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;")
         .run();
   }
 
   @Test
-  public void testCast4Types() {
-    // downcast must be explicit
-    Node root =
+  public void testAddMethodsPrototypeTwoWays() {
+    Node js1Node =
         parseAndTypeCheck(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = "
-                + "/** @type {!derived} */(new base());\n");
-    Node castedExprNode = root.getLastChild().getFirstFirstChild().getFirstChild();
-    assertThat(castedExprNode.getJSType().toString()).isEqualTo("derived");
-    assertThat(castedExprNode.getJSTypeBeforeCast().toString()).isEqualTo("base");
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {}"
+                + "A.prototype = {m1: 5, m2: true};"
+                + "A.prototype.m3 = 'third property!';");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertThat(instanceType.toString()).isEqualTo("A");
+    assertHasXMorePropertiesThanNativeObject(instanceType, 3);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
+    checkObjectType(instanceType, "m2", getNativeBooleanType());
+    checkObjectType(instanceType, "m3", getNativeStringType());
   }
 
   @Test
-  public void testCast5() {
-    // cannot explicitly cast to an unrelated type
-    newTest()
-        .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor */function bar() {}\n"
-                + "var baz = /** @type {!foo} */(new bar);\n")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
-        .run();
+  public void testPrototypePropertyTypes() {
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {\n"
+                + "  /** @type {string} */ this.m1;\n"
+                + "  /** @type {Object?} */ this.m2 = {};\n"
+                + "  /** @type {boolean} */ this.m3;\n"
+                + "}\n"
+                + "/** @type {string} */ A.prototype.m4;\n"
+                + "/** @type {number} */ A.prototype.m5 = 0;\n"
+                + "/** @type {boolean} */ A.prototype.m6;\n");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 6);
+    checkObjectType(instanceType, "m1", getNativeStringType());
+    checkObjectType(
+        instanceType, "m2", createUnionType(getNativeObjectType(), getNativeNullType()));
+    checkObjectType(instanceType, "m3", getNativeBooleanType());
+    checkObjectType(instanceType, "m4", getNativeStringType());
+    checkObjectType(instanceType, "m5", getNativeNumberType());
+    checkObjectType(instanceType, "m6", getNativeBooleanType());
   }
 
   @Test
-  public void testCast5a() {
-    // cannot explicitly cast to an unrelated type
-    newTest()
-        .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor */function bar() {}\n"
-                + "var barInstance = new bar;\n"
-                + "var baz = /** @type {!foo} */(barInstance);\n")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
-        .run();
+  public void testValueTypeBuiltInPrototypePropertyType() {
+    Node node = parseAndTypeCheck(new TestExternsBuilder().addString().build(), "\"x\".charAt(0)");
+    assertTypeEquals(getNativeStringType(), node.getFirstFirstChild().getJSType());
   }
 
   @Test
-  public void testCast6() {
-    // can explicitly cast to a subtype or supertype
-    newTest()
-        .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor \n @extends foo */function bar() {}\n"
-                + "var baz = /** @type {!bar} */(new bar);\n"
-                + "var baz = /** @type {!foo} */(new foo);\n"
-                + "var baz = /** @type {bar} */(new bar);\n"
-                + "var baz = /** @type {foo} */(new foo);\n"
-                + "var baz = /** @type {!foo} */(new bar);\n"
-                + "var baz = /** @type {!bar} */(new foo);\n"
-                + "var baz = /** @type {foo} */(new bar);\n"
-                + "var baz = /** @type {bar} */(new foo);\n")
-        .run();
+  public void testDeclareBuiltInConstructor() {
+    // Built-in prototype properties should be accessible
+    // even if the built-in constructor is declared.
+    Node node =
+        parseAndTypeCheck(
+            new TestExternsBuilder().addString().build(),
+            lines(
+                "/** @constructor */ var String = function(opt_str) {};",
+                "(new String(\"x\")).charAt(0)"));
+    assertTypeEquals(getNativeStringType(), node.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testCast7() {
-    newTest()
-        .addSource("var x = /** @type {foo} */ (new Object());")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
-        .run();
+  public void testExtendBuiltInType1() {
+    String externs =
+        "/** @constructor */ var String = function(opt_str) {};\n"
+            + "/**\n"
+            + "* @param {number} start\n"
+            + "* @param {number} opt_length\n"
+            + "* @return {string}\n"
+            + "*/\n"
+            + "String.prototype.substr = function(start, opt_length) {};\n";
+    Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);");
+    assertTypeEquals(getNativeStringType(), n1.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testCast8() {
-    newTest()
-        .addSource("function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
-        .run();
+  public void testExtendBuiltInType2() {
+    String externs =
+        "/** @constructor */ var String = function(opt_str) {};\n"
+            + "/**\n"
+            + "* @param {number} start\n"
+            + "* @param {number} opt_length\n"
+            + "* @return {string}\n"
+            + "*/\n"
+            + "String.prototype.substr = function(start, opt_length) {};\n";
+    Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);");
+    assertTypeEquals(getNativeStringType(), n2.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testCast9() {
-    newTest()
-        .addSource("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
-        .run();
+  public void testExtendFunction1() {
+    Node n =
+        parseAndTypeCheck(
+            "/**@return {number}*/Function.prototype.f = "
+                + "function() { return 1; };\n"
+                + "(new Function()).f();");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertTypeEquals(getNativeNumberType(), type);
   }
 
   @Test
-  public void testCast10() {
-    newTest()
-        .addSource(
-            "var foo = function() {};"
-                + "function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
-        .run();
+  public void testExtendFunction2() {
+    Node n =
+        parseAndTypeCheck(
+            "/**@return {number}*/Function.prototype.f = "
+                + "function() { return 1; };\n"
+                + "(function() {}).f();");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertTypeEquals(getNativeNumberType(), type);
   }
 
   @Test
-  public void testCast11() {
+  public void testClassExtendPrimitive() {
     newTest()
-        .addSource(
-            "var goog = {}; goog.foo = {};"
-                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+        .addSource("/** @extends {number} */ class C extends number {}")
+        .addDiagnostic("C @extends non-object type number")
         .run();
   }
 
   @Test
-  public void testCast12() {
+  public void testInheritanceCheck1() {
     newTest()
         .addSource(
-            "var goog = {}; goog.foo = function() {};"
-                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+            "/** @constructor */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast13() {
-    // In a typespace world, types and values may collide on the same symbol.
-    testClosureTypes(
-        "goog.forwardDeclare('goog.foo');"
-            + "goog.foo = function() {};"
-            + "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        null);
-  }
-
-  @Test
-  public void testCast14() {
-    // Test to make sure that the forward-declaration still prevents
-    // some warnings.
-    testClosureTypes(
-        "goog.forwardDeclare('goog.bar');"
-            + "function f() { return /** @type {goog.bar} */ (new Object()); }",
-        null);
+  public void testInheritanceCheck2() {
+    newTest()
+        .addSource(
+            "/** @constructor */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("property foo not defined on any superclass of Sub")
+        .run();
   }
 
   @Test
-  public void testCast15() {
-    // This fixes a bug where a type cast on an object literal
-    // would cause a run-time cast exception if the node was visited
-    // more than once.
-
-    // Some code assumes that an object literal must have a object type,
-    // while because of the cast, it could have any type (including
-    // a union).
-
-    // This test is specifically checking loose property check behavior.
-    disableStrictMissingPropertyChecks();
-
+  public void testInheritanceCheck3() {
     newTest()
         .addSource(
-            "for (var i = 0; i < 10; i++) {",
-            "var x = /** @type {Object|number} */ ({foo: 3});",
-            "/** @param {number} x */ function f(x) {}",
-            "f(x.foo);",
-            "f([].foo);",
-            "}")
-        .addDiagnostic("Property foo never defined on Array<?>")
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .addDiagnostic(
+            "property foo already defined on superclass Super; " + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testCast15b() {
-    // This fixes a bug where a type cast on an object literal
-    // would cause a run-time cast exception if the node was visited
-    // more than once.
-
-    // Some code assumes that an object literal must have a object type,
-    // while because of the cast, it could have any type (including
-    // a union).
+  public void testInheritanceCheck4() {
     newTest()
         .addSource(
-            "for (var i = 0; i < 10; i++) {",
-            "var x = /** @type {{foo:number}}|number} */ ({foo: 3});",
-            "/** @param {number} x */ function f(x) {}",
-            "f(x.foo);",
-            "f([].foo);",
-            "}")
-        .addDiagnostic("Property foo never defined on Array<?>")
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast16() {
-    // A type cast should not invalidate the checks on the members
+  public void testInheritanceCheck5() {
     newTest()
         .addSource(
-            "for (var i = 0; i < 10; i++) {"
-                + "var x = /** @type {Object|number} */ ("
-                + "  {/** @type {string} */ foo: 3});"
-                + "}")
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .addDiagnostic(
-            "assignment to property foo of {foo: string}\n"
-                + "found   : number\n"
-                + "required: string")
+            "property foo already defined on superclass Root; " + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testCast17a() {
-    // Mostly verifying that rhino actually understands these JsDocs.
+  public void testInheritanceCheck6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {} \n"
-                + "/** @type {Foo} */ var x = /** @type {Foo} */ (y)")
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast17b() {
-    // Mostly verifying that rhino actually understands these JsDocs.
+  public void testInheritanceCheck7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {} \n"
-                + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "goog.Sub.prototype.foo = 5;")
         .run();
   }
 
   @Test
-  public void testCast19() {
+  public void testInheritanceCheck8() {
     newTest()
         .addSource(
-            "var x = 'string';\n" + "/** @type {number} */\n" + "var y = /** @type {number} */(x);")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: string\n" + "to  : number")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override */goog.Sub.prototype.foo = 5;")
         .run();
   }
 
   @Test
-  public void testCast20() {
+  public void testInheritanceCheck9_1() {
     newTest()
         .addSource(
-            "/** @enum {boolean|null} */\n"
-                + "var X = {"
-                + "  AA: true,"
-                + "  BB: false,"
-                + "  CC: null"
-                + "};\n"
-                + "var y = /** @type {X} */(true);")
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() { return 3; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1; };")
         .run();
   }
 
   @Test
-  public void testCast21() {
+  public void testInheritanceCheck9_2() {
     newTest()
         .addSource(
-            "/** @enum {boolean|null} */\n"
-                + "var X = {"
-                + "  AA: true,"
-                + "  BB: false,"
-                + "  CC: null"
-                + "};\n"
-                + "var value = true;\n"
-                + "var y = /** @type {X} */(value);")
+            "/** @constructor */function Super() {};"
+                + "/** @return {number} */"
+                + "Super.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo =\n"
+                + "function() {};")
         .run();
   }
 
   @Test
-  public void testCast22() {
+  public void testInheritanceCheck9_3() {
     newTest()
-        .addSource("var x = null;\n" + "var y = /** @type {number} */(x);")
+        .addSource(
+            "/** @constructor */function Super() {};"
+                + "/** @return {number} */"
+                + "Super.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
+                + "function() { return \"some string\" };")
         .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: null\n" + "to  : number")
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Super\n"
+                + "original: function(this:Super): number\n"
+                + "override: function(this:Sub): string")
         .run();
   }
 
   @Test
-  public void testCast23() {
-    newTest().addSource("var x = null;\n" + "var y = /** @type {Number} */(x);").run();
-  }
-
-  @Test
-  public void testCast24() {
+  public void testInheritanceCheck10_1() {
     newTest()
-        .addSource("var x = undefined;\n" + "var y = /** @type {number} */(x);")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n"
-                + "from: undefined\n"
-                + "to  : number")
+        .addSource(
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() { return 3; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1; };")
         .run();
   }
 
   @Test
-  public void testCast25() {
+  public void testInheritanceCheck10_2() {
     newTest()
-        .addSource("var x = undefined;\n" + "var y = /** @type {number|undefined} */(x);")
+        .addSource(
+            "/** @constructor */function Root() {};"
+                + "/** @return {number} */"
+                + "Root.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo =\n"
+                + "function() {};")
         .run();
   }
 
   @Test
-  public void testCast26() {
+  public void testInheritanceCheck10_3() {
     newTest()
         .addSource(
-            "function fn(dir) {\n"
-                + "  var node = dir ? 1 : 2;\n"
-                + "  fn(/** @type {number} */ (node));\n"
-                + "}")
+            "/** @constructor */function Root() {};"
+                + "/** @return {number} */"
+                + "Root.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
+                + "function() { return \"some string\" };")
+        .addDiagnostic(
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Root\n"
+                + "original: function(this:Root): number\n"
+                + "override: function(this:Sub): string")
         .run();
   }
 
   @Test
-  public void testCast27() {
-    // C doesn't implement I but a subtype might.
+  public void testInterfaceInheritanceCheck11() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "var x = new C();\n"
-                + "var y = /** @type {I} */(x);")
+            "/** @constructor */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
+        .addDiagnostic(
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Super\n"
+                + "original: function(this:Super, number): undefined\n"
+                + "override: function(this:Sub, string): undefined")
         .run();
   }
 
   @Test
-  public void testCast27a() {
-    // C doesn't implement I but a subtype might.
+  public void testInheritanceCheck12() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {C} */ var x ;\n"
-                + "var y = /** @type {I} */(x);")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override */goog.Sub.prototype.foo = \"some string\";")
         .run();
   }
 
   @Test
-  public void testCast28() {
-    // C doesn't implement I but a subtype might.
+  public void testInheritanceCheck13() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {!I} */ var x;\n"
-                + "var y = /** @type {C} */(x);")
+            "var goog = {};\n"
+                + "/** @constructor\n @extends {goog.Missing} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("Bad type annotation. Unknown type goog.Missing")
         .run();
   }
 
   @Test
-  public void testCast28a() {
-    // C doesn't implement I but a subtype might.
+  public void testInheritanceCheck14() {
+    testClosureTypes(
+        lines(
+            "/** @constructor\n @extends {goog.Missing} */",
+            "goog.Super = function() {};",
+            "/** @constructor\n @extends {goog.Super} */function Sub() {};",
+            "/** @override */ Sub.prototype.foo = function() {};"),
+        "Bad type annotation. Unknown type goog.Missing");
+  }
+
+  @Test
+  public void testInheritanceCheck15() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {I} */ var x;\n"
-                + "var y = /** @type {C} */(x);")
+            "/** @constructor */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo;"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n  @param {number} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
         .run();
   }
 
   @Test
-  public void testCast29a() {
-    // C doesn't implement the record type but a subtype might.
+  public void testInheritanceCheck16() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "var x = new C();\n"
-                + "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "/** @type {number} */ goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @type {number} */ goog.Sub.prototype.foo = 5;")
+        .addDiagnostic(
+            "property foo already defined on superclass goog.Super; "
+                + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testCast29b() {
-    // C doesn't implement the record type but a subtype might.
+  public void testInheritanceCheck17() {
+    // Make sure this warning still works, even when there's no
+    // @override tag.
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {C} */ var x;\n"
-                + "var y = /** @type {{prop1: Array, prop2: string}} */(x);")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override @param {string} x */ goog.Sub.prototype.foo = function(x) {};")
+        .addDiagnostic(
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass goog.Super\n"
+                + "original: function(this:goog.Super, number): undefined\n"
+                + "override: function(this:goog.Sub, string): undefined")
         .run();
   }
 
   @Test
-  public void testCast29c() {
-    // C doesn't implement the record type but a subtype might.
+  public void testInterfacePropertyOverride1() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n"
-                + "var y = /** @type {C} */(x);")
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast30() {
-    // Should be able to cast to a looser return type
+  public void testInterfacePropertyOverride2() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {function():string} */ var x ;\n"
-                + "var y = /** @type {function():?} */(x);")
+            "/** @interface */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @interface\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast31() {
-    // Should be able to cast to a tighter parameter type
+  public void testInterfacePropertyBadOverrideFails() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {function(*)} */ var x ;\n"
-                + "var y = /** @type {function(string)} */(x);")
+            "/** @interface */function Super() {};",
+            "/** @type {number} */",
+            "Super.prototype.foo;",
+            "/** @interface @extends {Super} */function Sub() {};",
+            "/** @type {string} */",
+            "Sub.prototype.foo;")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Sub and the type of the property it "
+                    + "overrides from interface Super",
+                "original: number",
+                "override: string"))
         .run();
   }
 
   @Test
-  public void testCast32() {
+  public void testInterfaceInheritanceCheck1() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Object} */ var x ;\n"
-                + "var y = /** @type {null|{length:number}} */(x);")
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .addDiagnostic(
+            "property foo already defined on interface Super; use @override to " + "override it")
         .run();
   }
 
   @Test
-  public void testCast33a() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
+  public void testInterfaceInheritanceCheck2() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string?|undefined} */(x);")
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testCast33b() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
+  public void testInterfaceInheritanceCheck3() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string|undefined} */(x);")
+            "/** @interface */function Root() {};"
+                + "/** @return {number} */Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @return {number} */Sub.prototype.foo = function() { return 1;};")
+        .addDiagnostic(
+            "property foo already defined on interface Root; use @override to " + "override it")
         .run();
   }
 
   @Test
-  public void testCast33c() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
+  public void testInterfaceInheritanceCheck4() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string?} */(x);")
+            "/** @interface */function Root() {};"
+                + "/** @return {number} */Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override\n * @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1;};")
         .run();
   }
 
   @Test
-  public void testCast33d() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
+  public void testInterfaceInheritanceCheck5() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {null} */(x);")
+            "/** @interface */function Super() {};/** @return {string} */Super.prototype.foo ="
+                + " function() {};/** @constructor\n"
+                + " @implements {Super} */function Sub() {};/** @override\n"
+                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Super\n"
+                + "original: function(this:Super): string\n"
+                + "override: function(this:Sub): number")
         .run();
   }
 
   @Test
-  public void testCast34a() {
+  public void testInterfaceInheritanceCheck6() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Object} */ var x ;\n"
-                + "var y = /** @type {Function} */(x);")
+            "/** @interface */function Root() {};/** @return {string} */Root.prototype.foo ="
+                + " function() {};/** @interface\n"
+                + " @extends {Root} */function Super() {};/** @constructor\n"
+                + " @implements {Super} */function Sub() {};/** @override\n"
+                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Root\n"
+                + "original: function(this:Root): string\n"
+                + "override: function(this:Sub): number")
         .run();
   }
 
   @Test
-  public void testCast34b() {
+  public void testInterfaceInheritanceCheck7() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Function} */ var x ;\n"
-                + "var y = /** @type {Object} */(x);")
+            "/** @interface */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Super\n"
+                + "original: function(this:Super, number): undefined\n"
+                + "override: function(this:Sub, string): undefined")
         .run();
   }
 
   @Test
-  public void testCastToNameRequiringPropertyResolution() {
-    // regression test for correctly typing properties off of types in CASTs.
-    // The type JSDoc in a cast is currently evaluated during TypeInference. In the past any
-    // 'unresolved' types in cast JSDoc were not resolved until after type inference completed. This
-    // caused type inference to infer properties off of those unresolved types as unknown.
+  public void testInterfaceInheritanceCheck8() {
     newTest()
-        .addExterns("var unknownVar;")
         .addSource(
-            "const foo = {bar: {}};",
-            "const bar = foo.bar;",
-            "bar.Class = class {",
-            "  /** @return {number} */",
-            "  id() { return 0; }",
-            "};",
-            // Because `foo.bar.Class = ...` was never directly assigned, the type 'foo.bar.Class'
-            // is not in the JSTypeRegistry. It's resolved through NamedType#resolveViaProperty.
-            // The same thing would have occurred if we assigned 'foo.bar.Class = ...' then
-            // referred to '!bar.Class' in the JSDoc.
-            // Verify that type inference correctly infers the id property's type.
-
-            "const /** null */ n = /** @type {!foo.bar.Class} */ (unknownVar).id;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : function(this:bar.Class): number",
-                "required: null"))
+            "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("Bad type annotation. Unknown type Super")
+        .addDiagnostic("property foo not defined on any superclass of Sub")
         .run();
   }
 
   @Test
-  public void testNestedCasts() {
+  public void testInterfaceInheritanceCheck9() {
     newTest()
         .addSource(
-            "/** @constructor */var T = function() {};\n"
-                + "/** @constructor */var V = function() {};\n"
-                + "/**\n"
-                + "* @param {boolean} b\n"
-                + "* @return {T|V}\n"
-                + "*/\n"
-                + "function f(b) { return b ? new T() : new V(); }\n"
-                + "/**\n"
-                + "* @param {boolean} b\n"
-                + "* @return {boolean|undefined}\n"
-                + "*/\n"
-                + "function g(b) { return b ? true : undefined; }\n"
-                + "/** @return {T} */\n"
-                + "function h() {\n"
-                + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n"
-                + "}")
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.bar = function() {};"
+                + "/** @constructor */ function F() {}"
+                + "/** @return {number} */ F.prototype.bar = function() {return 3; };"
+                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
+                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
+                + "function G() {}"
+                + "/** @return {string} */ function f() { return new G().bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testNativeCast1() {
+  public void testInterfaceInheritanceCheck10() {
     newTest()
-        .addSource("/** @param {number} x */ function f(x) {}" + "f(String(true));")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+        .addSource(
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.bar = function() {};"
+                + "/** @constructor */ function F() {}"
+                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
+                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
+                + "function G() {}"
+                + "/** @return {number} \n * @override */ "
+                + "G.prototype.bar = G.prototype.foo;"
+                + "/** @return {string} */ function f() { return new G().bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testNativeCast2() {
+  public void testInterfaceInheritanceCheck12() {
     newTest()
-        .addSource("/** @param {string} x */ function f(x) {}" + "f(Number(true));")
+        .addSource(
+            "/** @interface */ function I() {};\n"
+                + "/** @type {string} */ I.prototype.foobar;\n"
+                + "/** \n * @constructor \n * @implements {I} */\n"
+                + "function C() {\n"
+                + "/** \n * @type {number} */ this.foobar = 2;};\n"
+                + "/** @type {I} */ \n var test = new C(); alert(test.foobar);")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "mismatch of the foobar property on type C and the type of the property"
+                + " it overrides from interface I\n"
+                + "original: string\n"
+                + "override: number")
         .run();
   }
 
   @Test
-  public void testNativeCast3() {
+  public void testInterfaceInheritanceCheck13() {
     newTest()
-        .addSource("/** @param {number} x */ function f(x) {}" + "f(Boolean(''));")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+        .addSource(
+            "function abstractMethod() {};\n"
+                + "/** @interface */var base = function() {};\n"
+                + "/** @extends {base} \n @interface */ var Int = function() {}\n"
+                + "/** @type {{bar : !Function}} */ var x; \n"
+                + "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n"
+                + "/** @type {Int} */ var foo;\n"
+                + "foo.bar();")
         .run();
   }
 
+  /** Verify that templatized interfaces can extend one another and share template values. */
   @Test
-  public void testNativeCast4() {
+  public void testInterfaceInheritanceCheck14() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}", //
-            "f(Array(1));")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Array",
-                "required: number"))
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
+                + "/** @return {U} */B.prototype.bar = function() {};"
+                + "/** @constructor\n @implements {B<string>} */function C() {};"
+                + "/** @return {string}\n @override */C.prototype.foo = function() {};"
+                + "/** @return {string}\n @override */C.prototype.bar = function() {};")
         .run();
   }
 
+  /** Verify that templatized instances can correctly implement templatized interfaces. */
   @Test
-  public void testBadConstructorCall() {
+  public void testInterfaceInheritanceCheck15() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "Foo();")
-        .addDiagnostic("Constructor (typeof Foo) should be called with the \"new\" keyword")
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
+                + "/** @return {U} */B.prototype.bar = function() {};"
+                + "/** @constructor\n @template V\n @implements {B<V>}\n */function C() {};"
+                + "/** @return {V}\n @override */C.prototype.foo = function() {};"
+                + "/** @return {V}\n @override */C.prototype.bar = function() {};")
         .run();
   }
 
+  /**
+   * Verify that using @override to declare the signature for an implementing class works correctly
+   * when the interface is generic.
+   */
   @Test
-  public void testTypeof() {
-    newTest().addSource("/**@return {void}*/function foo(){ var a = typeof foo(); }").run();
+  public void testInterfaceInheritanceCheck16() {
+    newTest()
+        .addSource(
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @return {T} */A.prototype.bar = function() {};"
+                + "/** @constructor\n @implements {A<string>} */function B() {};"
+                + "/** @override */B.prototype.foo = function() { return 'string'};"
+                + "/** @override */B.prototype.bar = function() { return 3 };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
   }
 
   @Test
-  public void testTypeof2() {
+  public void testInterfacePropertyNotImplemented() {
     newTest()
-        .addSource("function f(){ if (typeof 123 == 'numbr') return 321; }")
-        .addDiagnostic("unknown type: numbr")
+        .addSource(
+            "/** @interface */function Int() {};"
+                + "Int.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Int} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
         .run();
   }
 
   @Test
-  public void testTypeof3() {
+  public void testInterfacePropertyNotImplemented2() {
     newTest()
         .addSource(
-            "function f() {",
-            "  return (",
-            "      typeof 123 == 'number' ||",
-            "      typeof 123 == 'string' ||",
-            "      typeof 123 == 'boolean' ||",
-            "      typeof 123 == 'undefined' ||",
-            "      typeof 123 == 'function' ||",
-            "      typeof 123 == 'object' ||",
-            "      typeof 123 == 'symbol' ||",
-            "      typeof 123 == 'unknown'); }")
+            "/** @interface */function Int() {};"
+                + "Int.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int} */function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
         .run();
   }
 
+  /** Verify that templatized interfaces enforce their template type values. */
   @Test
-  public void testConstDecl1() {
+  public void testInterfacePropertyNotImplemented3() {
     newTest()
         .addSource(
-            "/** @param {?number} x \n @return {boolean} */"
-                + "function f(x) { "
-                + "  if (x) { /** @const */ var y = x; return y } return true; "
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
+            "/** @interface  @template T */ function Int() {};",
+            "/** @return {T} */ Int.prototype.foo = function() {};",
+            "",
+            "/** @constructor @implements {Int<string>} */ function Foo() {};",
+            "/** @return {number}  @override */ Foo.prototype.foo = function() {};")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Foo and the type of the property it "
+                    + "overrides from interface Int",
+                "original: function(this:Int): string",
+                "override: function(this:Foo): number"))
         .run();
   }
 
   @Test
-  public void testConstDecl2() {
+  public void testStubConstructorImplementingInterface() {
+    // This does not throw a warning for unimplemented property because Foo is
+    // just a stub.
     newTest()
-        .addSource(
-            "/** @param {?number} x */"
-                + "function f(x) { "
-                + "  if (x) {"
-                + "    /** @const */ var y = x; "
-                + "    /** @return {boolean} */ function g() { return y; } "
-                + "  }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
+        .addExterns(
+            "/** @interface */ function Int() {}\n"
+                + "Int.prototype.foo = function() {};"
+                + "/** @constructor \n @implements {Int} */ var Foo;\n")
+        .addSource("")
         .run();
   }
 
   @Test
-  public void testConstructorType1() {
-    newTest()
-        .addSource("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();")
-        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: Foo")
-        .run();
-  }
+  public void testObjectLiteral() {
+    Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}");
 
-  @Test
-  public void testConstructorType2() {
-    newTest()
-        .addSource(
-            "/**@constructor*/function Foo(){\n"
-                + "/**@type{Number}*/this.bar = new Number(5);\n"
-                + "}\n"
-                + "/**@type{Foo}*/var f = new Foo();\n"
-                + "/**@type{Number}*/var n = f.bar;")
-        .run();
+    Node nameNode = n.getFirstFirstChild();
+    Node objectNode = nameNode.getFirstChild();
+
+    // node extraction
+    assertNode(nameNode).hasToken(Token.NAME);
+    assertNode(objectNode).hasToken(Token.OBJECTLIT);
+
+    // value's type
+    ObjectType objectType = (ObjectType) objectNode.getJSType();
+    assertTypeEquals(getNativeNumberType(), objectType.getPropertyType("m1"));
+    assertTypeEquals(getNativeStringType(), objectType.getPropertyType("m2"));
+
+    // variable's type
+    assertTypeEquals(objectType, nameNode.getJSType());
   }
 
   @Test
-  public void testConstructorType3() {
-    // Reverse the declaration order so that we know that Foo is getting set
-    // even on an out-of-order declaration sequence.
+  public void testObjectLiteralDeclaration1() {
     newTest()
         .addSource(
-            "/**@type{Foo}*/var f = new Foo();\n"
-                + "/**@type{Number}*/var n = f.bar;"
-                + "/**@constructor*/function Foo(){\n"
-                + "/**@type{Number}*/this.bar = new Number(5);\n"
-                + "}\n")
+            "var x = {"
+                + "/** @type {boolean} */ abc: true,"
+                + "/** @type {number} */ 'def': 0,"
+                + "/** @type {string} */ 3: 'fgh'"
+                + "};")
         .run();
   }
 
   @Test
-  public void testConstructorType4() {
+  public void testObjectLiteralDeclaration2() {
     newTest()
-        .addSource(
-            "/**@constructor*/function Foo(){\n"
-                + "/**@type{!Number}*/this.bar = new Number(5);\n"
-                + "}\n"
-                + "/**@type{!Foo}*/var f = new Foo();\n"
-                + "/**@type{!String}*/var n = f.bar;")
-        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: String")
+        .addSource("var x = {" + "  /** @type {boolean} */ abc: true" + "};" + "x.abc = 0;")
+        .addDiagnostic(
+            "assignment to property abc of x\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testConstructorType5() {
-    newTest().addSource("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n").run();
-  }
-
-  @Test
-  public void testConstructorType6() {
+  public void testObjectLiteralDeclaration3() {
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "function bar() {}\n"
-                + "function _foo() {\n"
-                + " /** @param {bar} x */\n"
-                + "  function f(x) {}\n"
-                + "}")
+            "/** @param {{foo: !Function}} x */ function f(x) {}" + "f({foo: function() {}});")
         .run();
   }
 
   @Test
-  public void testConstructorType7() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};");
-
-    JSType type = p.scope.getVar("A").getType();
-    assertThat(type).isInstanceOf(FunctionType.class);
-    FunctionType fType = (FunctionType) type;
-    assertThat(fType.getReferenceName()).isEqualTo("A");
+  public void testObjectLiteralDeclaration4() {
+    testClosureTypes(
+        "var x = {"
+            + "  /** @param {boolean} x */ abc: function(x) {}"
+            + "};"
+            + "/**\n"
+            + " * @param {string} x\n"
+            + " * @suppress {duplicate}\n"
+            + " */ x.abc = function(x) {};",
+        "assignment to property abc of x\n"
+            + "found   : function(string): undefined\n"
+            + "required: function(boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. Maybe it needs
+    // a new suppress name instead?
   }
 
   @Test
-  public void testConstructorType8() {
+  public void testObjectLiteralDeclaration5() {
     newTest()
         .addSource(
-            "var ns = {};"
-                + "ns.create = function() { return function() {}; };"
-                + "/** @constructor */ ns.Foo = ns.create();"
-                + "ns.Foo.prototype = {x: 0, y: 0};"
+            "var x = {"
+                + "  /** @param {boolean} x */ abc: function(x) {}"
+                + "};"
                 + "/**\n"
-                + " * @param {ns.Foo} foo\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function f(foo) {"
-                + "  return foo.x;"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+                + " * @param {boolean} x\n"
+                + " * @suppress {duplicate}\n"
+                + " */ x.abc = function(x) {};")
         .run();
   }
 
   @Test
-  public void testConstructorType9() {
+  public void testObjectLiteralDeclaration6() {
     newTest()
         .addSource(
-            "var ns = {};"
-                + "ns.create = function() { return function() {}; };"
-                + "ns.extend = function(x) { return x; };"
-                + "/** @constructor */ ns.Foo = ns.create();"
-                + "ns.Foo.prototype = ns.extend({x: 0, y: 0});"
+            "var x = {};"
                 + "/**\n"
-                + " * @param {ns.Foo} foo\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function f(foo) {"
-                + "  return foo.x;"
-                + "}")
+                + " * @param {boolean} x\n"
+                + " * @suppress {duplicate}\n"
+                + " */ x.abc = function(x) {};"
+                + "x = {"
+                + "  /**\n"
+                + "   * @param {boolean} x\n"
+                + "   * @suppress {duplicate}\n"
+                + "   */"
+                + "  abc: function(x) {}"
+                + "};")
         .run();
   }
 
   @Test
-  public void testConstructorType10() {
+  public void testObjectLiteralDeclaration7() {
     newTest()
         .addSource(
-            "/** @constructor */"
-                + "function NonStr() {}"
+            "var x = {};"
                 + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @extends{NonStr}\n"
-                + " */"
-                + "function NonStrKid() {}")
+                + " * @type {function(boolean): undefined}\n"
+                + " */ x.abc = function(x) {};"
+                + "x = {"
+                + "  /**\n"
+                + "   * @param {boolean} x\n"
+                + "   * @suppress {duplicate}\n"
+                + "   */"
+                + "  abc: function(x) {}"
+                + "};")
         .run();
   }
 
   @Test
-  public void testConstructorType11() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function NonDict() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " * @extends{NonDict}\n"
-                + " */"
-                + "function NonDictKid() {}")
-        .run();
+  public void testCallDateConstructorAsFunction() {
+    // ECMA-262 15.9.2: When Date is called as a function rather than as a
+    // constructor, it returns a string.
+    Node n = parseAndTypeCheck("Date()");
+    assertTypeEquals(getNativeStringType(), n.getFirstFirstChild().getJSType());
   }
 
+  // According to ECMA-262, Error & Array function calls are equivalent to
+  // constructor calls.
+
   @Test
-  public void testConstructorType12() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "Bar.prototype = {};\n")
-        .run();
+  public void testCallErrorConstructorAsFunction() {
+    String externs =
+        lines(
+            "/** @constructor",
+            "    @param {string} message",
+            "    @return {!Error} */",
+            "function Error(message) {}");
+    Node n = parseAndTypeCheck(externs, "Error('x')");
+    Node call = n.getFirstFirstChild();
+    assertThat(call.isCall()).isTrue();
+    assertTypeEquals(
+        call.getFirstChild().getJSType().toMaybeFunctionType().getInstanceType(), call.getJSType());
   }
 
   @Test
-  public void testBadStruct() {
-    newTest()
-        .addSource("/** @struct */function Struct1() {}")
-        .addDiagnostic("@struct used without @constructor for Struct1")
-        .run();
+  public void testCallArrayConstructorAsFunction() {
+    Node n = parseAndTypeCheck("Array()");
+    assertTypeEquals(getNativeArrayType(), n.getFirstFirstChild().getJSType());
   }
 
   @Test
-  public void testBadDict() {
+  public void testPropertyTypeOfUnionType() {
     newTest()
-        .addSource("/** @dict */function Dict1() {}")
-        .addDiagnostic("@dict used without @constructor for Dict1")
+        .addSource(
+            "var a = {};"
+                + "/** @constructor */ a.N = function() {};\n"
+                + "a.N.prototype.p = 1;\n"
+                + "/** @constructor */ a.S = function() {};\n"
+                + "a.S.prototype.p = 'a';\n"
+                + "/** @param {!a.N|!a.S} x\n@return {string} */\n"
+                + "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testAnonymousPrototype1() {
+  public void testGetPropertyTypeOfUnionType_withMatchingTemplates() {
     newTest()
         .addSource(
-            "var ns = {};"
-                + "/** @constructor */ ns.Foo = function() {"
-                + "  this.bar(3, 5);"
-                + "};"
-                + "ns.Foo.prototype = {"
-                + "  bar: function(x) {}"
-                + "};")
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<number>} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
         .addDiagnostic(
-            "Function ns.Foo.prototype.bar: called with 2 argument(s). "
-                + "Function requires at least 1 argument(s) and no more "
-                + "than 1 argument(s).")
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testAnonymousPrototype2() {
+  public void testGetPropertyTypeOfUnionType_withDifferingTemplates() {
     newTest()
         .addSource(
-            "/** @interface */ var Foo = function() {};"
-                + "Foo.prototype = {"
-                + "  foo: function(x) {}"
-                + "};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @implements {Foo}\n"
-                + " */ var Bar = function() {};")
-        .addDiagnostic("property foo on interface Foo is not implemented by type Bar")
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<string>} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : (number|string)",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testAnonymousType1() {
+  public void testGetPropertyTypeOfUnionType_withMembersThatExtendATemplatizedType() {
     newTest()
         .addSource(
-            "function f() { return {}; }", //
-            "/** @constructor */",
-            "f().bar = function() {};")
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "",
+            "/** @interface @extends {Foo<number>} */ function Bar() {};",
+            "/** @interface @extends {Foo<number>} */ function Baz() {}",
+            "",
+            "/**",
+            " * @param {!Bar|!Baz} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testAnonymousType2() {
+  public void testInvalidAssignToPropertyTypeOfUnionType_withMatchingTemplates_doesntWarn() {
+    // We don't warn for this assignment because we treat the type of `x.p` as inferred...
     newTest()
         .addSource(
-            "function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};")
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<number>} x",
+            " */",
+            "var f = function(x) { x.p = 'not a number'; };")
         .run();
   }
 
+  // TODO(user): We should flag these as invalid. This will probably happen
+  // when we make sure the interface is never referenced outside of its
+  // definition. We might want more specific and helpful error messages.
   @Test
-  public void testAnonymousType3() {
+  @Ignore
+  public void testWarningOnInterfacePrototype() {
     newTest()
-        .addSource("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};")
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype = function() { };")
+        .addDiagnostic("e of its definition")
         .run();
   }
 
   @Test
-  public void testBang1() {
+  @Ignore
+  public void testBadPropertyOnInterface1() {
     newTest()
-        .addSource("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (Object|null)\n" + "required: Object")
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.f = function() { return 1;};")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testBang2() {
+  @Ignore
+  public void testBadPropertyOnInterface2() {
     newTest()
         .addSource(
-            "/** @param {Object} x\n@return {!Object} */\n"
-                + "function f(x) { return x ? x : new Object(); }")
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.f = function() { return 1;};")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testBang3() {
+  @Ignore
+  public void testBadPropertyOnInterface3() {
     newTest()
-        .addSource(
-            "/** @param {Object} x\n@return {!Object} */\n"
-                + "function f(x) { return /** @type {!Object} */ (x); }")
+        .addSource("/** @interface */ u.T = function() {}; u.T.x")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testBang4() {
+  @Ignore
+  public void testBadPropertyOnInterface4() {
     newTest()
-        .addSource(
-            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
-                + "function f(x, y) {\n"
-                + "if (typeof x != 'undefined') { return x == y; }\n"
-                + "else { return x != y; }\n}")
+        .addSource("/** @interface */ function T() {}; T.x;")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testBang5() {
+  public void testAnnotatedPropertyOnInterface1() {
+    // For interfaces we must allow function definitions that don't have a
+    // return statement, even though they declare a returned type.
     newTest()
         .addSource(
-            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
-                + "function f(x, y) { return !!x && x == y; }")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype.f = function() {};")
         .run();
   }
 
   @Test
-  public void testBang6() {
+  public void testAnnotatedPropertyOnInterface2() {
     newTest()
-        .addSource("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }")
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype.f = function() { };")
         .run();
   }
 
   @Test
-  public void testBang7() {
+  public void testAnnotatedPropertyOnInterface3() {
     newTest()
         .addSource(
-            "/**@param {(Object|string|null)} x\n"
-                + "@return {(Object|string)}*/function f(x) { return x; }")
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.prototype.f = function() { };")
         .run();
   }
 
   @Test
-  public void testDefinePropertyOnNullableObject1() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
+  public void testAnnotatedPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/** @type {Object} */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */ function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
+            CLOSURE_DEFS
+                + "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.prototype.f = goog.abstractMethod;")
         .run();
   }
 
+  // TODO(user): If we want to support this syntax we have to warn about
+  // missing annotations.
   @Test
-  public void testDefinePropertyOnNullableObject1a() {
+  @Ignore
+  public void testWarnUnannotatedPropertyOnInterface1() {
     newTest()
-        .addSource(
-            "/** @const */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
+        .addSource("/** @interface */ u.T = function() {}; u.T.prototype.x;")
+        .addDiagnostic("interface property x is not annotated")
         .run();
   }
 
   @Test
-  public void testDefinePropertyOnObject() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testWarnUnannotatedPropertyOnInterface2() {
     newTest()
-        .addSource(
-            "/** @type {!Object} */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
+        .addSource("/** @interface */ function T() {}; T.prototype.x;")
+        .addDiagnostic("interface property x is not annotated")
         .run();
   }
 
   @Test
-  public void testDefinePropertyOnNullableObject2() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
+  public void testWarnUnannotatedPropertyOnInterface5() {
     newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @param {T} t\n@return {boolean} */function f(t) {\n"
-                + "t.x = 1; return t.x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
+        .addSource("/** @interface */ u.T = function() {};\n" + "u.T.prototype.x = function() {};")
         .run();
   }
 
   @Test
-  public void testDefinePropertyOnNullableObject2b() {
+  public void testWarnUnannotatedPropertyOnInterface6() {
     newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};",
-            "/** @param {T} t */function f(t) { t.x = 1; }")
-        .addDiagnostic("Property x never defined on T")
+        .addSource("/** @interface */ function T() {};\n" + "T.prototype.x = function() {};")
         .run();
   }
 
+  // TODO(user): If we want to support this syntax we have to warn about
+  // the invalid type of the interface member.
   @Test
-  public void testUnknownConstructorInstanceType1() {
-    newTest().addSource("/** @return {Array} */ function g(f) { return new f(); }").run();
+  @Ignore
+  public void testWarnDataPropertyOnInterface1() {
+    newTest()
+        .addSource(
+            "/** @interface */ u.T = function() {};\n" + "/** @type {number} */u.T.prototype.x;")
+        .addDiagnostic("interface members can only be plain functions")
+        .run();
   }
 
   @Test
-  public void testUnknownConstructorInstanceType2() {
-    newTest().addSource("function g(f) { return /** @type {Array} */(new f()); }").run();
+  public void testDataPropertyOnInterface1() {
+    newTest()
+        .addSource("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;")
+        .run();
   }
 
   @Test
-  public void testUnknownConstructorInstanceType3() {
-    newTest().addSource("function g(f) { var x = new f(); x.a = 1; return x; }").run();
+  public void testDataPropertyOnInterface2() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() {}\n"
+                + "/** @override */\n"
+                + "C.prototype.x = 'foo';")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
+        .run();
   }
 
   @Test
-  public void testUnknownPrototypeChain1() {
+  public void testDataPropertyOnInterface3() {
     newTest()
         .addSource(
-            "/**",
-            "* @param {Object} co",
-            " * @return {Object}",
-            " */",
-            "function inst(co) {",
-            " /** @constructor */",
-            " var c = function() {};",
-            " c.prototype = co.prototype;",
-            " return new c;",
-            "}")
-        .addDiagnostic("Property prototype never defined on Object")
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() {}\n"
+                + "/** @override */\n"
+                + "C.prototype.x = 'foo';")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
         .run();
   }
 
   @Test
-  public void testUnknownPrototypeChain2() {
+  public void testDataPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/**",
-            " * @param {Function} co",
-            " * @return {Object}",
-            " */",
-            "function inst(co) {",
-            " /** @constructor */",
-            " var c = function() {};",
-            " c.prototype = co.prototype;",
-            " return new c;",
-            "}")
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() { /** @type {string} */ \n this.x = 'foo'; }\n")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
         .run();
   }
 
   @Test
-  public void testNamespacedConstructor() {
-    Node root =
-        parseAndTypeCheck(
-            "var goog = {};"
-                + "/** @constructor */ goog.MyClass = function() {};"
-                + "/** @return {!goog.MyClass} */ "
-                + "function foo() { return new goog.MyClass(); }");
-
-    JSType typeOfFoo = root.getLastChild().getJSType();
-    assertType(typeOfFoo).isInstanceOf(FunctionType.class);
-
-    JSType retType = ((FunctionType) typeOfFoo).getReturnType();
-    assertType(retType).isInstanceOf(ObjectType.class);
-    assertThat(((ObjectType) retType).getReferenceName()).isEqualTo("goog.MyClass");
-  }
-
-  @Test
-  public void testComplexNamespace() {
-    String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;";
-
-    TypeCheckResult p = parseAndTypeCheckWithScope(js);
-
-    // goog type in the scope
-    JSType googScopeType = p.scope.getVar("goog").getType();
-    assertThat(googScopeType).isInstanceOf(ObjectType.class);
-    assertWithMessage("foo property not present on goog type")
-        .that(googScopeType.hasProperty("foo"))
-        .isTrue();
-    assertWithMessage("bar property present on goog type")
-        .that(googScopeType.hasProperty("bar"))
-        .isFalse();
-
-    // goog type on the VAR node
-    Node varNode = p.root.getFirstChild();
-    assertNode(varNode).hasToken(Token.VAR);
-    JSType googNodeType = varNode.getFirstChild().getJSType();
-    assertThat(googNodeType).isInstanceOf(ObjectType.class);
-
-    // goog scope type and goog type on VAR node must be the same
-    assertThat(googScopeType).isSameInstanceAs(googNodeType);
-
-    // goog type on the left of the GETPROP node (under fist ASSIGN)
-    Node getpropFoo1 = varNode.getNext().getFirstFirstChild();
-    assertNode(getpropFoo1).hasToken(Token.GETPROP);
-    assertThat(getpropFoo1.getFirstChild().getString()).isEqualTo("goog");
-    JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType();
-    assertThat(googGetpropFoo1Type).isInstanceOf(ObjectType.class);
-
-    // still the same type as the one on the variable
-    assertThat(googGetpropFoo1Type).isSameInstanceAs(googScopeType);
-
-    // the foo property should be defined on goog
-    JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo");
-    assertThat(googFooType).isInstanceOf(ObjectType.class);
-
-    // goog type on the left of the GETPROP lower level node
-    // (under second ASSIGN)
-    Node getpropFoo2 = varNode.getNext().getNext().getFirstFirstChild().getFirstChild();
-    assertNode(getpropFoo2).hasToken(Token.GETPROP);
-    assertThat(getpropFoo2.getFirstChild().getString()).isEqualTo("goog");
-    JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType();
-    assertThat(googGetpropFoo2Type).isInstanceOf(ObjectType.class);
-
-    // still the same type as the one on the variable
-    assertThat(googGetpropFoo2Type).isSameInstanceAs(googScopeType);
-
-    // goog.foo type on the left of the top-level GETPROP node
-    // (under second ASSIGN)
-    JSType googFooGetprop2Type = getpropFoo2.getJSType();
-    assertWithMessage("goog.foo incorrectly annotated in goog.foo.bar selection")
-        .that(googFooGetprop2Type)
-        .isInstanceOf(ObjectType.class);
-    ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type;
-    assertWithMessage("foo property present on goog.foo type")
-        .that(googFooGetprop2ObjectType.hasProperty("foo"))
-        .isFalse();
-    assertWithMessage("bar property not present on goog.foo type")
-        .that(googFooGetprop2ObjectType.hasProperty("bar"))
-        .isTrue();
-    assertTypeEquals(
-        "bar property on goog.foo type incorrectly inferred",
-        getNativeNumberType(),
-        googFooGetprop2ObjectType.getPropertyType("bar"));
-  }
-
-  @Test
-  public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() {
-    disableStrictMissingPropertyChecks();
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS, "/** @constructor */function A() {}" + "A.prototype.m1 = 5");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 1);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
+  public void testWarnDataPropertyOnInterface3() {
+    newTest()
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @type {number} */u.T.prototype.x = 1;")
+        .addDiagnostic(
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod")
+        .run();
   }
 
   @Test
-  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            "var goog = {};"
-                + "goog.A = /** @constructor */function() {};"
-                + "/** @type {number} */goog.A.prototype.m1 = 5");
-
-    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
+  public void testWarnDataPropertyOnInterface4() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;")
+        .addDiagnostic(
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod")
+        .run();
   }
 
+  // TODO(user): If we want to support this syntax we should warn about the
+  // mismatching types in the two tests below.
   @Test
-  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            "var goog = {};"
-                + "/** @constructor */goog.A = function() {};"
-                + "/** @type {number} */goog.A.prototype.m1 = 5");
-
-    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
-  }
-
-  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(TypeCheckResult p) {
-    ObjectType goog = (ObjectType) p.scope.getVar("goog").getType();
-    assertHasXMorePropertiesThanNativeObject(goog, 1);
-    JSType googA = goog.getPropertyType("A");
-    assertThat(googA).isNotNull();
-    assertThat(googA).isInstanceOf(FunctionType.class);
-    FunctionType googAFunction = (FunctionType) googA;
-    ObjectType classA = googAFunction.getInstanceType();
-    assertHasXMorePropertiesThanNativeObject(classA, 1);
-    checkObjectType(classA, "m1", getNativeNumberType());
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface1() {
+    newTest()
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "/** @param {String} foo */function(foo) {};")
+        .addDiagnostic("found   : \n" + "required: ")
+        .run();
   }
 
   @Test
-  public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 2);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
-    checkObjectType(instanceType, "m2", getNativeBooleanType());
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface2() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */T.prototype.x =\n"
+                + "/** @return {string} */function() {};")
+        .addDiagnostic("found   : \n" + "required: ")
+        .run();
   }
 
+  // TODO(user): We should warn about this (bar is missing an annotation). We
+  // probably don't want to warn about all missing parameter annotations, but
+  // we should be as strict as possible regarding interfaces.
   @Test
-  public void testDontAddMethodsIfNoConstructor() {
-    Node js1Node = parseAndTypeCheck("function A() {}" + "A.prototype = {m1: 5, m2: true}");
-
-    JSType functionAType = js1Node.getFirstChild().getJSType();
-    assertThat(functionAType.toString()).isEqualTo("function(): undefined");
-    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m1"));
-    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m2"));
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface3() {
+    newTest()
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "function(foo, bar) {};")
+        .addDiagnostic("found   : \n" + "required: ")
+        .run();
   }
 
   @Test
-  public void testFunctionAssignement() {
+  public void testErrorMismatchingPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/**"
-                + "* @param {string} ph0"
-                + "* @param {string} ph1"
-                + "* @return {string}"
-                + "*/"
-                + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}"
-                + "/** @type {Function} */"
-                + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "function() {};")
+        .addDiagnostic("parameter foo does not appear in u.T.prototype.x's parameter list")
         .run();
   }
 
   @Test
-  public void testAddMethodsPrototypeTwoWays() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {}"
-                + "A.prototype = {m1: 5, m2: true};"
-                + "A.prototype.m3 = 'third property!';");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertThat(instanceType.toString()).isEqualTo("A");
-    assertHasXMorePropertiesThanNativeObject(instanceType, 3);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
-    checkObjectType(instanceType, "m2", getNativeBooleanType());
-    checkObjectType(instanceType, "m3", getNativeStringType());
+  public void testErrorMismatchingPropertyOnInterface5() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x = function() { };")
+        .addDiagnostic(
+            "assignment to property x of T.prototype\n"
+                + "found   : function(): undefined\n"
+                + "required: number")
+        .run();
   }
 
   @Test
-  public void testPrototypePropertyTypes() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {\n"
-                + "  /** @type {string} */ this.m1;\n"
-                + "  /** @type {Object?} */ this.m2 = {};\n"
-                + "  /** @type {boolean} */ this.m3;\n"
-                + "}\n"
-                + "/** @type {string} */ A.prototype.m4;\n"
-                + "/** @type {number} */ A.prototype.m5 = 0;\n"
-                + "/** @type {boolean} */ A.prototype.m6;\n");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 6);
-    checkObjectType(instanceType, "m1", getNativeStringType());
-    checkObjectType(
-        instanceType, "m2", createUnionType(getNativeObjectType(), getNativeNullType()));
-    checkObjectType(instanceType, "m3", getNativeBooleanType());
-    checkObjectType(instanceType, "m4", getNativeStringType());
-    checkObjectType(instanceType, "m5", getNativeNumberType());
-    checkObjectType(instanceType, "m6", getNativeBooleanType());
+  public void testErrorMismatchingPropertyOnInterface6() {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1",
+        ImmutableList.of(
+            "assignment to property x of T.prototype\n"
+                + "found   : number\n"
+                + "required: function(this:T): number",
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod"));
   }
 
   @Test
-  public void testValueTypeBuiltInPrototypePropertyType() {
-    Node node = parseAndTypeCheck(new TestExternsBuilder().addString().build(), "\"x\".charAt(0)");
-    assertTypeEquals(getNativeStringType(), node.getFirstFirstChild().getJSType());
+  public void testInterfaceNonEmptyFunction() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }")
+        .addDiagnostic("interface member functions must have an empty body")
+        .run();
   }
 
   @Test
-  public void testDeclareBuiltInConstructor() {
-    // Built-in prototype properties should be accessible
-    // even if the built-in constructor is declared.
-    Node node =
-        parseAndTypeCheck(
-            new TestExternsBuilder().addString().build(),
-            lines(
-                "/** @constructor */ var String = function(opt_str) {};",
-                "(new String(\"x\")).charAt(0)"));
-    assertTypeEquals(getNativeStringType(), node.getLastChild().getFirstChild().getJSType());
+  public void testDoubleNestedInterface() {
+    newTest()
+        .addSource(
+            "/** @interface */ var I1 = function() {};\n"
+                + "/** @interface */ I1.I2 = function() {};\n"
+                + "/** @interface */ I1.I2.I3 = function() {};\n")
+        .run();
   }
 
   @Test
-  public void testExtendBuiltInType1() {
-    String externs =
-        "/** @constructor */ var String = function(opt_str) {};\n"
-            + "/**\n"
-            + "* @param {number} start\n"
-            + "* @param {number} opt_length\n"
-            + "* @return {string}\n"
-            + "*/\n"
-            + "String.prototype.substr = function(start, opt_length) {};\n";
-    Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);");
-    assertTypeEquals(getNativeStringType(), n1.getLastChild().getFirstChild().getJSType());
+  public void testStaticDataPropertyOnNestedInterface() {
+    newTest()
+        .addSource(
+            "/** @interface */ var I1 = function() {};\n"
+                + "/** @interface */ I1.I2 = function() {};\n"
+                + "/** @type {number} */ I1.I2.x = 1;\n")
+        .run();
   }
 
   @Test
-  public void testExtendBuiltInType2() {
-    String externs =
-        "/** @constructor */ var String = function(opt_str) {};\n"
-            + "/**\n"
-            + "* @param {number} start\n"
-            + "* @param {number} opt_length\n"
-            + "* @return {string}\n"
-            + "*/\n"
-            + "String.prototype.substr = function(start, opt_length) {};\n";
-    Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);");
-    assertTypeEquals(getNativeStringType(), n2.getLastChild().getFirstChild().getJSType());
+  public void testInterfaceInstantiation() {
+    newTest()
+        .addSource("/** @interface */var f = function(){}; new f")
+        .addDiagnostic("cannot instantiate non-constructor")
+        .run();
   }
 
   @Test
-  public void testExtendFunction1() {
-    Node n =
-        parseAndTypeCheck(
-            "/**@return {number}*/Function.prototype.f = "
-                + "function() { return 1; };\n"
-                + "(new Function()).f();");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertTypeEquals(getNativeNumberType(), type);
+  public void testPrototypeLoop() {
+    disableStrictMissingPropertyChecks();
+
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @constructor \n * @extends {T} */var T = function() {};"
+            + "alert((new T).foo);",
+        ImmutableList.of(
+            "Cycle detected in inheritance chain of type T",
+            "Could not resolve type in @extends tag of T"));
   }
 
   @Test
-  public void testExtendFunction2() {
-    Node n =
-        parseAndTypeCheck(
-            "/**@return {number}*/Function.prototype.f = "
-                + "function() { return 1; };\n"
-                + "(function() {}).f();");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertTypeEquals(getNativeNumberType(), type);
+  public void testImplementsLoop() {
+    testClosureTypesMultipleWarnings(
+        lines(
+            "/** @constructor \n * @implements {T} */var T = function() {};",
+            suppressMissingPropertyFor("T", "foo"),
+            "alert((new T).foo);"),
+        ImmutableList.of("Cycle detected in inheritance chain of type T"));
   }
 
   @Test
-  public void testClassExtendPrimitive() {
-    newTest()
-        .addSource("/** @extends {number} */ class C extends number {}")
-        .addDiagnostic("C @extends non-object type number")
-        .run();
+  public void testImplementsExtendsLoop() {
+    disableStrictMissingPropertyChecks();
+
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @constructor \n * @implements {F} */var G = function() {};"
+            + "/** @constructor \n * @extends {G} */var F = function() {};"
+            + "alert((new F).foo);",
+        ImmutableList.of("Cycle detected in inheritance chain of type F"));
   }
 
+  // TODO(johnlenz): This test causes an infinite loop,
   @Test
-  public void testInheritanceCheck1() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .run();
+  @Ignore
+  public void testInterfaceExtendsLoop() {
+    testClosureTypesMultipleWarnings(
+        lines(
+            "/** @interface \n * @extends {F} */var G = function() {};",
+            "/** @interface \n * @extends {G} */var F = function() {};",
+            "/** @constructor \n * @implements {F} */var H = function() {};",
+            suppressMissingPropertyFor("H", "foo"),
+            "alert((new H).foo);"),
+        ImmutableList.of(
+            "extends loop involving F, " + "loop: F -> G -> F",
+            "extends loop involving G, " + "loop: G -> F -> G"));
   }
 
   @Test
-  public void testInheritanceCheck2() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("property foo not defined on any superclass of Sub")
-        .run();
+  public void testInterfaceExtendsLoop2() {
+    testClosureTypes(
+        lines(
+            "/** @record \n * @extends {F} */var G = function() {};",
+            "/** @record \n * @extends {G} */var F = function() {};",
+            "/** @constructor \n * @implements {F} */var H = function() {};",
+            suppressMissingPropertyFor("H", "foo"),
+            "alert((new H).foo);"),
+        "Cycle detected in inheritance chain of type F");
   }
 
   @Test
-  public void testInheritanceCheck3() {
+  public void testInheritPropFromMultipleInterfaces1() {
+    // Low#prop gets the type of whichever property is declared last,
+    // even if that type is not the most specific.
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
+            "/** @interface */",
+            "function High1() {}",
+            "/** @type {number|string} */",
+            "High1.prototype.prop;",
+            "/** @interface */",
+            "function High2() {}",
+            "/** @type {number} */",
+            "High2.prototype.prop;",
+            "/**",
+            " * @interface",
+            " * @extends {High1}",
+            " * @extends {High2}",
+            " */",
+            "function Low() {}",
+            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
         .addDiagnostic(
-            "property foo already defined on superclass Super; " + "use @override to override it")
+            lines(
+                "initializing variable", //
+                "found   : (number|string)",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testInheritanceCheck4() {
+  public void testInheritPropFromMultipleInterfaces2() {
+    // Low#prop gets the type of whichever property is declared last,
+    // even if that type is not the most specific.
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
+            "/** @interface */",
+            "function High1() {}",
+            "/** @type {number} */",
+            "High1.prototype.prop;",
+            "/** @interface */",
+            "function High2() {}",
+            "/** @type {number|string} */",
+            "High2.prototype.prop;",
+            "/**",
+            " * @interface",
+            " * @extends {High1}",
+            " * @extends {High2}",
+            " */",
+            "function Low() {}",
+            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testInheritanceCheck5() {
+  public void testInheritPropFromMultipleInterfaces3() {
     newTest()
         .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .addDiagnostic(
-            "property foo already defined on superclass Root; " + "use @override to override it")
+            "/**",
+            " * @interface",
+            " * @template T1",
+            " */",
+            "function MyCollection() {}",
+            "/**",
+            " * @interface",
+            " * @template T2",
+            " * @extends {MyCollection<T2>}",
+            " */",
+            "function MySet() {}",
+            "/**",
+            " * @interface",
+            " * @template T3,T4",
+            " */",
+            "function MyMapEntry() {}",
+            "/**",
+            " * @interface",
+            " * @template T5,T6",
+            " */",
+            "function MyMultimap() {}",
+            "/** @return {MyCollection<MyMapEntry<T5, T6>>} */",
+            "MyMultimap.prototype.entries = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T7,T8",
+            " * @extends {MyMultimap<T7, T8>}",
+            " */",
+            "function MySetMultimap() {}",
+            "/** @return {MySet<MyMapEntry<T7, T8>>} */",
+            "MySetMultimap.prototype.entries = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T9,T10",
+            " * @extends {MyMultimap<T9, T10>}",
+            " */",
+            "function MyFilteredMultimap() {}",
+            "/**",
+            " * @interface",
+            " * @template T11,T12",
+            " * @extends {MyFilteredMultimap<T11, T12>}",
+            " * @extends {MySetMultimap<T11, T12>}",
+            " */",
+            "function MyFilteredSetMultimap() {}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck6() {
+  public void testInheritSameGenericInterfaceFromDifferentPaths() {
     newTest()
         .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
+            "/** @const */ var ns = {};",
+            "/**",
+            " * @constructor",
+            " * @template T1",
+            " */",
+            "ns.Foo = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T2",
+            " */",
+            "ns.High = function() {};",
+            "/** @type {!ns.Foo<T2>} */",
+            "ns.High.prototype.myprop;",
+            "/**",
+            " * @interface",
+            " * @template T3",
+            " * @extends {ns.High<T3>}",
+            " */",
+            "ns.Med1 = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T4",
+            " * @extends {ns.High<T4>}",
+            " */",
+            "ns.Med2 = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T5",
+            " * @extends {ns.Med1<T5>}",
+            " * @extends {ns.Med2<T5>}",
+            " */",
+            "ns.Low = function() {};")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck7() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "goog.Sub.prototype.foo = 5;")
-        .run();
+  public void testConversionFromInterfaceToRecursiveConstructor() {
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @interface */ var OtherType = function() {}\n"
+            + "/** @implements {MyType} \n * @constructor */\n"
+            + "var MyType = function() {}\n"
+            + "/** @type {MyType} */\n"
+            + "var x = /** @type {!OtherType} */ (new Object());",
+        ImmutableList.of(
+            "Cycle detected in inheritance chain of type MyType",
+            "initializing variable\n" + "found   : OtherType\n" + "required: (MyType|null)"));
   }
 
   @Test
-  public void testInheritanceCheck8() {
+  public void testDirectPrototypeAssign() {
+    // For now, we just ignore @type annotations on the prototype.
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override */goog.Sub.prototype.foo = 5;")
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @type {Array} */ Bar.prototype = new Foo()")
         .run();
   }
 
+  // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
+  // be resolved via the registry and not via properties.
+
   @Test
-  public void testInheritanceCheck9_1() {
+  public void testResolutionViaRegistry1() {
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() { return 3; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1; };")
+            "/** @constructor */ u.T = function() {};\n"
+                + "/** @type {(number|string)} */ u.T.prototype.a;\n"
+                + "/**\n"
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck9_2() {
+  public void testResolutionViaRegistry2() {
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @return {number} */"
-                + "Super.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo =\n"
-                + "function() {};")
+            "/** @constructor */ u.T = function() {"
+                + "  this.a = 0; };\n"
+                + "/**\n"
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck9_3() {
+  public void testResolutionViaRegistry3() {
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @return {number} */"
-                + "Super.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
-                + "function() { return \"some string\" };")
+            "/** @constructor */ u.T = function() {};\n"
+                + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n"
+                + "/**\n"
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
         .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Super\n"
-                + "original: function(this:Super): number\n"
-                + "override: function(this:Sub): string")
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck10_1() {
+  public void testResolutionViaRegistry4() {
     newTest()
         .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() { return 3; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1; };")
+            "/** @constructor */ u.A = function() {};\n"
+                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;"
+                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n"
+                + "var ab = new u.A.B();\n"
+                + "/** @type {!u.A} */ var a = ab;\n"
+                + "/** @type {!u.A.A} */ var aa = ab;\n")
+        .addDiagnostic("initializing variable\n" + "found   : u.A.B\n" + "required: u.A.A")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck10_2() {
+  public void testResolutionViaRegistry5() {
+    Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertThat(type).isInstanceOf(FunctionType.class);
+    assertThat(((FunctionType) type).getInstanceType().getReferenceName()).isEqualTo("u.T");
+  }
+
+  @Test
+  public void testGatherProperyWithoutAnnotation1() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertThat(type).isInstanceOf(ObjectType.class);
+    ObjectType objectType = (ObjectType) type;
+    assertThat(objectType.hasProperty("x")).isFalse();
+  }
+
+  @Test
+  public void testGatherProperyWithoutAnnotation2() {
+    TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;");
+    Node n = ns.root;
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertTypeEquals(type, getNativeObjectType());
+    assertThat(type).isInstanceOf(ObjectType.class);
+    ObjectType objectType = (ObjectType) type;
+    assertThat(objectType.hasProperty("x")).isFalse();
+  }
+
+  @Test
+  public void testFunctionMasksVariableBug() {
     newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "/** @return {number} */"
-                + "Root.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo =\n"
-                + "function() {};")
+        .addSource("var x = 4; var f = function x(b) { return b ? 1 : x(true); };")
+        .addDiagnostic("function x masks variable (IE bug)")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck10_3() {
+  public void testDfa1() {
+    newTest().addSource("var x = null;\n x = 1;\n /** @type {number} */ var y = x;").run();
+  }
+
+  @Test
+  public void testDfa2() {
     newTest()
         .addSource(
-            "/** @constructor */function Root() {};"
-                + "/** @return {number} */"
-                + "Root.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
-                + "function() { return \"some string\" };")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Root\n"
-                + "original: function(this:Root): number\n"
-                + "override: function(this:Sub): string")
+            "function u() {}\n"
+                + "/** @return {number} */ function f() {\nvar x = 'todo';\n"
+                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck11() {
+  public void testDfa3() {
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Super\n"
-                + "original: function(this:Super, number): undefined\n"
-                + "override: function(this:Sub, string): undefined")
+            "function u() {}\n"
+                + "/** @return {number} */ function f() {\n"
+                + "/** @type {number|string} */ var x = 'todo';\n"
+                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck12() {
+  public void testDfa4() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override */goog.Sub.prototype.foo = \"some string\";")
+            "/** @param {Date?} d */ function f(d) {\n"
+                + "if (!d) { return; }\n"
+                + "/** @type {!Date} */ var e = d;\n}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck13() {
+  public void testDfa5() {
     newTest()
         .addSource(
-            "var goog = {};\n"
-                + "/** @constructor\n @extends {goog.Missing} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("Bad type annotation. Unknown type goog.Missing")
+            "/** @return {string?} */ function u() {return 'a';}\n"
+                + "/** @param {string?} x\n@return {string} */ function f(x) {\n"
+                + "while (!x) { x = u(); }\nreturn x;\n}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck14() {
-    testClosureTypes(
-        lines(
-            "/** @constructor\n @extends {goog.Missing} */",
-            "goog.Super = function() {};",
-            "/** @constructor\n @extends {goog.Super} */function Sub() {};",
-            "/** @override */ Sub.prototype.foo = function() {};"),
-        "Bad type annotation. Unknown type goog.Missing");
+  public void testDfa6() {
+    newTest()
+        .addSource(
+            "/** @return {Object?} */ function u() {return {};}\n"
+                + "/** @param {Object?} x */ function f(x) {\n"
+                + "while (x) { x = u(); if (!x) { x = u(); } }\n}")
+        .run();
   }
 
   @Test
-  public void testInheritanceCheck15() {
+  public void testDfa7() {
     newTest()
         .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo;"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n  @param {number} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @type {Date?} */ T.prototype.x = null;\n"
+                + "/** @param {!T} t */ function f(t) {\n"
+                + "if (!t.x) { return; }\n"
+                + "/** @type {!Date} */ var e = t.x;\n}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck16() {
+  public void testDfa8() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "/** @type {number} */ goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @type {number} */ goog.Sub.prototype.foo = 5;")
-        .addDiagnostic(
-            "property foo already defined on superclass goog.Super; "
-                + "use @override to override it")
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @type {number|string} */ T.prototype.x = '';\n"
+                + "function u() {}\n"
+                + "/** @param {!T} t\n@return {number} */ function f(t) {\n"
+                + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}")
         .run();
   }
 
   @Test
-  public void testInheritanceCheck17() {
-    // Make sure this warning still works, even when there's no
-    // @override tag.
+  public void testDfa9() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override @param {string} x */ goog.Sub.prototype.foo = function(x) {};")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass goog.Super\n"
-                + "original: function(this:goog.Super, number): undefined\n"
-                + "override: function(this:goog.Sub, string): undefined")
+            "function f() {\n/** @type {string?} */var x;\nx = null;\n"
+                + "if (x == null) { return 0; } else { return 1; } }")
+        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
         .run();
   }
 
   @Test
-  public void testInterfacePropertyOverride1() {
+  public void testDfa10() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
+            "/** @param {null} x */ function g(x) {}"
+                + "/** @param {string?} x */function f(x) {\n"
+                + "if (!x) { x = ''; }\n"
+                + "if (g(x)) { return 0; } else { return 1; } }")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: null")
         .run();
   }
 
   @Test
-  public void testInterfacePropertyOverride2() {
+  public void testDfa11() {
     newTest()
         .addSource(
-            "/** @interface */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @interface\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
+            "/** @param {string} opt_x\n@return {string} */\n"
+                + "function f(opt_x) { if (!opt_x) { "
+                + "throw new Error('x cannot be empty'); } return opt_x; }")
         .run();
   }
 
   @Test
-  public void testInterfacePropertyBadOverrideFails() {
+  public void testDfa12() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};",
-            "/** @type {number} */",
-            "Super.prototype.foo;",
-            "/** @interface @extends {Super} */function Sub() {};",
-            "/** @type {string} */",
-            "Sub.prototype.foo;")
+            "/** @param {string} x \n * @constructor \n */"
+                + "var Bar = function(x) {};"
+                + "/** @param {string} x */ function g(x) { return true; }"
+                + "/** @param {string|number} opt_x */ "
+                + "function f(opt_x) { "
+                + "  if (opt_x) { new Bar(g(opt_x) && 'x'); }"
+                + "}")
         .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Sub and the type of the property it "
-                    + "overrides from interface Super",
-                "original: number",
-                "override: string"))
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : (number|string)\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck1() {
+  public void testDfa13() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .addDiagnostic(
-            "property foo already defined on interface Super; use @override to " + "override it")
+            "/**\n"
+                + " * @param {string} x \n"
+                + " * @param {number} y \n"
+                + " * @param {number} z \n"
+                + " */"
+                + "function g(x, y, z) {}"
+                + "function f() { "
+                + "  var x = 'a'; g(x, x = 3, x);"
+                + "}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck2() {
+  public void testTypeInferenceWithCast1() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
+            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
+                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
+                + "/**@return {number?}*/function g(x) {"
+                + "var y = /**@type {number?}*/(u(x)); return f(y);}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck3() {
+  public void testTypeInferenceWithCast2() {
     newTest()
         .addSource(
-            "/** @interface */function Root() {};"
-                + "/** @return {number} */Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @return {number} */Sub.prototype.foo = function() { return 1;};")
-        .addDiagnostic(
-            "property foo already defined on interface Root; use @override to " + "override it")
+            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
+                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
+                + "/**@return {number?}*/function g(x) {"
+                + "var y; y = /**@type {number?}*/(u(x)); return f(y);}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck4() {
+  public void testTypeInferenceWithCast3() {
     newTest()
         .addSource(
-            "/** @interface */function Root() {};"
-                + "/** @return {number} */Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override\n * @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1;};")
+            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
+                + "/**@return {number}*/function g(x) {"
+                + "return /**@type {number}*/(u(x));}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck5() {
+  public void testTypeInferenceWithCast4() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};/** @return {string} */Super.prototype.foo ="
-                + " function() {};/** @constructor\n"
-                + " @implements {Super} */function Sub() {};/** @override\n"
-                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
-        .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Super\n"
-                + "original: function(this:Super): string\n"
-                + "override: function(this:Sub): number")
+            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
+                + "/**@return {number}*/function g(x) {"
+                + "return /**@type {number}*/(u(x)) && 1;}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck6() {
+  public void testTypeInferenceWithCast5() {
     newTest()
         .addSource(
-            "/** @interface */function Root() {};/** @return {string} */Root.prototype.foo ="
-                + " function() {};/** @interface\n"
-                + " @extends {Root} */function Super() {};/** @constructor\n"
-                + " @implements {Super} */function Sub() {};/** @override\n"
-                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
+            "/** @param {number} x */ function foo(x) {}"
+                + "/** @param {{length:*}} y */ function bar(y) {"
+                + "  /** @type {string} */ y.length;"
+                + "  foo(y.length);"
+                + "}")
         .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Root\n"
-                + "original: function(this:Root): string\n"
-                + "override: function(this:Sub): number")
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck7() {
+  public void testTypeInferenceWithClosure1() {
     newTest()
         .addSource(
-            "/** @interface */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
-        .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Super\n"
-                + "original: function(this:Super, number): undefined\n"
-                + "override: function(this:Sub, string): undefined")
+            "/** @return {boolean} */"
+                + "function f() {"
+                + "  /** @type {?string} */ var x = null;"
+                + "  function g() { x = 'y'; } g(); "
+                + "  return x == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck8() {
+  public void testTypeInferenceWithClosure2() {
     newTest()
         .addSource(
-            "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("Bad type annotation. Unknown type Super")
-        .addDiagnostic("property foo not defined on any superclass of Sub")
+            "/** @return {boolean} */"
+                + "function f() {"
+                + "  /** @type {?string} */ var x = null;"
+                + "  function g() { x = 'y'; } g(); "
+                + "  return x === 3;"
+                + "}")
+        .addDiagnostic(
+            "condition always evaluates to false\n" + "left : (null|string)\n" + "right: number")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck9() {
+  public void testTypeInferenceWithNoEntry1() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.bar = function() {};"
-                + "/** @constructor */ function F() {}"
-                + "/** @return {number} */ F.prototype.bar = function() {return 3; };"
-                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
-                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
-                + "function G() {}"
-                + "/** @return {string} */ function f() { return new G().bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.init = function() {"
+                + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
+                + "};"
+                + "/**\n"
+                + " * @extends {Foo}\n"
+                + " * @constructor\n"
+                + " */"
+                + "function SubFoo() {}"
+                + "/** Method */"
+                + "SubFoo.prototype.method = function() {"
+                + "  for (var i = 0; i < 10; i++) {"
+                + "    f(this.bar);"
+                + "    f(this.bar.baz);"
+                + "  }"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (null|{baz: number})\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck10() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.bar = function() {};"
-                + "/** @constructor */ function F() {}"
-                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
-                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
-                + "function G() {}"
-                + "/** @return {number} \n * @override */ "
-                + "G.prototype.bar = G.prototype.foo;"
-                + "/** @return {string} */ function f() { return new G().bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testTypeInferenceWithNoEntry2() {
+    testClosureTypes(
+        "/** @param {number} x */ function f(x) {}"
+            + "/** @param {!Object} x */ function g(x) {}"
+            + "/** @constructor */ function Foo() {}"
+            + "Foo.prototype.init = function() {"
+            + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
+            + "};"
+            + "/**\n"
+            + " * @extends {Foo}\n"
+            + " * @constructor\n"
+            + " */"
+            + "function SubFoo() {}"
+            + "/** Method */"
+            + "SubFoo.prototype.method = function() {"
+            + "  for (var i = 0; i < 10; i++) {"
+            + "    f(this.bar);"
+            + "    goog.asserts.assert(this.bar);"
+            + "    g(this.bar);"
+            + "  }"
+            + "};",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : (null|{baz: number})\n"
+            + "required: number");
   }
 
   @Test
-  public void testInterfaceInheritanceCheck12() {
+  public void testForwardPropertyReference() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {};\n"
-                + "/** @type {string} */ I.prototype.foobar;\n"
-                + "/** \n * @constructor \n * @implements {I} */\n"
-                + "function C() {\n"
-                + "/** \n * @type {number} */ this.foobar = 2;};\n"
-                + "/** @type {I} */ \n var test = new C(); alert(test.foobar);")
-        .addDiagnostic(
-            "mismatch of the foobar property on type C and the type of the property"
-                + " it overrides from interface I\n"
-                + "original: string\n"
-                + "override: number")
+            "/** @constructor */ var Foo = function() { this.init(); };"
+                + "/** @return {string} */"
+                + "Foo.prototype.getString = function() {"
+                + "  return this.number_;"
+                + "};"
+                + "Foo.prototype.init = function() {"
+                + "  /** @type {number} */"
+                + "  this.number_ = 3;"
+                + "};")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testInterfaceInheritanceCheck13() {
+  public void testNoForwardTypeDeclaration() {
     newTest()
-        .addSource(
-            "function abstractMethod() {};\n"
-                + "/** @interface */var base = function() {};\n"
-                + "/** @extends {base} \n @interface */ var Int = function() {}\n"
-                + "/** @type {{bar : !Function}} */ var x; \n"
-                + "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n"
-                + "/** @type {Int} */ var foo;\n"
-                + "foo.bar();")
+        .addSource("/** @param {MyType} x */ function f(x) {}")
+        .addDiagnostic("Bad type annotation. Unknown type MyType")
         .run();
   }
 
-  /** Verify that templatized interfaces can extend one another and share template values. */
   @Test
-  public void testInterfaceInheritanceCheck14() {
+  public void testNoForwardTypeDeclarationAndNoBraces() {
     newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
-                + "/** @return {U} */B.prototype.bar = function() {};"
-                + "/** @constructor\n @implements {B<string>} */function C() {};"
-                + "/** @return {string}\n @override */C.prototype.foo = function() {};"
-                + "/** @return {string}\n @override */C.prototype.bar = function() {};")
+        .addSource("/** @return The result. */ function f() {}")
+        .addDiagnostic(RhinoErrorReporter.JSDOC_MISSING_TYPE_WARNING)
         .run();
   }
 
-  /** Verify that templatized instances can correctly implement templatized interfaces. */
   @Test
-  public void testInterfaceInheritanceCheck15() {
-    newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
-                + "/** @return {U} */B.prototype.bar = function() {};"
-                + "/** @constructor\n @template V\n @implements {B<V>}\n */function C() {};"
-                + "/** @return {V}\n @override */C.prototype.foo = function() {};"
-                + "/** @return {V}\n @override */C.prototype.bar = function() {};")
-        .run();
+  public void testForwardTypeDeclaration2() {
+    String f = "goog.forwardDeclare('MyType');" + "/** @param {MyType} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(
+        f + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: (MyType|null)");
   }
 
-  /**
-   * Verify that using @override to declare the signature for an implementing class works correctly
-   * when the interface is generic.
-   */
   @Test
-  public void testInterfaceInheritanceCheck16() {
-    newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @return {T} */A.prototype.bar = function() {};"
-                + "/** @constructor\n @implements {A<string>} */function B() {};"
-                + "/** @override */B.prototype.foo = function() { return 'string'};"
-                + "/** @override */B.prototype.bar = function() { return 3 };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
+  public void testForwardTypeDeclaration3() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */ function f(x) { return x; }"
+            + "/** @constructor */ var MyType = function() {};"
+            + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: (MyType|null)");
   }
 
   @Test
-  public void testInterfacePropertyNotImplemented() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int() {};"
-                + "Int.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Int} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
-        .run();
+  public void testForwardTypeDeclaration4() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */ function f(x) { return x; }"
+            + "/** @constructor */ var MyType = function() {};"
+            + "f(new MyType());",
+        null);
   }
 
   @Test
-  public void testInterfacePropertyNotImplemented2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int() {};"
-                + "Int.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int} */function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
-        .run();
+  public void testForwardTypeDeclaration5() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @constructor\n"
+            + " * @extends {MyType}\n"
+            + " */ var YourType = function() {};"
+            + "/** @override */ YourType.prototype.method = function() {};",
+        "Could not resolve type in @extends tag of YourType");
   }
 
-  /** Verify that templatized interfaces enforce their template type values. */
   @Test
-  public void testInterfacePropertyNotImplemented3() {
-    newTest()
-        .addSource(
-            "/** @interface  @template T */ function Int() {};",
-            "/** @return {T} */ Int.prototype.foo = function() {};",
-            "",
-            "/** @constructor @implements {Int<string>} */ function Foo() {};",
-            "/** @return {number}  @override */ Foo.prototype.foo = function() {};")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Foo and the type of the property it "
-                    + "overrides from interface Int",
-                "original: function(this:Int): string",
-                "override: function(this:Foo): number"))
-        .run();
+  public void testForwardTypeDeclaration6() {
+    testClosureTypesMultipleWarnings(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @constructor\n"
+            + " * @implements {MyType}\n"
+            + " */ var YourType = function() {};"
+            + "/** @override */ YourType.prototype.method = function() {};",
+        ImmutableList.of(
+            "Could not resolve type in @implements tag of YourType",
+            "property method not defined on any superclass of YourType"));
   }
 
   @Test
-  public void testStubConstructorImplementingInterface() {
-    // This does not throw a warning for unimplemented property because Foo is
-    // just a stub.
-    newTest()
-        .addExterns(
-            "/** @interface */ function Int() {}\n"
-                + "Int.prototype.foo = function() {};"
-                + "/** @constructor \n @implements {Int} */ var Foo;\n")
-        .addSource("")
-        .run();
+  public void testForwardTypeDeclaration7() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType=} x */"
+            + "function f(x) { return x == undefined; }",
+        null);
   }
 
   @Test
-  public void testObjectLiteral() {
-    Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}");
+  public void testForwardTypeDeclaration8() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */"
+            + "function f(x) { return x.name == undefined; }",
+        null);
+  }
 
-    Node nameNode = n.getFirstFirstChild();
-    Node objectNode = nameNode.getFirstChild();
-
-    // node extraction
-    assertNode(nameNode).hasToken(Token.NAME);
-    assertNode(objectNode).hasToken(Token.OBJECTLIT);
-
-    // value's type
-    ObjectType objectType = (ObjectType) objectNode.getJSType();
-    assertTypeEquals(getNativeNumberType(), objectType.getPropertyType("m1"));
-    assertTypeEquals(getNativeStringType(), objectType.getPropertyType("m2"));
-
-    // variable's type
-    assertTypeEquals(objectType, nameNode.getJSType());
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration1() {
-    newTest()
-        .addSource(
-            "var x = {"
-                + "/** @type {boolean} */ abc: true,"
-                + "/** @type {number} */ 'def': 0,"
-                + "/** @type {string} */ 3: 'fgh'"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration2() {
-    newTest()
-        .addSource("var x = {" + "  /** @type {boolean} */ abc: true" + "};" + "x.abc = 0;")
-        .addDiagnostic(
-            "assignment to property abc of x\n" + "found   : number\n" + "required: boolean")
-        .run();
-  }
+  @Test
+  public void testForwardTypeDeclaration9() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */"
+            + "function f(x) { x.name = 'Bob'; }",
+        null);
+  }
 
   @Test
-  public void testObjectLiteralDeclaration3() {
-    newTest()
-        .addSource(
-            "/** @param {{foo: !Function}} x */ function f(x) {}" + "f({foo: function() {}});")
-        .run();
+  public void testForwardTypeDeclaration10() {
+    String f =
+        "goog.forwardDeclare('MyType');" + "/** @param {MyType|number} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);", null);
+    testClosureTypes(
+        f + "f('3');",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : string\n"
+            + "required: (MyType|null|number)");
   }
 
   @Test
-  public void testObjectLiteralDeclaration4() {
+  public void testForwardTypeDeclaration12() {
+    // We assume that {Function} types can produce anything, and don't
+    // want to type-check them.
     testClosureTypes(
-        "var x = {"
-            + "  /** @param {boolean} x */ abc: function(x) {}"
-            + "};"
+        "goog.forwardDeclare('MyType');"
             + "/**\n"
-            + " * @param {string} x\n"
-            + " * @suppress {duplicate}\n"
-            + " */ x.abc = function(x) {};",
-        "assignment to property abc of x\n"
-            + "found   : function(string): undefined\n"
-            + "required: function(boolean): undefined");
-    // TODO(user): suppress {duplicate} currently also silence the
-    // redefining type error in the TypeValidator. Maybe it needs
-    // a new suppress name instead?
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration5() {
-    newTest()
-        .addSource(
-            "var x = {"
-                + "  /** @param {boolean} x */ abc: function(x) {}"
-                + "};"
-                + "/**\n"
-                + " * @param {boolean} x\n"
-                + " * @suppress {duplicate}\n"
-                + " */ x.abc = function(x) {};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration6() {
-    newTest()
-        .addSource(
-            "var x = {};"
-                + "/**\n"
-                + " * @param {boolean} x\n"
-                + " * @suppress {duplicate}\n"
-                + " */ x.abc = function(x) {};"
-                + "x = {"
-                + "  /**\n"
-                + "   * @param {boolean} x\n"
-                + "   * @suppress {duplicate}\n"
-                + "   */"
-                + "  abc: function(x) {}"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration7() {
-    newTest()
-        .addSource(
-            "var x = {};"
-                + "/**\n"
-                + " * @type {function(boolean): undefined}\n"
-                + " */ x.abc = function(x) {};"
-                + "x = {"
-                + "  /**\n"
-                + "   * @param {boolean} x\n"
-                + "   * @suppress {duplicate}\n"
-                + "   */"
-                + "  abc: function(x) {}"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testCallDateConstructorAsFunction() {
-    // ECMA-262 15.9.2: When Date is called as a function rather than as a
-    // constructor, it returns a string.
-    Node n = parseAndTypeCheck("Date()");
-    assertTypeEquals(getNativeStringType(), n.getFirstFirstChild().getJSType());
-  }
-
-  // According to ECMA-262, Error & Array function calls are equivalent to
-  // constructor calls.
-
-  @Test
-  public void testCallErrorConstructorAsFunction() {
-    String externs =
-        lines(
-            "/** @constructor",
-            "    @param {string} message",
-            "    @return {!Error} */",
-            "function Error(message) {}");
-    Node n = parseAndTypeCheck(externs, "Error('x')");
-    Node call = n.getFirstFirstChild();
-    assertThat(call.isCall()).isTrue();
-    assertTypeEquals(
-        call.getFirstChild().getJSType().toMaybeFunctionType().getInstanceType(), call.getJSType());
-  }
-
-  @Test
-  public void testCallArrayConstructorAsFunction() {
-    Node n = parseAndTypeCheck("Array()");
-    assertTypeEquals(getNativeArrayType(), n.getFirstFirstChild().getJSType());
-  }
-
-  @Test
-  public void testPropertyTypeOfUnionType() {
-    newTest()
-        .addSource(
-            "var a = {};"
-                + "/** @constructor */ a.N = function() {};\n"
-                + "a.N.prototype.p = 1;\n"
-                + "/** @constructor */ a.S = function() {};\n"
-                + "a.S.prototype.p = 'a';\n"
-                + "/** @param {!a.N|!a.S} x\n@return {string} */\n"
-                + "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testGetPropertyTypeOfUnionType_withMatchingTemplates() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<number>} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
+            + " * @param {!Function} ctor\n"
+            + " * @return {MyType}\n"
+            + " */\n"
+            + "function f(ctor) { return new ctor(); }",
+        null);
   }
 
   @Test
-  public void testGetPropertyTypeOfUnionType_withDifferingTemplates() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<string>} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : (number|string)",
-                "required: string"))
-        .run();
+  public void testForwardTypeDeclaration13() {
+    // Some projects use {Function} registries to register constructors
+    // that aren't in their binaries. We want to make sure we can pass these
+    // around, but still do other checks on them.
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @param {!Function} ctor\n"
+            + " * @return {MyType}\n"
+            + " */\n"
+            + "function f(ctor) { return (new ctor()).impossibleProp; }",
+        "Property impossibleProp never defined on ?" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION);
   }
 
   @Test
-  public void testGetPropertyTypeOfUnionType_withMembersThatExtendATemplatizedType() {
+  public void testDuplicateTypeDef() {
     newTest()
         .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "",
-            "/** @interface @extends {Foo<number>} */ function Bar() {};",
-            "/** @interface @extends {Foo<number>} */ function Baz() {}",
-            "",
-            "/**",
-            " * @param {!Bar|!Baz} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
+            "var goog = {};",
+            "/** @constructor */ goog.Bar = function() {};",
+            "/** @typedef {number} */ goog.Bar;")
         .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testInvalidAssignToPropertyTypeOfUnionType_withMatchingTemplates_doesntWarn() {
-    // We don't warn for this assignment because we treat the type of `x.p` as inferred...
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<number>} x",
-            " */",
-            "var f = function(x) { x.p = 'not a number'; };")
-        .run();
-  }
-
-  // TODO(user): We should flag these as invalid. This will probably happen
-  // when we make sure the interface is never referenced outside of its
-  // definition. We might want more specific and helpful error messages.
-  @Test
-  @Ignore
-  public void testWarningOnInterfacePrototype() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype = function() { };")
-        .addDiagnostic("e of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.f = function() { return 1;};")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.f = function() { return 1;};")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface3() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {}; u.T.x")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface4() {
-    newTest()
-        .addSource("/** @interface */ function T() {}; T.x;")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface1() {
-    // For interfaces we must allow function definitions that don't have a
-    // return statement, even though they declare a returned type.
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype.f = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype.f = function() { };")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.prototype.f = function() { };")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            CLOSURE_DEFS
-                + "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.prototype.f = goog.abstractMethod;")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we have to warn about
-  // missing annotations.
-  @Test
-  @Ignore
-  public void testWarnUnannotatedPropertyOnInterface1() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {}; u.T.prototype.x;")
-        .addDiagnostic("interface property x is not annotated")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testWarnUnannotatedPropertyOnInterface2() {
-    newTest()
-        .addSource("/** @interface */ function T() {}; T.prototype.x;")
-        .addDiagnostic("interface property x is not annotated")
-        .run();
-  }
-
-  @Test
-  public void testWarnUnannotatedPropertyOnInterface5() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {};\n" + "u.T.prototype.x = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testWarnUnannotatedPropertyOnInterface6() {
-    newTest()
-        .addSource("/** @interface */ function T() {};\n" + "T.prototype.x = function() {};")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we have to warn about
-  // the invalid type of the interface member.
-  @Test
-  @Ignore
-  public void testWarnDataPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n" + "/** @type {number} */u.T.prototype.x;")
-        .addDiagnostic("interface members can only be plain functions")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface1() {
-    newTest()
-        .addSource("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() {}\n"
-                + "/** @override */\n"
-                + "C.prototype.x = 'foo';")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() {}\n"
-                + "/** @override */\n"
-                + "C.prototype.x = 'foo';")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() { /** @type {string} */ \n this.x = 'foo'; }\n")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testWarnDataPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @type {number} */u.T.prototype.x = 1;")
-        .addDiagnostic(
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod")
-        .run();
-  }
-
-  @Test
-  public void testWarnDataPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;")
-        .addDiagnostic(
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we should warn about the
-  // mismatching types in the two tests below.
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "/** @param {String} foo */function(foo) {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */T.prototype.x =\n"
-                + "/** @return {string} */function() {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  // TODO(user): We should warn about this (bar is missing an annotation). We
-  // probably don't want to warn about all missing parameter annotations, but
-  // we should be as strict as possible regarding interfaces.
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "function(foo, bar) {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "function() {};")
-        .addDiagnostic("parameter foo does not appear in u.T.prototype.x's parameter list")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface5() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x = function() { };")
-        .addDiagnostic(
-            "assignment to property x of T.prototype\n"
-                + "found   : function(): undefined\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface6() {
-    testClosureTypesMultipleWarnings(
-        "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1",
-        ImmutableList.of(
-            "assignment to property x of T.prototype\n"
-                + "found   : number\n"
-                + "required: function(this:T): number",
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod"));
-  }
-
-  @Test
-  public void testInterfaceNonEmptyFunction() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }")
-        .addDiagnostic("interface member functions must have an empty body")
-        .run();
-  }
-
-  @Test
-  public void testDoubleNestedInterface() {
-    newTest()
-        .addSource(
-            "/** @interface */ var I1 = function() {};\n"
-                + "/** @interface */ I1.I2 = function() {};\n"
-                + "/** @interface */ I1.I2.I3 = function() {};\n")
-        .run();
-  }
-
-  @Test
-  public void testStaticDataPropertyOnNestedInterface() {
-    newTest()
-        .addSource(
-            "/** @interface */ var I1 = function() {};\n"
-                + "/** @interface */ I1.I2 = function() {};\n"
-                + "/** @type {number} */ I1.I2.x = 1;\n")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInstantiation() {
-    newTest()
-        .addSource("/** @interface */var f = function(){}; new f")
-        .addDiagnostic("cannot instantiate non-constructor")
-        .run();
-  }
-
-  @Test
-  public void testPrototypeLoop() {
-    disableStrictMissingPropertyChecks();
-
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @constructor \n * @extends {T} */var T = function() {};"
-            + "alert((new T).foo);",
-        ImmutableList.of(
-            "Parse error. Cycle detected in inheritance chain of type T",
-            "Could not resolve type in @extends tag of T"));
-  }
-
-  @Test
-  public void testImplementsLoop() {
-    testClosureTypesMultipleWarnings(
-        lines(
-            "/** @constructor \n * @implements {T} */var T = function() {};",
-            suppressMissingPropertyFor("T", "foo"),
-            "alert((new T).foo);"),
-        ImmutableList.of("Parse error. Cycle detected in inheritance chain of type T"));
-  }
-
-  @Test
-  public void testImplementsExtendsLoop() {
-    disableStrictMissingPropertyChecks();
-
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @constructor \n * @implements {F} */var G = function() {};"
-            + "/** @constructor \n * @extends {G} */var F = function() {};"
-            + "alert((new F).foo);",
-        ImmutableList.of("Parse error. Cycle detected in inheritance chain of type F"));
-  }
-
-  // TODO(johnlenz): This test causes an infinite loop,
-  @Test
-  @Ignore
-  public void testInterfaceExtendsLoop() {
-    testClosureTypesMultipleWarnings(
-        lines(
-            "/** @interface \n * @extends {F} */var G = function() {};",
-            "/** @interface \n * @extends {G} */var F = function() {};",
-            "/** @constructor \n * @implements {F} */var H = function() {};",
-            suppressMissingPropertyFor("H", "foo"),
-            "alert((new H).foo);"),
-        ImmutableList.of(
-            "extends loop involving F, " + "loop: F -> G -> F",
-            "extends loop involving G, " + "loop: G -> F -> G"));
-  }
-
-  @Test
-  public void testInterfaceExtendsLoop2() {
-    testClosureTypes(
-        lines(
-            "/** @record \n * @extends {F} */var G = function() {};",
-            "/** @record \n * @extends {G} */var F = function() {};",
-            "/** @constructor \n * @implements {F} */var H = function() {};",
-            suppressMissingPropertyFor("H", "foo"),
-            "alert((new H).foo);"),
-        "Parse error. Cycle detected in inheritance chain of type F");
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces1() {
-    // Low#prop gets the type of whichever property is declared last,
-    // even if that type is not the most specific.
-    newTest()
-        .addSource(
-            "/** @interface */",
-            "function High1() {}",
-            "/** @type {number|string} */",
-            "High1.prototype.prop;",
-            "/** @interface */",
-            "function High2() {}",
-            "/** @type {number} */",
-            "High2.prototype.prop;",
-            "/**",
-            " * @interface",
-            " * @extends {High1}",
-            " * @extends {High2}",
-            " */",
-            "function Low() {}",
-            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (number|string)",
-                "required: null"))
-        .run();
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces2() {
-    // Low#prop gets the type of whichever property is declared last,
-    // even if that type is not the most specific.
-    newTest()
-        .addSource(
-            "/** @interface */",
-            "function High1() {}",
-            "/** @type {number} */",
-            "High1.prototype.prop;",
-            "/** @interface */",
-            "function High2() {}",
-            "/** @type {number|string} */",
-            "High2.prototype.prop;",
-            "/**",
-            " * @interface",
-            " * @extends {High1}",
-            " * @extends {High2}",
-            " */",
-            "function Low() {}",
-            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
-        .run();
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces3() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @interface",
-            " * @template T1",
-            " */",
-            "function MyCollection() {}",
-            "/**",
-            " * @interface",
-            " * @template T2",
-            " * @extends {MyCollection<T2>}",
-            " */",
-            "function MySet() {}",
-            "/**",
-            " * @interface",
-            " * @template T3,T4",
-            " */",
-            "function MyMapEntry() {}",
-            "/**",
-            " * @interface",
-            " * @template T5,T6",
-            " */",
-            "function MyMultimap() {}",
-            "/** @return {MyCollection<MyMapEntry<T5, T6>>} */",
-            "MyMultimap.prototype.entries = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T7,T8",
-            " * @extends {MyMultimap<T7, T8>}",
-            " */",
-            "function MySetMultimap() {}",
-            "/** @return {MySet<MyMapEntry<T7, T8>>} */",
-            "MySetMultimap.prototype.entries = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T9,T10",
-            " * @extends {MyMultimap<T9, T10>}",
-            " */",
-            "function MyFilteredMultimap() {}",
-            "/**",
-            " * @interface",
-            " * @template T11,T12",
-            " * @extends {MyFilteredMultimap<T11, T12>}",
-            " * @extends {MySetMultimap<T11, T12>}",
-            " */",
-            "function MyFilteredSetMultimap() {}")
-        .run();
-  }
-
-  @Test
-  public void testInheritSameGenericInterfaceFromDifferentPaths() {
-    newTest()
-        .addSource(
-            "/** @const */ var ns = {};",
-            "/**",
-            " * @constructor",
-            " * @template T1",
-            " */",
-            "ns.Foo = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T2",
-            " */",
-            "ns.High = function() {};",
-            "/** @type {!ns.Foo<T2>} */",
-            "ns.High.prototype.myprop;",
-            "/**",
-            " * @interface",
-            " * @template T3",
-            " * @extends {ns.High<T3>}",
-            " */",
-            "ns.Med1 = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T4",
-            " * @extends {ns.High<T4>}",
-            " */",
-            "ns.Med2 = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T5",
-            " * @extends {ns.Med1<T5>}",
-            " * @extends {ns.Med2<T5>}",
-            " */",
-            "ns.Low = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testConversionFromInterfaceToRecursiveConstructor() {
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @interface */ var OtherType = function() {}\n"
-            + "/** @implements {MyType} \n * @constructor */\n"
-            + "var MyType = function() {}\n"
-            + "/** @type {MyType} */\n"
-            + "var x = /** @type {!OtherType} */ (new Object());",
-        ImmutableList.of(
-            "Parse error. Cycle detected in inheritance chain of type MyType",
-            "initializing variable\n" + "found   : OtherType\n" + "required: (MyType|null)"));
-  }
-
-  @Test
-  public void testDirectPrototypeAssign() {
-    // For now, we just ignore @type annotations on the prototype.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @type {Array} */ Bar.prototype = new Foo()")
-        .run();
-  }
-
-  // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
-  // be resolved via the registry and not via properties.
-
-  @Test
-  public void testResolutionViaRegistry1() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {};\n"
-                + "/** @type {(number|string)} */ u.T.prototype.a;\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testResolutionViaRegistry2() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {"
-                + "  this.a = 0; };\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testResolutionViaRegistry3() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {};\n"
-                + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testResolutionViaRegistry4() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.A = function() {};\n"
-                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;"
-                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n"
-                + "var ab = new u.A.B();\n"
-                + "/** @type {!u.A} */ var a = ab;\n"
-                + "/** @type {!u.A.A} */ var aa = ab;\n")
-        .addDiagnostic("initializing variable\n" + "found   : u.A.B\n" + "required: u.A.A")
-        .run();
-  }
-
-  @Test
-  public void testResolutionViaRegistry5() {
-    Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertThat(type).isInstanceOf(FunctionType.class);
-    assertThat(((FunctionType) type).getInstanceType().getReferenceName()).isEqualTo("u.T");
-  }
-
-  @Test
-  public void testGatherProperyWithoutAnnotation1() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertThat(type).isInstanceOf(ObjectType.class);
-    ObjectType objectType = (ObjectType) type;
-    assertThat(objectType.hasProperty("x")).isFalse();
-  }
-
-  @Test
-  public void testGatherProperyWithoutAnnotation2() {
-    TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;");
-    Node n = ns.root;
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertTypeEquals(type, getNativeObjectType());
-    assertThat(type).isInstanceOf(ObjectType.class);
-    ObjectType objectType = (ObjectType) type;
-    assertThat(objectType.hasProperty("x")).isFalse();
-  }
-
-  @Test
-  public void testFunctionMasksVariableBug() {
-    newTest()
-        .addSource("var x = 4; var f = function x(b) { return b ? 1 : x(true); };")
-        .addDiagnostic("function x masks variable (IE bug)")
-        .run();
-  }
-
-  @Test
-  public void testDfa1() {
-    newTest().addSource("var x = null;\n x = 1;\n /** @type {number} */ var y = x;").run();
-  }
-
-  @Test
-  public void testDfa2() {
-    newTest()
-        .addSource(
-            "function u() {}\n"
-                + "/** @return {number} */ function f() {\nvar x = 'todo';\n"
-                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa3() {
-    newTest()
-        .addSource(
-            "function u() {}\n"
-                + "/** @return {number} */ function f() {\n"
-                + "/** @type {number|string} */ var x = 'todo';\n"
-                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa4() {
-    newTest()
-        .addSource(
-            "/** @param {Date?} d */ function f(d) {\n"
-                + "if (!d) { return; }\n"
-                + "/** @type {!Date} */ var e = d;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa5() {
-    newTest()
-        .addSource(
-            "/** @return {string?} */ function u() {return 'a';}\n"
-                + "/** @param {string?} x\n@return {string} */ function f(x) {\n"
-                + "while (!x) { x = u(); }\nreturn x;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa6() {
-    newTest()
-        .addSource(
-            "/** @return {Object?} */ function u() {return {};}\n"
-                + "/** @param {Object?} x */ function f(x) {\n"
-                + "while (x) { x = u(); if (!x) { x = u(); } }\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa7() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @type {Date?} */ T.prototype.x = null;\n"
-                + "/** @param {!T} t */ function f(t) {\n"
-                + "if (!t.x) { return; }\n"
-                + "/** @type {!Date} */ var e = t.x;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa8() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @type {number|string} */ T.prototype.x = '';\n"
-                + "function u() {}\n"
-                + "/** @param {!T} t\n@return {number} */ function f(t) {\n"
-                + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}")
-        .run();
-  }
-
-  @Test
-  public void testDfa9() {
-    newTest()
-        .addSource(
-            "function f() {\n/** @type {string?} */var x;\nx = null;\n"
-                + "if (x == null) { return 0; } else { return 1; } }")
-        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
-        .run();
-  }
-
-  @Test
-  public void testDfa10() {
-    newTest()
-        .addSource(
-            "/** @param {null} x */ function g(x) {}"
-                + "/** @param {string?} x */function f(x) {\n"
-                + "if (!x) { x = ''; }\n"
-                + "if (g(x)) { return 0; } else { return 1; } }")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testDfa11() {
-    newTest()
-        .addSource(
-            "/** @param {string} opt_x\n@return {string} */\n"
-                + "function f(opt_x) { if (!opt_x) { "
-                + "throw new Error('x cannot be empty'); } return opt_x; }")
-        .run();
-  }
-
-  @Test
-  public void testDfa12() {
-    newTest()
-        .addSource(
-            "/** @param {string} x \n * @constructor \n */"
-                + "var Bar = function(x) {};"
-                + "/** @param {string} x */ function g(x) { return true; }"
-                + "/** @param {string|number} opt_x */ "
-                + "function f(opt_x) { "
-                + "  if (opt_x) { new Bar(g(opt_x) && 'x'); }"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : (number|string)\n"
-                + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testDfa13() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {string} x \n"
-                + " * @param {number} y \n"
-                + " * @param {number} z \n"
-                + " */"
-                + "function g(x, y, z) {}"
-                + "function f() { "
-                + "  var x = 'a'; g(x, x = 3, x);"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithCast1() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
-                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
-                + "/**@return {number?}*/function g(x) {"
-                + "var y = /**@type {number?}*/(u(x)); return f(y);}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithCast2() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
-                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
-                + "/**@return {number?}*/function g(x) {"
-                + "var y; y = /**@type {number?}*/(u(x)); return f(y);}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithCast3() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
-                + "/**@return {number}*/function g(x) {"
-                + "return /**@type {number}*/(u(x));}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithCast4() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
-                + "/**@return {number}*/function g(x) {"
-                + "return /**@type {number}*/(u(x)) && 1;}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithCast5() {
-    newTest()
-        .addSource(
-            "/** @param {number} x */ function foo(x) {}"
-                + "/** @param {{length:*}} y */ function bar(y) {"
-                + "  /** @type {string} */ y.length;"
-                + "  foo(y.length);"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithClosure1() {
-    newTest()
-        .addSource(
-            "/** @return {boolean} */"
-                + "function f() {"
-                + "  /** @type {?string} */ var x = null;"
-                + "  function g() { x = 'y'; } g(); "
-                + "  return x == null;"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithClosure2() {
-    newTest()
-        .addSource(
-            "/** @return {boolean} */"
-                + "function f() {"
-                + "  /** @type {?string} */ var x = null;"
-                + "  function g() { x = 'y'; } g(); "
-                + "  return x === 3;"
-                + "}")
-        .addDiagnostic(
-            "condition always evaluates to false\n" + "left : (null|string)\n" + "right: number")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithNoEntry1() {
-    newTest()
-        .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.init = function() {"
-                + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
-                + "};"
-                + "/**\n"
-                + " * @extends {Foo}\n"
-                + " * @constructor\n"
-                + " */"
-                + "function SubFoo() {}"
-                + "/** Method */"
-                + "SubFoo.prototype.method = function() {"
-                + "  for (var i = 0; i < 10; i++) {"
-                + "    f(this.bar);"
-                + "    f(this.bar.baz);"
-                + "  }"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (null|{baz: number})\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTypeInferenceWithNoEntry2() {
-    testClosureTypes(
-        "/** @param {number} x */ function f(x) {}"
-            + "/** @param {!Object} x */ function g(x) {}"
-            + "/** @constructor */ function Foo() {}"
-            + "Foo.prototype.init = function() {"
-            + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
-            + "};"
-            + "/**\n"
-            + " * @extends {Foo}\n"
-            + " * @constructor\n"
-            + " */"
-            + "function SubFoo() {}"
-            + "/** Method */"
-            + "SubFoo.prototype.method = function() {"
-            + "  for (var i = 0; i < 10; i++) {"
-            + "    f(this.bar);"
-            + "    goog.asserts.assert(this.bar);"
-            + "    g(this.bar);"
-            + "  }"
-            + "};",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : (null|{baz: number})\n"
-            + "required: number");
-  }
-
-  @Test
-  public void testForwardPropertyReference() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() { this.init(); };"
-                + "/** @return {string} */"
-                + "Foo.prototype.getString = function() {"
-                + "  return this.number_;"
-                + "};"
-                + "Foo.prototype.init = function() {"
-                + "  /** @type {number} */"
-                + "  this.number_ = 3;"
-                + "};")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testNoForwardTypeDeclaration() {
-    newTest()
-        .addSource("/** @param {MyType} x */ function f(x) {}")
-        .addDiagnostic("Bad type annotation. Unknown type MyType")
-        .run();
-  }
-
-  @Test
-  public void testNoForwardTypeDeclarationAndNoBraces() {
-    newTest()
-        .addSource("/** @return The result. */ function f() {}")
-        .addDiagnostic(RhinoErrorReporter.JSDOC_MISSING_TYPE_WARNING)
-        .run();
-  }
-
-  @Test
-  public void testForwardTypeDeclaration2() {
-    String f = "goog.forwardDeclare('MyType');" + "/** @param {MyType} x */ function f(x) { }";
-    testClosureTypes(f, null);
-    testClosureTypes(
-        f + "f(3);",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: (MyType|null)");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration3() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */ function f(x) { return x; }"
-            + "/** @constructor */ var MyType = function() {};"
-            + "f(3);",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: (MyType|null)");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration4() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */ function f(x) { return x; }"
-            + "/** @constructor */ var MyType = function() {};"
-            + "f(new MyType());",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration5() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @constructor\n"
-            + " * @extends {MyType}\n"
-            + " */ var YourType = function() {};"
-            + "/** @override */ YourType.prototype.method = function() {};",
-        "Could not resolve type in @extends tag of YourType");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration6() {
-    testClosureTypesMultipleWarnings(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @constructor\n"
-            + " * @implements {MyType}\n"
-            + " */ var YourType = function() {};"
-            + "/** @override */ YourType.prototype.method = function() {};",
-        ImmutableList.of(
-            "Could not resolve type in @implements tag of YourType",
-            "property method not defined on any superclass of YourType"));
-  }
-
-  @Test
-  public void testForwardTypeDeclaration7() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType=} x */"
-            + "function f(x) { return x == undefined; }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration8() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */"
-            + "function f(x) { return x.name == undefined; }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration9() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */"
-            + "function f(x) { x.name = 'Bob'; }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration10() {
-    String f =
-        "goog.forwardDeclare('MyType');" + "/** @param {MyType|number} x */ function f(x) { }";
-    testClosureTypes(f, null);
-    testClosureTypes(f + "f(3);", null);
-    testClosureTypes(
-        f + "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : string\n"
-            + "required: (MyType|null|number)");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration12() {
-    // We assume that {Function} types can produce anything, and don't
-    // want to type-check them.
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @param {!Function} ctor\n"
-            + " * @return {MyType}\n"
-            + " */\n"
-            + "function f(ctor) { return new ctor(); }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration13() {
-    // Some projects use {Function} registries to register constructors
-    // that aren't in their binaries. We want to make sure we can pass these
-    // around, but still do other checks on them.
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @param {!Function} ctor\n"
-            + " * @return {MyType}\n"
-            + " */\n"
-            + "function f(ctor) { return (new ctor()).impossibleProp; }",
-        "Property impossibleProp never defined on ?" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION);
-  }
-
-  @Test
-  public void testDuplicateTypeDef() {
-    newTest()
-        .addSource(
-            "var goog = {};",
-            "/** @constructor */ goog.Bar = function() {};",
-            "/** @typedef {number} */ goog.Bar;")
-        .addDiagnostic(
-            "variable goog.Bar redefined with type None, "
-                + "original definition at [testcode]:2 "
-                + "with type (typeof goog.Bar)")
-        .run();
-  }
-
-  @Test
-  public void testTypeDef1() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f(3);")
-        .run();
-  }
-
-  @Test
-  public void testTypeDef2() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f('3');")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTypeDef3() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ var Bar;"
-                + "/** @param {Bar} x */ function f(x) {}"
-                + "f('3');")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTypeDef4() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function A() {}"
-                + "/** @constructor */ function B() {}"
-                + "/** @typedef {(A|B)} */ var AB;"
-                + "/** @param {AB} x */ function f(x) {}"
-                + "f(new A()); f(new B()); f(1);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: (A|B|null)")
-        .run();
-  }
-
-  @Test
-  public void testTypeDef5() {
-    // Notice that the error message is slightly different than
-    // the one for testTypeDef4, even though they should be the same.
-    // This is an implementation detail necessary for NamedTypes work out
-    // OK, and it should change if NamedTypes ever go away.
-    newTest()
-        .addSource(
-            "/** @param {AB} x */ function f(x) {}"
-                + "/** @constructor */ function A() {}"
-                + "/** @constructor */ function B() {}"
-                + "/** @typedef {(A|B)} */ var AB;"
-                + "f(new A()); f(new B()); f(1);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: (A|B|null)")
-        .run();
-  }
-
-  @Test
-  public void testCircularTypeDef() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @typedef {number|Array<goog.Bar>} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f(3); f([3]); f([[3]]);")
-        .run();
-  }
-
-  @Test
-  public void testGetTypedPercent1() {
-    String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(50.0);
-  }
-
-  @Test
-  public void testGetTypedPercent2() {
-    String js = "var x = {}; x.y = 1;";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
-  }
-
-  @Test
-  public void testGetTypedPercent3() {
-    String js = "var f = function(x) { x.a = x.b; }";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(25.0);
-  }
-
-  @Test
-  public void testGetTypedPercent4() {
-    String js =
-        "var n = {};\n /** @constructor */ n.T = function() {};\n"
-            + "/** @type {n.T} */ var x = new n.T();";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
-  }
-
-  @Test
-  public void testGetTypedPercent5() {
-    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
-  }
-
-  @Test
-  public void testGetTypedPercent6() {
-    String js = "a = {TRUE: 1, FALSE: 0};";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
-  }
-
-  @Test
-  public void testPrototypePropertyReference() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            ""
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "/** @param {number} a */\n"
-                + "Foo.prototype.bar = function(a){};\n"
-                + "/** @param {Foo} f */\n"
-                + "function baz(f) {\n"
-                + "  Foo.prototype.bar.call(f, 3);\n"
-                + "}");
-    assertThat(compiler.getErrorCount()).isEqualTo(0);
-    assertThat(compiler.getWarningCount()).isEqualTo(0);
-
-    assertThat(p.scope.getVar("Foo").getType()).isInstanceOf(FunctionType.class);
-    FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType();
-    assertThat(fooType.getPrototype().getPropertyType("bar").toString())
-        .isEqualTo("function(this:Foo, number): undefined");
-  }
-
-  @Test
-  public void testResolvingNamedTypes() {
-    String externs = new TestExternsBuilder().addObject().build();
-    String js =
-        lines(
-            "/** @constructor */",
-            "var Foo = function() {}",
-            "/** @param {number} a */",
-            "Foo.prototype.foo = function(a) {",
-            "  return this.baz().toString();",
-            "};",
-            "/** @return {Baz} */",
-            "Foo.prototype.baz = function() { return new Baz(); };",
-            "/** @constructor",
-            "  * @extends Foo */",
-            "var Bar = function() {};",
-            "/** @constructor */",
-            "var Baz = function() {};");
-    assertThat(getTypedPercentWithExterns(externs, js)).isWithin(0.1).of(100.0);
-  }
-
-  @Test
-  public void testMissingProperty1a() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "Foo.prototype.baz = function() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
-        .addDiagnostic("Property a never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty1b() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.a = 3; };")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty2a() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.b = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty2b() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.baz = function() { this.b = 3; };")
-        .addDiagnostic("Property b never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty3a() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "(new Foo).a = 3;")
-        .addDiagnostic("Property a never defined on Foo") // method
-        .addDiagnostic("Property a never defined on Foo")
-        .run(); // global assignment
-  }
-
-  @Test
-  public void testMissingProperty3b() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "(new Foo).a = 3;")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty4a() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "(new Foo).b = 3;")
-        .addDiagnostic("Property a never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty4b() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "(new Foo).b = 3;")
-        .addDiagnostic("Property b never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty5() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "/** @constructor */ function Bar() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty6a() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "/** @constructor \n * @extends {Foo} */ ",
-            "function Bar() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty6b() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "/** @constructor \n * @extends {Foo} */ "
-                + "function Bar() { this.a = 3; };")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty7() {
-    newTest()
-        .addSource("/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }")
-        .addDiagnostic(
-            "Property impossible never defined on Object"
-                + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty8() {
-    newTest()
-        .addSource(
-            "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty9() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { if (obj.impossible) { return true; } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty10() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { while (obj.impossible) { return true; } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty11() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { for (;obj.impossible;) { return true; } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty12() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }")
-        .run();
-  }
-
-  // Note: testMissingProperty{13,14} pertained to a deleted coding convention.
-
-  @Test
-  public void testMissingProperty15() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource("/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty16() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource("/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }")
-        .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty17() {
-    newTest()
-        .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty18() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty19() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }")
-        .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty20() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} x */" + "function f(x) { if (x.foo) { } else { x.foo(); } }")
-        .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty21() {
-    disableStrictMissingPropertyChecks();
-    newTest().addSource("/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }").run();
-  }
-
-  @Test
-  public void testMissingProperty22() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} x \n * @return {boolean} */"
-                + "function f(x) { return x.foo ? x.foo() : true; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty23() {
-    newTest()
-        .addSource("function f(x) { x.impossible(); }")
-        .addDiagnostic(
-            "Property impossible never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty24() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {MissingType} x */"
-            + "function f(x) { x.impossible(); }",
-        null);
-  }
-
-  @Test
-  public void testMissingProperty25() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "Foo.prototype.bar = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "(new FooAlias()).bar();")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty26() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "FooAlias.prototype.bar = function() {};"
-                + "(new Foo()).bar();")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty27() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {?MissingType} x */"
-            + "function f(x) {"
-            + "  for (var parent = x; parent; parent = parent.getParent()) {}"
-            + "}",
-        null);
-  }
-
-  @Test
-  public void testMissingProperty28a() {
-    newTest()
-        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foo;" + "}")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty28b() {
-    newTest()
-        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foox;" + "}")
-        .addDiagnostic(
-            "Property foox never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty29() {
-    // This used to emit a warning.
-    newTest()
-        .addExterns(
-            "/** @constructor */ var Foo;"
-                + "Foo.prototype.opera;"
-                + "Foo.prototype.opera.postError;")
-        .addSource("")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty30a() {
-    newTest()
-        .addSource(
-            "/** @return {*} */",
-            "function f() {",
-            " return {};",
-            "}",
-            "f().a = 3;",
-            "/** @param {Object} y */ function g(y) { return y.a; }")
-        .addDiagnostic("Property a never defined on *")
-        .addDiagnostic("Property a never defined on Object")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty30b() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @return {*} */"
-                + "function f() {"
-                + " return {};"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Object} y */ function g(y) { return y.a; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty31a() {
-    newTest()
-        .addSource(
-            "/** @return {Array|number} */", //
-            "function f() {",
-            " return [];",
-            "}",
-            "f().a = 3;")
-        .addDiagnostic("Property a never defined on (Array|Number)")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty31b() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/** @return {Array|number} */"
-                + "function f() {"
-                + " return [];"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Array} y */ function g(y) { return y.a; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty32() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @return {Array|number} */"
-                + "function f() {"
-                + " return [];"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Date} y */ function g(y) { return y.a; }")
-        .addDiagnostic("Property a never defined on Date")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty33() {
-    disableStrictMissingPropertyChecks();
-    newTest().addSource("/** @param {Object} x */" + "function f(x) { !x.foo || x.foo(); }").run();
-  }
-
-  @Test
-  public void testMissingProperty34() {
-    newTest()
-        .addSource(
-            "/** @fileoverview \n * @suppress {missingProperties} */"
-                + "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.b = 3; };")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty35a() {
-    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "/** @constructor */ function Bar() {}",
-            "/** @constructor */ function Baz() {}",
-            "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }",
-            "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
-        .addDiagnostic("Property specialProp never defined on (Foo|Bar)")
-        .addDiagnostic("Property specialProp never defined on (Bar|Baz)")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty35b() {
-    disableStrictMissingPropertyChecks();
-
-    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @constructor */ function Baz() {}"
-                + "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }"
-                + "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty36a() {
-    // Foo has baz defined, and SubFoo has bar defined, so some objects with
-    // bar may have baz.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.baz = 0;",
-            "/** @constructor \n * @extends {Foo} */ function SubFoo() {}",
-            "SubFoo.prototype.bar = 0;",
-            "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
-        .addDiagnostic("Property baz never defined on x")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty36b() {
-    disableStrictMissingPropertyChecks();
-
-    // Foo has baz defined, and SubFoo has bar defined, so some objects with
-    // bar may have baz.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.baz = 0;"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "SubFoo.prototype.bar = 0;"
-                + "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty37a() {
-    // This used to emit a missing property warning because we couldn't
-    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
-    newTest()
-        .addSource(
-            "/** @param {{isVisible: boolean}} x */",
-            "function f(x){",
-            "  x.isVisible = false;",
-            "}",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo}",
-            " */",
-            "function SubFoo() {}",
-            "/** @type {boolean} */",
-            "SubFoo.prototype.isVisible = true;",
-            "/**",
-            " * @param {Foo} x",
-            " * @return {boolean}",
-            " */",
-            "function g(x) { return x.isVisible; }")
-        .addDiagnostic("Property isVisible never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty37b() {
-    disableStrictMissingPropertyChecks();
-
-    // This used to emit a missing property warning because we couldn't
-    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
-    newTest()
-        .addSource(
-            "/** @param {{isVisible: boolean}} x */ function f(x){"
-                + "  x.isVisible = false;"
-                + "}"
-                + "/** @constructor */ function Foo() {}"
-                + "/**\n"
-                + " * @constructor \n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/** @type {boolean} */ SubFoo.prototype.isVisible = true;"
-                + "/**\n"
-                + " * @param {Foo} x\n"
-                + " * @return {boolean}\n"
-                + " */\n"
-                + "function g(x) { return x.isVisible; }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty38() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @return {Foo|Bar} */ function f() { return new Foo(); }"
-                + "f().missing;")
-        .addDiagnostic("Property missing never defined on (Foo|Bar)")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty39a() {
-    disableStrictMissingPropertyChecks();
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
-        .addSource(
-            "/** @return {string|number} */ function f() { return 3; }", //
-            "f().length;")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty39b() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
-        .addSource(
-            "/** @return {string|number} */ function f() { return 3; }", //
-            "f().length;")
-        // TODO(johnlenz): enable this.
-        // "Property length not defined on all member types of (String|Number)"
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty40a() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {MissingType} x */"
-            + "function f(x) { x.impossible(); }",
-        null);
-  }
-
-  @Test
-  public void testMissingProperty40b() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {(Array|MissingType)} x */"
-            + "function f(x) { x.impossible(); }",
-        // TODO(johnlenz): enable this.
-        // "Property impossible not defined on all member types of x"
-        null);
-  }
-
-  @Test
-  public void testMissingProperty41a() {
-    newTest()
-        .addSource(
-            "/** @param {(Array|Date)} x */", //
-            "function f(x) { if (x.impossible) x.impossible(); }")
-        .addDiagnostic("Property impossible never defined on (Array|Date)")
-        .addDiagnostic("Property impossible never defined on (Array|Date)")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty41b() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {(Array|Date)} x */", //
-            "function f(x) { if (x.impossible) x.impossible(); }")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty42() {
-    newTest()
-        .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { "
-                + "  if (typeof x.impossible == 'undefined') throw Error();"
-                + "  return x.impossible;"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty43() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource("function f(x) { " + " return /** @type {number} */ (x.impossible) && 1;" + "}")
-        .run();
-  }
-
-  @Test
-  public void testMissingProperty_notReportedInPropertyAbsenceCheck() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "function f(/** !Object */ x) {", //
-            "  if (x.y == null) throw new Error();",
-            "}")
-        .run();
-  }
-
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
-  @Test
-  public void optChainGetPropAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.z;",
-            "}")
-        .run();
-  }
-
-  // this is the same test as above except that it does not use optional chaining so it should
-  // emit a warning about missing properties
-  @Test
-  public void normalGetPropNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y.z;",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
-  @Test
-  public void optChainGetElemAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.[z];",
-            "}")
-        .run();
-  }
-
-  // this is the same test as above except that it does not use optional chaining so it should emit
-  // a warning about missing properties
-  @Test
-  public void normalGetElemNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y[z];",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
-  @Test
-  public void optChainCallAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.();",
-            "}")
-        .run();
-  }
-
-  // this is the same test as above except that it does not use optional chaining so it should emit
-  // a warning about missing properties
-  @Test
-  public void normalCallNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y();",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  // prop.access?.() is property test and should allow loose property access
-  // but x?.(prop.access) is not
-  @Test
-  public void getNotFirstChildOfOptChainCallNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  return false;",
-            "}",
-            "f?.(x.y)")
-        .addDiagnostic("Property y never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  // prop.access?.[x] is property test and should allow loose property access
-  // but x?.[prop.access] is not
-  @Test
-  public void getNotFirstChildOfOptionalGetElemNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x?.[y.z];",
-            "}")
-        .addDiagnostic("Property z never defined on y" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
-  }
-
-  @Test
-  public void testOptChainGetPropProvidesThisForMethodCall() {
-    newTest()
-        .addSource(
-            "class A {",
-            "  foo() {}",
-            "}",
-            "/** @param {?A} a */",
-            "function f(a) {",
-            // TypeCheck should not complain that foo() is getting called without a correctly typed
-            // `this` value.
-            "  a?.foo();",
-            "}",
-            "",
-            "")
-        .run();
-  }
-
-  @Test
-  public void testReflectObject1() {
-    testClosureTypes(
-        "goog.reflect = {}; "
-            + "goog.reflect.object = function(x, y){};"
-            + "/** @constructor */ function A() {}"
-            + "goog.reflect.object(A, {x: 3});",
-        null);
-  }
-
-  @Test
-  public void testReflectObject2() {
-    testClosureTypes(
-        "goog.reflect = {}; "
-            + "goog.reflect.object = function(x, y){};"
-            + "/** @param {string} x */ function f(x) {}"
-            + "/** @constructor */ function A() {}"
-            + "goog.reflect.object(A, {x: f(1 + 1)});",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: string");
-  }
-
-  @Test
-  public void testLends1() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends */ ({bar: 1}));")
-        .addDiagnostic(
-            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
-
-  @Test
-  public void testLends2() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foob} */ ({bar: 1}));")
-        .addDiagnostic("Variable Foob not declared before @lends annotation.")
-        .run();
-  }
-
-  @Test
-  public void testLends3() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, {bar: 1});"
-                + "alert(Foo.bar);")
-        .addDiagnostic("Property bar never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testLends4() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));"
-                + "alert(Foo.bar);")
-        .run();
-  }
-
-  @Test
-  public void testLends5() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, {bar: 1});"
-                + "alert((new Foo()).bar);")
-        .addDiagnostic("Property bar never defined on Foo")
-        .run();
-  }
-
-  @Test
-  public void testLends6() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));"
-                + "alert((new Foo()).bar);")
-        .run();
-  }
-
-  @Test
-  public void testLends7() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));")
-        .addDiagnostic("Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
-
-  @Test
-  public void testLends8() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @type {number} */ var Foo = 3;"
-                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));")
-        .addDiagnostic("May only lend properties to object types. Foo has type number.")
-        .run();
-  }
-
-  @Test
-  public void testLends9() {
-    testClosureTypesMultipleWarnings(
-        "function extend(x, y) {}"
-            + "/** @constructor */ function Foo() {}"
-            + "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
-        ImmutableList.of(
-            "Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK,
-            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK));
-  }
-
-  @Test
-  public void testLends10() {
-    newTest()
-        .addSource(
-            "function defineClass(x) { return function() {}; } "
-                + "/** @constructor */"
-                + "var Foo = defineClass("
-                + "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));"
-                + "/** @return {string} */ function f() { return (new Foo()).bar; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testLends11() {
-    newTest()
-        .addSource(
-            "function defineClass(x, y) { return function() {}; } "
-                + "/** @constructor */"
-                + "var Foo = function() {};"
-                + "/** @return {*} */ Foo.prototype.bar = function() { return 3; };"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "var SubFoo = defineClass(Foo, "
-                + "    /** @lends {SubFoo.prototype} */ ({\n"
-                + "      /** @override @return {number} */ bar: function() { return 3; }}));"
-                + "/** @return {string} */ function f() { return (new SubFoo()).bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testDeclaredNativeTypeEquality() {
-    Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType());
-  }
-
-  @Test
-  public void testUndefinedVar() {
-    Node n = parseAndTypeCheck("var undefined;");
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstFirstChild().getJSType());
-  }
-
-  @Test
-  public void testFlowScopeBug1() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @param {number} a \n"
-                + "* @param {number} b */\n"
-                + "function f(a, b) {\n"
-                + "/** @type {number} */"
-                + "var i = 0;"
-                + "for (; (i + a) < b; ++i) {}}");
-
-    // check the type of the add node for i + f
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.NUMBER_TYPE),
-        n.getFirstChild()
-            .getLastChild()
-            .getLastChild()
-            .getFirstChild()
-            .getNext()
-            .getFirstChild()
-            .getJSType());
-  }
-
-  @Test
-  public void testFlowScopeBug2() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {};\n"
-                + "Foo.prototype.hi = false;"
-                + "function foo(a, b) {\n"
-                + "  /** @type {Array} */"
-                + "  var arr;"
-                + "  /** @type {number} */"
-                + "  var iter;"
-                + "  for (iter = 0; iter < arr.length; ++ iter) {"
-                + "    /** @type {Foo} */"
-                + "    var afoo = arr[iter];"
-                + "    afoo;"
-                + "  }"
-                + "}");
-
-    // check the type of afoo when referenced
-    assertTypeEquals(
-        registry.createNullableType(registry.getGlobalType("Foo")),
-        n.getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getJSType());
-  }
-
-  @Test
-  public void testAddSingletonGetter() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);");
-    ObjectType o = (ObjectType) n.getFirstChild().getJSType();
-    assertThat(o.getPropertyType("getInstance").toString()).isEqualTo("function(): Foo");
-    assertThat(o.getPropertyType("instance_").toString()).isEqualTo("Foo");
-  }
-
-  @Test
-  public void testTypeCheckStandaloneAST() {
-    Node externs = IR.root();
-    Node firstScript = compiler.parseTestCode("function Foo() { }");
-    typeCheck(firstScript);
-    Node root = IR.root(externs, IR.root(firstScript.detach()));
-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
-    TypedScope topScope = scopeCreator.createScope(root, null);
-
-    Node secondScript = compiler.parseTestCode("new Foo");
-
-    firstScript.replaceWith(secondScript);
-
-    new TypeCheck(
-            compiler,
-            new SemanticReverseAbstractInterpreter(registry),
-            registry,
-            topScope,
-            scopeCreator)
-        .process(externs, secondScript.getParent());
-
-    assertThat(compiler.getWarningCount()).isEqualTo(1);
-    assertThat(compiler.getWarnings().get(0).getDescription())
-        .isEqualTo("cannot instantiate non-constructor");
-  }
-
-  @Test
-  public void testUpdateParameterTypeOnClosure() {
-    newTest()
-        .addExterns(
-            "/**\n"
-                + "* @constructor\n"
-                + "* @param {*=} opt_value\n"
-                + "* @return {!Object}\n"
-                + "*/\n"
-                + "function Object(opt_value) {}\n"
-                + "/**\n"
-                + "* @constructor\n"
-                + "* @param {...*} var_args\n"
-                + "*/\n"
-                + "function Function(var_args) {}\n"
-                + "/**\n"
-                + "* @type {Function}\n"
-                + "*/\n"
-                +
-                // The line below sets JSDocInfo on Object so that the type of the
-                // argument to function f has JSDoc through its prototype chain.
-                "Object.prototype.constructor = function() {};\n")
-        .addSource(
-            "/**\n"
-                + "* @param {function(): boolean} fn\n"
-                + "*/\n"
-                + "function f(fn) {}\n"
-                + "f(function() { });\n")
-        .run();
-  }
-
-  @Test
-  public void testTemplatedThisType1() {
-    newTest()
-        .addSource(
-            "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "/**\n"
-                + " * @this {T}\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "Foo.prototype.method = function() {};\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "var g = new Bar().method();\n"
-                + "/**\n"
-                + " * @param {number} a\n"
-                + " */\n"
-                + "function compute(a) {};\n"
-                + "compute(g);\n")
-        .addDiagnostic(
-            "actual parameter 1 of compute does not match formal parameter\n"
-                + "found   : Bar\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatedThisType2() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @this {Array<T>|{length:number}}\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "Array.prototype.method = function() {};\n"
-                + "(function(){\n"
-                + "  Array.prototype.method.call(arguments);"
-                + "})();")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testTemplateType1() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {T} y\n"
-                + "* @param {function(this:T, ...)} z\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y, z) {}\n"
-                + "f(this, this, function() { this });")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType2() {
-    // "this" types need to be coerced for ES3 style function or left
-    // allow for ES5-strict methods.
-    newTest()
-        .addSource(
-            "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(0, function() {});")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType3() {
-    newTest()
-        .addSource(
-            "/**"
-                + " * @param {T} v\n"
-                + " * @param {function(T)} f\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function call(v, f) { f.call(null, v); }"
-                + "/** @type {string} */ var s;"
-                + "call(3, function(x) {"
-                + " x = true;"
-                + " s = x;"
-                + "});")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: string")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testTemplateType4() {
-    newTest()
-        .addSource(
-            "/**"
-                + " * @param {...T} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(3, null);")
-        .addDiagnostic("assignment\n" + "found   : (null|number)\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType5() {
-    newTest()
-        .addSource(
-            "const CGI_PARAM_RETRY_COUNT = 'rc';",
-            "",
-            "/**",
-            " * @param {...T} p",
-            " * @return {T} ",
-            " * @template T",
-            " */",
-            "function fn(p) { return p; }",
-            "/** @type {!Object} */ var x;",
-            "",
-            "/** @return {void} */",
-            "function aScope() {",
-            "  x = fn(CGI_PARAM_RETRY_COUNT, 1);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (number|string)",
-                "required: Object"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateType6() {
-    newTest()
-        .addSource(
-            "/**"
-                + " * @param {Array<T>} arr \n"
-                + " * @param {?function(T)} f \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(arr, f) { return arr[0]; }\n"
-                + "/** @param {Array<number>} arr */ function g(arr) {"
-                + "  /** @type {!Object} */ var x = fn.call(null, arr, null);"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testTemplateType7() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
-        .addSource(
-            "/** @type {!Array<string>} */", //
-            "var query = [];",
-            "query.push(1);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of Array.prototype.push does not match formal parameter",
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateType8() {
-    newTest()
-        .addSource(
-            "/** @constructor \n"
-                + " * @template S,T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "/**"
-                + " * @param {Bar<T>} bar \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(bar) {}\n"
-                + "/** @param {Bar<number>} bar */ function g(bar) {"
-                + "  /** @type {!Object} */ var x = fn(bar);"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType9() {
-    // verify interface type parameters are recognized.
-    newTest()
-        .addSource(
-            "/** @interface \n"
-                + " * @template S,T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "/**"
-                + " * @param {Bar<T>} bar \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(bar) {}\n"
-                + "/** @param {Bar<number>} bar */ function g(bar) {"
-                + "  /** @type {!Object} */ var x = fn(bar);"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType10() {
-    // verify a type parameterized with unknown can be assigned to
-    // the same type with any other type parameter.
-    newTest()
-        .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "\n"
-                + ""
-                + "/** @type {!Bar<?>} */ var x;"
-                + "/** @type {!Bar<number>} */ var y;"
-                + "y = x;")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType11() {
-    // verify that assignment/subtype relationships work when extending
-    // templatized types.
-    newTest()
-        .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @extends {Foo<string>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @extends {Foo<number>}\n"
-                + " */\n"
-                + "function B() {}\n"
-                + ""
-                + "/** @type {!Foo<string>} */ var a = new A();\n"
-                + "/** @type {!Foo<string>} */ var b = new B();")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType12() {
-    // verify that assignment/subtype relationships work when implementing
-    // templatized types.
-    newTest()
-        .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {Foo<string>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {Foo<number>}\n"
-                + " */\n"
-                + "function B() {}\n"
-                + ""
-                + "/** @type {!Foo<string>} */ var a = new A();\n"
-                + "/** @type {!Foo<string>} */ var b = new B();")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType13() {
-    // verify that assignment/subtype relationships work when extending
-    // templatized types.
-    newTest()
-        .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @template T\n"
-                + " * @extends {Foo<T>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "var a1 = new A();\n"
-                + "var a2 = /** @type {!A<string>} */ (new A());\n"
-                + "var a3 = /** @type {!A<number>} */ (new A());\n"
-                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
-                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
-                + "/** @type {!Foo<string>} */ var f3 = a3;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType14() {
-    // verify that assignment/subtype relationships work when implementing
-    // templatized types.
-    newTest()
-        .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @template T\n"
-                + " * @implements {Foo<T>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "var a1 = new A();\n"
-                + "var a2 = /** @type {!A<string>} */ (new A());\n"
-                + "var a3 = /** @type {!A<number>} */ (new A());\n"
-                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
-                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
-                + "/** @type {!Foo<string>} */ var f3 = a3;")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType15() {
-    newTest()
-        .addSource(
-            "/**"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn({foo:3});")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType16() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {\n"
-                + "  /** @type {number} */ this.foo = 1\n"
-                + "}\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(new C());")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType17() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "C.prototype.foo = 1;\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(new C());")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType18() {
-    // Until template types can be restricted to exclude undefined, they
-    // are always optional.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "C.prototype.foo = 1;\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn({});")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType19() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {T} t\n"
-                + " * @param {U} u\n"
-                + " * @return {{t:T, u:U}} \n"
-                + " * @template T,U\n"
-                + " */\n"
-                + "function fn(t, u) { return {t:t, u:u}; }\n"
-                + "/** @type {null} */ var x = fn(1, 'str');")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : {\n  t: number,\n  u: string\n}\n"
-                + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType20() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {\n"
-                + "  /** @type {void} */ this.x;\n"
-                + "}\n"
-                + "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(new C, /** @param {number} a */ function(a) {this.x = a;});")
-        .addDiagnostic(
-            "assignment to property x of C\n" + "found   : number\n" + "required: undefined")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType21() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor @implements {A<Bar>} */\n"
-                + "function Bar() {}\n"
-                + "/** @type {!Foo} */\n"
-                + "var x = new Bar();\n")
-        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Foo")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType22() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @interface @template T */ function B() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor @implements {B<Foo>} */\n"
-                + "function Bar() {}\n"
-                + "/** @constructor @implements {B<Foo>} */\n"
-                + "function Qux() {}\n"
-                + "/** @type {!Qux} */\n"
-                + "var x = new Bar();\n")
-        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Qux")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType23() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @type {!Foo} */\n"
-                + "var x = new Foo();\n")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType24() {
-    // Recursive templated type definition.
-    newTest()
-        .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " * @param {T} x",
-            " */",
-            "function Foo(x) {",
-            "  /** @type {T} */",
-            "  this.p = x;",
-            "}",
-            "/** @return {Foo<Foo<T>>} */",
-            "Foo.prototype.m = function() {",
-            "  return null;",
-            "};",
-            "/** @return {T} */",
-            "Foo.prototype.get = function() {",
-            "  return this.p;",
-            "};",
-            "var /** null */ n = new Foo(new Object).m().get();")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Foo<Object>|null)\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType25() {
-    // Non-nullable recursive templated type definition.
-    newTest()
-        .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " * @param {T} x",
-            " */",
-            "function Foo(x) {",
-            "  /** @type {T} */",
-            "  this.p = x;",
-            "}",
-            "/** @return {!Foo<!Foo<T>>} */",
-            "Foo.prototype.m = function() {",
-            "  return new Foo(new Foo(new Object));",
-            "};",
-            "/** @return {T} */",
-            "Foo.prototype.get = function() {",
-            "  return this.p;",
-            "};",
-            "var /** null */ n = new Foo(new Object).m().get();")
-        .addDiagnostic("initializing variable\n" + "found   : Foo<Object>\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateType26() {
-    // Class hierarchies which use the same template parameter name should not be treated as
-    // infinite recursion.
-    newTest()
-        .addSource(
-            "/**",
-            " * @param {T} bar",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function Bar(bar) {",
-            "  /** @type {T} */",
-            "  this.bar = bar;",
-            "}",
-            "/** @return {T} */",
-            "Bar.prototype.getBar = function() {",
-            "  return this.bar;",
-            "};",
-            "/**",
-            " * @param {T} foo",
-            " * @constructor",
-            " * @template T",
-            " * @extends {Bar<!Array<T>>}",
-            " */",
-            "function Foo(foo) {",
-            "  /** @type {T} */",
-            "  this.foo = foo;",
-            "}",
-            "var /** null */ n = new Foo(new Object).getBar();")
-        .addDiagnostic("initializing variable\n" + "found   : Array<Object>\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeCollidesWithParameter() {
-    // Function templates are in the same scope as parameters, so cannot collide.
-    newTest()
-        .addSource(
-            "/**", //
-            " * @param {T} T",
-            " * @template T",
-            " */",
-            "function f(T) {}")
-        .addDiagnostic(
-            "variable T redefined with type undefined, original definition at [testcode]:5 with"
-                + " type T")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReference() {
-    // TODO(martinprobst): the test below asserts incorrect behavior for backwards compatibility.
-    newTest()
-        .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReference_declared() {
-    compiler.forwardDeclareType("Foo");
-    newTest()
-        .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReferenceFunctionWithExtra() {
-    // TODO(johnlenz): report an error when forward references contain extraneous
-    // type arguments.
-    newTest()
-        .addSource(
-            "/** @param {!Foo<string, boolean>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReferenceVar() {
-    newTest()
-        .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "var Foo = function() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReference_declaredMissing() {
-    compiler.forwardDeclareType("Foo");
-    compiler.forwardDeclareType("DoesNotExist");
-    newTest()
-        .addSource(
-            "/** @param {!Foo<DoesNotExist>} x */", //
-            "function f(x) {}")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeForwardReference_extends() {
-    compiler.forwardDeclareType("Bar");
-    compiler.forwardDeclareType("Baz");
-    newTest()
-        .addSource(
-            "/** @constructor @extends {Bar<Baz>} */",
-            "function Foo() {}",
-            "/** @constructor */",
-            "function Bar() {}")
-        .run();
-  }
-
-  @Test
-  public void testSubtypeNotTemplated1() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}",
-            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
-            "function f(/** (!Object|!Foo<string>) */ x) {",
-            "  var /** null */ n = x;",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testSubtypeNotTemplated2() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}",
-            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
-            "function f(/** (!Object|!Foo) */ x) {",
-            "  var /** null */ n = x;",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeWithUnresolvedType() {
-    testClosureTypes(
-        "goog.forwardDeclare('Color');\n"
-            + "/** @interface @template T */ function C() {}\n"
-            + "/** @return {!Color} */ C.prototype.method;\n"
-            + "/** @constructor @implements {C} */ function D() {}\n"
-            + "/** @override */ D.prototype.method = function() {};",
-        null); // no warning expected.
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef1a() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + ""
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "/** @type {Generic<!Bar>} */ var y;\n"
-                + ""
-                + "x = y;\n"
-                + // no warning
-                "/** @type {null} */ var z1 = y;\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef1b() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + ""
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "/** @type {Generic<!Bar>} */ var y;\n"
-                + ""
-                + "y = x;\n"
-                + // no warning.
-                "/** @type {null} */ var z1 = x;\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef2a() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Bar> */ x) {}\n"
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef2b() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Bar> */ x) {}\n"
-                + "/** @type {Generic<!Bar>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef2c() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Foo> */ x) {}\n"
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
-  }
-
-  @Test
-  public void testTemplateTypeWithTypeDef2d() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Foo> */ x) {}\n"
-                + "/** @type {Generic<!Bar>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
-  }
-
-  @Test
-  public void testTemplatedFunctionInUnion1() {
-    newTest()
-        .addSource(
-            "/**",
-            "* @param {T} x",
-            "* @param {function(this:T, ...)|{fn:Function}} z",
-            "* @template T",
-            "*/",
-            "function f(x, z) {}",
-            "f([], function() { /** @type {string} */ var x = this });")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : Array<?>",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeRecursion1() {
-    newTest()
-        .addSource(
-            "/** @typedef {{a: D2}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeRecursion2() {
-    newTest()
-        .addSource(
-            "/** @typedef {{a: D2}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "/** @type {D1} */ var x;"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
-        .run();
-  }
-
-  @Test
-  public void testTemplateTypeRecursion3() {
-    newTest()
-        .addSource(
-            "/** @typedef {{a: function(D2)}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "/** @type {D1} */ var x;"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadTemplateType4() {
-    // TODO(johnlenz): Add a check for useless of template types.
-    // Unless there are at least two references to a Template type in
-    // a definition it isn't useful.
-    newTest()
-        .addSource("/**\n" + "* @template T\n" + "*/\n" + "function f() {}\n" + "f();")
-        .addDiagnostic(FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format())
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadTemplateType5() {
-    // TODO(johnlenz): Add a check for useless of template types.
-    // Unless there are at least two references to a Template type in
-    // a definition it isn't useful.
-    newTest()
-        .addSource(
-            "/**\n" + "* @template T\n" + "* @return {T}\n" + "*/\n" + "function f() {}\n" + "f();")
-        .addDiagnostic(FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format())
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testFunctionLiteralUndefinedThisArgument() {
-    // TODO(johnlenz): this was a weird error.  We should add a general
-    // restriction on what is accepted for T. Something like:
-    // "@template T of {Object|string}" or some such.
-    newTest()
-        .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() { this; });")
-        .addDiagnostic("Function literal argument refers to undefined this argument")
-        .run();
-  }
-
-  @Test
-  public void testFunctionLiteralDefinedThisArgument() {
-    newTest()
-        .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() { this; }, {});")
-        .run();
-  }
-
-  @Test
-  public void testFunctionLiteralDefinedThisArgument2() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
-        .addSource(
-            "/** @param {string} x */ function f(x) {}",
-            "/**",
-            " * @param {?function(this:T, ...)} fn",
-            " * @param {T=} opt_obj",
-            " * @template T",
-            " */",
-            "function baz(fn, opt_obj) {}",
-            "function g() { baz(function() { f(this.length); }, []); }")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testFunctionLiteralUnreadNullThisArgument() {
-    newTest()
-        .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() {}, null);")
-        .run();
-  }
-
-  @Test
-  public void testUnionTemplateThisType() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @return {F|Array} */ function g() { return []; }"
-                + "/** @param {F} x */ function h(x) { }"
-                + "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(g(), function() { h(this); });")
-        .addDiagnostic(
-            "actual parameter 1 of h does not match formal parameter\n"
-                + "found   : (Array|F|null)\n"
-                + "required: (F|null)")
-        .run();
-  }
-
-  @Test
-  public void testRecordType1() {
-    newTest()
-        .addSource(
-            "/** @param {{prop: number}} x */", //
-            "function f(x) {}",
-            "f({});")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|undefined)}",
-                "required: {prop: number}",
-                "missing : []",
-                "mismatch: [prop]"))
-        .run();
-  }
-
-  @Test
-  public void testRecordType2() {
-    newTest()
-        .addSource("/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "f({});")
-        .run();
-  }
-
-  @Test
-  public void testRecordType3() {
-    newTest()
-        .addSource(
-            "/** @param {{prop: number}} x */", //
-            "function f(x) {}",
-            "f({prop: 'x'});")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|string)}",
-                "required: {prop: number}",
-                "missing : []",
-                "mismatch: [prop]"))
-        .run();
-  }
-
-  @Test
-  public void testRecordType4() {
-    // Notice that we do not do flow-based inference on the object type:
-    // We don't try to prove that x.prop may not be string until x
-    // gets passed to g.
-    testClosureTypesMultipleWarnings(
-        "/** @param {{prop: (number|undefined)}} x */"
-            + "function f(x) {}"
-            + "/** @param {{prop: (string|undefined)}} x */"
-            + "function g(x) {}"
-            + "var x = {}; f(x); g(x);",
-        ImmutableList.of(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|string|undefined)}",
-                "required: {prop: (number|undefined)}",
-                "missing : []",
-                "mismatch: [prop]"),
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : {prop: (number|string|undefined)}",
-                "required: {prop: (string|undefined)}",
-                "missing : []",
-                "mismatch: [prop]")));
-  }
-
-  @Test
-  public void testRecordType5() {
-    newTest()
-        .addSource(
-            "/** @param {{prop: (number|undefined)}} x */"
-                + "function f(x) {}"
-                + "/** @param {{otherProp: (string|undefined)}} x */"
-                + "function g(x) {}"
-                + "var x = {}; f(x); g(x);")
-        .run();
-  }
-
-  @Test
-  public void testRecordType6() {
-    newTest()
-        .addSource("/** @return {{prop: (number|undefined)}} x */" + "function f() { return {}; }")
-        .run();
-  }
-
-  @Test
-  public void testRecordType7() {
-    newTest()
-        .addSource(
-            "/** @return {{prop: (number|undefined)}} x */"
-                + "function f() { var x = {}; g(x); return x; }"
-                + "/** @param {number} x */"
-                + "function g(x) {}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : {prop: (number|undefined)}\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testRecordType8() {
-    newTest()
-        .addSource(
-            "/** @return {{prop: (number|string)}} x */"
-                + "function f() { var x = {prop: 3}; g(x.prop); return x; }"
-                + "/** @param {string} x */"
-                + "function g(x) {}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testDuplicateRecordFields1() {
-    newTest()
-        .addSource("/**" + "* @param {{x:string, x:number}} a" + "*/" + "function f(a) {};")
-        .addDiagnostic("Bad type annotation. Duplicate record field x." + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
-
-  @Test
-  public void testDuplicateRecordFields2() {
-    newTest()
-        .addSource(
-            "/**" + "* @param {{name:string,number:x,number:y}} a" + " */" + "function f(a) {};")
-        .addDiagnostic("Bad type annotation. Unknown type x")
-        .addDiagnostic("Bad type annotation. Duplicate record field number." + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ function base1() {}\n"
-                + "/** @interface */ function base2() {}\n"
-                + "/** @interface\n"
-                + "* @extends {base1}\n"
-                + "* @extends {base2}\n"
-                + "*/\n"
-                + "function derived() {}")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "Int0.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int0 is not implemented by type Foo")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "Int1.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int1 is not implemented by type Foo")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
-                + " @extends {number} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("Int2 @extends non-object type number")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface5() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @constructor */function Int1() {};"
-                + "/** @return {string} x */"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};")
-        .addDiagnostic("Int2 cannot extend this type; interfaces can only extend interfaces")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterface6() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super1() {};",
-            "/** @interface */function Super2() {};",
-            "/** @param {number} bar */Super2.prototype.foo = function(bar) {};",
-            "/** @interface @extends {Super1} @extends {Super2} */function Sub() {};",
-            "/** @override @param {string} bar */Sub.prototype.foo =",
-            "function(bar) {};")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Sub and the type of the property it "
-                    + "overrides from interface Super2",
-                "original: function(this:Super2, number): undefined",
-                "override: function(this:Sub, string): undefined"))
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterfaceAssignment() {
-    newTest()
-        .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */ var I2 = function() {}\n"
-                + "/** @interface\n@extends {I1}\n@extends {I2}*/"
-                + "var I3 = function() {};\n"
-                + "/** @constructor\n@implements {I3}*/var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I1} */var i1 = t;\n"
-                + "/** @type {I2} */var i2 = t;\n"
-                + "/** @type {I3} */var i3 = t;\n"
-                + "i1 = i3;\n"
-                + "i2 = i3;\n")
-        .run();
-  }
-
-  @Test
-  public void testMultipleExtendsInterfaceParamPass() {
-    newTest()
-        .addSource(
-            "/** @interface */",
-            "var I1 = function() {};",
-            "/** @interface */",
-            "var I2 = function() {}",
-            "/** @interface @extends {I1} @extends {I2} */",
-            "var I3 = function() {};",
-            "/** @constructor @implements {I3} */",
-            "var T = function() {};",
-            "var t = new T();",
-            "/**",
-            " * @param {I1} x",
-            " * @param {I2} y",
-            " * @param {I3} z",
-            " */",
-            "function foo(x,y,z){};",
-            "foo(t,t,t)")
-        .run();
-  }
-
-  @Test
-  public void testBadMultipleExtendsClass() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function base1() {}\n"
-                + "/** @constructor */ function base2() {}\n"
-                + "/** @constructor\n"
-                + "* @extends {base1}\n"
-                + "* @extends {base2}\n"
-                + "*/\n"
-                + "function derived() {}")
-        .addDiagnostic(
-            "Bad type annotation. type annotation incompatible with other annotations."
-                + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
-
-  @Test
-  public void testInterfaceExtendsResolution() {
-    newTest()
-        .addSource(
-            "/** @interface \n @extends {A} */ function B() {};\n"
-                + "/** @constructor \n @implements {B} */ function C() {};\n"
-                + "/** @interface */ function A() {};")
-        .run();
-  }
-
-  @Test
-  public void testPropertyCanBeDefinedInObject() {
-    // This test is specifically checking loose property check behavior.
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {};",
-            "I.prototype.bar = function() {};",
-            "/** @type {Object} */ var foo;",
-            "foo.bar();")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility1() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};")
-        .addDiagnostic(
-            "Interface Int2 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int1")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @interface */function Int2() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @type {Object} */"
-                + "Int2.prototype.foo;"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
-                + "@extends {Int2}*/"
-                + "function Int3() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in "
-                + "its super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in "
-                + "its super interfaces Int1 and Int2")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility3() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int1")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility4() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface \n @extends {Int0} */ function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @interface */function Int2() {};"
-                + "/** @interface \n @extends {Int2} */ function Int3() {};"
-                + "/** @type {string} */"
-                + "Int2.prototype.foo;"
-                + "/** @interface \n @extends {Int1} \n @extends {Int3} */"
-                + "function Int4() {};")
-        .addDiagnostic(
-            "Interface Int4 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int2")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility5() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {number} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int1 and Int4")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility6() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {string} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility7() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {Object} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int1 and Int4")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility8() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.bar;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {Object} */"
-                + "Int4.prototype.foo;"
-                + "/** @type {Null} */"
-                + "Int4.prototype.bar;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int5 has a property bar with incompatible types in its"
-                + " super interfaces Int1 and Int4")
-        .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int4")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibility9() {
-    newTest()
-        .addSource(
-            "/** @interface\n * @template T */function Int0() {};"
-                + "/** @interface\n * @template T */function Int1() {};"
-                + "/** @type {T} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {T} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int0<number>} \n @extends {Int1<string>} */"
-                + "function Int2() {};")
-        .addDiagnostic(
-            "Interface Int2 has a property foo with incompatible types in its "
-                + "super interfaces Int0<number> and Int1<string>")
-        .run();
-  }
-
-  @Test
-  public void testExtendedInterfacePropertiesCompatibilityNoError() {
-    newTest()
-        .addSource(
-            ""
-                + "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @param {number} x */"
-                + "Int0.prototype.foo;"
-                + "/** @param {number} x */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n * @extends {Int0} \n * @extends {Int1} */"
-                + "function Int2() {};")
-        .run();
-  }
-
-  @Test
-  public void testImplementedInterfacePropertiesShouldFailOnConflict() {
-    // TODO(b/132718172): Provide a better error message.
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};",
-            "/** @interface */function Int1() {};",
-            "/** @type {number} */",
-            "Int0.prototype.foo;",
-            "/** @type {string} */",
-            "Int1.prototype.foo;",
-            "/** @constructor @implements {Int0} @implements {Int1} */",
-            "function Foo() {};",
-            "Foo.prototype.foo;")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Foo and the type of the property it"
-                    + " overrides from interface Int1",
-                "original: string",
-                "override: number"))
-        .run();
-  }
-
-  @Test
-  public void testImplementedInterfacePropertiesShouldFailOnConflictForAbstractClasses() {
-    // TODO(b/132718172): Provide an error message.
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};",
-            "/** @interface */function Int1() {};",
-            "/** @type {number} */",
-            "Int0.prototype.foo;",
-            "/** @type {string} */",
-            "Int1.prototype.foo;",
-            "/** @constructor @abstract @implements {Int0} @implements {Int1} */",
-            "function Foo() {};")
-        .run();
-  }
-
-  @Test
-  public void testImplementedInterfacePropertiesShouldFailOnConflictForAbstractClasses2() {
-    // TODO(b/132718172): Provide an error message.
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};",
-            "/** @interface */function Int1() {};",
-            "/** @type {number} */",
-            "Int0.prototype.foo;",
-            "/** @type {string} */",
-            "Int1.prototype.foo;",
-            "/** @constructor @abstract @implements {Int0} */",
-            "function Foo() {};",
-            "/** @constructor @abstract @extends {Foo} @implements {Int1} */",
-            "function Zoo() {};")
+            "variable goog.Bar redefined with type None, "
+                + "original definition at [testcode]:2 "
+                + "with type (typeof goog.Bar)")
         .run();
   }
 
   @Test
-  public void testGenerics1a() {
-    String fnDecl =
-        "/** \n"
-            + " * @param {T} x \n"
-            + " * @param {function(T):T} y \n"
-            + " * @template T\n"
-            + " */ \n"
-            + "function f(x,y) { return y(x); }\n";
-
+  public void testTypeDef1() {
     newTest()
         .addSource(
-            fnDecl
-                + "/** @type {string} */"
-                + "var out;"
-                + "/** @type {string} */"
-                + "var result = f('hi', function(x){ out = x; return x; });")
+            "var goog = {};"
+                + "/** @typedef {number} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f(3);")
         .run();
   }
 
   @Test
-  public void testGenerics1b() {
-    String fnDecl =
-        "/** \n"
-            + " * @param {T} x \n"
-            + " * @param {function(T):T} y \n"
-            + " * @template T\n"
-            + " */ \n"
-            + "function f(x,y) { return y(x); }\n";
-
+  public void testTypeDef2() {
     newTest()
         .addSource(
-            fnDecl
-                + "/** @type {string} */"
-                + "var out;"
-                + "var result = f(0, function(x){ out = x; return x; });")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+            "var goog = {};"
+                + "/** @typedef {number} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f('3');")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testFilter0() {
+  public void testTypeDef3() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {T} arr\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<string>} */"
-                + "var result = filter(arr);")
+            "var goog = {};"
+                + "/** @typedef {number} */ var Bar;"
+                + "/** @param {Bar} x */ function f(x) {}"
+                + "f('3');")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testFilter1() {
+  public void testTypeDef4() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {!Array<T>} arr\n"
-                + " * @return {!Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<string>} */"
-                + "var result = filter(arr);")
+            "/** @constructor */ function A() {}"
+                + "/** @constructor */ function B() {}"
+                + "/** @typedef {(A|B)} */ var AB;"
+                + "/** @param {AB} x */ function f(x) {}"
+                + "f(new A()); f(new B()); f(1);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: (A|B|null)")
         .run();
   }
 
   @Test
-  public void testFilter2() {
+  public void testTypeDef5() {
+    // Notice that the error message is slightly different than
+    // the one for testTypeDef4, even though they should be the same.
+    // This is an implementation detail necessary for NamedTypes work out
+    // OK, and it should change if NamedTypes ever go away.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {!Array<T>} arr\n"
-                + " * @return {!Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<number>} */"
-                + "var result = filter(arr);")
+            "/** @param {AB} x */ function f(x) {}"
+                + "/** @constructor */ function A() {}"
+                + "/** @constructor */ function B() {}"
+                + "/** @typedef {(A|B)} */ var AB;"
+                + "f(new A()); f(new B()); f(1);")
         .addDiagnostic(
-            "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: (A|B|null)")
         .run();
   }
 
   @Test
-  public void testFilter3() {
+  public void testCircularTypeDef() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {Array<T>} arr\n"
-                + " * @return {Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {Array<number>} */"
-                + "var result = filter(arr);")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : (Array<string>|null)\n"
-                + "required: (Array<number>|null)")
+            "var goog = {};"
+                + "/** @typedef {number|Array<goog.Bar>} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f(3); f([3]); f([[3]]);")
         .run();
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter1() {
-    testClosureTypes(
-        "/** @type {Array<string>} */"
-            + "var arr;\n"
-            + "/** @type {!Array<number>} */"
-            + "var result = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {return false;});",
-        "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>");
+  public void testGetTypedPercent1() {
+    String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(50.0);
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter2() {
-    testClosureTypes(
-        "/** @type {number} */"
-            + "var out;"
-            + "/** @type {Array<string>} */"
-            + "var arr;\n"
-            + "var out4 = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {out = item; return false});",
-        "assignment\n" + "found   : string\n" + "required: number");
+  public void testGetTypedPercent2() {
+    String js = "var x = {}; x.y = 1;";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter3() {
-    testClosureTypes(
-        "/** @type {string} */"
-            + "var out;"
-            + "/** @type {Array<string>} */ var arr;\n"
-            + "var result = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {out = index;});",
-        "assignment\n" + "found   : number\n" + "required: string");
+  public void testGetTypedPercent3() {
+    String js = "var f = function(x) { x.a = x.b; }";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(25.0);
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter4() {
-    testClosureTypes(
-        lines(
-            "/** @type {string} */",
-            "var out;",
-            "/** @type {Array<string>} */ var arr;",
-            "var out4 = goog.array.filter(",
-            "   arr,",
-            "   function(item,index,srcArr) {out = srcArr;});"),
-        lines(
-            "assignment", // keep newlines
-            "found   : (Array|null|{length: number})",
-            "required: string"));
+  public void testGetTypedPercent4() {
+    String js =
+        "var n = {};\n /** @constructor */ n.T = function() {};\n"
+            + "/** @type {n.T} */ var x = new n.T();";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
   }
 
   @Test
-  public void testCatchExpression1() {
-    newTest()
-        .addSource(
-            "function fn() {"
-                + "  /** @type {number} */"
-                + "  var out = 0;"
-                + "  try {\n"
-                + "    foo();\n"
-                + "  } catch (/** @type {string} */ e) {\n"
-                + "    out = e;"
-                + "  }"
-                + "}\n")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
-        .run();
+  public void testGetTypedPercent5() {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
   }
 
   @Test
-  public void testCatchExpression2() {
-    newTest()
-        .addSource(
-            "function fn() {"
-                + "  /** @type {number} */"
-                + "  var out = 0;"
-                + "  /** @type {string} */"
-                + "  var e;"
-                + "  try {\n"
-                + "    foo();\n"
-                + "  } catch (e) {\n"
-                + "    out = e;"
-                + "  }"
-                + "}\n")
-        .run();
+  public void testGetTypedPercent6() {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testPrototypePropertyReference() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            ""
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "/** @param {number} a */\n"
+                + "Foo.prototype.bar = function(a){};\n"
+                + "/** @param {Foo} f */\n"
+                + "function baz(f) {\n"
+                + "  Foo.prototype.bar.call(f, 3);\n"
+                + "}");
+    assertThat(compiler.getErrorCount()).isEqualTo(0);
+    assertThat(compiler.getWarningCount()).isEqualTo(0);
+
+    assertThat(p.scope.getVar("Foo").getType()).isInstanceOf(FunctionType.class);
+    FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType();
+    assertThat(fooType.getPrototype().getPropertyType("bar").toString())
+        .isEqualTo("function(this:Foo, number): undefined");
+  }
+
+  @Test
+  public void testResolvingNamedTypes() {
+    String externs = new TestExternsBuilder().addObject().build();
+    String js =
+        lines(
+            "/** @constructor */",
+            "var Foo = function() {}",
+            "/** @param {number} a */",
+            "Foo.prototype.foo = function(a) {",
+            "  return this.baz().toString();",
+            "};",
+            "/** @return {Baz} */",
+            "Foo.prototype.baz = function() { return new Baz(); };",
+            "/** @constructor",
+            "  * @extends Foo */",
+            "var Bar = function() {};",
+            "/** @constructor */",
+            "var Baz = function() {};");
+    assertThat(getTypedPercentWithExterns(externs, js)).isWithin(0.1).of(100.0);
   }
 
   @Test
-  public void testTemplatized1() {
+  public void testMissingProperty1a() {
     newTest()
         .addSource(
-            "/** @type {!Array<string>} */"
-                + "var arr1 = [];\n"
-                + "/** @type {!Array<number>} */"
-                + "var arr2 = [];\n"
-                + "arr1 = arr2;")
-        .addDiagnostic("assignment\n" + "found   : Array<number>\n" + "required: Array<string>")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "Foo.prototype.baz = function() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized2() {
+  public void testMissingProperty1b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @type {!Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : Array<number>\n" + "required: Array<string>")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.a = 3; };")
         .run();
   }
 
   @Test
-  public void testTemplatized3() {
+  public void testMissingProperty2a() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @type {Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : Array<number>\n"
-                + "required: (Array<string>|null)")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.b = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized4() {
+  public void testMissingProperty2b() {
     newTest()
         .addSource(
-            "/** @type {Array<string>} */"
-                + "var arr1 = [];\n"
-                + "/** @type {Array<number>} */"
-                + "var arr2 = arr1;\n")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : (Array<string>|null)\n"
-                + "required: (Array<number>|null)")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.baz = function() { this.b = 3; };")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized5() {
+  public void testMissingProperty3a() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {Object<T>} obj\n"
-                + " * @return {boolean|undefined}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var some = function(obj) {"
-                + "  for (var key in obj) if (obj[key]) return true;"
-                + "};"
-                + "/** @return {!Array} */ function f() { return []; }"
-                + "/** @return {!Array<string>} */ function g() { return []; }"
-                + "some(f());\n"
-                + "some(g());\n")
-        .run();
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "(new Foo).a = 3;")
+        .addDiagnostic("Property a never defined on Foo") // method
+        .addDiagnostic("Property a never defined on Foo")
+        .run(); // global assignment
   }
 
   @Test
-  public void testTemplatized6() {
+  public void testMissingProperty3b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @interface */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {I}\n"
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + ""
-                + "/** @type {null} */ var some = new C().method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "(new Foo).a = 3;")
         .run();
   }
 
   @Test
-  public void testTemplatized7() {
+  public void testMissingProperty4a() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " * @implements {I<number>}\n"
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {null} */ var some = new C().method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "(new Foo).b = 3;")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  @Ignore
-  public void testTemplatized8() {
-    // TODO(johnlenz): this should generate a warning but does not.
+  public void testMissingProperty4b() {
     newTest()
         .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " *  @implements {I<R>}\n"
-                + " *  @template R\n "
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {C<number>} var x = new C();"
-                + "/** @type {null} */ var some = x.method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+            "/** @constructor */ function Foo() {}", //
+            "(new Foo).b = 3;")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized9() {
+  public void testMissingProperty5() {
     newTest()
         .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " *  @param {R} a\n"
-                + " *  @implements {I<R>}\n"
-                + " *  @template R\n "
-                + " */ function C(a){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {null} */ var some = new C(1).method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "/** @constructor */ function Bar() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized10() {
+  public void testMissingProperty6a() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Parent() {};\n"
-                + "\n"
-                + "/** @param {T} x */\n"
-                + "Parent.prototype.method = function(x) {};\n"
-                + "\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Parent<string>}\n"
-                + " */\n"
-                + "function Child() {};\n"
-                + "Child.prototype = new Parent();\n"
-                + "\n"
-                + "(new Child()).method(123); \n")
-        .addDiagnostic(
-            "actual parameter 1 of Parent.prototype.method does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "/** @constructor \n * @extends {Foo} */ ",
+            "function Bar() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplatized11() {
+  public void testMissingProperty6b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** \n"
-                + " * @template T\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C() {}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {T|K} a\n"
-                + " * @return {T}\n"
-                + " * @template K\n"
-                + " */\n"
-                + "C.prototype.method = function(a) {};\n"
-                + "\n"
-                +
-                // method returns "?"
-                "/** @type {void} */ var x = new C().method(1);")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "/** @constructor \n * @extends {Foo} */ "
+                + "function Bar() { this.a = 3; };")
         .run();
   }
 
   @Test
-  public void testIssue1058() {
+  public void testMissingProperty7() {
     newTest()
-        .addSource(
-            "/**\n"
-                + "  * @constructor\n"
-                + "  * @template CLASS\n"
-                + "  */\n"
-                + "var Class = function() {};\n"
-                + "\n"
-                + "/**\n"
-                + "  * @param {function(CLASS):CLASS} a\n"
-                + "  * @template T\n"
-                + "  */\n"
-                + "Class.prototype.foo = function(a) {\n"
-                + "  return 'string';\n"
-                + "};\n"
-                + "\n"
-                + "/** @param {number} a\n"
-                + "  * @return {string} */\n"
-                + "var a = function(a) { return '' };\n"
-                + "\n"
-                + "new Class().foo(a);")
+        .addSource("/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }")
+        .addDiagnostic(
+            "Property impossible never defined on Object"
+                + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testDeterminacyIssue() {
+  public void testMissingProperty8() {
     newTest()
         .addSource(
-            "(function() {\n"
-                + "    /** @constructor */\n"
-                + "    var ImageProxy = function() {};\n"
-                + "    /** @constructor */\n"
-                + "    var FeedReader = function() {};\n"
-                + "    /** @type {ImageProxy} */\n"
-                + "    FeedReader.x = new ImageProxy();\n"
-                + "})();")
+            "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }")
         .run();
   }
 
   @Test
-  public void testUnknownTypeReport() {
-    enableReportUnknownTypes();
+  public void testMissingProperty9() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
-        .addSource("function id(x) { return x; }")
-        .addDiagnostic("could not determine the type of this expression")
+        .addSource(
+            "/** @param {Object} obj */"
+                + "function foo(obj) { if (obj.impossible) { return true; } }")
         .run();
   }
 
   @Test
-  public void testUnknownTypeReport_allowsUnknownIfStatement() {
-    enableReportUnknownTypes();
-    newTest().addSource("function id(x) { x; }").run();
-  }
-
-  @Test
-  public void testUnknownForIn() {
-    enableReportUnknownTypes();
-    newTest().addSource("var x = {'a':1}; var y; \n for(\ny\n in x) {}").run();
-  }
-
-  @Test
-  public void testUnknownTypeDisabledByDefault() {
-    newTest().addSource("function id(x) { return x; }").run();
-  }
-
-  @Test
-  public void testTemplatizedTypeSubtypes2() {
-    JSType arrayOfNumber = createTemplatizedType(getNativeArrayType(), getNativeNumberType());
-    JSType arrayOfString = createTemplatizedType(getNativeArrayType(), getNativeStringType());
-    assertThat(arrayOfString.isSubtypeOf(createUnionType(arrayOfNumber, getNativeNullVoidType())))
-        .isFalse();
+  public void testMissingProperty10() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @param {Object} obj */"
+                + "function foo(obj) { while (obj.impossible) { return true; } }")
+        .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessOnStruct() {
+  public void testMissingProperty11() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "var A = function() {};\n"
-                + "/** @param {A} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
-                + "}")
-        .addDiagnostic("Property bar never defined on A")
+            "/** @param {Object} obj */"
+                + "function foo(obj) { for (;obj.impossible;) { return true; } }")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessOnStructOrObject() {
+  public void testMissingProperty12() {
     disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "var A = function() {};\n"
-                + "/** @param {A|Object} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
-                + "}")
+            "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }")
         .run();
   }
 
+  // Note: testMissingProperty{13,14} pertained to a deleted coding convention.
+
   @Test
-  public void testNonexistentPropertyAccessOnExternStruct() {
+  public void testMissingProperty15() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(
-            "/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "var A = function() {};")
-        .addSource(
-            "/** @param {A} a */\n" + "function foo(a) {\n" + "  if (a.bar) { a.bar(); }\n" + "}")
-        .addDiagnostic("Property bar never defined on A")
+        .addSource("/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructSubtype() {
+  public void testMissingProperty16() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "var A = function() {};"
-                + ""
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @extends {A}\n"
-                + " */\n"
-                + "var B = function() { this.bar = function(){}; };"
-                + ""
-                + "/** @param {A} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
-                + "}")
-        .addDiagnostic("Property bar never defined on A")
+        .addSource("/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }")
+        .addDiagnostic(
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructInterfaceSubtype() {
+  public void testMissingProperty17() {
     newTest()
         .addSource(
-            "/**",
-            " * @interface",
-            " * @struct",
-            " */",
-            "var A = function() {};",
-            "",
-            "/**",
-            " * @interface",
-            " * @struct",
-            " * @extends {A}",
-            " */",
-            "var B = function() {};",
-            "/** @return {void} */ B.prototype.bar = function(){};",
-            "",
-            "/** @param {A} a */",
-            "function foo(a) {",
-            "  if (a.bar) { a.bar(); }",
-            "}")
-        .addDiagnostic("Property bar never defined on A")
+            "/** @param {Object} x */"
+                + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructRecordSubtype() {
+  public void testMissingProperty18() {
     disableStrictMissingPropertyChecks();
-
     newTest()
         .addSource(
-            "/**",
-            " * @record",
-            " * @struct",
-            " */",
-            "var A = function() {};",
-            "",
-            "/**",
-            " * @record",
-            " * @struct",
-            " * @extends {A}",
-            " */",
-            "var B = function() {};",
-            "/** @return {void} */ B.prototype.bar = function(){};",
-            "",
-            "/** @param {A} a */",
-            "function foo(a) {",
-            "  if (a.bar) {",
-            "    a.bar();",
-            "  }",
-            "}")
-        .addDiagnostic("Property bar never defined on A")
+            "/** @param {Object} x */"
+                + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructSubtype2() {
+  public void testMissingProperty19() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Foo() {\n"
-                + "  this.x = 123;\n"
-                + "}\n"
-                + "var objlit = /** @struct */ { y: 234 };\n"
-                + "Foo.prototype = objlit;\n"
-                + "var n = objlit.x;\n")
-        .addDiagnostic("Property x never defined on Foo.prototype")
+            "/** @param {Object} x */"
+                + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }")
+        .addDiagnostic(
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testIssue1024a() {
-    // This test is specifically checking loose property check behavior.
+  public void testMissingProperty20() {
     disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @param {Object} a */",
-            "function f(a) {",
-            "  a.prototype = '__proto'",
-            "}",
-            "/** @param {Object} b",
-            " *  @return {!Object}",
-            " */",
-            "function g(b) {",
-            "  return b.prototype",
-            "}")
+            "/** @param {Object} x */" + "function f(x) { if (x.foo) { } else { x.foo(); } }")
+        .addDiagnostic(
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testIssue1024b() {
+  public void testMissingProperty21() {
+    disableStrictMissingPropertyChecks();
+    newTest().addSource("/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }").run();
+  }
+
+  @Test
+  public void testMissingProperty22() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @param {Object} a */",
-            "function f(a) {",
-            "  a.prototype = {foo:3};",
-            "}",
-            "/** @param {Object} b",
-            " */",
-            "function g(b) {",
-            "  b.prototype = function(){};",
-            "}")
+            "/** @param {Object} x \n * @return {boolean} */"
+                + "function f(x) { return x.foo ? x.foo() : true; }")
         .run();
   }
 
   @Test
-  public void testBug12722936() {
-    // Verify we don't use a weaker type when a
-    // stronger type is known for a slot.
+  public void testMissingProperty23() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function X() {}\n"
-                + "/** @constructor */ function C() {\n"
-                + "  /** @type {!X<boolean>}*/\n"
-                + "  this.a = new X();\n"
-                + "  /** @type {null} */ var x = this.a;\n"
-                + "};\n"
-                + "\n")
-        .addDiagnostic("initializing variable\n" + "found   : X<boolean>\n" + "required: null")
+        .addSource("function f(x) { x.impossible(); }")
+        .addDiagnostic(
+            "Property impossible never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testModuleReferenceNotAllowed() {
+  public void testMissingProperty24() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {MissingType} x */"
+            + "function f(x) { x.impossible(); }",
+        null);
+  }
+
+  @Test
+  public void testMissingProperty25() {
     newTest()
-        .addSource("/** @param {./Foo} z */ function f(z) {}")
-        .addDiagnostic("Bad type annotation. Unknown type ./Foo")
+        .addSource(
+            "/** @constructor */ var Foo = function() {};"
+                + "Foo.prototype.bar = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "(new FooAlias()).bar();")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey1() {
+  public void testMissingProperty26() {
     newTest()
-        .addSource("/** @type {!Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "FooAlias.prototype.bar = function() {};"
+                + "(new Foo()).bar();")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey2() {
+  public void testMissingProperty27() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {?MissingType} x */"
+            + "function f(x) {"
+            + "  for (var parent = x; parent; parent = parent.getParent()) {}"
+            + "}",
+        null);
+  }
+
+  @Test
+  public void testMissingProperty28a() {
     newTest()
-        .addSource("/** @type {!Object<function(), number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foo;" + "}")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey3() {
+  public void testMissingProperty28b() {
     newTest()
-        .addSource("/** @type {!Object<!Array<!Object>, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foox;" + "}")
+        .addDiagnostic(
+            "Property foox never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey4() {
+  public void testMissingProperty29() {
+    // This used to emit a warning.
     newTest()
-        .addSource("/** @type {!Object<*, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addExterns(
+            "/** @constructor */ var Foo;"
+                + "Foo.prototype.opera;"
+                + "Foo.prototype.opera.postError;")
+        .addSource("")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey5() {
+  public void testMissingProperty30a() {
     newTest()
-        .addSource("/** @type {(string|Object<Object, number>)} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @return {*} */",
+            "function f() {",
+            " return {};",
+            "}",
+            "f().a = 3;",
+            "/** @param {Object} y */ function g(y) { return y.a; }")
+        .addDiagnostic("Property a never defined on *")
+        .addDiagnostic("Property a never defined on Object")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey6() {
+  public void testMissingProperty30b() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource("/** @type {!Object<number, !Object<Object, number>>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @return {*} */"
+                + "function f() {"
+                + " return {};"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Object} y */ function g(y) { return y.a; }")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey7() {
+  public void testMissingProperty31a() {
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "var MyClass = function() {};\n"
-                + "/** @type {!Object<MyClass, number>} */\n"
-                + "var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/** @return {Array|number} */", //
+            "function f() {",
+            " return [];",
+            "}",
+            "f().a = 3;")
+        .addDiagnostic("Property a never defined on (Array|Number)")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey8() {
+  public void testMissingProperty31b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @enum{!Object} */\n"
-                + "var Enum = {};\n"
-                + "/** @type {!Object<Enum, number>} */\n"
-                + "var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/** @return {Array|number} */"
+                + "function f() {"
+                + " return [];"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Array} y */ function g(y) { return y.a; }")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey9() {
+  public void testMissingProperty32() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource("/** @type {function(!Object<!Object, number>)} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @return {Array|number} */"
+                + "function f() {"
+                + " return [];"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Date} y */ function g(y) { return y.a; }")
+        .addDiagnostic("Property a never defined on Date")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey10() {
+  public void testMissingProperty33() {
+    disableStrictMissingPropertyChecks();
+    newTest().addSource("/** @param {Object} x */" + "function f(x) { !x.foo || x.foo(); }").run();
+  }
+
+  @Test
+  public void testMissingProperty34() {
     newTest()
-        .addSource("/** @type {function(): !Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @fileoverview \n * @suppress {missingProperties} */"
+                + "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.b = 3; };")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey11() {
+  public void testMissingProperty35a() {
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "function X() {}\n"
-                + "/** @constructor @extends {X} */\n"
-                + "function X2() {}\n"
-                + "/** @enum {!X} */\n"
-                + "var XE = {A:new X};\n"
-                + "/** @type {Object<(!XE|!X2), string>} */\n"
-                + "var Y = {};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/** @constructor */ function Foo() {}",
+            "/** @constructor */ function Bar() {}",
+            "/** @constructor */ function Baz() {}",
+            "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }",
+            "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
+        .addDiagnostic("Property specialProp never defined on (Foo|Bar)")
+        .addDiagnostic("Property specialProp never defined on (Bar|Baz)")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags1() {
+  public void testMissingProperty35b() {
+    disableStrictMissingPropertyChecks();
+
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
     newTest()
-        .addSource("/** @type {!Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @constructor */ function Baz() {}"
+                + "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }"
+                + "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags2() {
+  public void testMissingProperty36a() {
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
     newTest()
-        .addSource("/** @param {!Object<!Object, number>} a */ var f = function(a) {};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.baz = 0;",
+            "/** @constructor \n * @extends {Foo} */ function SubFoo() {}",
+            "SubFoo.prototype.bar = 0;",
+            "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
+        .addDiagnostic("Property baz never defined on x")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags3() {
+  public void testMissingProperty36b() {
+    disableStrictMissingPropertyChecks();
+
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
     newTest()
-        .addSource("/** @return {!Object<!Object, number>} */ var f = function() {return {}};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.baz = 0;"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "SubFoo.prototype.bar = 0;"
+                + "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags4() {
+  public void testMissingProperty37a() {
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
     newTest()
-        .addSource("/** @typedef {!Object<!Object, number>} */ var MyType;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @param {{isVisible: boolean}} x */",
+            "function f(x){",
+            "  x.isVisible = false;",
+            "}",
+            "/** @constructor */",
+            "function Foo() {}",
+            "/**",
+            " * @constructor",
+            " * @extends {Foo}",
+            " */",
+            "function SubFoo() {}",
+            "/** @type {boolean} */",
+            "SubFoo.prototype.isVisible = true;",
+            "/**",
+            " * @param {Foo} x",
+            " * @return {boolean}",
+            " */",
+            "function g(x) { return x.isVisible; }")
+        .addDiagnostic("Property isVisible never defined on Foo")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey1() {
-    newTest().addSource("/** @type {!Object<number, number>} */ var k;").run();
+  public void testMissingProperty37b() {
+    disableStrictMissingPropertyChecks();
+
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
+    newTest()
+        .addSource(
+            "/** @param {{isVisible: boolean}} x */ function f(x){"
+                + "  x.isVisible = false;"
+                + "}"
+                + "/** @constructor */ function Foo() {}"
+                + "/**\n"
+                + " * @constructor \n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/** @type {boolean} */ SubFoo.prototype.isVisible = true;"
+                + "/**\n"
+                + " * @param {Foo} x\n"
+                + " * @return {boolean}\n"
+                + " */\n"
+                + "function g(x) { return x.isVisible; }")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey2() {
-    newTest().addSource("/** @type {!Object<string, number>} */ var k;").run();
+  public void testMissingProperty38() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @return {Foo|Bar} */ function f() { return new Foo(); }"
+                + "f().missing;")
+        .addDiagnostic("Property missing never defined on (Foo|Bar)")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey3() {
-    newTest().addSource("/** @type {!Object<boolean, number>} */ var k;").run();
+  public void testMissingProperty39a() {
+    disableStrictMissingPropertyChecks();
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
+        .addSource(
+            "/** @return {string|number} */ function f() { return 3; }", //
+            "f().length;")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey4() {
-    newTest().addSource("/** @type {!Object<null, number>} */ var k;").run();
+  public void testMissingProperty39b() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
+        .addSource(
+            "/** @return {string|number} */ function f() { return 3; }", //
+            "f().length;")
+        .addDiagnostic("Property length not defined on all member types of (String|Number)")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey5() {
-    newTest().addSource("/** @type {!Object<undefined, number>} */ var k;").run();
+  public void testMissingProperty40a() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {MissingType} x */"
+            + "function f(x) { x.impossible(); }",
+        null);
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey6() {
-    newTest().addSource("/** @type {!Object<!Date, number>} */ var k;").run();
+  public void testMissingProperty40b() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {(Array|MissingType)} x */"
+            + "function f(x) { x.impossible(); }",
+        "Property impossible not defined on all member types of x");
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey7() {
-    newTest().addSource("/** @type {!Object<!RegExp, number>} */ var k;").run();
+  public void testMissingProperty41a() {
+    newTest()
+        .addSource(
+            "/** @param {(Array|Date)} x */", //
+            "function f(x) { if (x.impossible) x.impossible(); }")
+        .addDiagnostic("Property impossible never defined on (Array|Date)")
+        .addDiagnostic("Property impossible never defined on (Array|Date)")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey8() {
-    newTest().addSource("/** @type {!Object<!Array, number>} */ var k;").run();
+  public void testMissingProperty41b() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @param {(Array|Date)} x */", //
+            "function f(x) { if (x.impossible) x.impossible(); }")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey9() {
-    newTest().addSource("/** @type {!Object<!Array<number>, number>} */ var k;").run();
+  public void testMissingProperty42() {
+    newTest()
+        .addSource(
+            "/** @param {Object} x */"
+                + "function f(x) { "
+                + "  if (typeof x.impossible == 'undefined') throw Error();"
+                + "  return x.impossible;"
+                + "}")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey10() {
-    newTest().addSource("/** @type {!Object<?, number>} */ var k;").run();
+  public void testMissingProperty43() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource("function f(x) { " + " return /** @type {number} */ (x.impossible) && 1;" + "}")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey11() {
-    newTest().addSource("/** @type {!Object<(string|number), number>} */ var k").run();
+  public void testMissingProperty_notReportedInPropertyAbsenceCheck() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "function f(/** !Object */ x) {", //
+            "  if (x.y == null) throw new Error();",
+            "}")
+        .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testCheckObjectKeysGoodKey12() {
-    newTest().addSource("/** @type {!Object<Object>} */ var k;").run();
+  public void optChainGetPropAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.z;",
+            "}")
+        .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should
+  // emit a warning about missing properties
   @Test
-  public void testCheckObjectKeysGoodKey13() {
+  public void normalGetPropNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */\n"
-                + "var MyInterface = function() {};\n"
-                + "/** @type {!Object<!MyInterface, number>} */\n"
-                + "var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y.z;",
+            "}")
+        .addDiagnostic(
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testCheckObjectKeysGoodKey14() {
+  public void optChainGetElemAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @typedef {{a: number}} */ var MyRecord;\n"
-                + "/** @type {!Object<MyRecord, number>} */ var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.[z];",
+            "}")
         .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should emit
+  // a warning about missing properties
   @Test
-  public void testCheckObjectKeysGoodKey15() {
+  public void normalGetElemNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @enum{number} */\n"
-                + "var Enum = {};\n"
-                + "/** @type {!Object<Enum, number>} */\n"
-                + "var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y[z];",
+            "}")
+        .addDiagnostic(
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testCheckObjectKeysClassWithToString() {
+  public void optChainCallAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var MyClass = function() {};",
-            "/** @override*/",
-            "MyClass.prototype.toString = function() { return ''; };",
-            "/** @type {!Object<!MyClass, number>} */",
-            "var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.();",
+            "}")
         .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should emit
+  // a warning about missing properties
   @Test
-  public void testCheckObjectKeysClassInheritsToString() {
+  public void normalCallNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var Parent = function() {};",
-            "/** @override */",
-            "Parent.prototype.toString = function() { return ''; };",
-            "/** @constructor @extends {Parent} */",
-            "var Child = function() {};",
-            "/** @type {!Object<!Child, number>} */",
-            "var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y();",
+            "}")
+        .addDiagnostic(
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // prop.access?.() is property test and should allow loose property access
+  // but x?.(prop.access) is not
   @Test
-  public void testCheckObjectKeysForEnumUsingClassWithToString() {
+  public void getNotFirstChildOfOptChainCallNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var MyClass = function() {};",
-            "/** @override*/",
-            "MyClass.prototype.toString = function() { return ''; };",
-            "/** @enum{!MyClass} */",
-            "var Enum = {};",
-            "/** @type {!Object<Enum, number>} */",
-            "var k;")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  return false;",
+            "}",
+            "f?.(x.y)")
+        .addDiagnostic("Property y never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // prop.access?.[x] is property test and should allow loose property access
+  // but x?.[prop.access] is not
   @Test
-  public void testBadSuperclassInheritance1() {
+  public void getNotFirstChildOfOptionalGetElemNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
-            "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @type {number} */",
-            "Bar.prototype.myprop = 1;")
-        .addDiagnostic(TypeCheck.HIDDEN_SUPERCLASS_PROPERTY)
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x?.[y.z];",
+            "}")
+        .addDiagnostic("Property z never defined on y" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testBadSuperclassInheritance2() {
+  public void testOptChainGetPropProvidesThisForMethodCall() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
+            "class A {",
+            "  foo() {}",
+            "}",
+            "/** @param {?A} a */",
+            "function f(a) {",
+            // TypeCheck should not complain that foo() is getting called without a correctly typed
+            // `this` value.
+            "  a?.foo();",
+            "}",
             "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @override @type {string} */",
-            "Bar.prototype.myprop = 'qwer';")
-        .addDiagnostic(TypeValidator.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH)
+            "")
         .run();
   }
 
-  // If the property has no initializer, the HIDDEN_SUPERCLASS_PROPERTY_MISMATCH warning is missed.
   @Test
-  public void testBadSuperclassInheritance3() {
+  public void testReflectObject1() {
+    testClosureTypes(
+        "goog.reflect = {}; "
+            + "goog.reflect.object = function(x, y){};"
+            + "/** @constructor */ function A() {}"
+            + "goog.reflect.object(A, {x: 3});",
+        null);
+  }
+
+  @Test
+  public void testReflectObject2() {
+    testClosureTypes(
+        "goog.reflect = {}; "
+            + "goog.reflect.object = function(x, y){};"
+            + "/** @param {string} x */ function f(x) {}"
+            + "/** @constructor */ function A() {}"
+            + "goog.reflect.object(A, {x: f(1 + 1)});",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: string");
+  }
+
+  @Test
+  public void testLends1() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
-            "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @override @type {string} */",
-            "Bar.prototype.myprop;")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends */ ({bar: 1}));")
+        .addDiagnostic(
+            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysWithNamedType() {
+  public void testLends2() {
     newTest()
         .addSource(
-            "/** @type {!Object<!PseudoId, number>} */\n"
-                + "var k;\n"
-                + "/** @typedef {number|string} */\n"
-                + "var PseudoId;")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foob} */ ({bar: 1}));")
+        .addDiagnostic("Variable Foob not declared before @lends annotation.")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeyRecursiveType() {
+  public void testLends3() {
     newTest()
         .addSource(
-            "/** @typedef {!Object<string, !Predicate>} */ var Schema;\n"
-                + "/** @typedef {function(*): boolean|!Schema} */ var Predicate;\n"
-                + "/** @type {!Schema} */ var k;")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, {bar: 1});"
+                + "alert(Foo.bar);")
+        .addDiagnostic("Property bar never defined on Foo")
         .run();
   }
 
   @Test
-  public void testDontOverrideNativeScalarTypes() {
+  public void testLends4() {
     newTest()
-        .addSource("string = 123;\n" + "var /** string */ s = 123;")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));"
+                + "alert(Foo.bar);")
         .run();
+  }
 
+  @Test
+  public void testLends5() {
     newTest()
-        .addSource("var string = goog.require('goog.string');\n" + "var /** string */ s = 123;")
-        .addDiagnostic(
-            "Property require never defined on goog" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, {bar: 1});"
+                + "alert((new Foo()).bar);")
+        .addDiagnostic("Property bar never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplateMap1() {
+  public void testLends6() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  /** @type {Int8Array} */\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IArrayLike<string>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n" + "found   : (Int8Array|null)\n" + "required: (IArrayLike<string>|null)")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));"
+                + "alert((new Foo()).bar);")
         .run();
   }
 
   @Test
-  public void testTemplateMap2() {
+  public void testLends7() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  /** @type {Int8Array} */\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IObject<number, string>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n"
-                + "found   : (Int8Array|null)\n"
-                + "required: (IObject<number,string>|null)")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));")
+        .addDiagnostic("Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testTemplateMap3() {
+  public void testLends8() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IArrayLike<string>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n" + "found   : Int8Array\n" + "required: (IArrayLike<string>|null)")
+            "function extend(x, y) {}"
+                + "/** @type {number} */ var Foo = 3;"
+                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));")
+        .addDiagnostic("May only lend properties to object types. Foo has type number.")
         .run();
   }
 
   @Test
-  public void testTemplateMap4() {
+  public void testLends9() {
+    testClosureTypesMultipleWarnings(
+        "function extend(x, y) {}"
+            + "/** @constructor */ function Foo() {}"
+            + "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
+        ImmutableList.of(
+            "Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK,
+            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK));
+  }
+
+  @Test
+  public void testLends10() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IObject<number, string>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n" + "found   : Int8Array\n" + "required: (IObject<number,string>|null)")
+            "function defineClass(x) { return function() {}; } "
+                + "/** @constructor */"
+                + "var Foo = defineClass("
+                + "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));"
+                + "/** @return {string} */ function f() { return (new Foo()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplateMap5() {
+  public void testLends11() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IArrayLike<number>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
-        .includeDefaultExterns()
+            "function defineClass(x, y) { return function() {}; } "
+                + "/** @constructor */"
+                + "var Foo = function() {};"
+                + "/** @return {*} */ Foo.prototype.bar = function() { return 3; };"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "var SubFoo = defineClass(Foo, "
+                + "    /** @lends {SubFoo.prototype} */ ({\n"
+                + "      /** @override @return {number} */ bar: function() { return 3; }}));"
+                + "/** @return {string} */ function f() { return (new SubFoo()).bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplateMap6() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IObject<number, number>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .includeDefaultExterns()
-        .run();
+  public void testDeclaredNativeTypeEquality() {
+    Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType());
   }
 
-  private static final String EXTERNS_WITH_IARRAYLIKE_DECLS =
-      "/**\n"
-          + " * @constructor @implements IArrayLike<number>\n"
-          + " */\n"
-          + "function Int8Array(length, opt_byteOffset, opt_length) {}\n"
-          + "/** @type {number} */\n"
-          + "Int8Array.prototype.length;\n"
-          + "/**\n"
-          + "* @constructor\n"
-          + "* @extends {Int8Array}\n"
-          + "*/\n"
-          + "function Int8Array2(len) {};\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<number>}\n"
-          + " */\n"
-          + "function IArrayLike2(){}\n"
-          + "\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike2}\n"
-          + " */\n"
-          + "function Int8Array3(len) {};\n"
-          + "/** @type {number} */\n"
-          + "Int8Array3.prototype.length;\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<VALUE3>}\n"
-          + " * @template VALUE3\n"
-          + " */\n"
-          + "function IArrayLike3(){}\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike3<number>}\n"
-          + " */\n"
-          + "function Int8Array4(length) {};\n"
-          + "/** @type {number} */\n"
-          + "Int8Array4.prototype.length;\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<VALUE2>}\n"
-          + " * @template VALUE2\n"
-          + " */\n"
-          + "function IArrayLike4(){}\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike4<boolean>}\n"
-          + " */\n"
-          + "function IArrayLike5(){}\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike5}\n"
-          + " */\n"
-          + "function BooleanArray5(length) {};\n"
-          + "/** @type {number} */\n"
-          + "BooleanArray5.prototype.length;";
+  @Test
+  public void testUndefinedVar() {
+    Node n = parseAndTypeCheck("var undefined;");
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstFirstChild().getJSType());
+  }
 
   @Test
-  public void testArrayImplementsIArrayLike() {
-    newTest()
-        .addSource(
-            "/** @type {!Array<number>} */ var arr = [];\n" + "var /** null */ n = arr[0];\n")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: null")
-        .run();
+  public void testFlowScopeBug1() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @param {number} a \n"
+                + "* @param {number} b */\n"
+                + "function f(a, b) {\n"
+                + "/** @type {number} */"
+                + "var i = 0;"
+                + "for (; (i + a) < b; ++i) {}}");
+
+    // check the type of the add node for i + f
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.NUMBER_TYPE),
+        n.getFirstChild()
+            .getLastChild()
+            .getLastChild()
+            .getFirstChild()
+            .getNext()
+            .getFirstChild()
+            .getJSType());
   }
 
   @Test
-  public void testIArrayLike1() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource(
-            "var arr = new Int8Array(7);\n" + "// no warning\n" + "arr[0] = 1;\n" + "arr[1] = 2;\n")
-        .includeDefaultExterns()
-        .run();
+  public void testFlowScopeBug2() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {};\n"
+                + "Foo.prototype.hi = false;"
+                + "function foo(a, b) {\n"
+                + "  /** @type {Array} */"
+                + "  var arr;"
+                + "  /** @type {number} */"
+                + "  var iter;"
+                + "  for (iter = 0; iter < arr.length; ++ iter) {"
+                + "    /** @type {Foo} */"
+                + "    var afoo = arr[iter];"
+                + "    afoo;"
+                + "  }"
+                + "}");
+
+    // check the type of afoo when referenced
+    assertTypeEquals(
+        registry.createNullableType(registry.getGlobalType("Foo")),
+        n.getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getJSType());
   }
 
   @Test
-  public void testIArrayLike2() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array(7);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testAddSingletonGetter() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);");
+    ObjectType o = (ObjectType) n.getFirstChild().getJSType();
+    assertThat(o.getPropertyType("getInstance").toString()).isEqualTo("function(): Foo");
+    assertThat(o.getPropertyType("instance_").toString()).isEqualTo("Foo");
   }
 
   @Test
-  public void testIArrayLike3() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
-        .run();
+  public void testTypeCheckStandaloneAST() {
+    Node externs = IR.root();
+    Node firstScript = compiler.parseTestCode("function Foo() { }");
+    typeCheck(firstScript);
+    Node root = IR.root(externs, IR.root(firstScript.detach()));
+    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
+    TypedScope topScope = scopeCreator.createScope(root, null);
+
+    Node secondScript = compiler.parseTestCode("new Foo");
+
+    firstScript.replaceWith(secondScript);
+
+    new TypeCheck(
+            compiler,
+            new SemanticReverseAbstractInterpreter(registry),
+            registry,
+            topScope,
+            scopeCreator)
+        .process(externs, secondScript.getParent());
+
+    assertThat(compiler.getWarningCount()).isEqualTo(1);
+    assertThat(compiler.getWarnings().get(0).getDescription())
+        .isEqualTo("cannot instantiate non-constructor");
   }
 
   @Test
-  public void testIArrayLike4() {
+  public void testUpdateParameterTypeOnClosure() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addExterns(
+            "/**\n"
+                + "* @constructor\n"
+                + "* @param {*=} opt_value\n"
+                + "* @return {!Object}\n"
+                + "*/\n"
+                + "function Object(opt_value) {}\n"
+                + "/**\n"
+                + "* @constructor\n"
+                + "* @param {...*} var_args\n"
+                + "*/\n"
+                + "function Function(var_args) {}\n"
+                + "/**\n"
+                + "* @type {Function}\n"
+                + "*/\n"
+                +
+                // The line below sets JSDocInfo on Object so that the type of the
+                // argument to function f has JSDoc through its prototype chain.
+                "Object.prototype.constructor = function() {};\n")
+        .addSource(
+            "/**\n"
+                + "* @param {function(): boolean} fn\n"
+                + "*/\n"
+                + "function f(fn) {}\n"
+                + "f(function() { });\n")
         .run();
   }
 
   @Test
-  public void testIArrayLike5() {
+  public void testTemplatedThisType1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array3(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource(
+            "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "/**\n"
+                + " * @this {T}\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "Foo.prototype.method = function() {};\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "var g = new Bar().method();\n"
+                + "/**\n"
+                + " * @param {number} a\n"
+                + " */\n"
+                + "function compute(a) {};\n"
+                + "compute(g);\n")
+        .addDiagnostic(
+            "actual parameter 1 of compute does not match formal parameter\n"
+                + "found   : Bar\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIArrayLike6() {
+  public void testTemplatedThisType2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array4(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource(
+            "/**\n"
+                + " * @this {Array<T>|{length:number}}\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "Array.prototype.method = function() {};\n"
+                + "(function(){\n"
+                + "  Array.prototype.method.call(arguments);"
+                + "})();")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testIArrayLike7() {
+  public void testTemplateType1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr5 = new BooleanArray5(10);\n" + "arr5[2] = true;\n" + "arr5[3] = \"\";")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: boolean")
+        .addSource(
+            "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {T} y\n"
+                + "* @param {function(this:T, ...)} z\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y, z) {}\n"
+                + "f(this, this, function() { this });")
         .run();
   }
 
   @Test
-  public void testIArrayLike8() {
+  public void testTemplateType2() {
+    // "this" types need to be coerced for ES3 style function or left
+    // allow for ES5-strict methods.
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(0, function() {});")
         .run();
   }
 
   @Test
-  public void testIArrayLike9() {
+  public void testTemplateType3() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array2(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/**"
+                + " * @param {T} v\n"
+                + " * @param {function(T)} f\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function call(v, f) { f.call(null, v); }"
+                + "/** @type {string} */ var s;"
+                + "call(3, function(x) {"
+                + " x = true;"
+                + " s = x;"
+                + "});")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testIArrayLike10() {
+  public void testTemplateType4() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array3(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/**"
+                + " * @param {...T} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(3, null);")
+        .addDiagnostic("assignment\n" + "found   : (null|number)\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testIArrayLike11() {
+  public void testTemplateType5() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array4(10);", //
-            "arr2[true] = 1;")
+            "const CGI_PARAM_RETRY_COUNT = 'rc';",
+            "",
+            "/**",
+            " * @param {...T} p",
+            " * @return {T} ",
+            " * @template T",
+            " */",
+            "function fn(p) { return p; }",
+            "/** @type {!Object} */ var x;",
+            "",
+            "/** @return {void} */",
+            "function aScope() {",
+            "  x = fn(CGI_PARAM_RETRY_COUNT, 1);",
+            "}")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+                "assignment", //
+                "found   : (number|string)",
+                "required: Object"))
         .run();
   }
 
   @Test
-  public void testIArrayLike12() {
+  public void testTemplateType6() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new BooleanArray5(10);", //
-            "arr2['prop'] = true;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : string",
-                "required: number"))
+            "/**"
+                + " * @param {Array<T>} arr \n"
+                + " * @param {?function(T)} f \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(arr, f) { return arr[0]; }\n"
+                + "/** @param {Array<number>} arr */ function g(arr) {"
+                + "  /** @type {!Object} */ var x = fn.call(null, arr, null);"
+                + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testIArrayLike13() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+  public void testTemplateType7() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "var numOrStr = null ? 0 : 'prop';",
-            "var arr2 = new BooleanArray5(10);",
-            "arr2[numOrStr] = true;")
+            "/** @type {!Array<string>} */", //
+            "var query = [];",
+            "query.push(1);")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : (number|string)",
-                "required: number"))
+                "actual parameter 1 of Array.prototype.push does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testIterableCovariant() {
+  public void testTemplateType8() {
     newTest()
         .addSource(
-            "function f(/** !Iterable<(number|string)>*/ x){};",
-            "function g(/** !Iterable<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @constructor \n"
+                + " * @template S,T\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "/**"
+                + " * @param {Bar<T>} bar \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(bar) {}\n"
+                + "/** @param {Bar<number>} bar */ function g(bar) {"
+                + "  /** @type {!Object} */ var x = fn(bar);"
+                + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testLocalShadowOfIterableNotCovariant() {
+  public void testTemplateType9() {
+    // verify interface type parameters are recognized.
     newTest()
         .addSource(
-            "/** @template T */",
-            "class Iterable {}",
-            "function f(/** !Iterable<(number|string)>*/ x) {};",
-            "function g(/** !Iterable<number> */ arr) {",
-            "    f(arr);",
-            "}",
-            "export {};")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Iterable<number>",
-                "required: Iterable<(number|string)>"))
-        .includeDefaultExterns()
+            "/** @interface \n"
+                + " * @template S,T\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "/**"
+                + " * @param {Bar<T>} bar \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(bar) {}\n"
+                + "/** @param {Bar<number>} bar */ function g(bar) {"
+                + "  /** @type {!Object} */ var x = fn(bar);"
+                + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testIterableNotContravariant() {
+  public void testTemplateType10() {
+    // verify a type parameterized with unknown can be assigned to
+    // the same type with any other type parameter.
     newTest()
         .addSource(
-            "function f(/** !Iterable<number>*/ x){};",
-            "function g(/** !Iterable<(number|string)> */ arr) {",
-            "    f(arr);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Iterable<(number|string)>",
-                "required: Iterable<number>"))
-        .includeDefaultExterns()
+            "/** @constructor \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "\n"
+                + ""
+                + "/** @type {!Bar<?>} */ var x;"
+                + "/** @type {!Bar<number>} */ var y;"
+                + "y = x;")
         .run();
   }
 
   @Test
-  public void testIterableCovariantWhenComparingToSubtype() {
+  public void testTemplateType11() {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
     newTest()
-        .addExterns(
-            "/** @constructor",
-            " * @implements {Iterable<T>}",
-            " * @template T",
-            " */",
-            "function Set() {}")
         .addSource(
-            "function f(/** !Iterable<(number|string)>*/ x){};",
-            "function g(/** !Set<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @constructor \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @extends {Foo<string>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @extends {Foo<number>}\n"
+                + " */\n"
+                + "function B() {}\n"
+                + ""
+                + "/** @type {!Foo<string>} */ var a = new A();\n"
+                + "/** @type {!Foo<string>} */ var b = new B();")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testIteratorCovariant() {
+  public void testTemplateType12() {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
     newTest()
         .addSource(
-            "function f(/** !Iterator<(string|number)>*/ x){};",
-            "function g(/** !Iterator<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {Foo<string>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {Foo<number>}\n"
+                + " */\n"
+                + "function B() {}\n"
+                + ""
+                + "/** @type {!Foo<string>} */ var a = new A();\n"
+                + "/** @type {!Foo<string>} */ var b = new B();")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testGeneratorCovariant() {
+  public void testTemplateType13() {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
     newTest()
         .addSource(
-            "function f(/** !Generator<(string|number)>*/ x){};",
-            "function g(/** !Generator<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @constructor \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @template T\n"
+                + " * @extends {Foo<T>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "var a1 = new A();\n"
+                + "var a2 = /** @type {!A<string>} */ (new A());\n"
+                + "var a3 = /** @type {!A<number>} */ (new A());\n"
+                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
+                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
+                + "/** @type {!Foo<string>} */ var f3 = a3;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testIterableImplementorInvariant() {
+  public void testTemplateType14() {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
     newTest()
-        .addExterns(
-            "/** @constructor",
-            " * @implements {Iterable<T>}",
-            " * @template T",
-            " */",
-            "function Set() {}")
         .addSource(
-            "function f(/** !Set<(string|number)>*/ x){};",
-            "function g(/** !Set<number> */ arr) {",
-            "    f(arr);",
-            "}")
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @template T\n"
+                + " * @implements {Foo<T>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "var a1 = new A();\n"
+                + "var a2 = /** @type {!A<string>} */ (new A());\n"
+                + "var a3 = /** @type {!A<number>} */ (new A());\n"
+                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
+                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
+                + "/** @type {!Foo<string>} */ var f3 = a3;")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Set<number>",
-                "required: Set<(number|string)>"))
+            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testIArrayLikeCovariant1() {
+  public void testTemplateType15() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<(string|number)>*/ x){};",
-            "function g(/** !IArrayLike<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/**"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn({foo:3});")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testIArrayLikeCovariant2() {
+  public void testTemplateType16() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<(string|number)>*/ x){};",
-            "function g(/** !Array<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {\n"
+                + "  /** @type {number} */ this.foo = 1\n"
+                + "}\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(new C());")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testIArrayLikeBivaraint() {
+  public void testTemplateType17() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<number>*/ x){};",
-            "function g(/** !IArrayLike<(string|number)> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "C.prototype.foo = 1;\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(new C());")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch1() {
+  public void testTemplateType18() {
+    // Until template types can be restricted to exclude undefined, they
+    // are always optional.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */ Foo.prototype.length",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "C.prototype.foo = 1;\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn({});")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch2() {
+  public void testTemplateType19() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.length = 5;",
-            "}",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @param {T} t\n"
+                + " * @param {U} u\n"
+                + " * @return {{t:T, u:U}} \n"
+                + " * @template T,U\n"
+                + " */\n"
+                + "function fn(t, u) { return {t:t, u:u}; }\n"
+                + "/** @type {null} */ var x = fn(1, 'str');")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : {\n  t: number,\n  u: string\n}\n"
+                + "required: null")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch3() {
+  public void testTemplateType20() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};", //
-            "f({length: 5})")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {\n"
+                + "  /** @type {void} */ this.x;\n"
+                + "}\n"
+                + "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(new C, /** @param {number} a */ function(a) {this.x = a;});")
+        .addDiagnostic(
+            "assignment to property x of C\n" + "found   : number\n" + "required: undefined")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch4() {
+  public void testTemplateType21() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @const */ var ns = {};",
-            "/** @type {number} */ ns.length",
-            "f(ns)")
-        .includeDefaultExterns()
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor @implements {A<Bar>} */\n"
+                + "function Bar() {}\n"
+                + "/** @type {!Foo} */\n"
+                + "var x = new Bar();\n")
+        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Foo")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch5() {
+  public void testTemplateType22() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "var ns = function() {};",
-            "/** @type {number} */ ns.length",
-            "f(ns)")
-        .includeDefaultExterns()
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @interface @template T */ function B() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor @implements {B<Foo>} */\n"
+                + "function Bar() {}\n"
+                + "/** @constructor @implements {B<Foo>} */\n"
+                + "function Qux() {}\n"
+                + "/** @type {!Qux} */\n"
+                + "var x = new Bar();\n")
+        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Qux")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch6() {
-    // Even though Foo's [] element type may not be string, we treat the lack
-    // of explicit type like ? and allow this.
+  public void testTemplateType23() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<string> */ x){};",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */ Foo.prototype.length",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @type {!Foo} */\n"
+                + "var x = new Foo();\n")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch1() {
+  public void testTemplateType24() {
+    // Recursive templated type definition.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop;",
-            "function f(/** !WithPropT<number> */ x){}",
-            "/** @constructor */ function Foo() {}",
-            "/** @type {number} */ Foo.prototype.prop;",
-            "f(new Foo);")
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " * @param {T} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {T} */",
+            "  this.p = x;",
+            "}",
+            "/** @return {Foo<Foo<T>>} */",
+            "Foo.prototype.m = function() {",
+            "  return null;",
+            "};",
+            "/** @return {T} */",
+            "Foo.prototype.get = function() {",
+            "  return this.p;",
+            "};",
+            "var /** null */ n = new Foo(new Object).m().get();")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (Foo<Object>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch2() {
+  public void testTemplateType25() {
+    // Non-nullable recursive templated type definition.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {number} */ Foo.prototype.prop",
-            "f(new Foo)")
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " * @param {T} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {T} */",
+            "  this.p = x;",
+            "}",
+            "/** @return {!Foo<!Foo<T>>} */",
+            "Foo.prototype.m = function() {",
+            "  return new Foo(new Foo(new Object));",
+            "};",
+            "/** @return {T} */",
+            "Foo.prototype.get = function() {",
+            "  return this.p;",
+            "};",
+            "var /** null */ n = new Foo(new Object).m().get();")
+        .addDiagnostic("initializing variable\n" + "found   : Foo<Object>\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch3() {
+  public void testTemplateType26() {
+    // Class hierarchies which use the same template parameter name should not be treated as
+    // infinite recursion.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<string> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {U} */ Foo.prototype.prop",
-            "f(new Foo)")
+            "/**",
+            " * @param {T} bar",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "function Bar(bar) {",
+            "  /** @type {T} */",
+            "  this.bar = bar;",
+            "}",
+            "/** @return {T} */",
+            "Bar.prototype.getBar = function() {",
+            "  return this.bar;",
+            "};",
+            "/**",
+            " * @param {T} foo",
+            " * @constructor",
+            " * @template T",
+            " * @extends {Bar<!Array<T>>}",
+            " */",
+            "function Foo(foo) {",
+            "  /** @type {T} */",
+            "  this.foo = foo;",
+            "}",
+            "var /** null */ n = new Foo(new Object).getBar();")
+        .addDiagnostic("initializing variable\n" + "found   : Array<Object>\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch1() {
+  public void testTemplateTypeCollidesWithParameter() {
+    // Function templates are in the same scope as parameters, so cannot collide.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor */ function Foo() {}",
-            "/** @type {string} */ Foo.prototype.prop = 'str'",
-            "f(new Foo)")
+            "/**", //
+            " * @param {T} T",
+            " * @template T",
+            " */",
+            "function f(T) {}")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+            "variable T redefined with type undefined, original definition at [testcode]:5 with"
+                + " type T")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch2() {
+  public void testTemplateTypeForwardReference() {
+    // TODO(martinprobst): the test below asserts incorrect behavior for backwards compatibility.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {string} */ Foo.prototype.prop = 'str'",
-            "f(new Foo)")
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @constructor",
+            " */",
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
         .addDiagnostic(
             lines(
                 "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<?>",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch3() {
+  public void testTemplateTypeForwardReference_declared() {
+    compiler.forwardDeclareType("Foo");
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
             "/**",
+            " * @template T",
             " * @constructor",
-            " * @template U",
-            " * @param {U} x",
             " */",
-            "function Foo(x) {",
-            "  /** @type {U} */ this.prop = x",
-            "}",
-            "f(new Foo('str'))")
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
         .addDiagnostic(
             lines(
                 "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<string>",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch4() {
+  public void testTemplateTypeForwardReferenceFunctionWithExtra() {
+    // TODO(johnlenz): report an error when forward references contain extraneous
+    // type arguments.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithProp() {}",
-            "/** @type {T} */ WithProp.prototype.prop;",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.prop = 4;",
-            "}",
+            "/** @param {!Foo<string, boolean>} x */",
+            "function f(x) {}",
+            "",
             "/**",
-            " * @template U",
-            " * @param {!WithProp<U>} x",
-            " * @param {U} y",
+            " * @constructor",
+            " * @template T",
             " */",
-            "function f(x, y){};",
-            "f(new Foo, 'str')")
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
         .addDiagnostic(
             lines(
                 "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo",
-                "required: WithProp<string>",
-                "missing : []",
-                "mismatch: [prop]"))
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatchNotFound() {
-    // TODO(blickly): We would like to find the parameter mismatch here.
-    // Currently they match with type WithProp<?>, which is somewhat unsatisfying.
+  public void testTemplateTypeForwardReferenceVar() {
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithProp() {}",
-            "/** @type {T} */ WithProp.prototype.prop;",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.prop = 4;",
-            "}",
-            "/** @constructor */",
-            "function Bar() {",
-            "  /** @type {string} */ this.prop = 'str';",
-            "}",
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
             "/**",
-            " * @template U",
-            " * @param {!WithProp<U>} x",
-            " * @param {!WithProp<U>} y",
+            " * @template T",
+            " * @constructor",
             " */",
-            "function f(x, y){};",
-            "f(new Foo, new Bar)")
-        .run();
-  }
-
-  private static final String EXTERNS_WITH_IOBJECT_DECLS =
-      lines(
-          "/**",
-          " * @constructor",
-          " * @implements IObject<(string|number), number>",
-          " */",
-          "function Object2() {}",
-          "/**",
-          " * @constructor @struct",
-          " * @implements IObject<number, number>",
-          " */",
-          "function Object3() {}");
-
-  @Test
-  public void testIObject1() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[0] = 1;")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testIObject2() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "var arr2 = new Object2();", //
-            "arr2['str'] = 1;")
-        .includeDefaultExterns()
+            "var Foo = function() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testIObject3() {
+  public void testTemplateTypeForwardReference_declaredMissing() {
+    compiler.forwardDeclareType("Foo");
+    compiler.forwardDeclareType("DoesNotExist");
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: (number|string)"))
+            "/** @param {!Foo<DoesNotExist>} x */", //
+            "function f(x) {}")
         .run();
   }
 
   @Test
-  public void testIObject4() {
+  public void testTemplateTypeForwardReference_extends() {
+    compiler.forwardDeclareType("Bar");
+    compiler.forwardDeclareType("Baz");
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[function(){}] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type",
-                "found   : function(): undefined",
-                "required: (number|string)"))
+            "/** @constructor @extends {Bar<Baz>} */",
+            "function Foo() {}",
+            "/** @constructor */",
+            "function Bar() {}")
         .run();
   }
 
   @Test
-  public void testIObject5() {
+  public void testSubtypeNotTemplated1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[{}] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : {}",
-                "required: (number|string)"))
+            "/** @interface @template T */ function A() {}",
+            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
+            "function f(/** (!Object|!Foo<string>) */ x) {",
+            "  var /** null */ n = x;",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testIObject6() {
+  public void testSubtypeNotTemplated2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[undefined] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : undefined",
-                "required: (number|string)"))
+            "/** @interface @template T */ function A() {}",
+            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
+            "function f(/** (!Object|!Foo) */ x) {",
+            "  var /** null */ n = x;",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testIObject7() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[null] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : null",
-                "required: (number|string)"))
-        .run();
+  public void testTemplateTypeWithUnresolvedType() {
+    testClosureTypes(
+        "goog.forwardDeclare('Color');\n"
+            + "/** @interface @template T */ function C() {}\n"
+            + "/** @return {!Color} */ C.prototype.method;\n"
+            + "/** @constructor @implements {C} */ function D() {}\n"
+            + "/** @override */ D.prototype.method = function() {};",
+        null); // no warning expected.
   }
 
   @Test
-  public void testIObject8() {
+  public void testTemplateTypeWithTypeDef1a() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object2();", //
-            "/** @type {boolean} */",
-            "var x = arr[3];")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + ""
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "/** @type {Generic<!Bar>} */ var y;\n"
+                + ""
+                + "x = y;\n"
+                + // no warning
+                "/** @type {null} */ var z1 = y;\n")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: boolean"))
+            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testIObject9() {
+  public void testTemplateTypeWithTypeDef1b() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object2();", //
-            "/** @type {(number|string)} */",
-            "var x = arr[3];")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + ""
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "/** @type {Generic<!Bar>} */ var y;\n"
+                + ""
+                + "y = x;\n"
+                + // no warning.
+                "/** @type {null} */ var z1 = x;\n")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testIObject10() {
+  public void testTemplateTypeWithTypeDef2a() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {number} */",
-            "var x = arr[3];")
-        .includeDefaultExterns()
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Bar> */ x) {}\n"
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testIObject11() {
+  public void testTemplateTypeWithTypeDef2b() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {boolean} */",
-            "var x = arr[3];")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: boolean"))
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Bar> */ x) {}\n"
+                + "/** @type {Generic<!Bar>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testIObject12() {
+  public void testTemplateTypeWithTypeDef2c() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {string} */",
-            "var x = arr[3];")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: string"))
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Foo> */ x) {}\n"
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testIObject13() {
+  public void testTemplateTypeWithTypeDef2d() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "arr[3] = false;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : boolean",
-                "required: number"))
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Foo> */ x) {}\n"
+                + "/** @type {Generic<!Bar>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testIObject14() {
+  public void testTemplatedFunctionInUnion1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "arr[3] = 'value';")
+            "/**",
+            "* @param {T} x",
+            "* @param {function(this:T, ...)|{fn:Function}} z",
+            "* @template T",
+            "*/",
+            "function f(x, z) {}",
+            "f([], function() { /** @type {string} */ var x = this });")
         .addDiagnostic(
             lines(
-                "assignment", //
-                "found   : string",
-                "required: number"))
+                "initializing variable", //
+                "found   : Array<?>",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testIObject15() {
+  public void testTemplateTypeRecursion1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "function f(/** !Object<string, string> */ x) {}",
-            "var /** !IObject<string, string> */ y;",
-            "f(y);")
-        .includeDefaultExterns()
+            "/** @typedef {{a: D2}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
   }
 
   @Test
-  public void testIObject16() {
+  public void testTemplateTypeRecursion2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "function f(/** !Object<string, string> */ x) {}",
-            "var /** !IObject<string, number> */ y;",
-            "f(y);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : IObject<string,number>",
-                "required: Object<string,string>"))
+            "/** @typedef {{a: D2}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "/** @type {D1} */ var x;"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
   }
 
-  /**
-   * although C1 does not declare to extend Interface1, obj2 : C1 still structurally matches obj1 :
-   * Interface1 because of the structural interface matching (Interface1 is declared with @record
-   * tag)
-   */
   @Test
-  public void testStructuralInterfaceMatching1() {
+  public void testTemplateTypeRecursion3() {
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function Interface1() {}",
-            "/** @type {number} */",
-            "Interface1.prototype.length;",
-            "",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @type {number} */",
-            "C1.prototype.length;")
         .addSource(
-            "/** @type{Interface1} */",
-            "var obj1;",
-            "/** @type{C1} */",
-            "var obj2 = new C1();",
-            "obj1 = obj2;")
-        .includeDefaultExterns()
+            "/** @typedef {{a: function(D2)}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "/** @type {D1} */ var x;"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching2() {
+  @Ignore
+  public void testFunctionLiteralUndefinedThisArgument() {
+    // TODO(johnlenz): this was a weird error.  We should add a general
+    // restriction on what is accepted for T. Something like:
+    // "@template T of {Object|string}" or some such.
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function Interface1() {}",
-            "/** @type {number} */",
-            "Interface1.prototype.length;",
-            "",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @type {number} */",
-            "C1.prototype.length;")
         .addSource(
-            "/** @type{Interface1} */", //
-            "var obj1;",
-            "var obj2 = new C1();",
-            "obj1 = obj2;")
-        .includeDefaultExterns()
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() { this; });")
+        .addDiagnostic("Function literal argument refers to undefined this argument")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching3() {
+  public void testFunctionLiteralDefinedThisArgument() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I1() {}",
-            "",
-            "/** @record */",
-            "function I2() {}")
-        .addSource(
-            "/** @type {I1} */", //
-            "var i1;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i1 = i2;",
-            "i2 = i1;")
-        .includeDefaultExterns()
+        .addSource(
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() { this; }, {});")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching4_1() {
+  public void testFunctionLiteralDefinedThisArgument2() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I1() {}",
-            "",
-            "/** @record */",
-            "function I2() {}")
-        .addSource(
-            "/** @type {I1} */", //
-            "var i1;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i2 = i1;",
-            "i1 = i2;")
-        .includeDefaultExterns()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/** @param {string} x */ function f(x) {}",
+            "/**",
+            " * @param {?function(this:T, ...)} fn",
+            " * @param {T=} opt_obj",
+            " * @template T",
+            " */",
+            "function baz(fn, opt_obj) {}",
+            "function g() { baz(function() { f(this.length); }, []); }")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching5_1() {
+  public void testFunctionLiteralUnreadNullThisArgument() {
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function I1() {}",
-            "",
-            "/** @interface */",
-            "function I3() {}",
-            "/** @type {number} */",
-            "I3.prototype.length;")
         .addSource(
-            "/** @type {I1} */", //
-            "var i1;",
-            "/** @type {I3} */",
-            "var i3;",
-            "i1 = i3;")
-        .includeDefaultExterns()
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() {}, null);")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching7_1() {
+  public void testUnionTemplateThisType() {
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function I1() {}",
-            "",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @type {number} */",
-            "C1.prototype.length;")
         .addSource(
-            "/** @type {I1} */",
-            "var i1;" + "/** @type {C1} */",
-            "var c1;",
-            "i1 = c1;   // no warning")
-        .includeDefaultExterns()
+            "/** @constructor */ function F() {}"
+                + "/** @return {F|Array} */ function g() { return []; }"
+                + "/** @param {F} x */ function h(x) { }"
+                + "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(g(), function() { h(this); });")
+        .addDiagnostic(
+            "actual parameter 1 of h does not match formal parameter\n"
+                + "found   : (Array|F|null)\n"
+                + "required: (F|null)")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching9() {
+  public void testRecordType1() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @type {number} */",
-            "C1.prototype.length;",
-            "",
-            "/** @constructor */",
-            "function C2() {}",
-            "/** @type {number} */",
-            "C2.prototype.length;")
         .addSource(
-            "/** @type {C1} */", //
-            "var c1;" + "/** @type {C2} */",
-            "var c2;",
-            "c1 = c2;")
+            "/** @param {{prop: number}} x */", //
+            "function f(x) {}",
+            "f({});")
         .addDiagnostic(
             lines(
-                "assignment", //
-                "found   : (C2|null)",
-                "required: (C1|null)"))
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|undefined)}",
+                "required: {prop: number}",
+                "missing : []",
+                "mismatch: [prop]"))
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching11_1() {
+  public void testRecordType2() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I3() {}",
-            "/** @type {number} */",
-            "I3.prototype.length;",
-            "",
-            "/** ",
-            " * @record",
-            " * @extends I3",
-            " */",
-            "function I4() {}",
-            "/** @type {boolean} */",
-            "I4.prototype.prop;",
-            "",
-            "/** @constructor */",
-            "function C4() {}",
-            "/** @type {number} */",
-            "C4.prototype.length;",
-            "/** @type {boolean} */",
-            "C4.prototype.prop;")
-        .addSource(
-            "/** @type {I4} */", //
-            "var i4;" + "/** @type {C4} */",
-            "var c4;",
-            "i4 = c4;")
-        .includeDefaultExterns()
+        .addSource("/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "f({});")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching13() {
+  public void testRecordType3() {
     newTest()
-        .addExterns(
-            "/**",
-            "   * @record",
-            "   */",
-            "  function I5() {}",
-            "  /** @type {I5} */",
-            "  I5.prototype.next;",
-            "",
-            "  /**",
-            "   * @interface",
-            "   */",
-            "  function C5() {}",
-            "  /** @type {C5} */",
-            "  C5.prototype.next;")
-        .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @param {{prop: number}} x */", //
+            "function f(x) {}",
+            "f({prop: 'x'});")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|string)}",
+                "required: {prop: number}",
+                "missing : []",
+                "mismatch: [prop]"))
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching13_2() {
-    newTest()
-        .addExterns(
-            "/**",
-            "   * @record",
-            "   */",
-            "  function I5() {}",
-            "  /** @type {I5} */",
-            "  I5.prototype.next;",
-            "",
-            "  /**",
-            "   * @record",
-            "   */",
-            "  function C5() {}",
-            "  /** @type {C5} */",
-            "  C5.prototype.next;")
-        .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .includeDefaultExterns()
-        .run();
+  public void testRecordType4() {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */"
+            + "function f(x) {}"
+            + "/** @param {{prop: (string|undefined)}} x */"
+            + "function g(x) {}"
+            + "var x = {}; f(x); g(x);",
+        ImmutableList.of(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|string|undefined)}",
+                "required: {prop: (number|undefined)}",
+                "missing : []",
+                "mismatch: [prop]"),
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : {prop: (number|string|undefined)}",
+                "required: {prop: (string|undefined)}",
+                "missing : []",
+                "mismatch: [prop]")));
   }
 
   @Test
-  public void testStructuralInterfaceMatching13_3() {
+  public void testRecordType5() {
     newTest()
-        .addExterns(
-            "/**",
-            "   * @interface",
-            "   */",
-            "  function I5() {}",
-            "  /** @type {I5} */",
-            "  I5.prototype.next;",
-            "",
-            "  /**",
-            "   * @record",
-            "   */",
-            "  function C5() {}",
-            "  /** @type {C5} */",
-            "  C5.prototype.next;")
         .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C5|null)",
-                "required: (I5|null)"))
+            "/** @param {{prop: (number|undefined)}} x */"
+                + "function f(x) {}"
+                + "/** @param {{otherProp: (string|undefined)}} x */"
+                + "function g(x) {}"
+                + "var x = {}; f(x); g(x);")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching15() {
+  public void testRecordType6() {
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function I5() {}",
-            "/** @type {I5} */",
-            "I5.prototype.next;",
-            "",
-            "/** @constructor */",
-            "function C6() {}",
-            "/** @type {C6} */",
-            "C6.prototype.next;",
-            "",
-            "/** @constructor */",
-            "function C5() {}",
-            "/** @type {C6} */",
-            "C5.prototype.next;")
-        .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .includeDefaultExterns()
+        .addSource("/** @return {{prop: (number|undefined)}} x */" + "function f() { return {}; }")
         .run();
   }
 
-  /**
-   * a very long structural chain, all property types from I5 and C5 are structurally the same, I5
-   * is declared as @record so structural interface matching will be performed
-   */
-  private static final String EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD =
-      lines(
-          "/** @record */",
-          "function I5() {}",
-          "/** @type {I5} */",
-          "I5.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6() {}",
-          "/** @type {C6} */",
-          "C6.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_1() {}",
-          "/** @type {C6} */",
-          "C6_1.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_2() {}",
-          "/** @type {C6_1} */",
-          "C6_2.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_3() {}",
-          "/** @type {C6_2} */",
-          "C6_3.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_4() {}",
-          "/** @type {C6_3} */",
-          "C6_4.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_5() {}",
-          "/** @type {C6_4} */",
-          "C6_5.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C5() {}",
-          "/** @type {C6_5} */",
-          "C5.prototype.next;");
-
   @Test
-  public void testStructuralInterfaceMatching16_1() {
-    // I5 and C5 shares the same type structure
+  public void testRecordType7() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
         .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .includeDefaultExterns()
+            "/** @return {{prop: (number|undefined)}} x */"
+                + "function f() { var x = {}; g(x); return x; }"
+                + "/** @param {number} x */"
+                + "function g(x) {}")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : {prop: (number|undefined)}\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching17_1() {
-    // I5 and C5 shares the same type structure
+  public void testRecordType8() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
         .addSource(
-            "/** @type {C5} */",
-            "var c5;",
-            "/**",
-            " * @param {I5} i5",
-            " */",
-            "function f(i5) {}",
-            "",
-            "f(c5);")
-        .includeDefaultExterns()
+            "/** @return {{prop: (number|string)}} x */"
+                + "function f() { var x = {prop: 3}; g(x.prop); return x; }"
+                + "/** @param {string} x */"
+                + "function g(x) {}")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching18_1() {
-    // I5 and C5 shares the same type structure
+  public void testDuplicateRecordFields1() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD)
-        .addSource(
-            "/** @type {I5} */", //
-            "var i5;" + "/** @type {C5} */",
-            "var c5;",
-            "i5.next = c5;")
-        .includeDefaultExterns()
+        .addSource("/**" + "* @param {{x:string, x:number}} a" + "*/" + "function f(a) {};")
+        .addDiagnostic("Bad type annotation. Duplicate record field x." + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
-  /**
-   * a very long non-structural chain, there is a slight difference between the property type
-   * structural of I5 and that of C5: I5.next.next.next.next.next has type I5 while
-   * C5.next.next.next.next.next has type number
-   */
-  private static final String EXTERNS_FOR_LONG_NONMATCHING_CHAIN =
-      lines(
-          "/** @record */",
-          "function I5() {}",
-          "/** @type {I5} */",
-          "I5.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6() {}",
-          "/** @type {number} */",
-          "C6.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_1() {}",
-          "/** @type {C6} */",
-          "C6_1.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_2() {}",
-          "/** @type {C6_1} */",
-          "C6_2.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_3() {}",
-          "/** @type {C6_2} */",
-          "C6_3.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_4() {}",
-          "/** @type {C6_3} */",
-          "C6_4.prototype.next;",
-          "",
-          "/** @constructor */",
-          "function C6_5() {}",
-          "/** @type {C6_4} */",
-          "C6_5.prototype.next;",
-          "",
-          "/** @interface */",
-          "function C5() {}",
-          "/** @type {C6_5} */",
-          "C5.prototype.next;");
+  @Test
+  public void testDuplicateRecordFields2() {
+    newTest()
+        .addSource(
+            "/**" + "* @param {{name:string,number:x,number:y}} a" + " */" + "function f(a) {};")
+        .addDiagnostic("Bad type annotation. Unknown type x")
+        .addDiagnostic("Bad type annotation. Duplicate record field number." + BAD_TYPE_WIKI_LINK)
+        .run();
+  }
 
   @Test
-  public void testStructuralInterfaceMatching19() {
-    // the type structure of I5 and C5 are different
+  public void testMultipleExtendsInterface1() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
         .addSource(
-            "/** @type {I5} */", //
-            "var i5;",
-            "/** @type {C5} */",
-            "var c5;",
-            "i5 = c5;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C5|null)",
-                "required: (I5|null)"))
-        .includeDefaultExterns()
+            "/** @interface */ function base1() {}\n"
+                + "/** @interface */ function base2() {}\n"
+                + "/** @interface\n"
+                + "* @extends {base1}\n"
+                + "* @extends {base2}\n"
+                + "*/\n"
+                + "function derived() {}")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching20() {
-    // the type structure of I5 and C5 are different
+  public void testMultipleExtendsInterface2() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
         .addSource(
-            "/** @type {C5} */",
-            "var c5;",
-            "/**",
-            " * @param {I5} i5",
-            " */",
-            "function f(i5) {}",
-            "",
-            "f(c5);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : (C5|null)",
-                "required: (I5|null)"))
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "Int0.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int0 is not implemented by type Foo")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching21() {
-    // the type structure of I5 and C5 are different
+  public void testMultipleExtendsInterface3() {
     newTest()
-        .addExterns(EXTERNS_FOR_LONG_NONMATCHING_CHAIN)
         .addSource(
-            "/** @type {I5} */", //
-            "var i5;",
-            "/** @type {C5} */",
-            "var c5;",
-            "i5.next = c5;")
-        .addDiagnostic(
-            lines(
-                "assignment to property next of I5", //
-                "found   : (C5|null)",
-                "required: (I5|null)"))
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "Int1.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int1 is not implemented by type Foo")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the return types of the ordinary function types match (should match, since declared
-   * with @record)
-   */
   @Test
-  public void testStructuralInterfaceMatching22_1() {
-    // I5 and C5 shares the same type structure
+  public void testMultipleExtendsInterface4() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
+                + " @extends {number} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("Int2 @extends non-object type number")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the return types of the ordinary function types match (should not match)
-   */
   @Test
-  public void testStructuralInterfaceMatching23() {
-    // the type structure of I5 and C5 are different
+  public void testMultipleExtendsInterface5() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_NONMATCHING_CHAIN,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C7|null)",
-                "required: (I7|null)"))
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @constructor */function Int1() {};"
+                + "/** @return {string} x */"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};")
+        .addDiagnostic("Int2 cannot extend this type; interfaces can only extend interfaces")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the parameter types of the ordinary function types match (should match, since declared
-   * with @record)
-   */
   @Test
-  public void testStructuralInterfaceMatching24_1() {
-    // I5 and C5 shares the same type structure
+  public void testMultipleExtendsInterface6() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(C5): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(I5): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Super1() {};",
+            "/** @interface */function Super2() {};",
+            "/** @param {number} bar */Super2.prototype.foo = function(bar) {};",
+            "/** @interface @extends {Super1} @extends {Super2} */function Sub() {};",
+            "/** @override @param {string} bar */Sub.prototype.foo =",
+            "function(bar) {};")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Sub and the type of the property it "
+                    + "overrides from interface Super2",
+                "original: function(this:Super2, number): undefined",
+                "override: function(this:Sub, string): undefined"))
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the parameter types of the ordinary function types match (should match, since declared
-   * with @record)
-   */
   @Test
-  public void testStructuralInterfaceMatching26_1() {
-    // I5 and C5 shares the same type structure
+  public void testMultipleExtendsInterfaceAssignment() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(C5, C5, I5): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(I5, C5): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */ var I2 = function() {}\n"
+                + "/** @interface\n@extends {I1}\n@extends {I2}*/"
+                + "var I3 = function() {};\n"
+                + "/** @constructor\n@implements {I3}*/var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I1} */var i1 = t;\n"
+                + "/** @type {I2} */var i2 = t;\n"
+                + "/** @type {I3} */var i3 = t;\n"
+                + "i1 = i3;\n"
+                + "i2 = i3;\n")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the parameter types of the ordinary function types match (should match)
-   */
   @Test
-  public void testStructuralInterfaceMatching29_1() {
-    // I5 and C5 shares the same type structure
+  public void testMultipleExtendsInterfaceParamPass() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */",
+            "var I1 = function() {};",
+            "/** @interface */",
+            "var I2 = function() {}",
+            "/** @interface @extends {I1} @extends {I2} */",
+            "var I3 = function() {};",
+            "/** @constructor @implements {I3} */",
+            "var T = function() {};",
+            "var t = new T();",
+            "/**",
+            " * @param {I1} x",
+            " * @param {I2} y",
+            " * @param {I3} z",
+            " */",
+            "function foo(x,y,z){};",
+            "foo(t,t,t)")
         .run();
   }
 
-  /** the "this" of I5 and C5 are covariants, so should match */
   @Test
-  public void testStructuralInterfaceMatching30_1_1() {
-    // I5 and C5 shares the same type structure
+  public void testBadMultipleExtendsClass() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @constructor */ function base1() {}\n"
+                + "/** @constructor */ function base2() {}\n"
+                + "/** @constructor\n"
+                + "* @extends {base1}\n"
+                + "* @extends {base2}\n"
+                + "*/\n"
+                + "function derived() {}")
+        .addDiagnostic(
+            "Bad type annotation. type annotation incompatible with other annotations."
+                + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
-  /** the "this" of I5 and C5 are covariants, so should match */
   @Test
-  public void testStructuralInterfaceMatching30_2_1() {
-    // I5 and C5 shares the same type structure
+  public void testInterfaceExtendsResolution() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface \n @extends {A} */ function B() {};\n"
+                + "/** @constructor \n @implements {B} */ function C() {};\n"
+                + "/** @interface */ function A() {};")
         .run();
   }
 
-  /** the "this" of I5 and C5 are covariants, so should match */
   @Test
-  public void testStructuralInterfaceMatching30_3_1() {
+  public void testPropertyCanBeDefinedInObject() {
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(
-            "/** @record */ function I5() {}",
-            "/** @constructor @implements {I5} */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */ function I() {};",
+            "I.prototype.bar = function() {};",
+            "/** @type {Object} */ var foo;",
+            "foo.bar();")
         .run();
   }
 
-  /** I7 is declared with @record tag, so it will match */
   @Test
-  public void testStructuralInterfaceMatching30_3_2() {
+  public void testExtendedInterfacePropertiesCompatibility1() {
     newTest()
-        .addExterns(
-            "/** @interface */ function I5() {}",
-            "/** @constructor @implements {I5} */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};")
+        .addDiagnostic(
+            "Interface Int2 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int1")
         .run();
   }
 
-  /**
-   * Although I7 is declared with @record tag, note that I5 is declared with @interface and C5 does
-   * not extend I5, so it will not match
-   */
   @Test
-  public void testStructuralInterfaceMatching30_3_3() {
+  public void testExtendedInterfacePropertiesCompatibility2() {
     newTest()
-        .addExterns(
-            "/** @interface */ function I5() {}",
-            "/** @constructor */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @interface */function Int2() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @type {Object} */"
+                + "Int2.prototype.foo;"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
+                + "@extends {Int2}*/"
+                + "function Int3() {};")
         .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C7|null)",
-                "required: (I7|null)"))
+            "Interface Int3 has a property foo with incompatible types in "
+                + "its super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in "
+                + "its super interfaces Int1 and Int2")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching30_3_4() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility3() {
     newTest()
-        .addExterns(
-            "/** @record */ function I5() {}",
-            "/** @constructor */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int1")
         .run();
   }
 
-  /** the "this" of I5 and C5 are covariants, so should match */
   @Test
-  public void testStructuralInterfaceMatching30_4_1() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility4() {
     newTest()
-        .addExterns(
-            "/** @record */ function I5() {}",
-            "/** @constructor @implements {I5} */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface \n @extends {Int0} */ function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @interface */function Int2() {};"
+                + "/** @interface \n @extends {Int2} */ function Int3() {};"
+                + "/** @type {string} */"
+                + "Int2.prototype.foo;"
+                + "/** @interface \n @extends {Int1} \n @extends {Int3} */"
+                + "function Int4() {};")
+        .addDiagnostic(
+            "Interface Int4 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int2")
         .run();
   }
 
-  /**
-   * although I7 is declared with @record tag I5 is declared with @interface tag, so no structural
-   * interface matching
-   */
   @Test
-  public void testStructuralInterfaceMatching30_4_2() {
+  public void testExtendedInterfacePropertiesCompatibility5() {
     newTest()
-        .addExterns(
-            "/** @interface */ function I5() {}",
-            "/** @constructor */ function C5() {}",
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:I5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:C5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {number} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
         .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C7|null)",
-                "required: (I7|null)"))
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int1 and Int4")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the this types of the ordinary function types match (should match)
-   */
   @Test
-  public void testStructuralInterfaceMatching31_1() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility6() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {string} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
         .run();
   }
 
-  /** test structural interface matching for record types */
   @Test
-  public void testStructuralInterfaceMatching32_2() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility7() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {{prop: I7, prop2: C7}}*/",
-            "var r1;",
-            "/** @type {{prop: C7, prop2: C7}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {Object} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int1 and Int4")
         .run();
   }
 
-  /** test structural interface matching for record types */
   @Test
-  public void testStructuralInterfaceMatching33_3() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility8() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {{prop: I7, prop2: C7}}*/",
-            "var r1;",
-            "/** @type {{prop: C7, prop2: C7, prop3: C7}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.bar;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {Object} */"
+                + "Int4.prototype.foo;"
+                + "/** @type {Null} */"
+                + "Int4.prototype.bar;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int5 has a property bar with incompatible types in its"
+                + " super interfaces Int1 and Int4")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int4")
         .run();
   }
 
-  /**
-   * test structural interface matching for a combination of ordinary function types and record
-   * types
-   */
   @Test
-  public void testStructuralInterfaceMatching36_2() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibility9() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
-            " var com1;",
-            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
-            "var com2;",
-            "",
-            "com1 = com2;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface\n * @template T */function Int0() {};"
+                + "/** @interface\n * @template T */function Int1() {};"
+                + "/** @type {T} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {T} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int0<number>} \n @extends {Int1<string>} */"
+                + "function Int2() {};")
+        .addDiagnostic(
+            "Interface Int2 has a property foo with incompatible types in its "
+                + "super interfaces Int0<number> and Int1<string>")
         .run();
   }
 
-  /**
-   * test structural interface matching for a combination of ordinary function types and record
-   * types
-   */
   @Test
-  public void testStructuralInterfaceMatching36_3() {
-    // I5 and C5 shares the same type structure
+  public void testExtendedInterfacePropertiesCompatibilityNoError() {
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
-            " var com1;",
-            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
-            "var com2;",
-            "",
-            "com1 = com2;")
-        .includeDefaultExterns()
+        .addSource(
+            ""
+                + "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @param {number} x */"
+                + "Int0.prototype.foo;"
+                + "/** @param {number} x */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n * @extends {Int0} \n * @extends {Int1} */"
+                + "function Int2() {};")
         .run();
   }
 
-  /**
-   * test structural interface matching for a combination of ordinary function types and record
-   * types here C7 does not structurally match I7
-   */
   @Test
-  public void testStructuralInterfaceMatching37() {
-    // the type structure of I5 and C5 are different
+  public void testImplementedInterfacePropertiesShouldFailOnConflict() {
+    // TODO(b/132718172): Provide a better error message.
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_NONMATCHING_CHAIN,
-            "/** @record */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {{fun: function(C7):I7, prop: {prop: I7}}} */",
-            "var com1;",
-            "/** @type {{fun: function(I7):C7, prop: {prop: C7}}} */",
-            "var com2;",
-            "",
-            "com1 = com2;")
+        .addSource(
+            "/** @interface */function Int0() {};",
+            "/** @interface */function Int1() {};",
+            "/** @type {number} */",
+            "Int0.prototype.foo;",
+            "/** @type {string} */",
+            "Int1.prototype.foo;",
+            "/** @constructor @implements {Int0} @implements {Int1} */",
+            "function Foo() {};",
+            "Foo.prototype.foo;")
         .addDiagnostic(
             lines(
-                "assignment",
-                "found   : {\n  fun: function((I7|null)): (C7|null),\n  prop: {prop: (C7|null)}\n}",
-                "required: {\n  fun: function((C7|null)): (I7|null),\n  prop: {prop: (I7|null)}\n}",
-                "missing : []",
-                "mismatch: [fun,prop]"))
-        .includeDefaultExterns()
+                "mismatch of the foo property on type Foo and the type of the property it"
+                    + " overrides from interface Int1",
+                "original: string",
+                "override: number"))
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_39() {
+  public void testGenerics1a() {
+    String fnDecl =
+        "/** \n"
+            + " * @param {T} x \n"
+            + " * @param {function(T):T} y \n"
+            + " * @template T\n"
+            + " */ \n"
+            + "function f(x,y) { return y(x); }\n";
+
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
         .addSource(
-            "/** @type {I2} */", //
-            "var o1 = {length : 'test'};")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : {length: string}",
-                "required: (I2|null)",
-                "missing : []",
-                "mismatch: [length]"))
+            fnDecl
+                + "/** @type {string} */"
+                + "var out;"
+                + "/** @type {string} */"
+                + "var result = f('hi', function(x){ out = x; return x; });")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_matching() {
+  public void testGenerics1b() {
+    String fnDecl =
+        "/** \n"
+            + " * @param {T} x \n"
+            + " * @param {function(T):T} y \n"
+            + " * @template T\n"
+            + " */ \n"
+            + "function f(x,y) { return y(x); }\n";
+
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
         .addSource(
-            "/** @type {I2} */", //
-            "var o1 = {length : 123};")
-        .includeDefaultExterns()
+            fnDecl
+                + "/** @type {string} */"
+                + "var out;"
+                + "var result = f(0, function(x){ out = x; return x; });")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_matching() {
+  public void testFilter0() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {",
-            "  /** @type {number} */",
-            "  this.length;",
-            "}")
         .addSource(
-            "/** @type {!I2} */", //
-            "var o1 = {length : 123};")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @param {T} arr\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<string>} */"
+                + "var result = filter(arr);")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_missing() {
+  public void testFilter1() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
         .addSource(
-            "/** @type {!I2} */", //
-            "var o1 = {};")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : {}",
-                "required: I2",
-                "missing : [length]",
-                "mismatch: []"))
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @param {!Array<T>} arr\n"
+                + " * @return {!Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<string>} */"
+                + "var result = filter(arr);")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_missing() {
+  public void testFilter2() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {",
-            "  /** @type {number} */",
-            "  this.length;",
-            "}")
         .addSource(
-            "/** @type {!I2} */", //
-            "var o1 = {};")
+            "/**\n"
+                + " * @param {!Array<T>} arr\n"
+                + " * @return {!Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<number>} */"
+                + "var result = filter(arr);")
         .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : {}",
-                "required: I2",
-                "missing : [length]",
-                "mismatch: []"))
-        .includeDefaultExterns()
+            "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_prototypeProp_mismatch() {
+  public void testFilter3() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
         .addSource(
-            "/** @type {!I2} */", //
-            "var o1 = {length: null};")
+            "/**\n"
+                + " * @param {Array<T>} arr\n"
+                + " * @return {Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {Array<number>} */"
+                + "var result = filter(arr);")
         .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : {length: null}",
-                "required: I2",
-                "missing : []",
-                "mismatch: [length]"))
-        .includeDefaultExterns()
+            "initializing variable\n"
+                + "found   : (Array<string>|null)\n"
+                + "required: (Array<number>|null)")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_instanceProp_mismatch() {
-    newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {",
-            "  /** @type {number} */",
-            "  this.length;",
-            "}")
-        .addSource(
-            "/** @type {!I2} */", //
-            "var o1 = {length: null};")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : {length: null}",
-                "required: I2",
-                "missing : []",
-                "mismatch: [length]"))
-        .includeDefaultExterns()
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter1() {
+    testClosureTypes(
+        "/** @type {Array<string>} */"
+            + "var arr;\n"
+            + "/** @type {!Array<number>} */"
+            + "var result = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {return false;});",
+        "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>");
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_41() {
-    newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
-        .addSource(
-            "/** @type {I2} */",
-            "var o1 = {length : 123};",
-            "/** @type {I2} */",
-            "var i;",
-            "i = o1;")
-        .includeDefaultExterns()
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter2() {
+    testClosureTypes(
+        "/** @type {number} */"
+            + "var out;"
+            + "/** @type {Array<string>} */"
+            + "var arr;\n"
+            + "var out4 = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {out = item; return false});",
+        "assignment\n" + "found   : string\n" + "required: number");
   }
 
   @Test
-  public void testStructuralInterfaceMatching41_forObjectLiterals_41_1() {
-    newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
-        .addSource(
-            "/** @type {I2} */",
-            "var o1 = {length : 123};",
-            "/** @type {I2} */",
-            "var i;",
-            "i = o1;")
-        .includeDefaultExterns()
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter3() {
+    testClosureTypes(
+        "/** @type {string} */"
+            + "var out;"
+            + "/** @type {Array<string>} */ var arr;\n"
+            + "var result = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {out = index;});",
+        "assignment\n" + "found   : number\n" + "required: string");
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_42() {
-    newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
-        .addSource(
-            "/** @type {{length: number}} */",
-            "var o1 = {length : 123};",
-            "/** @type {I2} */",
-            "var i;",
-            "i = o1;")
-        .includeDefaultExterns()
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter4() {
+    testClosureTypes(
+        lines(
+            "/** @type {string} */",
+            "var out;",
+            "/** @type {Array<string>} */ var arr;",
+            "var out4 = goog.array.filter(",
+            "   arr,",
+            "   function(item,index,srcArr) {out = srcArr;});"),
+        lines(
+            "assignment", // keep newlines
+            "found   : (Array|null|{length: number})",
+            "required: string"));
   }
 
   @Test
-  public void testStructuralInterfaceMatching_forObjectLiterals_43() {
+  public void testCatchExpression1() {
     newTest()
-        .addExterns(
-            "/** @record */", //
-            "function I2() {}",
-            "/** @type {number} */",
-            "I2.prototype.length;")
         .addSource(
-            "var o1 = {length : 123};", //
-            "/** @type {I2} */",
-            "var i;",
-            "i = o1;")
-        .includeDefaultExterns()
+            "function fn() {"
+                + "  /** @type {number} */"
+                + "  var out = 0;"
+                + "  try {\n"
+                + "    foo();\n"
+                + "  } catch (/** @type {string} */ e) {\n"
+                + "    out = e;"
+                + "  }"
+                + "}\n")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching44() {
+  public void testCatchExpression2() {
     newTest()
-        .addExterns(
-            "/** @record */ function I() {}",
-            "/** @type {!Function} */ I.prototype.removeEventListener;",
-            "/** @type {!Function} */ I.prototype.addEventListener;",
-            "/** @constructor */ function C() {}",
-            "/** @type {!Function} */ C.prototype.addEventListener;")
-        .addSource(
-            "/** @param {C|I} x */", //
-            "function f(x) { x.addEventListener(); }",
-            "f(new C());")
-        .includeDefaultExterns()
+        .addSource(
+            "function fn() {"
+                + "  /** @type {number} */"
+                + "  var out = 0;"
+                + "  /** @type {string} */"
+                + "  var e;"
+                + "  try {\n"
+                + "    foo();\n"
+                + "  } catch (e) {\n"
+                + "    out = e;"
+                + "  }"
+                + "}\n")
         .run();
   }
 
-  /**
-   * Currently, the structural interface matching does not support structural matching for template
-   * types Using @template @interfaces requires @implements them explicitly.
-   */
   @Test
-  public void testStructuralInterfaceMatching45() {
+  public void testIssue1058() {
     newTest()
         .addSource(
-            "/**",
-            " * @record",
-            " * @template X",
-            " */",
-            "function I() {}",
-            "/** @constructor */",
-            "function C() {}",
-            "var /** !I */ i = new C;")
+            "/**\n"
+                + "  * @constructor\n"
+                + "  * @template CLASS\n"
+                + "  */\n"
+                + "var Class = function() {};\n"
+                + "\n"
+                + "/**\n"
+                + "  * @param {function(CLASS):CLASS} a\n"
+                + "  * @template T\n"
+                + "  */\n"
+                + "Class.prototype.foo = function(a) {\n"
+                + "  return 'string';\n"
+                + "};\n"
+                + "\n"
+                + "/** @param {number} a\n"
+                + "  * @return {string} */\n"
+                + "var a = function(a) { return '' };\n"
+                + "\n"
+                + "new Class().foo(a);")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching46() {
+  public void testDeterminacyIssue() {
     newTest()
         .addSource(
-            "/** @interface */",
-            "function I2() {}",
-            "/**",
-            " * @interface",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}",
-            "/**",
-            " * @record",
-            " * @extends {I3}",
-            " */",
-            "function I4() {}",
-            "/** @type {I4} */",
-            "var i4;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i4 = i2;")
+            "(function() {\n"
+                + "    /** @constructor */\n"
+                + "    var ImageProxy = function() {};\n"
+                + "    /** @constructor */\n"
+                + "    var FeedReader = function() {};\n"
+                + "    /** @type {ImageProxy} */\n"
+                + "    FeedReader.x = new ImageProxy();\n"
+                + "})();")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching47() {
+  public void testUnknownTypeReport() {
+    enableReportUnknownTypes();
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I2() {}",
-            "/**",
-            " * @interface",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}",
-            "/**",
-            " * @record",
-            " * @extends {I3}",
-            " */",
-            "function I4() {}")
-        .addSource(
-            "/** @type {I4} */", //
-            "var i4;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i4 = i2;")
-        .includeDefaultExterns()
+        .addSource("function id(x) { return x; }")
+        .addDiagnostic("could not determine the type of this expression")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching48() {
-    newTest()
-        .addExterns("")
-        .addSource(
-            "/** @interface */",
-            "function I2() {}",
-            "/**",
-            " * @record",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}",
-            "/** @type {I3} */",
-            "var i3;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i3 = i2;")
-        .includeDefaultExterns()
-        .run();
+  public void testUnknownTypeReport_allowsUnknownIfStatement() {
+    enableReportUnknownTypes();
+    newTest().addSource("function id(x) { x; }").run();
+  }
+
+  @Test
+  public void testUnknownForIn() {
+    enableReportUnknownTypes();
+    newTest().addSource("var x = {'a':1}; var y; \n for(\ny\n in x) {}").run();
+  }
+
+  @Test
+  public void testUnknownTypeDisabledByDefault() {
+    newTest().addSource("function id(x) { return x; }").run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching49() {
+  public void testNonexistentPropertyAccessOnStruct() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I2() {}",
-            "/**",
-            " * @record",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}")
         .addSource(
-            "/** @type {I3} */", //
-            "var i3;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i3 = i2;")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};\n"
+                + "/** @param {A} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching49_2() {
+  public void testNonexistentPropertyAccessOnStructOrObject() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(
-            "/** @record */",
-            "function I2() {}",
-            "/**",
-            " * @record",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}")
         .addSource(
-            "/** @type {I3} */", //
-            "var i3;",
-            "/** @type {I2} */",
-            "var i2;",
-            "i3 = i2;")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};\n"
+                + "/** @param {A|Object} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching50() {
+  public void testNonexistentPropertyAccessOnExternStruct() {
     newTest()
         .addExterns(
-            "/** @interface */",
-            "function I2() {}",
-            "/**",
-            " * @record",
-            " * @extends {I2}",
-            " */",
-            "function I3() {}")
+            "/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "var A = function() {};")
         .addSource(
-            "/** @type {I3} */",
-            "var i3;",
-            "/** @type {{length : number}} */",
-            "var r = {length: 123};",
-            "i3 = r;")
-        .includeDefaultExterns()
+            "/** @param {A} a */\n" + "function foo(a) {\n" + "  if (a.bar) { a.bar(); }\n" + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord1() {
-    // Verify that empty @record subtypes don't cause circular definition warnings.
+  public void testNonexistentPropertyAccessStructSubtype() {
     newTest()
         .addSource(
-            "/** @record */ function I1() {};",
-            "/** @type {number|undefined} */ I1.prototype.prop;",
-            "",
-            "/** @record @extends {I1} */ function I2() {}",
-            "/** @record @extends {I2} */ function I3() {}",
-            "/** @type {string} */ I3.prototype.prop2;",
-            "/** @constructor @implements {I3} */ function C() {",
-            "    /** @type {number} */ this.prop = 1;",
-            "    /** @type {string} */ this.prop2 = 'str';",
-            "}",
-            "",
-            "/** @param {I3} a */ function fn(a) {}")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};"
+                + ""
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " * @extends {A}\n"
+                + " */\n"
+                + "var B = function() { this.bar = function(){}; };"
+                + ""
+                + "/** @param {A} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord2() {
+  public void testNonexistentPropertyAccessStructInterfaceSubtype() {
     newTest()
         .addSource(
-            "/** @type {!SubInterface} */ var value;",
-            "/** @record */ var SuperInterface = function () {};",
-            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};")
+            "/**",
+            " * @interface",
+            " * @struct",
+            " */",
+            "var A = function() {};",
+            "",
+            "/**",
+            " * @interface",
+            " * @struct",
+            " * @extends {A}",
+            " */",
+            "var B = function() {};",
+            "/** @return {void} */ B.prototype.bar = function(){};",
+            "",
+            "/** @param {A} a */",
+            "function foo(a) {",
+            "  if (a.bar) { a.bar(); }",
+            "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord3() {
-    newTest()
-        .addSource(
-            "/** @record */ var SuperInterface = function () {};",
-            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};",
-            "/** @type {!SubInterface} */ var value;")
-        .run();
-  }
+  public void testNonexistentPropertyAccessStructRecordSubtype() {
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testEmptySubtypeInterface1() {
     newTest()
         .addSource(
-            "/** @type {!SubInterface} */ var value;",
-            "/** @interface */ var SuperInterface = function () {};",
-            "/** @interface @extends {SuperInterface} */ var SubInterface = function() {};")
+            "/**",
+            " * @record",
+            " * @struct",
+            " */",
+            "var A = function() {};",
+            "",
+            "/**",
+            " * @record",
+            " * @struct",
+            " * @extends {A}",
+            " */",
+            "var B = function() {};",
+            "/** @return {void} */ B.prototype.bar = function(){};",
+            "",
+            "/** @param {A} a */",
+            "function foo(a) {",
+            "  if (a.bar) {",
+            "    a.bar();",
+            "  }",
+            "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceMatching1_1() {
+  public void testNonexistentPropertyAccessStructSubtype2() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function Interface1() {}",
-            "/** @type {number} */",
-            "Interface1.prototype.length;",
-            "",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @type {number} */",
-            "C1.prototype.length;")
         .addSource(
-            "/** @type{Interface1} */",
-            "var obj1;",
-            "/** @type{C1} */",
-            "var obj2 = new C1();",
-            "obj1 = obj2;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C1|null)",
-                "required: (Interface1|null)"))
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {\n"
+                + "  this.x = 123;\n"
+                + "}\n"
+                + "var objlit = /** @struct */ { y: 234 };\n"
+                + "Foo.prototype = objlit;\n"
+                + "var n = objlit.x;\n")
+        .addDiagnostic("Property x never defined on Foo.prototype")
         .run();
   }
 
-  /**
-   * structural interface matching will also be able to structurally match ordinary function types
-   * check if the return types of the ordinary function types match (should not match, since I7 is
-   * declared with @interface)
-   */
   @Test
-  public void testStructuralInterfaceMatching22_2() {
-    // I5 and C5 shares the same type structure
+  public void testIssue1024a() {
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(
-            EXTERNS_FOR_LONG_MATCHING_CHAIN_RECORD,
-            "/** @interface */",
-            "function I7() {}",
-            "/** @type{function(): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C7|null)",
-                "required: (I7|null)"))
-        .includeDefaultExterns()
+        .addSource(
+            "/** @param {Object} a */",
+            "function f(a) {",
+            "  a.prototype = '__proto'",
+            "}",
+            "/** @param {Object} b",
+            " *  @return {!Object}",
+            " */",
+            "function g(b) {",
+            "  return b.prototype",
+            "}")
         .run();
   }
 
-  /** declared with @interface, no structural interface matching */
   @Test
-  public void testStructuralInterfaceMatching30_3() {
-    // I5 and C5 shares the same type structure
+  public void testIssue1024b() {
     newTest()
-        .addExterns(
-            "/** @interface */ function I5() {}",
-            "/** @constructor @implements {I5} */ function C5() {}",
-            "/** @interface */",
-            "function I7() {}",
-            "/** @type{function(this:C5, C5, C5, I5=): I5} */",
-            "I7.prototype.getElement = function(){};",
-            "",
-            "/** @constructor */",
-            "function C7() {}",
-            "/** @type{function(this:I5, I5, C5=, I5=): C5} */",
-            "C7.prototype.getElement = function(){};")
-        .addSource(
-            "/** @type {I7} */", //
-            "var i7;",
-            "/** @type {C7} */",
-            "var c7;",
-            "",
-            "i7 = c7;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (C7|null)",
-                "required: (I7|null)"))
-        .includeDefaultExterns()
+        .addSource(
+            "/** @param {Object} a */",
+            "function f(a) {",
+            "  a.prototype = {foo:3};",
+            "}",
+            "/** @param {Object} b",
+            " */",
+            "function g(b) {",
+            "  b.prototype = function(){};",
+            "}")
         .run();
   }
 
   @Test
-  public void testRecordWithOptionalProperty() {
+  public void testModuleReferenceNotAllowed() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, opt_num: (undefined|number)} */ x = new Foo;")
+        .addSource("/** @param {./Foo} z */ function f(z) {}")
+        .addDiagnostic("Bad type annotation. Unknown type ./Foo")
         .run();
   }
 
   @Test
-  public void testRecordWithUnknownProperty() {
+  public void testCheckObjectKeysBadKey1() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, unknown: ?} */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: {\n  str: string,\n  unknown: ?\n}",
-                "missing : [unknown]",
-                "mismatch: []"))
+        .addSource("/** @type {!Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithOptionalUnknownProperty() {
+  public void testCheckObjectKeysBadKey2() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, opt_unknown: (?|undefined)} */ x = new Foo;")
+        .addSource("/** @type {!Object<function(), number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithTopProperty() {
+  public void testCheckObjectKeysBadKey3() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, top: *} */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: {\n  str: string,\n  top: *\n}",
-                "missing : [top]",
-                "mismatch: []"))
+        .addSource("/** @type {!Object<!Array<!Object>, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceWithOptionalProperty() {
+  public void testCheckObjectKeysBadKey4() {
     newTest()
-        .addSource(
-            "/** @record */ function Rec() {}",
-            "/** @type {string} */ Rec.prototype.str;",
-            "/** @type {(number|undefined)} */ Rec.prototype.opt_num;",
-            "",
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** !Rec */ x = new Foo;")
+        .addSource("/** @type {!Object<*, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceWithUnknownProperty() {
-    newTest()
-        .addSource(
-            "/** @record */ function Rec() {}",
-            "/** @type {string} */ Rec.prototype.str;",
-            "/** @type {?} */ Rec.prototype.unknown;",
-            "",
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** !Rec */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: Rec",
-                "missing : [unknown]",
-                "mismatch: []"))
+  public void testCheckObjectKeysBadKey5() {
+    newTest()
+        .addSource("/** @type {(string|Object<Object, number>)} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceWithOptionalUnknownProperty() {
+  public void testCheckObjectKeysBadKey6() {
     newTest()
-        .addSource(
-            "/** @record */ function Rec() {}",
-            "/** @type {string} */ Rec.prototype.str;",
-            "/** @type {?|undefined} */ Rec.prototype.opt_unknown;",
-            "",
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** !Rec */ x = new Foo;")
+        .addSource("/** @type {!Object<number, !Object<Object, number>>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testOptionalUnknownIsAssignableToUnknown() {
+  public void testCheckObjectKeysBadKey7() {
     newTest()
         .addSource(
-            "function f(/** (undefined|?) */ opt_unknown) {",
-            "  var /** ? */ unknown = opt_unknown;",
-            "}")
+            "/** @constructor */\n"
+                + "var MyClass = function() {};\n"
+                + "/** @type {!Object<MyClass, number>} */\n"
+                + "var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceWithTopProperty() {
+  public void testCheckObjectKeysBadKey8() {
     newTest()
         .addSource(
-            "/** @record */ function Rec() {}",
-            "/** @type {string} */ Rec.prototype.str;",
-            "/** @type {*} */ Rec.prototype.top;",
-            "",
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** !Rec */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: Rec",
-                "missing : [top]",
-                "mismatch: []"))
+            "/** @enum{!Object} */\n"
+                + "var Enum = {};\n"
+                + "/** @type {!Object<Enum, number>} */\n"
+                + "var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfaceCycleDoesntCrash() {
+  public void testCheckObjectKeysBadKey9() {
     newTest()
-        .addSource(
-            "/**  @record */ function Foo() {};",
-            "/**  @return {MutableFoo} */ Foo.prototype.toMutable;",
-            "/**  @record */ function MutableFoo() {};",
-            "/**  @param {Foo} from */ MutableFoo.prototype.copyFrom;",
-            "",
-            "/**  @record */ function Bar() {};",
-            "/**  @return {MutableBar} */ Bar.prototype.toMutable;",
-            "/**  @record */ function MutableBar() {};",
-            "/**  @param {Bar} from */ MutableBar.prototype.copyFrom;",
-            "",
-            "/** @constructor @implements {MutableBar} */ function MutableBarImpl() {};",
-            "/** @override */ MutableBarImpl.prototype.copyFrom = function(from) {};",
-            "/** @constructor  @implements {MutableFoo} */ function MutableFooImpl() {};",
-            "/** @override */ MutableFooImpl.prototype.copyFrom = function(from) {};")
+        .addSource("/** @type {function(!Object<!Object, number>)} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchOwnProperties1() {
+  public void testCheckObjectKeysBadKey10() {
     newTest()
-        .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.prop = 5;",
-            "}",
-            "var /** !WithProp */ wp = new Foo;")
+        .addSource("/** @type {function(): !Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchOwnProperties2() {
+  public void testCheckObjectKeysBadKey11() {
     newTest()
         .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.oops = 5;",
-            "}",
-            "var /** !WithProp */ wp = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: WithProp",
-                "missing : [prop]",
-                "mismatch: []"))
+            "/** @constructor */\n"
+                + "function X() {}\n"
+                + "/** @constructor @extends {X} */\n"
+                + "function X2() {}\n"
+                + "/** @enum {!X} */\n"
+                + "var XE = {A:new X};\n"
+                + "/** @type {Object<(!XE|!X2), string>} */\n"
+                + "var Y = {};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchOwnProperties3() {
+  public void testCheckObjectKeysVariousTags1() {
     newTest()
-        .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {string} */ this.prop = 'str';",
-            "}",
-            "var /** !WithProp */ wp = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: WithProp",
-                "missing : []",
-                "mismatch: [prop]"))
+        .addSource("/** @type {!Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchFunctionNamespace1() {
+  public void testCheckObjectKeysVariousTags2() {
     newTest()
-        .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "var ns = function() {};",
-            "/** @type {number} */ ns.prop;",
-            "var /** !WithProp */ wp = ns;")
+        .addSource("/** @param {!Object<!Object, number>} a */ var f = function(a) {};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchFunctionNamespace2() {
+  public void testCheckObjectKeysVariousTags3() {
     newTest()
-        .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "var ns = function() {};",
-            "/** @type {number} */ ns.oops;",
-            "var /** !WithProp */ wp = ns;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : function(): undefined",
-                "required: WithProp",
-                "missing : [prop]",
-                "mismatch: []"))
+        .addSource("/** @return {!Object<!Object, number>} */ var f = function() {return {}};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testStructuralInterfacesMatchFunctionNamespace3() {
+  public void testCheckObjectKeysVariousTags4() {
     newTest()
-        .addSource(
-            "/** @record */ function WithProp() {}",
-            "/** @type {number} */ WithProp.prototype.prop;",
-            "",
-            "var ns = function() {};",
-            "/** @type {string} */ ns.prop;",
-            "var /** !WithProp */ wp = ns;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : function(): undefined",
-                "required: WithProp",
-                "missing : []",
-                "mismatch: [prop]"))
+        .addSource("/** @typedef {!Object<!Object, number>} */ var MyType;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecursiveTemplatizedStructuralInterface() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @record",
-            " * @template T",
-            " */",
-            "var Rec = function() { };",
-            "/** @type {!Rec<T>} */",
-            "Rec.prototype.p;",
-            "",
-            "/**",
-            " * @constructor @implements {Rec<U>}",
-            " * @template U",
-            " */",
-            "var Foo = function() {};",
-            "/** @override */",
-            "Foo.prototype.p = new Foo;")
-        .run();
+  public void testCheckObjectKeysGoodKey1() {
+    newTest().addSource("/** @type {!Object<number, number>} */ var k;").run();
   }
 
   @Test
-  public void testCovarianceForRecordType1() {
-    newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor ",
-            "  * @extends {C} ",
-            "  */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
-        .run();
+  public void testCheckObjectKeysGoodKey2() {
+    newTest().addSource("/** @type {!Object<string, number>} */ var k;").run();
   }
 
   @Test
-  public void testCovarianceForRecordType2() {
-    newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor ",
-            "  * @extends {C} ",
-            "  */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C, prop2: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
-        .run();
+  public void testCheckObjectKeysGoodKey3() {
+    newTest().addSource("/** @type {!Object<boolean, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey4() {
+    newTest().addSource("/** @type {!Object<null, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey5() {
+    newTest().addSource("/** @type {!Object<undefined, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey6() {
+    newTest().addSource("/** @type {!Object<!Date, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey7() {
+    newTest().addSource("/** @type {!Object<!RegExp, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey8() {
+    newTest().addSource("/** @type {!Object<!Array, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey9() {
+    newTest().addSource("/** @type {!Object<!Array<number>, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey10() {
+    newTest().addSource("/** @type {!Object<?, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey11() {
+    newTest().addSource("/** @type {!Object<(string|number), number>} */ var k").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey12() {
+    newTest().addSource("/** @type {!Object<Object>} */ var k;").run();
   }
 
   @Test
-  public void testCovarianceForRecordType3() {
+  public void testCheckObjectKeysGoodKey13() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @interface */\n"
+                + "var MyInterface = function() {};\n"
+                + "/** @type {!Object<!MyInterface, number>} */\n"
+                + "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType4() {
+  public void testCheckObjectKeysGoodKey14() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
         .addSource(
-            "/** @type {{prop: C, prop2: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C2|null)}",
-                "required: {\n  prop: (C|null),\n  prop2: (C|null)\n}",
-                "missing : [prop2]",
-                "mismatch: []"))
+            "/** @typedef {{a: number}} */ var MyRecord;\n"
+                + "/** @type {!Object<MyRecord, number>} */ var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType5() {
+  public void testCheckObjectKeysGoodKey15() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function C() {}",
-            "/** @constructor */",
-            "function C2() {}")
         .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C2|null)}",
-                "required: {prop: (C|null)}",
-                "missing : []",
-                "mismatch: [prop]"))
+            "/** @enum{number} */\n"
+                + "var Enum = {};\n"
+                + "/** @type {!Object<Enum, number>} */\n"
+                + "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType6() {
+  public void testCheckObjectKeysClassWithToString() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {{prop: C2}} */",
-            "var r1;",
-            "/** @type {{prop: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C|null)}",
-                "required: {prop: (C2|null)}",
-                "missing : []",
-                "mismatch: [prop]"))
+            "/** @constructor */",
+            "var MyClass = function() {};",
+            "/** @override*/",
+            "MyClass.prototype.toString = function() { return ''; };",
+            "/** @type {!Object<!MyClass, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType7() {
+  public void testCheckObjectKeysClassInheritsToString() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {{prop: C2, prop2: C2}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {\n  prop: (C2|null),\n  prop2: (C|null)\n}",
-                "required: {\n  prop: (C2|null),\n  prop2: (C2|null)\n}",
-                "missing : []",
-                "mismatch: [prop2]"))
+            "/** @constructor */",
+            "var Parent = function() {};",
+            "/** @override */",
+            "Parent.prototype.toString = function() { return ''; };",
+            "/** @constructor @extends {Parent} */",
+            "var Child = function() {};",
+            "/** @type {!Object<!Child, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType8() {
+  public void testCheckObjectKeysForEnumUsingClassWithToString() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Foo(){}",
-            "/** @type {number} */",
-            "Foo.prototype.x = 5",
-            "/** @type {string} */",
-            "Foo.prototype.y = 'str'")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {{x: number, y: string}} */",
-            "var r1 = {x: 1, y: 'value'};",
-            "",
-            "/** @type {!Foo} */",
-            "var f = new Foo();",
-            "r1 = f;")
-        .includeDefaultExterns()
+            "/** @constructor */",
+            "var MyClass = function() {};",
+            "/** @override*/",
+            "MyClass.prototype.toString = function() { return ''; };",
+            "/** @enum{!MyClass} */",
+            "var Enum = {};",
+            "/** @type {!Object<Enum, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType9() {
+  public void testBadSuperclassInheritance1() {
     newTest()
-        .addExterns(
+        .addSource(
             "/** @constructor */",
-            "function Foo(){}",
+            "function Foo() {}",
             "/** @type {number} */",
-            "Foo.prototype.x1 = 5",
-            "/** @type {string} */",
-            "Foo.prototype.y = 'str'")
-        .addSource(
-            "/** @type {{x: number, y: string}} */",
-            "var r1 = {x: 1, y: 'value'};",
+            "Foo.prototype.myprop = 2;",
             "",
-            "/** @type {!Foo} */",
-            "var f = new Foo();",
-            "f = r1;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : {\n  x: number,\n  y: string\n}",
-                "required: Foo"))
+            "/** @constructor @extends {Foo} */",
+            "function Bar() {}",
+            "/** @type {number} */",
+            "Bar.prototype.myprop = 1;")
+        .addDiagnostic(TypeCheck.HIDDEN_SUPERCLASS_PROPERTY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType10() {
+  public void testBadSuperclassInheritance2() {
     newTest()
-        .addExterns(
+        .addSource(
             "/** @constructor */",
             "function Foo() {}",
-            "/** @type {{x: !Foo}} */",
-            "Foo.prototype.x = {x: new Foo()};")
-        .addSource(
-            "/** @type {!Foo} */",
-            "var o = new Foo();",
+            "/** @type {number} */",
+            "Foo.prototype.myprop = 2;",
             "",
-            "/** @type {{x: !Foo}} */",
-            "var r = {x : new Foo()};",
-            "r = o;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : Foo",
-                "required: {x: Foo}",
-                "missing : []",
-                "mismatch: [x]"))
+            "/** @constructor @extends {Foo} */",
+            "function Bar() {}",
+            "/** @override @type {string} */",
+            "Bar.prototype.myprop = 'qwer';")
+        .addDiagnostic(TypeValidator.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH)
         .run();
   }
 
+  // If the property has no initializer, the HIDDEN_SUPERCLASS_PROPERTY_MISMATCH warning is missed.
   @Test
-  public void testCovarianceForRecordType11() {
+  public void testBadSuperclassInheritance3() {
     newTest()
-        .addExterns(
-            "/** @interface */",
+        .addSource(
+            "/** @constructor */",
             "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "/** @return {number} */",
-            "Bar1.prototype.y = function(){return 1;};",
-            "/** @constructor @implements {Foo} */",
+            "/** @type {number} */",
+            "Foo.prototype.myprop = 2;",
+            "",
+            "/** @constructor @extends {Foo} */",
             "function Bar() {}",
-            "/** @return {string} */",
-            "Bar.prototype.y = function(){return 'test';};")
-        .addSource(
-            "function fun(/** Foo */f) {", //
-            "  f.y();",
-            "}",
-            "fun(new Bar1())",
-            "fun(new Bar());")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+            "/** @override @type {string} */",
+            "Bar.prototype.myprop;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType12() {
+  public void testCheckObjectKeysWithNamedType() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar() {}",
-            "/** @return {undefined} */",
-            "Bar.prototype.y = function(){};")
         .addSource(
-            "/** @type{Foo} */", //
-            "var f = new Bar1();",
-            "f.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run(); // Only if strict warnings are enabled.
+            "/** @type {!Object<!PseudoId, number>} */\n"
+                + "var k;\n"
+                + "/** @typedef {number|string} */\n"
+                + "var PseudoId;")
+        .run();
   }
 
   @Test
-  public void testCovarianceForRecordType13() {
+  public void testCheckObjectKeyRecursiveType() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor @implements {I} */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
         .addSource(
-            "/** @type{{x: {obj: I}}} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run(); // Only if strict warnings are enabled.
+            "/** @typedef {!Object<string, !Predicate>} */ var Schema;\n"
+                + "/** @typedef {function(*): boolean|!Schema} */ var Predicate;\n"
+                + "/** @type {!Schema} */ var k;")
+        .run();
   }
 
   @Test
-  public void testCovarianceForRecordType14a() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testDontOverrideNativeScalarTypes() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
-        .addSource(
-            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+        .addSource("string = 123;\n" + "var /** string */ s = 123;")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .run();
+
+    newTest()
+        .addSource("var string = goog.require('goog.string');\n" + "var /** string */ s = 123;")
+        .addDiagnostic(
+            "Property require never defined on goog" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType14b() {
+  public void testTemplateMap1() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
+            "function f() {\n"
+                + "  /** @type {Int8Array} */\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IArrayLike<string>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : (Int8Array|null)\n" + "required: (IArrayLike<string>|null)")
         .run();
-    // TODO(johnlenz): enable this.
-    // "Property y not defined on all member types of (I|C)"
   }
 
   @Test
-  public void testCovarianceForRecordType15() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testTemplateMap2() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y1 = function(){};",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @return {undefined} */",
-            "C1.prototype.y = function(){};")
-        .addSource(
-            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */",
-            "var ri;",
-            "ri.x.obj.y1();",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource(
+            "function f() {\n"
+                + "  /** @type {Int8Array} */\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IObject<number, string>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n"
+                + "found   : (Int8Array|null)\n"
+                + "required: (IObject<number,string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType16() {
+  public void testTemplateMap3() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {number} */",
-            "C.prototype.y = function(){return 1;};",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @return {string} */",
-            "C1.prototype.y = function(){return 'test';};")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IArrayLike<string>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : Int8Array\n" + "required: (IArrayLike<string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType17() {
+  public void testTemplateMap4() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "Bar1.prototype.y = function(){return {};};",
-            "/** @constructor @implements {Foo} */",
-            "function Bar() {}",
-            "/** @return {number} */",
-            "Bar.prototype.y = function(){return 1;};")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {Foo} */ var f;", //
-            "f.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IObject<number, string>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : Int8Array\n" + "required: (IObject<number,string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType18() {
-    disableStrictMissingPropertyChecks();
+  public void testTemplateMap5() {
     newTest()
-        .addExterns(
-            "/** @constructor*/",
-            "function Bar1() {}",
-            "/** @type {{x: number}} */",
-            "Bar1.prototype.prop;",
-            "/** @constructor */",
-            "function Bar() {}",
-            "/** @type {{x: number, y: number}} */",
-            "Bar.prototype.prop;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{x: number}} */ var f;", //
-            "f.z;")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IArrayLike<number>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType19a() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testTemplateMap6() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @constructor */",
-            "function Bar2() {}",
-            "/** @type {number} */",
-            "Bar2.prototype.prop;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {(Bar1|Bar2)} */ var b;", //
-            "var x = b.prop1")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IObject<number, number>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
         .includeDefaultExterns()
         .run();
   }
 
+  private static final String EXTERNS_WITH_IARRAYLIKE_DECLS =
+      "/**\n"
+          + " * @constructor @implements IArrayLike<number>\n"
+          + " */\n"
+          + "function Int8Array(length, opt_byteOffset, opt_length) {}\n"
+          + "/** @type {number} */\n"
+          + "Int8Array.prototype.length;\n"
+          + "/**\n"
+          + "* @constructor\n"
+          + "* @extends {Int8Array}\n"
+          + "*/\n"
+          + "function Int8Array2(len) {};\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<number>}\n"
+          + " */\n"
+          + "function IArrayLike2(){}\n"
+          + "\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike2}\n"
+          + " */\n"
+          + "function Int8Array3(len) {};\n"
+          + "/** @type {number} */\n"
+          + "Int8Array3.prototype.length;\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<VALUE3>}\n"
+          + " * @template VALUE3\n"
+          + " */\n"
+          + "function IArrayLike3(){}\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike3<number>}\n"
+          + " */\n"
+          + "function Int8Array4(length) {};\n"
+          + "/** @type {number} */\n"
+          + "Int8Array4.prototype.length;\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<VALUE2>}\n"
+          + " * @template VALUE2\n"
+          + " */\n"
+          + "function IArrayLike4(){}\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike4<boolean>}\n"
+          + " */\n"
+          + "function IArrayLike5(){}\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike5}\n"
+          + " */\n"
+          + "function BooleanArray5(length) {};\n"
+          + "/** @type {number} */\n"
+          + "BooleanArray5.prototype.length;";
+
   @Test
-  public void testCovarianceForRecordType19b() {
+  public void testArrayImplementsIArrayLike() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @constructor */",
-            "function Bar2() {}",
-            "/** @type {number} */",
-            "Bar2.prototype.prop;")
         .addSource(
-            "/** @type {(Bar1|Bar2)} */ var b;", //
-            "var x = b.prop1")
+            "/** @type {!Array<number>} */ var arr = [];\n" + "var /** null */ n = arr[0];\n")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: null")
         .run();
-    // TODO(johnlenz): enable this.
-    // "Property prop1 not defined on all member types of (Bar1|Bar2)"
   }
 
   @Test
-  public void testCovarianceForRecordType20() {
+  public void testIArrayLike1() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop2;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {(Bar1|{prop:number, prop2: number})} */ var b;",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = b.prop2")
-        .run();
-  }
-
-  @Test
-  public void testCovarianceForRecordType20_2() {
-    newTest()
+            "var arr = new Int8Array(7);\n" + "// no warning\n" + "arr[0] = 1;\n" + "arr[1] = 2;\n")
         .includeDefaultExterns()
-        .addSource(
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {({prop:number, prop1: number, prop2: number}|",
-            "{prop:number, prop2: number})} */ var b;",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = b.prop2")
-        .run();
-  }
-
-  @Test
-  public void testOptimizePropertyMap1() {
-    // For non object-literal types such as Function, the behavior doesn't change.
-    // The stray property is added as unknown.
-    newTest()
-        .addSource(
-            "/** @return {!Function} */",
-            "function f() {",
-            "  var x = function() {};",
-            "  /** @type {number} */",
-            "  x.prop = 123;",
-            "  return x;",
-            "}",
-            "function g(/** !Function */ x) {",
-            "  var /** null */ n = x.prop;",
-            "}")
-        .addDiagnostic("Property prop never defined on Function")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap1b() {
-    disableStrictMissingPropertyChecks();
-
-    // For non object-literal types such as Function, the behavior doesn't change.
-    // The stray property is added as unknown.
+  public void testIArrayLike2() {
     newTest()
-        .addSource(
-            "/** @return {!Function} */",
-            "function f() {",
-            "  var x = function() {};",
-            "  /** @type {number} */",
-            "  x.prop = 123;",
-            "  return x;",
-            "}",
-            "function g(/** !Function */ x) {",
-            "  var /** null */ n = x.prop;",
-            "}")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array(7);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap2() {
-    disableStrictMissingPropertyChecks();
-
-    // Don't add the inferred property to all Foo values.
+  public void testIArrayLike3() {
     newTest()
-        .addSource(
-            "/** @typedef {{a:number}} */",
-            "var Foo;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap2b() {
-    // Here strict missing properties warns, do we want it to?
+  public void testIArrayLike4() {
     newTest()
-        .addSource(
-            "/** @typedef {{a:number}} */",
-            "var Foo;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}")
-        .addDiagnostic("Property b never defined on y")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap3a() {
-    // For @record types, add the stray property to the index as before.
-    newTest()
-        .addSource(
-            "/** @record */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.a;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on Foo") // definition
-        .addDiagnostic("Property b never defined on Foo")
-        .run(); // reference
-  }
-
-  @Test
-  public void testOptimizePropertyMap3b() {
-    disableStrictMissingPropertyChecks();
-    // For @record types, add the stray property to the index as before.
+  public void testIArrayLike5() {
     newTest()
-        .addSource(
-            "/** @record */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.a;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array3(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap4() {
+  public void testIArrayLike6() {
     newTest()
-        .addSource(
-            "function f(x) {",
-            "  var y = { a: 1, b: 2 };",
-            "}",
-            "function g(x) {",
-            "  return x.b + 1;",
-            "}")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array4(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap5() {
-    // Tests that we don't declare the properties on Object (so they don't appear on
-    // all object types).
+  public void testIArrayLike7() {
     newTest()
-        .addSource(
-            "function f(x) {",
-            "  var y = { a: 1, b: 2 };",
-            "}",
-            "function g() {",
-            "  var x = { c: 123 };",
-            "  return x.a + 1;",
-            "}")
-        .addDiagnostic("Property a never defined on x")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr5 = new BooleanArray5(10);\n" + "arr5[2] = true;\n" + "arr5[3] = \"\";")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap6() {
-    // Checking loose property behavior
-    disableStrictMissingPropertyChecks();
-
-    // The stray property doesn't appear on other inline record types.
+  public void testIArrayLike8() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f(/** {a:number} */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** {c:number} */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+            "var arr2 = new Int8Array(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap7() {
+  public void testIArrayLike9() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {",
-            "  var x = {a:1};",
-            "  x.b = 2;",
-            "}",
-            "function g() {",
-            "  var y = {a:1};",
-            "  return y.b + 1;",
-            "}")
-        .addDiagnostic("Property b never defined on y")
+            "var arr2 = new Int8Array2(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap8() {
+  public void testIArrayLike10() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f(/** {a:number, b:number} */ x) {}",
-            "function g(/** {c:number} */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+            "var arr2 = new Int8Array3(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap9() {
-    // Checking loose property checks behavior
-    disableStrictMissingPropertyChecks();
-
-    // Don't add the stray property to all types that meet with {a: number, c: string}.
+  public void testIArrayLike11() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @constructor */",
-            "function Foo() {",
-            "  this.a = 123;",
-            "}",
-            "function f(/** {a: number, c: string} */ x) {",
-            "  x.b = 234;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  return x.b + 5;",
-            "}")
-        .addDiagnostic("Property b never defined on Foo")
+            "var arr2 = new Int8Array4(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType21() {
+  public void testIArrayLike12() {
     newTest()
-        .addExterns("")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @constructor */",
-            "function Bar1() {};",
-            "/** @type {number} */",
-            "Bar1.prototype.propName;",
-            "/** @type {number} */",
-            "Bar1.prototype.propName1;",
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {(Bar1|{propName:number, propName1: number})} */ var b;",
-            "var x = b.prop2;")
-        .addDiagnostic("Property prop2 never defined on b")
+            "var arr2 = new BooleanArray5(10);", //
+            "arr2['prop'] = true;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType23() {
+  public void testIArrayLike13() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function A() {}",
-            "/** @constructor @extends{A} */",
-            "function B() {}",
-            "",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @type {B} */",
-            "C.prototype.prop2;",
-            "/** @type {number} */",
-            "C.prototype.prop3;",
-            "",
-            "/** @constructor */",
-            "function D() {}",
-            "/** @type {number} */",
-            "D.prototype.prop;",
-            "/** @type {number} */",
-            "D.prototype.prop1;",
-            "/** @type {B} */",
-            "D.prototype.prop2;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{prop2: A}} */ var record;",
-            "var xhr = new C();",
-            "if (true) { xhr = new D(); }",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = xhr.prop2")
+            "var numOrStr = null ? 0 : 'prop';",
+            "var arr2 = new BooleanArray5(10);",
+            "arr2[numOrStr] = true;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : (number|string)",
+                "required: number"))
         .run();
   }
 
+
   @Test
-  public void testCovarianceForRecordType24() {
+  public void testIArrayLikeStructuralMatch1() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** @type {!Function} */",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function, count: number}} */",
-            "  var x;",
-            "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{abort: Function})} */",
-            "  var y;",
-            "  y.abort();",
-            "}")
+            "function f(/** !IArrayLike */ x){};",
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */ Foo.prototype.length",
+            "f(new Foo)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType25() {
+  public void testIArrayLikeStructuralMatch2() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** @type {!Function} */",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
         .addSource(
-            "function f() {",
-            "  /** @type{!Function} */ var f;",
-            "  var x = {abort: f, count: 1}",
-            "  return x;",
+            "function f(/** !IArrayLike */ x){};",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.length = 5;",
             "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{test2: number})} */",
-            "  var y;",
-            "  y.abort();",
-            "}")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+            "f(new Foo)")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType26() {
+  public void testIArrayLikeStructuralMatch3() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function}} */",
-            "  var x;",
-            "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{test2: number})} */",
-            "  var y;",
-            "  /** @type {C} */ (y).abort();",
-            "}")
+            "function f(/** !IArrayLike */ x){};", //
+            "f({length: 5})")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType26AndAHalf() {
+  public void testIArrayLikeStructuralMatch4() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;",
-            "var g = function /** !C */(){};")
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function}} */",
-            "  var x;",
-            "}",
-            "function f2() {",
-            "  var y = g();",
-            "  y.abort();",
-            "}")
+            "function f(/** !IArrayLike */ x){};",
+            "/** @const */ var ns = {};",
+            "/** @type {number} */ ns.length",
+            "f(ns)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType27() {
+  public void testIArrayLikeStructuralMatch5() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C(){}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop2:C}} */ var c;",
-            "/** @type {({prop:number, prop1: number, prop2: C}|",
-            "{prop:number, prop1: number, prop2: number})} */ var b;",
-            "var x = b.prop2;")
+        .addSource(
+            "function f(/** !IArrayLike */ x){};",
+            "var ns = function() {};",
+            "/** @type {number} */ ns.length",
+            "f(ns)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType28() {
+  public void testIArrayLikeStructuralMatch6() {
+    // Even though Foo's [] element type may not be string, we treat the lack
+    // of explicit type like ? and allow this.
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function XMLHttpRequest() {}",
-            "/**",
-            " * @return {undefined}",
-            " */",
-            "XMLHttpRequest.prototype.abort = function() {};",
-            "",
-            "/** @constructor */",
-            "function XDomainRequest() {}",
-            "",
-            "XDomainRequest.prototype.abort = function() {};")
         .addSource(
-            "/**",
-            " * @typedef {{abort: !Function, close: !Function}}",
-            " */",
-            "var WritableStreamSink;",
-            "function sendCrossOrigin() {",
-            "  var xhr = new XMLHttpRequest;",
-            "  xhr = new XDomainRequest;",
-            "  return function() {",
-            "    xhr.abort();",
-            "  };",
-            "}")
+            "function f(/** !IArrayLike<string> */ x){};",
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */ Foo.prototype.length",
+            "f(new Foo)")
         .includeDefaultExterns()
         .run();
   }
 
+  private static final String EXTERNS_WITH_IOBJECT_DECLS =
+      lines(
+          "/**",
+          " * @constructor",
+          " * @implements IObject<(string|number), number>",
+          " */",
+          "function Object2() {}",
+          "/**",
+          " * @constructor @struct",
+          " * @implements IObject<number, number>",
+          " */",
+          "function Object3() {}");
+
   @Test
-  public void testCovarianceForRecordType29() {
+  public void testIObject1() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function XMLHttpRequest() {}",
-            "/**",
-            " * @type {!Function}",
-            " */",
-            "XMLHttpRequest.prototype.abort = function() {};",
-            "",
-            "/** @constructor */",
-            "function XDomainRequest() {}",
-            "/**",
-            " * @type {!Function}",
-            " */",
-            "XDomainRequest.prototype.abort = function() {};")
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/**",
-            " * @typedef {{close: !Function, abort: !Function}}",
-            " */",
-            "var WritableStreamSink;",
-            "function sendCrossOrigin() {",
-            "  var xhr = new XMLHttpRequest;",
-            "  xhr = new XDomainRequest;",
-            "  return function() {",
-            "    xhr.abort();",
-            "  };",
-            "}")
+            "var arr2 = new Object2();", //
+            "arr2[0] = 1;")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType30() {
+  public void testIObject2() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function A() {}")
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/**",
-            " * @type {{prop1: (A)}}",
-            " */",
-            "var r1;",
-            "/**",
-            " * @type {{prop1: (A|undefined)}}",
-            " */",
-            "var r2;",
-            "r1 = r2")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop1: (A|null|undefined)}",
-                "required: {prop1: (A|null)}",
-                "missing : []",
-                "mismatch: [prop1]"))
+            "var arr2 = new Object2();", //
+            "arr2['str'] = 1;")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType31() {
+  public void testIObject3() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function A() {}")
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/**",
-            " * @type {{prop1: (A|null)}}",
-            " */",
-            "var r1;",
-            "/**",
-            " * @type {{prop1: (A|null|undefined)}}",
-            " */",
-            "var r2;",
-            "r1 = r2")
+            "var arr2 = new Object2();", //
+            "arr2[true] = 1;")
         .addDiagnostic(
             lines(
-                "assignment",
-                "found   : {prop1: (A|null|undefined)}",
-                "required: {prop1: (A|null)}",
-                "missing : []",
-                "mismatch: [prop1]"))
-        .run();
-  }
-
-  @Test
-  public void testDuplicateVariableDefinition1() {
-    newTest()
-        .addSource(
-            "/** @record */",
-            "function A() {}",
-            "/** @type {number} */",
-            "A.prototype.prop;",
-            "/** @record */",
-            "function B() {}",
-            "/** @type {number} */",
-            "B.prototype.prop;",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @type {number} */",
-            "C.prototype.prop;",
-            "/** @return {(A|B|C)} */",
-            "function fun () {}",
-            "/** @return {(B|A|C)} */",
-            "function fun () {}")
-        .addDiagnostic("variable fun redefined, original definition at [testcode]:14")
+                "restricted index type", //
+                "found   : boolean",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3() {
+  public void testIObject4() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};", //
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:number}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[function(){}] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type",
+                "found   : function(): undefined",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3_1() {
+  public void testIObject5() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};", //
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:string}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[{}] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type {x: string}, original definition "
-                + "at [testcode]:2 with type {x: number}")
+            lines(
+                "restricted index type", //
+                "found   : {}",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3_2() {
+  public void testIObject6() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:number, y:boolean}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[undefined] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type {\n  x: number,\n  y: boolean\n}, "
-                + "original definition at [testcode]:2 with type {x: number}")
+            lines(
+                "restricted index type", //
+                "found   : undefined",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition4() {
+  public void testIObject7() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @record */ function rec4(){}",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[null] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at [testcode]:4 with type"
-                + " rec3")
+            lines(
+                "restricted index type", //
+                "found   : null",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition5() {
+  public void testIObject8() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @record */ function rec4(){}",
-            "/** @type {number} */ rec4.prototype.prop;",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
+            "var arr = new Object2();", //
+            "/** @type {boolean} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at "
-                + "[testcode]:5 with type rec3")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition6() {
+  public void testIObject9() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @type {number} */ rec3.prototype.prop;",
-            "/** @record */ function rec4(){}",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at "
-                + "[testcode]:5 with type rec3")
+            "var arr = new Object2();", //
+            "/** @type {(number|string)} */",
+            "var x = arr[3];")
+        .includeDefaultExterns()
         .run();
   }
 
-  /** check bug fix 22713201 (the first case) */
   @Test
-  public void testDuplicateVariableDefinition7() {
+  public void testIObject10() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @typedef {{prop:TD2}} */",
-            "  var TD1;",
-            "",
-            "  /** @typedef {{prop:TD1}} */",
-            "  var TD2;",
-            "",
-            "  var /** TD1 */ td1;",
-            "  var /** TD2 */ td2;",
-            "",
-            "  td1 = td2;")
+            "var arr = new Object3();", //
+            "/** @type {number} */",
+            "var x = arr[3];")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8() {
+  public void testIObject11() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {number} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:number}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: number}, original definition at [testcode]:5"
-                + " with type rec")
+            "var arr = new Object3();", //
+            "/** @type {boolean} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
-                + " {prop: number}")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_2() {
+  public void testIObject12() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {number} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:string}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: string}, original "
-                + "definition at [testcode]:5 with type rec")
+            "var arr = new Object3();", //
+            "/** @type {string} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
-                + " {prop: number}")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_3() {
+  public void testIObject13() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {string} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:string}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: string}, original definition at [testcode]:5"
-                + " with type rec")
+            "var arr = new Object3();", //
+            "arr[3] = false;")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at "
-                + "[testcode]:8 with type {prop: number}")
+            lines(
+                "assignment", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_4() {
+  public void testIObject14() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I}} */ ns.x;")
+            "var arr = new Object3();", //
+            "arr[3] = 'value';")
         .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I|null)}, original definition at"
-                + " [testcode]:7 with type rec")
+            lines(
+                "assignment", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_5() {
+  public void testIObject15() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I<number>} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I<number>}} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I<number>|null)}, original definition at"
-                + " [testcode]:7 with type rec")
+            "function f(/** !Object<string, string> */ x) {}",
+            "var /** !IObject<string, string> */ y;",
+            "f(y);")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_6() {
+  public void testIObject16() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I<number>} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I<string>}} */ ns.x;")
+            "function f(/** !Object<string, string> */ x) {}",
+            "var /** !IObject<string, number> */ y;",
+            "f(y);")
         .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I<string>|null)}, "
-                + "original definition at [testcode]:7 with type rec")
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : IObject<string,number>",
+                "required: Object<string,string>"))
         .run();
   }
 
-  // should have no warning, need to handle equivalence checking for
-  // structural types with template types
   @Test
-  public void testDuplicateVariableDefinition8_7() {
+  public void testEmptySubtypeRecord1() {
+    // Verify that empty @record subtypes don't cause circular definition warnings.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function rec(){}",
-            "/** @type {T} */ rec.prototype.value;",
+            "/** @record */ function I1() {};",
+            "/** @type {number|undefined} */ I1.prototype.prop;",
             "",
-            "/** @type {rec<string>} */ ns.x;",
-            "/** @type {{value: string}} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {value: string}, "
-                + "original definition at [testcode]:5 with type (null|rec<string>)")
+            "/** @record @extends {I1} */ function I2() {}",
+            "/** @record @extends {I2} */ function I3() {}",
+            "/** @type {string} */ I3.prototype.prop2;",
+            "/** @constructor @implements {I3} */ function C() {",
+            "    /** @type {number} */ this.prop = 1;",
+            "    /** @type {string} */ this.prop2 = 'str';",
+            "}",
+            "",
+            "/** @param {I3} a */ function fn(a) {}")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules1() {
+  public void testEmptySubtypeRecord2() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "function f(/** function(?Foo, !Foo) */ x) {",
-            "  return /** @type {function(!Foo, ?Foo)} */ (x);",
-            "}")
+            "/** @type {!SubInterface} */ var value;",
+            "/** @record */ var SuperInterface = function () {};",
+            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules2() {
+  public void testEmptySubtypeRecord3() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "function f(/** !Array<!Foo> */ to, /** !Array<?Foo> */ from) {",
-            "  to = from;",
-            "}")
+            "/** @record */ var SuperInterface = function () {};",
+            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};",
+            "/** @type {!SubInterface} */ var value;")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules3() {
+  public void testEmptySubtypeInterface1() {
     newTest()
         .addSource(
-            "function f(/** ?Object */ x) {", //
-            "  return {} instanceof x;",
-            "}")
+            "/** @type {!SubInterface} */ var value;",
+            "/** @interface */ var SuperInterface = function () {};",
+            "/** @interface @extends {SuperInterface} */ var SubInterface = function() {};")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules4() {
+  public void testRecordWithOptionalProperty() {
     newTest()
         .addSource(
-            "function f(/** ?Function */ x) {", //
-            "  return x();",
-            "}")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, opt_num: (undefined|number)} */ x = new Foo;")
         .run();
   }
 
   @Test
-  public void testEs5ClassExtendingEs6Class() {
+  public void testRecordWithUnknownProperty() {
     newTest()
         .addSource(
-            "class Foo {}", //
-            "/** @constructor @extends {Foo} */ var Bar = function() {};")
-        .addDiagnostic("ES5 class Bar cannot extend ES6 class Foo")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, unknown: ?} */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: {\n  str: string,\n  unknown: ?\n}",
+                "missing : [unknown]",
+                "mismatch: []"))
         .run();
   }
 
   @Test
-  public void testEs5ClassExtendingEs6Class_noWarning() {
+  public void testRecordWithOptionalUnknownProperty() {
     newTest()
         .addSource(
-            "class A {}", //
-            "/** @constructor @extends {A} */",
-            "const B = createSubclass(A);")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, opt_unknown: (?|undefined)} */ x = new Foo;")
         .run();
   }
 
   @Test
-  public void testNonNullTemplatedThis() {
+  public void testRecordWithTopProperty() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** ",
-            "  @return {THIS} ",
-            "  @this {THIS}",
-            "  @template THIS",
-            "*/",
-            "C.prototype.method = function() {};",
-            "",
-            "/** @return {C|null} */",
-            "function f() {",
-            "  return x;",
-            "};",
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
             "",
-            "/** @type {string} */ var s = f().method();")
-        .addDiagnostic("initializing variable\n" + "found   : C\n" + "required: string")
+            "var /** {str: string, top: *} */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: {\n  str: string,\n  top: *\n}",
+                "missing : [top]",
+                "mismatch: []"))
         .run();
   }
 
-  // Github issue #2222: https://github.com/google/closure-compiler/issues/2222
   @Test
-  public void testSetPrototypeToNewInstance() {
+  public void testOptionalUnknownIsAssignableToUnknown() {
     newTest()
         .addSource(
-            "/** @constructor */", //
-            "function C() {}",
-            "C.prototype = new C;")
+            "function f(/** (undefined|?) */ opt_unknown) {",
+            "  var /** ? */ unknown = opt_unknown;",
+            "}")
         .run();
   }
 
-  @Test
-  public void testFilterNoResolvedType() {
-    testClosureTypes(
-        lines(
-            "goog.forwardDeclare('Foo');",
-            "/**",
-            " * @param {boolean} pred",
-            " * @param {?Foo} x",
-            " */",
-            "function f(pred, x) {",
-            "  var y;",
-            "  if (pred) {",
-            "    y = null;",
-            "  } else {",
-            "    y = x;",
-            "  }",
-            "  var /** number */ z = y;",
-            "}"),
-        // Tests that the type of y is (NoResolvedType|null) and not (Foo|null)
-        lines(
-            "initializing variable", //
-            "found   : (NoResolvedType|null)",
-            "required: number"));
-  }
 
   @Test
-  public void testNoResolvedTypeDoesntCauseInfiniteLoop() {
-    testClosureTypes(
-        lines(
-            "goog.forwardDeclare('Foo');",
-            "goog.forwardDeclare('Bar');",
-            "",
-            "/** @interface */",
-            "var Baz = function() {};",
-            "/** @return {!Bar} */",
-            "Baz.prototype.getBar = function() {};",
-            "/** @constructor */",
-            "var Qux = function() {",
-            "  /** @type {?Foo} */",
-            "  this.jobRuntimeTracker_ = null;",
-            "};",
-            "/** @param {!Baz} job */",
-            "Qux.prototype.runRenderJobs_ = function(job) {",
-            "  for (var i = 0; i < 10; i++) {",
-            "    if (this.jobRuntimeTracker_) {",
-            "      goog.asserts.assert(job.getBar, '');",
-            "    }",
-            "  }",
-            "};"),
-        null);
+  public void testOptimizePropertyMap1() {
+    // For non object-literal types such as Function, the behavior doesn't change.
+    // The stray property is added as unknown.
+    newTest()
+        .addSource(
+            "/** @return {!Function} */",
+            "function f() {",
+            "  var x = function() {};",
+            "  /** @type {number} */",
+            "  x.prop = 123;",
+            "  return x;",
+            "}",
+            "function g(/** !Function */ x) {",
+            "  var /** null */ n = x.prop;",
+            "}")
+        .addDiagnostic("Property prop never defined on Function")
+        .run();
   }
 
   @Test
-  public void testb38182645() {
+  public void testOptimizePropertyMap1b() {
+    disableStrictMissingPropertyChecks();
+
+    // For non object-literal types such as Function, the behavior doesn't change.
+    // The stray property is added as unknown.
     newTest()
         .addSource(
-            "",
-            "/**",
-            " * @interface",
-            " * @template VALUE",
-            " */",
-            "function MyI() {}",
-            "",
-            "",
-            "/**",
-            " * @constructor",
-            " * @implements {MyI<K|V>}",
-            " * @template K, V",
-            " */",
-            "function MyMap() {}",
-            "",
-            "",
-            "/**",
-            " * @param {!MyMap<string, T>} map",
-            " * @return {T}",
-            " * @template T",
-            " */",
-            "function getValueFromNameAndMap(map) {",
-            "  return /** @type {?} */ (123);",
+            "/** @return {!Function} */",
+            "function f() {",
+            "  var x = function() {};",
+            "  /** @type {number} */",
+            "  x.prop = 123;",
+            "  return x;",
             "}",
-            "var m = /** @type {!MyMap<string,number>} */ (new MyMap());",
-            "var /** null */ n = getValueFromNameAndMap(m);")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "function g(/** !Function */ x) {",
+            "  var /** null */ n = x.prop;",
+            "}")
         .run();
   }
 
   @Test
-  public void testLocalType1() {
+  public void testOptimizePropertyMap2() {
+    disableStrictMissingPropertyChecks();
+
+    // Don't add the inferred property to all Foo values.
     newTest()
         .addSource(
-            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
-            "function f() {",
-            "  // shadow",
-            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "/** @typedef {{a:number}} */",
+            "var Foo;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
             "}")
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testLocalType2() {
+  public void testOptimizePropertyMap2b() {
+    // Here strict missing properties warns, do we want it to?
     newTest()
         .addSource(
-            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
-            "function f() {",
-            "  // shadow",
-            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
-            "  /** @type {null} */ var x = new C().a;",
+            "/** @typedef {{a:number}} */",
+            "var Foo;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
             "}")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+        .addDiagnostic("Property b never defined on y")
         .run();
   }
 
   @Test
-  public void testForwardDecl1() {
+  public void testOptimizePropertyMap3a() {
+    // For @record types, add the stray property to the index as before.
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.Outer = function C() {};",
-            "/** @return {!ns.Outer.Inner} */",
-            "ns.Outer.prototype.method = function() {",
-            "  return new ns.Outer.Inner();",
-            "};",
-            "/** @constructor */ ns.Outer.Inner = function () {};")
-        .run();
+            "/** @record */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.a;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on Foo") // definition
+        .addDiagnostic("Property b never defined on Foo")
+        .run(); // reference
   }
 
   @Test
-  public void testForwardDecl2() {
+  public void testOptimizePropertyMap3b() {
+    disableStrictMissingPropertyChecks();
+    // For @record types, add the stray property to the index as before.
     newTest()
         .addSource(
-            "/** @const */ var ns1 = {};",
-            "/** @const */ ns1.ns2 = {};",
-            "/** @constructor */ ns1.ns2.Outer = function C() {};",
-            "/** @return {!ns1.ns2.Outer.Inner} */",
-            "ns1.ns2.Outer.prototype.method = function() {",
-            "  return new ns1.ns2.Outer.Inner();",
-            "};",
-            "/** @constructor */ ns1.ns2.Outer.Inner = function () {};")
+            "/** @record */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.a;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
         .run();
   }
 
   @Test
-  public void testMissingPropertiesWarningOnObject1() {
+  public void testOptimizePropertyMap4() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {",
-            "  this.prop = 123;",
-            "}",
-            "/** @param {!Object} x */",
             "function f(x) {",
-            "  return x.prop;",
+            "  var y = { a: 1, b: 2 };",
+            "}",
+            "function g(x) {",
+            "  return x.b + 1;",
             "}")
-        .addDiagnostic("Property prop never defined on Object")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators1() {
+  public void testOptimizePropertyMap5() {
+    // Tests that we don't declare the properties on Object (so they don't appear on
+    // all object types).
     newTest()
-        .addSource("var x = 'asdf' - 1;")
-        .addDiagnostic(
-            lines(
-                "left operand", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(x) {",
+            "  var y = { a: 1, b: 2 };",
+            "}",
+            "function g() {",
+            "  var x = { c: 123 };",
+            "  return x.a + 1;",
+            "}")
+        .addDiagnostic("Property a never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators2() {
-    newTest()
-        .addSource("var x = 1 - 'asdf';")
-        .addDiagnostic(
-            lines(
-                "right operand", //
-                "found   : string",
-                "required: number"))
-        .run();
-  }
+  public void testOptimizePropertyMap6() {
+    // Checking loose property behavior
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testStrictNumericOperators3() {
+    // The stray property doesn't appear on other inline record types.
     newTest()
-        .addSource("var x = 'asdf'; x++;")
-        .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(/** {a:number} */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** {c:number} */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators4a() {
+  public void testOptimizePropertyMap7() {
     newTest()
-        .addSource("var x = -'asdf';")
-        .addDiagnostic(
-            lines(
-                "sign operator", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f() {",
+            "  var x = {a:1};",
+            "  x.b = 2;",
+            "}",
+            "function g() {",
+            "  var y = {a:1};",
+            "  return y.b + 1;",
+            "}")
+        .addDiagnostic("Property b never defined on y")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators4b() {
-    newTest().addSource("var x = +'asdf';").run();
-  }
-
-  @Test
-  public void testStrictNumericOperators5() {
+  public void testOptimizePropertyMap8() {
     newTest()
-        .addSource("var x = 1 < 'asdf';")
-        .addDiagnostic(
-            lines(
-                "right side of numeric comparison",
-                "found   : string",
-                "required: (bigint|number)"))
+        .addSource(
+            "function f(/** {a:number, b:number} */ x) {}",
+            "function g(/** {c:number} */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators6() {
-    newTest()
-        .addSource("var x = 'asdf'; x *= 2;")
-        .addDiagnostic(
-            lines(
-                "left operand", //
-                "found   : string",
-                "required: number"))
-        .run();
-  }
+  public void testOptimizePropertyMap9() {
+    // Checking loose property checks behavior
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testStrictNumericOperators7() {
+    // Don't add the stray property to all types that meet with {a: number, c: string}.
     newTest()
-        .addSource("var x = ~ 'asdf';")
-        .addDiagnostic(
-            lines(
-                "bitwise NOT", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {",
+            "  this.a = 123;",
+            "}",
+            "function f(/** {a: number, c: string} */ x) {",
+            "  x.b = 234;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  return x.b + 5;",
+            "}")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
+
   @Test
-  public void testStrictNumericOperators8() {
+  public void testDuplicateVariableDefinition1() {
     newTest()
-        .addSource("var x = 'asdf' | 1;")
-        .addDiagnostic(
-            lines(
-                "bad left operand to bitwise operator", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "/** @record */",
+            "function A() {}",
+            "/** @type {number} */",
+            "A.prototype.prop;",
+            "/** @record */",
+            "function B() {}",
+            "/** @type {number} */",
+            "B.prototype.prop;",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @type {number} */",
+            "C.prototype.prop;",
+            "/** @return {(A|B|C)} */",
+            "function fun () {}",
+            "/** @return {(B|A|C)} */",
+            "function fun () {}")
+        .addDiagnostic("variable fun redefined, original definition at [testcode]:14")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators9() {
+  public void testDuplicateVariableDefinition3() {
     newTest()
-        .addSource("var x = 'asdf' << 1;")
-        .addDiagnostic(
-            lines(
-                "operator <<", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "var ns = {};", //
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:number}} */ ns.x;")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators10() {
+  public void testDuplicateVariableDefinition3_1() {
     newTest()
-        .addSource("var x = 1 >>> 'asdf';")
+        .addSource(
+            "var ns = {};", //
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:string}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "operator >>>", //
-                "found   : string",
-                "required: number"))
+            "variable ns.x redefined with type {x: string}, original definition "
+                + "at [testcode]:2 with type {x: number}")
         .run();
   }
 
   @Test
-  public void testBigIntArgument() {
-    newTest().addSource("BigInt(1)").run();
+  public void testDuplicateVariableDefinition3_2() {
     newTest()
-        .addSource("BigInt({})")
+        .addSource(
+            "var ns = {};",
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:number, y:boolean}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of BigInt does not match formal parameter",
-                "found   : {}",
-                "required: (bigint|number|string)"))
+            "variable ns.x redefined with type {\n  x: number,\n  y: boolean\n}, "
+                + "original definition at [testcode]:2 with type {x: number}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_increment() {
-    newTest().addSource("const x = 1n; x++;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; x++;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; x++;").run();
+  public void testDuplicateVariableDefinition4() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; x++;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @record */ function rec4(){}",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at [testcode]:4 with type"
+                + " rec3")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_decrement() {
-    newTest().addSource("const x = 1n; x--;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; x--;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; x--;").run();
+  public void testDuplicateVariableDefinition5() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; x--;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @record */ function rec4(){}",
+            "/** @type {number} */ rec4.prototype.prop;",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at "
+                + "[testcode]:5 with type rec3")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_logicalNot() {
-    newTest().addSource("const x = 1n; !x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; !x;").run();
-    newTest().addSource("/** @type {bigint|string} */var x; !x;").run();
-  }
-
-  @Test
-  public void testBigIntOperators_bitwiseNot() {
-    newTest().addSource("const x = 1n; ~x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; ~x;").run();
-    newTest().addSource("/** @type {?} */var x; ~x;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; ~x;").run();
+  public void testDuplicateVariableDefinition6() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; ~x;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @type {number} */ rec3.prototype.prop;",
+            "/** @record */ function rec4(){}",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "bitwise NOT", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at "
+                + "[testcode]:5 with type rec3")
         .run();
   }
 
+  /** check bug fix 22713201 (the first case) */
   @Test
-  public void testBigIntValueOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition7() {
     newTest()
-        .addSource("var x = 1n; +x;")
-        .addDiagnostic("unary operator + cannot be applied to bigint")
+        .addSource(
+            "/** @typedef {{prop:TD2}} */",
+            "  var TD1;",
+            "",
+            "  /** @typedef {{prop:TD1}} */",
+            "  var TD2;",
+            "",
+            "  var /** TD1 */ td1;",
+            "  var /** TD2 */ td2;",
+            "",
+            "  td1 = td2;")
         .run();
   }
 
   @Test
-  public void testBigIntObjectOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8() {
     newTest()
-        .addSource("/** @type {!BigInt} */ var x; +x;")
-        .addDiagnostic("unary operator + cannot be applied to BigInt")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {number} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:number}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: number}, original definition at [testcode]:5"
+                + " with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
+                + " {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntUnionOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8_2() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; +x;")
-        .addDiagnostic("unary operator + cannot be applied to (bigint|number)")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {number} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:string}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: string}, original "
+                + "definition at [testcode]:5 with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
+                + " {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8_3() {
     newTest()
-        .addSource("/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; +BIGINTS.ONE;")
-        .addDiagnostic("unary operator + cannot be applied to BIGINTS<bigint>")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {string} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:string}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: string}, original definition at [testcode]:5"
+                + " with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at "
+                + "[testcode]:8 with type {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_unaryMinus() {
-    newTest().addSource("const x = 1n; -x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; -x;").run();
-    newTest().addSource("/** @type {?} */var x; -x;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; -x;").run();
+  public void testDuplicateVariableDefinition8_4() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; -x;")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "unary minus operator", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type {prop: (I|null)}, original definition at"
+                + " [testcode]:7 with type rec")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryOperationWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x * y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_assignOpWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x *= y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_binaryBitwiseOperationWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x | y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_additionWithString() {
-    newTest().addSource("const x = 1n; const y = 'str'; x + y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_assignAddWithString() {
-    newTest().addSource("const x = 1n; const y = 'str'; x += y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_binaryOperationWithString() {
+  public void testDuplicateVariableDefinition8_5() {
     newTest()
-        .addSource("const x = 1n; const y = 'str'; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and string")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I<number>} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I<number>}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: (I<number>|null)}, original definition at"
+                + " [testcode]:7 with type rec")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithString() {
+  public void testDuplicateVariableDefinition8_6() {
     newTest()
-        .addSource("const x = 1n; const y = 'str'; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and string")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I<number>} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I<string>}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: (I<string>|null)}, "
+                + "original definition at [testcode]:7 with type rec")
         .run();
   }
 
+  // should have no warning, need to handle equivalence checking for
+  // structural types with template types
   @Test
-  public void testBigIntOperators_binaryOperationWithUnknown() {
+  public void testDuplicateVariableDefinition8_7() {
     newTest()
-        .addSource("var x = 1n; /** @type {?} */var y; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and ?")
+        .addSource(
+            "/** @record @template T */",
+            "function rec(){}",
+            "/** @type {T} */ rec.prototype.value;",
+            "",
+            "/** @type {rec<string>} */ ns.x;",
+            "/** @type {{value: string}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {value: string}, "
+                + "original definition at [testcode]:5 with type (null|rec<string>)")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithUnknown() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules1() {
     newTest()
-        .addSource("var x = 1n; /** @type {?} */var y; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and ?")
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {}",
+            "function f(/** function(?Foo, !Foo) */ x) {",
+            "  return /** @type {function(!Foo, ?Foo)} */ (x);",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryOperationWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules2() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and number")
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {}",
+            "function f(/** !Array<!Foo> */ to, /** !Array<?Foo> */ from) {",
+            "  to = from;",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules3() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and number")
+        .addSource(
+            "function f(/** ?Object */ x) {", //
+            "  return {} instanceof x;",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryBitwiseOperationWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules4() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x | y")
-        .addDiagnostic("operator | cannot be applied to bigint and number")
+        .addSource(
+            "function f(/** ?Function */ x) {", //
+            "  return x();",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntLeftShift() {
-    newTest().addSource("1n << 2n").run();
-    newTest().addSource("let x = 1n; x <<= 2n").run();
-  }
-
-  @Test
-  public void testBigIntRightShift() {
-    newTest().addSource("2n >> 1n").run();
-    newTest().addSource("let x = 2n; x >>= 1n").run();
-  }
-
-  @Test
-  public void testBigIntOperators_unsignedRightShift() {
+  public void testEs5ClassExtendingEs6Class() {
     newTest()
-        .addSource("const x = 1n; x >>> x;")
-        .addDiagnostic("operator >>> cannot be applied to bigint and bigint")
+        .addSource(
+            "class Foo {}", //
+            "/** @constructor @extends {Foo} */ var Bar = function() {};")
+        .addDiagnostic("ES5 class Bar cannot extend ES6 class Foo")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignUnsignedRightShift() {
+  public void testEs5ClassExtendingEs6Class_noWarning() {
     newTest()
-        .addSource("let x = 1n; x >>>= x;")
-        .addDiagnostic("operator >>>= cannot be applied to bigint and bigint")
+        .addSource(
+            "class A {}", //
+            "/** @constructor @extends {A} */",
+            "const B = createSubclass(A);")
         .run();
   }
 
   @Test
-  public void testBigIntOrNumberOperators_binaryOperationWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x * x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_assignOpWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x *= x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x | x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_binaryOperationWithBigInt() {
+  public void testNonNullTemplatedThis() {
     newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x * y;")
-        .addDiagnostic("operator * cannot be applied to bigint and (bigint|number)")
+        .addSource(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** ",
+            "  @return {THIS} ",
+            "  @this {THIS}",
+            "  @template THIS",
+            "*/",
+            "C.prototype.method = function() {};",
+            "",
+            "/** @return {C|null} */",
+            "function f() {",
+            "  return x;",
+            "};",
+            "",
+            "/** @type {string} */ var s = f().method();")
+        .addDiagnostic("initializing variable\n" + "found   : C\n" + "required: string")
         .run();
   }
 
+  // Github issue #2222: https://github.com/google/closure-compiler/issues/2222
   @Test
-  public void testBigIntOrNumberOperators_assignOpWithBigInt() {
+  public void testSetPrototypeToNewInstance() {
     newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to bigint and (bigint|number)")
+        .addSource(
+            "/** @constructor */", //
+            "function C() {}",
+            "C.prototype = new C;")
         .run();
   }
 
   @Test
-  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithBigInt() {
-    newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x | y;")
-        .addDiagnostic("operator | cannot be applied to bigint and (bigint|number)")
-        .run();
+  public void testFilterNoResolvedType() {
+    testClosureTypes(
+        lines(
+            "goog.forwardDeclare('Foo');",
+            "/**",
+            " * @param {boolean} pred",
+            " * @param {?Foo} x",
+            " */",
+            "function f(pred, x) {",
+            "  var y;",
+            "  if (pred) {",
+            "    y = null;",
+            "  } else {",
+            "    y = x;",
+            "  }",
+            "  var /** number */ z = y;",
+            "}"),
+        // Tests that the type of y is (NoResolvedType|null) and not (Foo|null)
+        lines(
+            "initializing variable", //
+            "found   : (NoResolvedType|null)",
+            "required: number"));
   }
 
   @Test
-  public void testBigIntOrNumberOperators_unsignedRightShift() {
-    newTest()
-        .addSource("/** @type {bigint|number} */ var x = 1n; x >>> x;")
-        .addDiagnostic("operator >>> cannot be applied to (bigint|number) and (bigint|number)")
-        .run();
+  public void testNoResolvedTypeDoesntCauseInfiniteLoop() {
+    testClosureTypes(
+        lines(
+            "goog.forwardDeclare('Foo');",
+            "goog.forwardDeclare('Bar');",
+            "",
+            "/** @interface */",
+            "var Baz = function() {};",
+            "/** @return {!Bar} */",
+            "Baz.prototype.getBar = function() {};",
+            "/** @constructor */",
+            "var Qux = function() {",
+            "  /** @type {?Foo} */",
+            "  this.jobRuntimeTracker_ = null;",
+            "};",
+            "/** @param {!Baz} job */",
+            "Qux.prototype.runRenderJobs_ = function(job) {",
+            "  for (var i = 0; i < 10; i++) {",
+            "    if (this.jobRuntimeTracker_) {",
+            "      goog.asserts.assert(job.getBar, '');",
+            "    }",
+            "  }",
+            "};"),
+        null);
   }
 
   @Test
-  public void testBigIntOrNumberOperators_assignUnsignedRightShift() {
+  public void testb38182645() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x = 1n; x >>>= x;")
-        .addDiagnostic("operator >>>= cannot be applied to (bigint|number) and (bigint|number)")
+        .addSource(
+            "",
+            "/**",
+            " * @interface",
+            " * @template VALUE",
+            " */",
+            "function MyI() {}",
+            "",
+            "",
+            "/**",
+            " * @constructor",
+            " * @implements {MyI<K|V>}",
+            " * @template K, V",
+            " */",
+            "function MyMap() {}",
+            "",
+            "",
+            "/**",
+            " * @param {!MyMap<string, T>} map",
+            " * @return {T}",
+            " * @template T",
+            " */",
+            "function getValueFromNameAndMap(map) {",
+            "  return /** @type {?} */ (123);",
+            "}",
+            "var m = /** @type {!MyMap<string,number>} */ (new MyMap());",
+            "var /** null */ n = getValueFromNameAndMap(m);")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_binaryOperationWithBigInt() {
+  public void testLocalType1() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x * y;")
-        .addDiagnostic("operator * cannot be applied to (bigint|string) and bigint")
+        .addSource(
+            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
+            "function f() {",
+            "  // shadow",
+            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_assignOpWithBigInt() {
+  public void testLocalType2() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to (bigint|string) and bigint")
+        .addSource(
+            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
+            "function f() {",
+            "  // shadow",
+            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "  /** @type {null} */ var x = new C().a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_binaryOperationWithBigIntOrNumber() {
+  public void testForwardDecl1() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x * y;")
-        .addDiagnostic("operator * cannot be applied to (bigint|string) and (bigint|number)")
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @constructor */ ns.Outer = function C() {};",
+            "/** @return {!ns.Outer.Inner} */",
+            "ns.Outer.prototype.method = function() {",
+            "  return new ns.Outer.Inner();",
+            "};",
+            "/** @constructor */ ns.Outer.Inner = function () {};")
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_assignOpWithBigIntOrNumber() {
+  public void testForwardDecl2() {
     newTest()
         .addSource(
-            "/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to (bigint|string) and (bigint|number)")
+            "/** @const */ var ns1 = {};",
+            "/** @const */ ns1.ns2 = {};",
+            "/** @constructor */ ns1.ns2.Outer = function C() {};",
+            "/** @return {!ns1.ns2.Outer.Inner} */",
+            "ns1.ns2.Outer.prototype.method = function() {",
+            "  return new ns1.ns2.Outer.Inner();",
+            "};",
+            "/** @constructor */ ns1.ns2.Outer.Inner = function () {};")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_binaryOperationWithSelf() {
+  public void testMissingPropertiesWarningOnObject1() {
     newTest()
         .addSource(
-            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE * BIGINTS.TWO;")
+            "/** @constructor */",
+            "function Foo() {",
+            "  this.prop = 123;",
+            "}",
+            "/** @param {!Object} x */",
+            "function f(x) {",
+            "  return x.prop;",
+            "}")
+        .addDiagnostic("Property prop never defined on Object")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_assignOpWithSelf() {
+  public void testStrictNumericOperators1() {
     newTest()
-        .addSource(
-            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE *= BIGINTS.TWO;")
+        .addSource("var x = 'asdf' - 1;")
+        .addDiagnostic(
+            lines(
+                "left operand", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntComparisons() {
-    newTest().addSource("var x = 1n; var y = 2n; x < y").run();
-    newTest().addSource("var x = 1n; /** @type {!BigInt} */ var y; x < y").run();
-    newTest().addSource("var x = 1n; var y = 2; x < y").run();
-    newTest().addSource("var x = 1n; /** @type {?} */ var y; x < y").run();
-  }
-
-  @Test
-  public void testBigIntComparisonWithString() {
+  public void testStrictNumericOperators2() {
     newTest()
-        .addSource("const x = 1n; const y = 'asdf'; x < y;")
+        .addSource("var x = 1 - 'asdf';")
         .addDiagnostic(
             lines(
-                "right side of numeric comparison",
+                "right operand", //
                 "found   : string",
-                "required: (bigint|number)"))
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntObjectComparisons() {
-    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2n; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {!BigInt} */ var y; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {?} */ var y; x < y").run();
-  }
-
-  @Test
-  public void testValidBigIntOrNumberComparisons() {
-    newTest()
-        .addSource("/** @type {bigint|number} */ var x; /** @type {bigint|number} */ var y; x < y;")
-        .run();
-    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2; x < y;").run();
-    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2n; x < y;").run();
+  public void testStrictNumericOperators3() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; /** @type {!BigInt} */ var y; x < y;")
+        .addSource("var x = 'asdf'; x++;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : string",
+                "required: number"))
         .run();
-    newTest().addSource("/** @type {bigint|number} */ var x; /** @type {?} */ var y; x < y").run();
   }
 
   @Test
-  public void testBigIntOrNumberComparisonWithString() {
+  public void testStrictNumericOperators4a() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; 'asdf' < x;")
+        .addSource("var x = -'asdf';")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison", //
+                "sign operator", //
                 "found   : string",
-                "required: (bigint|number)"))
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntOrOtherComparisons() {
-    newTest()
-        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|string} */ var y; x < y;")
-        .run();
-    newTest().addSource("/** @type {bigint|string} */ var x; /** @type {?} */ var y; x < y").run();
+  public void testStrictNumericOperators4b() {
+    newTest().addSource("var x = +'asdf';").run();
   }
 
   @Test
-  public void testBigIntOrOtherComparisonWithBigint() {
+  public void testStrictNumericOperators5() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 2n; x < y;")
+        .addSource("var x = 1 < 'asdf';")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison",
-                "found   : (bigint|string)",
+                "right side of numeric comparison",
+                "found   : string",
                 "required: (bigint|number)"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherComparisonWithNumber() {
+  public void testStrictNumericOperators6() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 2; x < y;")
+        .addSource("var x = 'asdf'; x *= 2;")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison",
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
-        .run();
-  }
-
-  @Test
-  public void testBigIntObjectIndex() {
-    // As is, TypeCheck allows for objects to be indexed with bigint. An error could be reported as
-    // is done with arrays, but for now we will avoid such restrictions.
-    newTest()
-        .addSource(
-            "var obj = {};",
-            "/** @type {bigint} */ var b;",
-            "/** @type {bigint|number} */ var bn;",
-            "obj[b] = 1;",
-            "obj[bn] = 3;")
+                "left operand", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntArrayIndex() {
-    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
-    // to maintain consistency with TypeScript.
+  public void testStrictNumericOperators7() {
     newTest()
-        .addSource("var arr = []; /** @type {bigint} */ var b; arr[b];")
+        .addSource("var x = ~ 'asdf';")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : bigint",
+                "bitwise NOT", //
+                "found   : string",
                 "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntConstructorWithNew() {
-    // BigInt object function type cannot be called with "new" keyword
-    newTest().addSource("new BigInt(1)").addDiagnostic("cannot instantiate non-constructor").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberArrayIndex() {
-    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
-    // to maintain consistency with TypeScript.
+  public void testStrictNumericOperators8() {
     newTest()
-        .addSource("var arr = []; /** @type {bigint|number} */ var bn; arr[bn];")
+        .addSource("var x = 'asdf' | 1;")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : (bigint|number)",
+                "bad left operand to bitwise operator", //
+                "found   : string",
                 "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntAsComputedPropForObjects() {
-    newTest().addSource("/** @type {bigint} */ var x; ({[x]: 'value', 123n() {}});").run();
-  }
-
-  @Test
-  public void testBigIntAsComputedPropForClasses() {
-    newTest().addSource("/** @unrestricted */ class C { 123n() {} }").run();
-    newTest().addSource("/** @dict */ class C { 123n() {} }").run();
-  }
-
-  @Test
-  public void testBigIntAsComputedPropForStructClasses() {
+  public void testStrictNumericOperators9() {
     newTest()
-        .addSource("class C { 123n() {} }")
-        .addDiagnostic("Cannot do '[]' access on a struct")
+        .addSource("var x = 'asdf' << 1;")
+        .addDiagnostic(
+            lines(
+                "operator <<", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testClassField() {
-    newTest().addSource("class A { x=2; }").run();
-    newTest().addSource("class B { x; }").run();
-    newTest().addSource("class C { x }").run();
-    newTest().addSource("class D { /** @type {string|undefined} */ x;}").run();
-    newTest().addSource("class E { /** @type {string} @suppress {checkTypes} */ x = 2; }").run();
-  }
-
-  @Test
-  public void testClassFieldStatic() {
-    newTest().addSource("class A { static x=2; }").run();
-    newTest().addSource("class B { static x; }").run();
-    newTest().addSource("class C { static x }").run();
-    newTest().addSource("class D { /** @type {string|undefined} */ static x;}").run();
+  public void testStrictNumericOperators10() {
     newTest()
-        .addSource("class E { /** @type {string} @suppress {checkTypes} */ static x = 2; }")
+        .addSource("var x = 1 >>> 'asdf';")
+        .addDiagnostic(
+            lines(
+                "operator >>>", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
@@ -26993,14 +21126,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testBigIntLiteralProperty() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addBigInt().build())
-        .addSource("(1n).toString()")
-        .run();
-  }
-
-  @Test
   public void testStrictComparison1() {
     newTest()
         .addSource("var x = true < 'asdf';")
@@ -27420,151 +21545,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
         .run();
   }
 
-  @Test
-  public void testCovariantIThenable1() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string|number>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable2() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !IThenable<string|number> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : IThenable<(number|string)>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable3() {
-    newTest()
-        .addSource(
-            "/** @type {!Promise<string|number>} */ var x;",
-            "function fn(/** !Promise<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable4() {
-    newTest()
-        .addSource(
-            "/** @type {!Promise<string>} */ var x;",
-            "function fn(/** !Promise<string|number> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : Promise<(number|string)>",
-                "required: Promise<string>"))
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable1() {
-    newTest()
-        .addSource(
-            "/** @type {!Array<string>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : IThenable<string>",
-                "required: Array<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable2() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !Array<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : Array<string>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable3() {
-    newTest()
-        .addSource(
-            "/** ",
-            "  @constructor",
-            "  @template T",
-            " */",
-            "function C() {}",
-            "/** @type {!C<string>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : IThenable<string>",
-                "required: C<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable4() {
-    newTest()
-        .addSource(
-            "/** ",
-            "  @constructor",
-            "  @template T",
-            " */",
-            "function C() {}",
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !C<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : C<string>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonNativeSubclass() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @implements {IThenable<T>}",
-            " * @template T",
-            " */",
-            "class CustomPromise {}",
-            "/** @type {!CustomPromise<(number|string)>} */ var x;",
-            "function fn(/** !CustomPromise<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .run();
-  }
 
   @Test
   public void testPropertyReferenceOnShadowingParameter() {
@@ -29271,12 +23251,12 @@ public final class TypeCheckTest extends TypeCheckTestCase {
         .run();
   }
 
-  private void testClosureTypes(String js, String description) {
+  private void testClosureTypes(String js, @Nullable String description) {
     testClosureTypesMultipleWarnings(
         js, description == null ? null : ImmutableList.of(description));
   }
 
-  private void testClosureTypesMultipleWarnings(String js, List<String> descriptions) {
+  private void testClosureTypesMultipleWarnings(String js, @Nullable List<String> descriptions) {
     compiler.initOptions(compiler.getOptions());
     Node jsRoot = IR.root(compiler.parseTestCode(js));
     Node externs =
diff --git a/test/com/google/javascript/jscomp/TypeInferenceTest.java b/test/com/google/javascript/jscomp/TypeInferenceTest.java
index a3630fc..4ba92bb 100644
--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java
+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java
@@ -79,6 +79,7 @@ import com.google.javascript.rhino.testing.TypeSubject;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -93,7 +94,7 @@ public final class TypeInferenceTest {
   private JSTypeResolver.Closer closer;
   private Map<String, JSType> assumptions;
   private JSType assumedThisType;
-  private FlowScope returnScope;
+  private @Nullable FlowScope returnScope;
   private static final AssertionFunctionLookup ASSERTION_FUNCTION_MAP =
       AssertionFunctionLookup.of(new ClosureCodingConvention().getAssertionFunctions());
 
@@ -245,9 +246,13 @@ public final class TypeInferenceTest {
     }
     scopeCreator.finishAndFreeze();
     // Create the control graph.
-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
-    cfa.process(null, cfgRoot);
-    ControlFlowGraph<Node> cfg = cfa.getCfg();
+    ControlFlowGraph<Node> cfg =
+        ControlFlowAnalysis.builder()
+            .setCompiler(compiler)
+            .setCfgRoot(cfgRoot)
+            .setTraverseFunctions(true)
+            .setIncludeEdgeAnnotations(true)
+            .computeCfg();
     // Create a simple reverse abstract interpreter.
     ReverseAbstractInterpreter rai = compiler.getReverseAbstractInterpreter();
     // Do the type inference by data-flow analysis.
@@ -379,7 +384,7 @@ public final class TypeInferenceTest {
 
   /** Returns a record type with a field `fieldName` and JSType specified by `fieldType`. */
   private JSType createRecordType(String fieldName, JSType fieldType) {
-    Map<String, JSType> property = ImmutableMap.of(fieldName, fieldType);
+    ImmutableMap<String, JSType> property = ImmutableMap.of(fieldName, fieldType);
     return registry.createRecordType(property);
   }
 
@@ -2575,7 +2580,7 @@ public final class TypeInferenceTest {
   }
 
   @Test
-  public void testClassFieldsInControlFlow() {
+  public void testComputedClassFieldsInControlFlow() {
     // Based on the class semantics, the static RHS expressions only execute after all of the
     // computed properties, so `y` will get the string value rather than the boolean here.
     inFunction(
@@ -2589,6 +2594,78 @@ public final class TypeInferenceTest {
   }
 
   @Test
+  public void testClassFieldsInControlFlow() {
+    inFunction(
+        lines(
+            "let y;", //
+            "class Foo {",
+            "  static y = (y = '');",
+            "  z = [y = null];",
+            "}"));
+    verify("y", STRING_TYPE);
+  }
+
+  @Test
+  public void testThisTypeAfterMemberField() {
+    JSType thisType = createRecordType("x", STRING_TYPE);
+    assumingThisType(thisType);
+    inFunction(
+        lines(
+            "let thisDotX;", //
+            "(class C {",
+            "  /** @type {number} */",
+            "  static x = 0;",
+            "}, thisDotX = this.x);"));
+    verify("thisDotX", STRING_TYPE);
+  }
+
+  @Test
+  public void testFunction() {
+    // should verify y as string, but due to function-rooted CFG
+    // being detached from larger, root CFG, verifies y as void
+    inScript(
+        lines(
+            "let y;", //
+            "function foo() {",
+            "  y = 'hi';",
+            "}",
+            "foo();"));
+    verify("y", VOID_TYPE);
+  }
+
+  @Test
+  public void testClassStaticBlock() {
+    // should verify y as string, but due to static block-rooted CFG
+    // being detached from larger, root CFG, verifies y as void
+    inScript(
+        lines(
+            "let y;", //
+            "class Foo {",
+            "  static {",
+            "    y = 'hi';",
+            "  }",
+            "}"));
+    verify("y", VOID_TYPE);
+  }
+
+  @Test
+  public void testSuper() {
+    // does not infer super
+    inScript(
+        lines(
+            "class Foo {", //
+            "  static str;",
+            "}",
+            "class Bar extends Foo {",
+            "  static {",
+            "    super.str = 'hi';",
+            "  }",
+            "}",
+            "let x = Bar.str;"));
+    verify("x", ALL_TYPE);
+  }
+
+  @Test
   public void testAssignOrNoAssign() {
     // The two examples below show imprecision of || operator
     // The resulting type of Node n is (boolean|string), when it can be
diff --git a/test/com/google/javascript/jscomp/TypeTransformationTest.java b/test/com/google/javascript/jscomp/TypeTransformationTest.java
index 5837d63..d0a83ba 100644
--- a/test/com/google/javascript/jscomp/TypeTransformationTest.java
+++ b/test/com/google/javascript/jscomp/TypeTransformationTest.java
@@ -38,7 +38,9 @@ public final class TypeTransformationTest extends CompilerTypeTestCase {
 
   private ImmutableMap<String, JSType> typeVars;
   private ImmutableMap<String, String> nameVars;
-  private static JSType recordTypeTest, nestedRecordTypeTest, asynchRecord;
+  private static JSType recordTypeTest;
+  private static JSType nestedRecordTypeTest;
+  private static JSType asynchRecord;
 
   static final String EXTRA_TYPE_DEFS =
       lines(
@@ -1090,7 +1092,7 @@ public final class TypeTransformationTest extends CompilerTypeTestCase {
   public void testTransformationInstanceObjectToRecord2() {
     // TODO(bradfordcsmith): Define Array.prototype.length using externs instead.
     getNativeArrayType()
-        .defineDeclaredProperty("length", getNativeNumberType(), /* propertyNode */ null);
+        .defineDeclaredProperty("length", getNativeNumberType(), /* propertyNode= */ null);
     testTTL(record("length", getNativeNumberType()), "record(type(ARR, N))");
   }
 
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index 102fc07..b85e4b1 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -35,6 +35,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
 import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.deps.JsFileLineParser;
@@ -58,8 +59,8 @@ import com.google.javascript.rhino.jstype.ObjectType;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -77,7 +78,6 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   private TypedScope globalScope;
   private TypedScope lastLocalScope;
   private TypedScope lastFunctionScope;
-  private final ResolutionMode moduleResolutionMode = ResolutionMode.BROWSER;
   private boolean processClosurePrimitives = false;
 
   /**
@@ -149,7 +149,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     // Create a fresh statement map for each test case.
     labeledStatementMap = new HashMap<>();
     return (Node externs, Node root) -> {
-      new GatherModuleMetadata(compiler, false, moduleResolutionMode).process(externs, root);
+      new GatherModuleMetadata(compiler, false, ResolutionMode.BROWSER).process(externs, root);
       new ModuleMapCreator(compiler, compiler.getModuleMetadataMap()).process(externs, root);
       new InferConsts(compiler).process(externs, root);
 
@@ -2622,7 +2622,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
 
     FunctionType fooClass = (FunctionType) findNameType("Foo", globalScope);
     ObjectType fooProto = fooClass.getPrototype();
-    List<FunctionType.Parameter> params = fooClass.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooClass.getParameters();
     Node ctorDef = getLabeledStatement("CTOR_BODY").statementNode.getAncestor(3);
 
     // Test class typing.
@@ -2896,7 +2896,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
 
     FunctionType fooClass = (FunctionType) findNameType("Foo", globalScope);
     ObjectType fooProto = fooClass.getPrototype();
-    List<FunctionType.Parameter> params = fooClass.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooClass.getParameters();
 
     // Test class typing.
     assertThat(fooClass.isConstructor()).isTrue();
@@ -2938,7 +2938,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooCtor).withTypeOfProp("method").isNotUnknown();
     assertType(fooCtor).withTypeOfProp("method").isNotEmpty();
 
-    List<FunctionType.Parameter> params = fooCtor.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooCtor.getParameters();
     assertThat(params).hasSize(1);
     assertType(params.get(0).getJSType()).isNumber();
     assertType(barConstructorProperty).toStringIsEqualTo("(typeof Bar)");
@@ -2964,7 +2964,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
             "}",
             "class Foo extends class extends class extends Bar {} {} {}"));
     FunctionType foo = (FunctionType) (findNameType("Foo", globalScope));
-    List<FunctionType.Parameter> params = foo.getParameters();
+    ImmutableList<FunctionType.Parameter> params = foo.getParameters();
     assertThat(params).hasSize(1);
     assertType(params.get(0).getJSType()).isString();
   }
@@ -3260,16 +3260,49 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooInstance.getPropertyType("b")).toStringIsEqualTo("(symbol|undefined)");
 
     assertThat(fooInstance.hasOwnDeclaredProperty("c")).isTrue();
-    assertType(fooInstance.getPropertyType("c")).isUnknown();
+    assertType(fooInstance.getPropertyType("c")).isNumber();
 
     assertThat(fooInstance.hasOwnDeclaredProperty("d")).isTrue();
-    assertType(fooInstance.getPropertyType("d")).isUnknown();
+    assertType(fooInstance.getPropertyType("d")).toStringIsEqualTo("*");
 
     assertThat(fooInstance.hasOwnDeclaredProperty("e")).isTrue();
     assertType(fooInstance.getPropertyType("e")).toStringIsEqualTo("(null|string)");
   }
 
   @Test
+  public void testClassDeclarationWithFieldThisAndSuper() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  /** @type {number} */",
+            "  a = 2;",
+            "  /** @type {number} */",
+            "  b = this.b;",
+            "}",
+            "class Bar extends Foo {",
+            "  /** @type {number} */",
+            "  c = super.a + 1;",
+            "}"));
+
+    FunctionType fooCtor = globalScope.getVar("Foo").getType().assertFunctionType();
+    ObjectType fooInstance = fooCtor.getInstanceType();
+    FunctionType barCtor = globalScope.getVar("Bar").getType().assertFunctionType();
+    ObjectType barInstance = barCtor.getInstanceType();
+
+    assertThat(fooInstance.hasOwnDeclaredProperty("a")).isTrue();
+    assertType(fooInstance.getPropertyType("a")).isNumber();
+    assertThat(barInstance.hasOwnDeclaredProperty("a")).isFalse();
+
+    assertThat(fooInstance.hasOwnDeclaredProperty("b")).isTrue();
+    assertType(fooInstance.getPropertyType("b")).isNumber();
+    assertThat(barInstance.hasOwnDeclaredProperty("b")).isFalse();
+
+    assertThat(fooInstance.hasOwnDeclaredProperty("c")).isFalse();
+    assertThat(barInstance.hasOwnDeclaredProperty("c")).isTrue();
+    assertType(barInstance.getPropertyType("c")).isNumber();
+  }
+
+  @Test
   public void testClassDeclarationWithStaticField() {
     testSame(
         lines(
@@ -3293,16 +3326,47 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooCtor.getPropertyType("b")).toStringIsEqualTo("(symbol|undefined)");
 
     assertThat(fooCtor.hasOwnDeclaredProperty("c")).isTrue();
-    assertType(fooCtor.getPropertyType("c")).isUnknown();
+    assertType(fooCtor.getPropertyType("c")).isNumber();
 
     assertThat(fooCtor.hasOwnDeclaredProperty("d")).isTrue();
-    assertType(fooCtor.getPropertyType("d")).isUnknown();
+    assertType(fooCtor.getPropertyType("d")).toStringIsEqualTo("*");
 
     assertThat(fooCtor.hasOwnDeclaredProperty("e")).isTrue();
     assertType(fooCtor.getPropertyType("e")).toStringIsEqualTo("(null|string)");
   }
 
   @Test
+  public void testClassDeclarationWithStaticFieldThisAndSuper() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  /** @type {number} */",
+            "  static a = 2;",
+            "  /** @type {number} */",
+            "  static b = this.b;",
+            "}",
+            "class Bar extends Foo {",
+            "  /** @type {number} */",
+            "  static c = super.a + 1;",
+            "}"));
+
+    FunctionType fooCtor = globalScope.getVar("Foo").getType().assertFunctionType();
+    FunctionType barCtor = globalScope.getVar("Bar").getType().assertFunctionType();
+
+    assertThat(fooCtor.hasOwnDeclaredProperty("a")).isTrue();
+    assertType(fooCtor.getPropertyType("a")).isNumber();
+    assertThat(barCtor.hasOwnDeclaredProperty("a")).isFalse();
+
+    assertThat(fooCtor.hasOwnDeclaredProperty("b")).isTrue();
+    assertType(fooCtor.getPropertyType("b")).isNumber();
+    assertThat(barCtor.hasOwnDeclaredProperty("b")).isFalse();
+
+    assertThat(fooCtor.hasOwnDeclaredProperty("c")).isFalse();
+    assertThat(barCtor.hasOwnDeclaredProperty("c")).isTrue();
+    assertType(barCtor.getPropertyType("c")).isNumber();
+  }
+
+  @Test
   public void testClassDeclarationWithDeprecatedField() {
     testSame(
         lines(
@@ -3479,6 +3543,197 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlockAndVariableDeclarations() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    STATIC:;",
+            "    let /** string */ x;",
+            "    const /** number */ y = 5;",
+            "    var /** boolean */ z;",
+            "  }",
+            "};"));
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classScope = staticScope.getParentScope();
+    assertScope(globalScope)
+        .declares("Foo")
+        .directly()
+        .withTypeThat()
+        .toStringIsEqualTo("(typeof Foo)");
+    assertScope(staticScope).declares("x").directly().withTypeThat().isString();
+    assertScope(classScope).doesNotDeclare("x");
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(staticScope).declares("y").directly().withTypeThat().isNumber();
+    assertScope(classScope).doesNotDeclare("y");
+    assertScope(globalScope).doesNotDeclare("y");
+    assertScope(staticScope).declares("z").directly().withTypeThat().isBoolean();
+    assertScope(classScope).doesNotDeclare("z");
+    assertScope(globalScope).doesNotDeclare("z");
+  }
+
+  @Test
+  public void testMultipleClassStaticBlocks() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    STATIC1:;",
+            "    var /** number */ x;",
+            "  }",
+            "  static {",
+            "    STATIC2:;",
+            "    var /** string */ y;",
+            "  }",
+            "};"));
+    TypedScope staticScope1 = getLabeledStatement("STATIC1").enclosingScope;
+    TypedScope staticScope2 = getLabeledStatement("STATIC2").enclosingScope;
+    TypedScope classScope = staticScope1.getParentScope();
+    assertScope(globalScope)
+        .declares("Foo")
+        .directly()
+        .withTypeThat()
+        .toStringIsEqualTo("(typeof Foo)");
+    assertThat(staticScope2.getParentScope()).isEqualTo(classScope);
+    assertScope(staticScope1).declares("x").directly().withTypeThat().isNumber();
+    assertScope(staticScope2).declares("y").directly().withTypeThat().isString();
+    assertScope(staticScope1).doesNotDeclare("y");
+    assertScope(staticScope2).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("y");
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(globalScope).doesNotDeclare("y");
+  }
+
+  @Test
+  public void testClassStaticBlockWithIf() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    STATIC:;",
+            "    if(true) {",
+            "      IF:;",
+            "      let /** boolean */ x;",
+            "      var /** string */ y;",
+            "      const /** number */ z = 1;",
+            "    }",
+            "  }",
+            "};"));
+    TypedScope ifScope = getLabeledStatement("IF").enclosingScope;
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classScope = staticScope.getParentScope();
+    assertScope(globalScope)
+        .declares("Foo")
+        .directly()
+        .withTypeThat()
+        .toStringIsEqualTo("(typeof Foo)");
+    assertScope(ifScope).declares("x").directly().withTypeThat().isBoolean();
+    assertScope(staticScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+    assertScope(globalScope).doesNotDeclare("x");
+    assertScope(ifScope).declares("y").onSomeParent().withTypeThat().isString();
+    assertScope(staticScope).declares("y").directly().withTypeThat().isString();
+    assertScope(classScope).doesNotDeclare("y");
+    assertScope(globalScope).doesNotDeclare("y");
+    assertScope(ifScope).declares("z").directly().withTypeThat().isNumber();
+    assertScope(staticScope).doesNotDeclare("z");
+    assertScope(classScope).doesNotDeclare("z");
+    assertScope(globalScope).doesNotDeclare("z");
+  }
+
+  @Test
+  public void testClassStaticBlockWithFunction() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    STATIC:;",
+            "    function bar() {",
+            "      FUNCTION:;",
+            "    }",
+            "  }",
+            "};"));
+    TypedScope functionScope = getLabeledStatement("FUNCTION").enclosingScope;
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classScope = staticScope.getParentScope();
+    assertThat(functionScope.getParentScope().getParentScope()).isEqualTo(staticScope);
+    assertScope(globalScope)
+        .declares("Foo")
+        .directly()
+        .withTypeThat()
+        .toStringIsEqualTo("(typeof Foo)");
+    assertScope(staticScope)
+        .declares("bar")
+        .directly()
+        .withTypeThat()
+        .toStringIsEqualTo("function(): undefined");
+    assertScope(classScope).doesNotDeclare("bar");
+    assertScope(globalScope).doesNotDeclare("bar");
+  }
+
+  @Test
+  public void testClassStaticBlockWithThisLHS() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  static {",
+            "    STATIC:;",
+            "    /** @type {string} */",
+            "    this.x = 'hello';",
+            "  }",
+            "};"));
+    FunctionType fooCtor = globalScope.getVar("Foo").getType().assertFunctionType();
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classScope = staticScope.getParentScope();
+    assertThat(fooCtor.hasProperty("x")).isTrue();
+    assertType(fooCtor.getPropertyType("x")).isString();
+    assertThat(fooCtor.isPropertyTypeDeclared("x")).isTrue();
+    assertThat(fooCtor.isPropertyTypeInferred("x")).isFalse();
+    assertScope(staticScope).doesNotDeclare("x");
+    assertScope(classScope).doesNotDeclare("x");
+  }
+
+  @Test
+  public void testClassStaticBlockWithThisRHS() {
+    testSame(
+        lines(
+            "class Foo {",
+            "  /** @type {number} */",
+            "  static y = 1;",
+            "  static {",
+            "    STATIC:;",
+            "    var x = this.y;",
+            "  }",
+            "};"));
+    FunctionType fooCtor = globalScope.getVar("Foo").getType().assertFunctionType();
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classScope = staticScope.getParentScope();
+    assertThat(fooCtor.hasOwnDeclaredProperty("y")).isTrue();
+    assertType(fooCtor.getPropertyType("y")).isNumber();
+    assertThat(fooCtor.hasProperty("x")).isFalse();
+    assertScope(staticScope).declares("x").directly().withTypeThat().isNumber();
+    assertScope(classScope).doesNotDeclare("x");
+  }
+
+  @Test
+  public void testSuperInEmptyClassStaticBlock() {
+    testSame(
+        lines(
+            "class Foo {}", //
+            "class Bar extends Foo {",
+            "  static {",
+            "    STATIC:;",
+            "  }",
+            "};"));
+    FunctionType fooCtor = globalScope.getVar("Foo").getType().assertFunctionType();
+    TypedScope staticScope = getLabeledStatement("STATIC").enclosingScope;
+    TypedScope classBarScope = staticScope.getParentScope();
+    assertScope(staticScope).declares("super").directly().withTypeThat().isEqualTo(fooCtor);
+    assertScope(classBarScope).doesNotDeclare("super");
+  }
+
+  @Test
   public void testForLoopIntegration() {
     testSame("var y = 3; for (var x = true; x; y = x) {}");
 
@@ -3957,6 +4212,29 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testTemplateType_shadowingNativeType() {
+    // Verify that some special handling of externs for types built-in to JSTypeRegistry, like
+    // Array, does not incorrectly run for local types shadowing native types.
+    testSame(
+        lines(
+            "function local() {",
+            "  /** @template U @constructor @param {U} e*/",
+            "  function Array(e) { this.e = e; }",
+            "  /** @return {U} */ Array.prototype.first = function() { return this.e; };",
+            "  /** @type {!Array<string>} */ let arr = new Array();",
+            "",
+            "  const first = arr.first();",
+            "  LOCAL: local;",
+            "}"));
+
+    assertType(findNameType("arr", lastLocalScope)).toStringIsEqualTo("Array<string>");
+    assertType(findNameType("first", lastLocalScope)).isString();
+
+    assertType(findNameType("Array", lastLocalScope))
+        .isNotEqualTo(registry.getNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE));
+  }
+
+  @Test
   public void testTemplatedThis_inClassInstanceMethod_isInferredToBe_receiverType() {
     testSame(
         lines(
@@ -4105,7 +4383,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
-  public void testClassTemplateType4() {
+  public void testClassTemplateType4_instanceProperty() {
     // Verify that template types used for instance properties are recognized.
     testSame(
         "/** @const */ var ns = {};"
@@ -4124,6 +4402,34 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassTemplateType4_instancePropertyWithInheritance() {
+    // Verify that template types used for instance properties are recognized
+    // when shadowing a template type on the superclass with the same name.
+    testSame(
+        lines(
+            "/**",
+            " * @template T",
+            " */",
+            "class Parent {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @extends {Parent<number>}",
+            " */",
+            "class Child extends Parent {",
+            "  constructor() {",
+            "    super();",
+            "    /** @type {T} */",
+            "    this.foo;",
+            "  }",
+            "};",
+            "",
+            "/** @type {!Child<string>} */ var x = new Child();",
+            "var result = x.foo;"));
+    assertThat(findNameType("result", globalScope).toString()).isEqualTo("string");
+  }
+
+  @Test
   public void testClassTemplateType5() {
     // Verify that template types used for prototype properties in stub
     // declarations are recognized.
@@ -5001,6 +5307,23 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testGoogModule_moduleBodyScopeIsStoredOnTheInput() {
+    testSame("goog.module('a'); EXPORTS: exports;");
+
+    final TypedScope moduleScope = getLabeledStatement("EXPORTS").enclosingScope;
+    final Node moduleBodyNode = moduleScope.getRootNode();
+    assertNode(moduleBodyNode).hasToken(Token.MODULE_BODY);
+    final Compiler lastCompiler = getLastCompiler();
+    final InputId inputId = NodeUtil.getInputId(moduleBodyNode);
+    assertThat(inputId).isNotNull();
+    final CompilerInput compilerInput = lastCompiler.getInput(inputId);
+    assertThat(compilerInput).isNotNull();
+    final TypedScope typedScopeStoredOnTheCompilerInput = compilerInput.getTypedScope();
+    assertThat(typedScopeStoredOnTheCompilerInput).isNotNull();
+    assertThat(typedScopeStoredOnTheCompilerInput).isSameInstanceAs(moduleScope);
+  }
+
+  @Test
   public void testGoogModule_declaresExportsVariableImplicitly() {
     testSame("goog.module('a'); EXPORTS: exports;");
 
@@ -6049,9 +6372,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   @Test
   public void testLegacyGoogModule_declaresParentNamespacesGlobally() {
     processClosurePrimitives = true;
-    testSame(
-        srcs(
-            "goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
+    testSame(srcs("goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
 
     assertScope(globalScope).declares("a").directly();
     assertScope(globalScope).declares("a.b").directly();
@@ -6062,9 +6383,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   @Test
   public void testLegacyGoogModule_isDeclaredPropertyOnParentNamespace() {
     processClosurePrimitives = true;
-    testSame(
-        srcs(
-            "goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
+    testSame(srcs("goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
 
     assertThat(globalScope.getVar("a.b")).hasJSTypeThat().hasDeclaredProperty("c");
   }
@@ -7563,7 +7882,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertAttachedGoogModuleId("SCOPED_CAST", null);
   }
 
-  private void assertAttachedGoogModuleId(String label, String expectedId) {
+  private void assertAttachedGoogModuleId(String label, @Nullable String expectedId) {
     JSType type = this.getLabeledStatement(label).statementNode.getOnlyChild().getJSType();
 
     final String actualId;
diff --git a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
index 65bec0b..9a3baec 100644
--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java
@@ -628,4 +628,24 @@ public final class UnreachableCodeEliminationTest extends CompilerTestCase {
             "  }()]() { return 1; }",
             "}"));
   }
+
+  @Test
+  public void testStaticBlockNotRemoved() {
+    testSame("class Foo { static {} }");
+  }
+
+  @Test
+  public void testRemoveUnreachableCodeInStaticBlock1() {
+    // TODO(b/240443227): Unreachable/Useless code isn't removed in static blocks
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    switch (a) { case 'a': break }",
+            "    try {var x = 1} catch (e) {e()}",
+            "    true;",
+            "    if (x) 1;",
+            "  }",
+            "}"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/ValidityCheckTest.java b/test/com/google/javascript/jscomp/ValidityCheckTest.java
index 84ec5d1..1657bac 100644
--- a/test/com/google/javascript/jscomp/ValidityCheckTest.java
+++ b/test/com/google/javascript/jscomp/ValidityCheckTest.java
@@ -22,6 +22,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +32,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ValidityCheckTest extends CompilerTestCase {
 
-  private CompilerPass otherPass = null;
+  private @Nullable CompilerPass otherPass = null;
 
   @Before
   @Override
diff --git a/test/com/google/javascript/jscomp/VarCheckTest.java b/test/com/google/javascript/jscomp/VarCheckTest.java
index 831e2c2..b87889a 100644
--- a/test/com/google/javascript/jscomp/VarCheckTest.java
+++ b/test/com/google/javascript/jscomp/VarCheckTest.java
@@ -30,6 +30,7 @@ import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.StaticSourceFile.SourceKind;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,7 +43,7 @@ public final class VarCheckTest extends CompilerTestCase {
   private CheckLevel strictModuleDepErrorLevel;
   private boolean validityCheck = false;
 
-  private CheckLevel externValidationErrorLevel;
+  private @Nullable CheckLevel externValidationErrorLevel;
 
   private boolean declarationCheck;
 
@@ -636,17 +637,20 @@ public final class VarCheckTest extends CompilerTestCase {
     testDependentModules("var x = 10; function a() {y++;} a();", "var y = 11;", null);
   }
 
-  private void testDependentModules(String code1, String code2, DiagnosticType error) {
+  private void testDependentModules(String code1, String code2, @Nullable DiagnosticType error) {
     testDependentModules(code1, code2, error, null);
   }
 
   private void testDependentModules(
-      String code1, String code2, DiagnosticType error, DiagnosticType warning) {
+      String code1, String code2, DiagnosticType error, @Nullable DiagnosticType warning) {
     testTwoModules(code1, code2, true, error, warning);
   }
 
   private void testIndependentModules(
-      String code1, String code2, DiagnosticType error, DiagnosticType warning) {
+      String code1,
+      String code2,
+      @Nullable DiagnosticType error,
+      @Nullable DiagnosticType warning) {
     testTwoModules(code1, code2, false, error, warning);
   }
 
diff --git a/test/com/google/javascript/jscomp/WarningsGuardTest.java b/test/com/google/javascript/jscomp/WarningsGuardTest.java
index 9a0ca8b..b9f27f9 100644
--- a/test/com/google/javascript/jscomp/WarningsGuardTest.java
+++ b/test/com/google/javascript/jscomp/WarningsGuardTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.jscomp.CheckLevel.OFF;
 import static com.google.javascript.jscomp.CheckLevel.WARNING;
 import static com.google.javascript.jscomp.CompilerTestCase.lines;
 import static com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST;
+import static com.google.javascript.jscomp.TypeCheck.ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -32,6 +33,7 @@ import com.google.javascript.rhino.Token;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.SortedSet;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -333,6 +335,28 @@ public final class WarningsGuardTest {
   }
 
   @Test
+  public void testSuppressGuard_strictMissingPropertyOnUnionTypes() {
+    Compiler compiler = new Compiler();
+    WarningsGuard guard =
+        new SuppressDocWarningsGuard(compiler, DiagnosticGroups.getRegisteredGroups());
+
+    Node code =
+        compiler.parseTestCode(
+            lines(
+                "class C {}",
+                "class D{}",
+                "/** @type {(C|D)} */",
+                "let obj;",
+                "/** @suppress {strictMissingProperties} */",
+                "obj.prop"));
+    assertThat(
+            guard.level(
+                JSError.make(
+                    findGetPropNode(code, "prop"), ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE)))
+        .isEqualTo(OFF);
+  }
+
+  @Test
   public void testSuppressGuard4() {
     Map<String, DiagnosticGroup> map = new HashMap<>();
     map.put("deprecated", new DiagnosticGroup(BAR_WARNING));
@@ -442,7 +466,21 @@ public final class WarningsGuardTest {
     return null;
   }
 
-  private static JSError makeError(String sourcePath) {
+  private static Node findGetPropNode(Node root, String name) {
+    if (root.isGetProp() && root.getString().equals(name)) {
+      return root;
+    }
+
+    for (Node n = root.getFirstChild(); n != null; n = n.getNext()) {
+      Node result = findGetPropNode(n, name);
+      if (result != null) {
+        return result;
+      }
+    }
+    return null;
+  }
+
+  private static JSError makeError(@Nullable String sourcePath) {
     Node n = new Node(Token.EMPTY);
     n.setSourceFileForTesting(sourcePath);
     return JSError.make(n, BAR_WARNING);
@@ -454,7 +492,7 @@ public final class WarningsGuardTest {
     return JSError.make(n, type);
   }
 
-  private static JSError makeError(String sourcePath, CheckLevel level) {
+  private static JSError makeError(@Nullable String sourcePath, CheckLevel level) {
     Node n = new Node(Token.EMPTY);
     n.setSourceFileForTesting(sourcePath);
     return JSError.make(n, DiagnosticType.make("FOO", level, "Foo description"));
diff --git a/test/com/google/javascript/jscomp/XtbMessageBundleTest.java b/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
index f7146e5..b08fc22 100644
--- a/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
+++ b/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
@@ -19,6 +19,8 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 
+import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.JsMessage.Part;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -55,21 +57,21 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     JsMessage message = bundle.getMessage("7639678437384034548");
-    assertThat(message.toString()).isEqualTo("descargar");
+    assertThat(message.asJsMessageString()).isEqualTo("descargar");
 
     message = bundle.getMessage("2398375912250604550");
-    assertThat(message.toString()).isEqualTo("Se han\nignorado {$num} conversaciones.");
+    assertThat(message.asJsMessageString()).isEqualTo("Se han\nignorado {$num} conversaciones.");
 
     message = bundle.getMessage("6323937743550839320");
-    assertThat(message.toString())
+    assertThat(message.asJsMessageString())
         .isEqualTo(
             "{$pStart}Si, puede {$linkStart_1_3}hacer "
                 + "clic{$linkEnd_1_3} para utilizar.{$pEnd}{$pStart}Esperamos "
                 + "poder ampliar.{$pEnd}");
 
     message = bundle.getMessage("3945720239421293834");
-    assertThat(message.toString()).isEmpty();
-    assertThat(message.parts()).isNotEmpty();
+    assertThat(message.asJsMessageString()).isEmpty();
+    assertThat(message.getParts()).isNotEmpty();
   }
 
   /**
@@ -100,16 +102,38 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     assertThat(bundle.getAllMessages()).hasSize(2);
-    assertThat(bundle.getMessage("123456").toString())
+    final JsMessage icuMsg = bundle.getMessage("123456");
+    assertThat(icuMsg.asIcuMessageString())
         .isEqualTo(
             "{USER_GENDER,select,"
                 + "female{Hello {USER_IDENTIFIER}.}"
                 + "male{Hello {USER_IDENTIFIER}.}"
                 + "other{Hello {USER_IDENTIFIER}.}}");
+    // For an ICU selector formatted message, XtbMessageBundle automatically converts all the
+    // placeholders into normal strings.
+    final ImmutableList<Part> icuMsgParts = icuMsg.getParts();
+    assertThat(icuMsgParts).hasSize(7);
+    assertThat(icuMsgParts.get(0).getString()).isEqualTo("{USER_GENDER,select,female{Hello ");
+    assertThat(icuMsgParts.get(1).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(2).getString()).isEqualTo(".}male{Hello ");
+    assertThat(icuMsgParts.get(3).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(4).getString()).isEqualTo(".}other{Hello ");
+    assertThat(icuMsgParts.get(5).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(6).getString()).isEqualTo(".}}");
 
     // Previous ICU message should not to affect next message
-    assertThat(bundle.getMessage("123457").toString())
+    final JsMessage normalMsg = bundle.getMessage("123457");
+    assertThat(normalMsg.asJsMessageString())
         .isEqualTo("{$startParagraph}p1{$endParagraph}{$startParagraph}p1{$endParagraph}");
+    final ImmutableList<Part> normalMsgParts = normalMsg.getParts();
+    // For a normal message the placeholders are not turned into strings
+    assertThat(normalMsgParts).hasSize(6);
+    assertThat(normalMsgParts.get(0).getJsPlaceholderName()).isEqualTo("startParagraph");
+    assertThat(normalMsgParts.get(1).getString()).isEqualTo("p1");
+    assertThat(normalMsgParts.get(2).getJsPlaceholderName()).isEqualTo("endParagraph");
+    assertThat(normalMsgParts.get(3).getJsPlaceholderName()).isEqualTo("startParagraph");
+    assertThat(normalMsgParts.get(4).getString()).isEqualTo("p1");
+    assertThat(normalMsgParts.get(5).getJsPlaceholderName()).isEqualTo("endParagraph");
   }
 
   /**
@@ -146,7 +170,7 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     assertThat(bundle.getAllMessages()).hasSize(2);
-    assertThat(bundle.getMessage("123456").toString())
+    assertThat(bundle.getMessage("123456").asIcuMessageString())
         .isEqualTo(
             "{NUM,plural, "
                 + "=1{Setting: {START_STRONG}{UDC_SETTING}{END_STRONG}"
@@ -154,7 +178,7 @@ public final class XtbMessageBundleTest {
                 + "other{Settings: {START_STRONG}{UDC_SETTING_LIST}{END_STRONG}"
                 + " Products: {START_STRONG}{PRODUCT_LIST}{END_STRONG}.}}");
     // Both translation entries should result into the same message in JavaScript.
-    assertThat(bundle.getMessage("987654").toString())
-        .isEqualTo(bundle.getMessage("123456").toString());
+    assertThat(bundle.getMessage("987654").asIcuMessageString())
+        .isEqualTo(bundle.getMessage("123456").asIcuMessageString());
   }
 }
diff --git a/test/com/google/javascript/jscomp/colors/ColorTest.java b/test/com/google/javascript/jscomp/colors/ColorTest.java
index 62d0ea5..beb2cd7 100644
--- a/test/com/google/javascript/jscomp/colors/ColorTest.java
+++ b/test/com/google/javascript/jscomp/colors/ColorTest.java
@@ -152,36 +152,6 @@ public class ColorTest {
   }
 
   @Test
-  public void union_debugInfoTypenameFormat() {
-    // Given
-    Color a =
-        Color.singleBuilder()
-            .setId(fromAscii("A"))
-            .setDebugInfo(DebugInfo.builder().setCompositeTypename("A").build())
-            .build();
-    Color b =
-        Color.singleBuilder()
-            .setId(fromAscii("B"))
-            .setDebugInfo(DebugInfo.builder().setCompositeTypename("B").build())
-            .build();
-    Color c =
-        Color.singleBuilder()
-            .setId(fromAscii("C"))
-            .setDebugInfo(DebugInfo.builder().setCompositeTypename("C").build())
-            .build();
-
-    // When
-    Color ab = Color.createUnion(ImmutableSet.of(a, b));
-    Color ba = Color.createUnion(ImmutableSet.of(b, a));
-    Color abc = Color.createUnion(ImmutableSet.of(ab, c));
-
-    // Then
-    assertThat(ab.getDebugInfo().getCompositeTypename()).isEqualTo("(A|B)");
-    assertThat(ba.getDebugInfo().getCompositeTypename()).isEqualTo("(A|B)");
-    assertThat(abc.getDebugInfo().getCompositeTypename()).isEqualTo("(A|B|C)");
-  }
-
-  @Test
   public void primitivesAreInvalidatingBasedOnConstantData() {
     assertThat(StandardColors.UNKNOWN).isInvalidating();
     assertThat(StandardColors.TOP_OBJECT).isInvalidating();
diff --git a/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java b/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
index 4abe9c5..506e5e3 100644
--- a/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
+++ b/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
@@ -147,8 +147,7 @@ public final class DependencyResolverTest {
     Set<String> seen = new HashSet<>();
     resolver = new DefaultDependencyResolver(ImmutableList.of(fakeDeps1), true);
     try {
-      Collection<String> deps = resolver.getDependencies(
-          "goog.require('foo');goog.require('a');", seen, false);
+      resolver.getDependencies("goog.require('foo');goog.require('a');", seen, false);
       assertWithMessage("Service exception should be thrown").fail();
     } catch (ServiceException expected) {
     }
diff --git a/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java b/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
index 61c91cd..a581193 100644
--- a/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
+++ b/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
@@ -516,7 +516,10 @@ public final class DepsGeneratorTest {
     SourceFile src1 = SourceFile.fromCode("src1.js",
         "goog.provide('a');\n");
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), true /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ true,
         "Namespace \"a\" is already provided in other file dep1.js");
   }
 
@@ -536,8 +539,10 @@ public final class DepsGeneratorTest {
     // doErrorMessagesRun uses closure_path //javascript/closure and therefore
     // fails to recognize and de-dupe the stub Closure Library at
     // //path/to/closure.
-    doErrorMessagesRun(ImmutableList.of(fauxClosureDeps),
-        ImmutableList.of(fauxClosureSrc, userSrc), true /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(fauxClosureDeps),
+        ImmutableList.of(fauxClosureSrc, userSrc),
+        /* fatal= */ true,
         "Namespace \"a\" is already provided in other file dep1.js");
   }
 
@@ -582,7 +587,10 @@ public final class DepsGeneratorTest {
         SourceFile.fromCode(
             "src1.js", LINE_JOINER.join("goog.provide('b');", "goog.provide('b');\n"));
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ false,
         "Multiple calls to goog.provide(\"b\")");
   }
 
@@ -594,7 +602,10 @@ public final class DepsGeneratorTest {
         SourceFile.fromCode(
             "src1.js", LINE_JOINER.join("goog.provide('b');", "goog.require('b');", ""));
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ false,
         "Namespace \"b\" is both required and provided in the same file.");
   }
 
@@ -608,7 +619,7 @@ public final class DepsGeneratorTest {
     doErrorMessagesRun(
         ImmutableList.of(dep1),
         ImmutableList.of(src1),
-        true /* fatal */,
+        /* fatal= */ true,
         "Namespace \"b\" is required but never provided.\n"
             + "You need to pass a library that has it in srcs or exports to your target's deps.");
   }
@@ -617,7 +628,10 @@ public final class DepsGeneratorTest {
   public void testNoDepsInDepsFile() throws Exception {
     SourceFile dep1 = SourceFile.fromCode("dep1.js", "");
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.<SourceFile>of(), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.<SourceFile>of(),
+        /* fatal= */ false,
         "No dependencies found in file");
   }
 
@@ -628,7 +642,7 @@ public final class DepsGeneratorTest {
     doErrorMessagesRun(
         ImmutableList.of(),
         ImmutableList.of(src1),
-        true /* fatal */,
+        /* fatal= */ true,
         "Could not find file \"./missing.js\".");
   }
 
diff --git a/test/com/google/javascript/jscomp/deps/JsFileRegexParserTest.java b/test/com/google/javascript/jscomp/deps/JsFileRegexParserTest.java
index 3dee3d1..4941131 100644
--- a/test/com/google/javascript/jscomp/deps/JsFileRegexParserTest.java
+++ b/test/com/google/javascript/jscomp/deps/JsFileRegexParserTest.java
@@ -31,10 +31,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link JsFileRegexParser}.
- *
- */
+/** Tests for {@link JsFileRegexParser}. */
 @RunWith(JUnit4.class)
 public final class JsFileRegexParserTest {
 
@@ -62,15 +59,16 @@ public final class JsFileRegexParserTest {
    */
   @Test
   public void testParseFile() {
-    String contents = "/*"
-      + "goog.provide('no1');*//*\n"
-      + "goog.provide('no2');\n"
-      + "*/goog.provide('yes1');\n"
-      + "/* blah */goog.provide(\"yes2\")/* blah*/\n"
-      + "goog.require('yes3'); // goog.provide('no3');\n"
-      + "// goog.provide('no4');\n"
-      + "goog.require(\"bar.data.SuperstarAddStarThreadActionRequestDelegate\"); "
-      + "//no new line at EOF";
+    String contents =
+        "/*"
+            + "goog.provide('no1');*//*\n"
+            + "goog.provide('no2');\n"
+            + "*/goog.provide('yes1');\n"
+            + "/* blah */goog.provide(\"yes2\")/* blah*/\n"
+            + "goog.require('yes3'); // goog.provide('no3');\n"
+            + "// goog.provide('no4');\n"
+            + "goog.require(\"bar.data.SuperstarAddStarThreadActionRequestDelegate\"); "
+            + "//no new line at EOF";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -88,11 +86,12 @@ public final class JsFileRegexParserTest {
   /** Tests correct recording of what was parsed. */
   @Test
   public void testParseFile2() {
-    String contents = ""
-      + "goog.module('yes1');\n"
-      + "var yes2 = goog.require('yes2');\n"
-      + "var C = goog.require(\"a.b.C\");\n"
-      + "let {D, E} = goog.require('a.b.d');";
+    String contents =
+        ""
+            + "goog.module('yes1');\n"
+            + "var yes2 = goog.require('yes2');\n"
+            + "var C = goog.require(\"a.b.C\");\n"
+            + "let {D, E} = goog.require('a.b.d');";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -113,11 +112,41 @@ public final class JsFileRegexParserTest {
   /** Tests correct recording of what was parsed. */
   @Test
   public void testParseFile3() {
-    String contents = ""
-      + "goog.module('yes1');\n"
-      + "var yes2=goog.require('yes2');\n"
-      + "var C=goog.require(\"a.b.C\");\n"
-      + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");";
+    String contents =
+        ""
+            + "goog.module('yes1');\n"
+            + "var yes2=goog.require('yes2');\n"
+            + "var C=goog.require(\"a.b.C\");\n"
+            + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");";
+
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("yes1"))
+            .setRequires(
+                ImmutableList.of(
+                    googRequireSymbol("yes2"),
+                    googRequireSymbol("a.b.C"),
+                    googRequireSymbol("a.b.d")))
+            .setLoadFlags(ImmutableMap.of("module", "goog"))
+            .build();
+
+    DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents);
+
+    assertDeps(expected, result);
+  }
+
+  /** Tests correct recording of what was parsed. */
+  @Test
+  public void testParseFileWithMultiLineRequires() {
+    parser.setShortcutMode(false);
+
+    String contents =
+        ""
+            + "goog.module('yes1');\n"
+            + "var fakerequire = 5;\n"
+            + "var yes2=goog.require(\n'yes2');\n"
+            + "var C=\ngoog.require(\"a.b.C\");\n"
+            + "const {\n  D,\n  E\n}=goog.require(\n\"a.b.d\");";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -174,11 +203,12 @@ public final class JsFileRegexParserTest {
   /** Tests correct recording of what was parsed. */
   @Test
   public void testParseWrappedGoogModule() {
-    String contents = ""
-      + "goog.loadModule(function(){\"use strict\";goog.module('yes1');\n"
-      + "var yes2=goog.require('yes2');\n"
-      + "var C=goog.require(\"a.b.C\");\n"
-      + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");});";
+    String contents =
+        ""
+            + "goog.loadModule(function(){\"use strict\";goog.module('yes1');\n"
+            + "var yes2=goog.require('yes2');\n"
+            + "var C=goog.require(\"a.b.C\");\n"
+            + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");});";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -201,12 +231,13 @@ public final class JsFileRegexParserTest {
   /** Tests ES6 modules parsed correctly, particularly the various formats. */
   @Test
   public void testParseEs6Module() {
-    String contents = ""
-        + "import def, {yes2} from './yes2';\n"
-        + "import C from './a/b/C';\n"
-        + "import * as d from './a/b/d';\n"
-        + "import \"./dquote\";\n"
-        + "export * from './exported';\n";
+    String contents =
+        ""
+            + "import def, {yes2} from './yes2';\n"
+            + "import C from './a/b/C';\n"
+            + "import * as d from './a/b/d';\n"
+            + "import \"./dquote\";\n"
+            + "export * from './exported';\n";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder("a.js", "b.js")
@@ -228,11 +259,8 @@ public final class JsFileRegexParserTest {
   /** Tests relative paths resolved correctly. */
   @Test
   public void testParseEs6Module2() {
-    String contents = ""
-        + "import './x';\n"
-        + "import '../y';\n"
-        + "import '../a/z';\n"
-        + "import '../c/w';\n";
+    String contents =
+        "" + "import './x';\n" + "import '../y';\n" + "import '../a/z';\n" + "import '../c/w';\n";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder("../../a/b.js", "/foo/bar/a/b.js")
@@ -253,9 +281,7 @@ public final class JsFileRegexParserTest {
   /** Tests handles goog.require and import 'goog:...'. */
   @Test
   public void testParseEs6Module3() {
-    String contents = ""
-        + "import 'goog:foo.bar.baz';\n"
-        + "goog.require('baz.qux');\n";
+    String contents = "" + "import 'goog:foo.bar.baz';\n" + "goog.require('baz.qux');\n";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder("b.js", "a.js")
@@ -280,12 +306,13 @@ public final class JsFileRegexParserTest {
             .setFactory(BrowserModuleResolver.FACTORY)
             .build();
 
-    String contents = ""
-        + "import './a';\n"
-        + "import './qux/b';\n"
-        + "import '../closure/c';\n"
-        + "import '../closure/d/e';\n"
-        + "import '../../corge/f';\n";
+    String contents =
+        ""
+            + "import './a';\n"
+            + "import './qux/b';\n"
+            + "import '../closure/c';\n"
+            + "import '../closure/d/e';\n"
+            + "import '../../corge/f';\n";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder("../bar/baz.js", "/foo/js/bar/baz.js")
@@ -301,9 +328,7 @@ public final class JsFileRegexParserTest {
             .build();
 
     DependencyInfo result =
-        parser
-            .setModuleLoader(loader)
-            .parseFile("/foo/js/bar/baz.js", "../bar/baz.js", contents);
+        parser.setModuleLoader(loader).parseFile("/foo/js/bar/baz.js", "../bar/baz.js", contents);
 
     assertDeps(expected, result);
   }
@@ -328,9 +353,7 @@ public final class JsFileRegexParserTest {
             .build();
 
     DependencyInfo result =
-        parser
-            .setModuleLoader(loader)
-            .parseFile("/foo/js/bar/baz.js", "../bar/baz.js", contents);
+        parser.setModuleLoader(loader).parseFile("/foo/js/bar/baz.js", "../bar/baz.js", contents);
 
     assertThat(result).isEqualTo(expected);
     assertThat(errorManager.getErrorCount()).isEqualTo(0);
@@ -390,13 +413,14 @@ public final class JsFileRegexParserTest {
   /** Tests shortcut mode doesn't stop at setTestOnly() or declareLegacyNamespace(). */
   @Test
   public void testNoShortcutForCommonModuleModifiers() {
-    String contents = ""
-      + "goog.module('yes1');\n"
-      + "goog.module.declareLegacyNamespace();\n"
-      + "goog.setTestOnly();\n"
-      + "var yes2=goog.require('yes2');\n"
-      + "var C=goog.require(\"a.b.C\");\n"
-      + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");";
+    String contents =
+        ""
+            + "goog.module('yes1');\n"
+            + "goog.module.declareLegacyNamespace();\n"
+            + "goog.setTestOnly();\n"
+            + "var yes2=goog.require('yes2');\n"
+            + "var C=goog.require(\"a.b.C\");\n"
+            + "const {\n  D,\n  E\n}=goog.require(\"a.b.d\");";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -413,13 +437,15 @@ public final class JsFileRegexParserTest {
 
   @Test
   public void testMultiplePerLine() {
-    String contents = "goog.provide('yes1');goog.provide('yes2');/*"
-        + "goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');";
+    String contents =
+        "goog.provide('yes1');goog.provide('yes2');/*"
+            + "goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');";
 
-    DependencyInfo expected = SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
-        .setProvides(ImmutableList.of("yes1", "yes2", "yes3"))
-        .setGoogModule(false)
-        .build();
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("yes1", "yes2", "yes3"))
+            .setGoogModule(false)
+            .build();
 
     DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents);
 
@@ -429,16 +455,18 @@ public final class JsFileRegexParserTest {
   @Test
   public void testShortcutMode1() {
     // For efficiency reasons, we stop reading after the ctor.
-    String contents = " // hi ! \n /* this is a comment */ "
-        + "goog.provide('yes1');\n /* and another comment */ \n"
-        + "goog.provide('yes2'); // include this\n"
-        + "foo = function() {};\n"
-        + "goog.provide('no1');";
-
-    DependencyInfo expected = SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
-        .setProvides(ImmutableList.of("yes1", "yes2"))
-        .setGoogModule(false)
-        .build();
+    String contents =
+        " // hi ! \n /* this is a comment */ "
+            + "goog.provide('yes1');\n /* and another comment */ \n"
+            + "goog.provide('yes2'); // include this\n"
+            + "foo = function() {};\n"
+            + "goog.provide('no1');";
+
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("yes1", "yes2"))
+            .setGoogModule(false)
+            .build();
     DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents);
 
     assertDeps(expected, result);
@@ -446,14 +474,16 @@ public final class JsFileRegexParserTest {
 
   @Test
   public void testShortcutMode2() {
-    String contents = "/** goog.provide('no1'); \n" +
-        " * goog.provide('no2');\n */\n"
-        + "goog.provide('yes1');\n";
-
-    DependencyInfo expected = SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
-        .setProvides(ImmutableList.of("yes1"))
-        .setGoogModule(false)
-        .build();
+    String contents =
+        "/** goog.provide('no1'); \n"
+            + " * goog.provide('no2');\n */\n"
+            + "goog.provide('yes1');\n";
+
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("yes1"))
+            .setGoogModule(false)
+            .build();
     DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents);
 
     assertDeps(expected, result);
@@ -461,14 +491,13 @@ public final class JsFileRegexParserTest {
 
   @Test
   public void testShortcutMode3() {
-    String contents = "/**\n" +
-        " * goog.provide('no1');\n */\n"
-        + "goog.provide('yes1');\n";
-
-    DependencyInfo expected = SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
-        .setProvides(ImmutableList.of("yes1"))
-        .setGoogModule(false)
-        .build();
+    String contents = "/**\n" + " * goog.provide('no1');\n */\n" + "goog.provide('yes1');\n";
+
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("yes1"))
+            .setGoogModule(false)
+            .build();
     DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents);
 
     assertDeps(expected, result);
@@ -478,12 +507,13 @@ public final class JsFileRegexParserTest {
   public void testIncludeGoog1() {
     String contents = "/**\n" + " * @provideGoog\n" + " */\n";
 
-    DependencyInfo expected = SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
-        .setProvides(ImmutableList.of("goog"))
-        .setGoogModule(false)
-        .build();
-    DependencyInfo result = parser.setIncludeGoogBase(true).parseFile(
-        SRC_PATH, CLOSURE_PATH, contents);
+    DependencyInfo expected =
+        SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
+            .setProvides(ImmutableList.of("goog"))
+            .setGoogModule(false)
+            .build();
+    DependencyInfo result =
+        parser.setIncludeGoogBase(true).parseFile(SRC_PATH, CLOSURE_PATH, contents);
     assertDeps(expected, result);
   }
 
@@ -552,19 +582,20 @@ public final class JsFileRegexParserTest {
             .setRequires(ImmutableList.of(googRequireSymbol("goog"), googRequireSymbol("bar")))
             .setGoogModule(false)
             .build();
-    DependencyInfo result = parser.setIncludeGoogBase(true).parseFile(
-        SRC_PATH, CLOSURE_PATH, contents);
+    DependencyInfo result =
+        parser.setIncludeGoogBase(true).parseFile(SRC_PATH, CLOSURE_PATH, contents);
     assertDeps(expected, result);
   }
 
   @Test
   public void testIncludeGoog3() {
     // This is pretending to provide goog, but it really doesn't.
-    String contents = "goog.provide('x');\n" +
-        "/**\n" +
-        " * the first constant in base.js\n" +
-        " */\n" +
-        "var COMPILED = false;\n";
+    String contents =
+        "goog.provide('x');\n"
+            + "/**\n"
+            + " * the first constant in base.js\n"
+            + " */\n"
+            + "var COMPILED = false;\n";
 
     DependencyInfo expected =
         SimpleDependencyInfo.builder(CLOSURE_PATH, SRC_PATH)
@@ -572,8 +603,8 @@ public final class JsFileRegexParserTest {
             .setRequires(ImmutableList.of(googRequireSymbol("goog")))
             .setGoogModule(false)
             .build();
-    DependencyInfo result = parser.setIncludeGoogBase(true).parseFile(
-        SRC_PATH, CLOSURE_PATH, contents);
+    DependencyInfo result =
+        parser.setIncludeGoogBase(true).parseFile(SRC_PATH, CLOSURE_PATH, contents);
     assertDeps(expected, result);
   }
 
@@ -586,8 +617,8 @@ public final class JsFileRegexParserTest {
             .setRequires(ImmutableList.of(googRequireSymbol("goog")))
             .setGoogModule(false)
             .build();
-    DependencyInfo result = parser.setIncludeGoogBase(true).parseFile(
-        SRC_PATH, CLOSURE_PATH, contents);
+    DependencyInfo result =
+        parser.setIncludeGoogBase(true).parseFile(SRC_PATH, CLOSURE_PATH, contents);
     assertDeps(expected, result);
   }
 
diff --git a/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java b/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
index 967dbff..15f27d0 100644
--- a/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
+++ b/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
@@ -32,7 +32,7 @@ import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathResolver;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -64,7 +64,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("js/a.js", "js/b.js"))
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
     assertUri("js/a.js", loader.resolve("js/a.js"));
     assertUri("js/b.js", resolveJsModule(loader.resolve("js/a.js"), "./b"));
@@ -78,7 +78,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("A/index.js", "B/index.js", "app.js"))
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     input("A/index.js");
@@ -113,7 +113,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/A/index.js", resolveJsModule(loader.resolve(" /foo.js"), "/A"));
@@ -321,7 +321,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/A/index.js", resolveJsModule(loader.resolve(" /foo.js"), "/A"));
@@ -378,7 +378,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(packageJsonMainEntries))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri(
@@ -420,7 +420,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("generated_files/"))
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(ImmutableMap.of()))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/node_modules/second.js", resolveJsModule(loader.resolve("/foo.js"), "second"));
@@ -451,7 +451,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("generated_files/"))
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(ImmutableMap.of()))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     // 'first' and 'second' should resolve from foo.js
@@ -475,7 +475,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("A/index.js", "B/index.js", "app.js"))
             .setFactory(new WebpackModuleResolver.Factory(webpackModulesById))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     input("A/index.js");
@@ -603,9 +603,8 @@ public final class ModuleLoaderTest {
                     ErrorHandler errorHandler,
                     PathEscaper pathEscaper) ->
                     new ModuleResolver(modulePaths, moduleRootPaths, errorHandler, pathEscaper) {
-                      @Nullable
                       @Override
-                      public String resolveJsModule(
+                      public @Nullable String resolveJsModule(
                           String scriptAddress,
                           String moduleAddress,
                           String sourcename,
diff --git a/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java b/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
index 8002f2b..5cab248 100644
--- a/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
@@ -55,7 +55,7 @@ import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -67,7 +67,7 @@ public final class ColorFindPropertyReferencesTest extends CompilerTestCase {
 
   private final Compiler compiler = new Compiler();
 
-  private CompilerPass processor;
+  private @Nullable CompilerPass processor;
   private ImmutableSet<String> expectedOriginalNameTypes = ImmutableSet.of();
 
   /**
diff --git a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
index 84bf22d..429cbb1 100644
--- a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
@@ -23,6 +23,8 @@ import static com.google.javascript.jscomp.disambiguate.ColorGraphBuilder.EdgeRe
 import static com.google.javascript.jscomp.disambiguate.ColorGraphBuilder.EdgeReason.CAN_HOLD;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Supplier;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableTable;
 import com.google.common.truth.Correspondence;
@@ -35,7 +37,7 @@ import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.ColorId;
 import com.google.javascript.jscomp.colors.ColorRegistry;
-import com.google.javascript.jscomp.colors.DebugInfo;
+import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.javascript.jscomp.disambiguate.ColorGraphBuilder.EdgeReason;
 import com.google.javascript.jscomp.graph.DiGraph;
 import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;
@@ -46,7 +48,7 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -70,8 +72,9 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
       ColorGraphNodeFactory.createFactory(
           ColorRegistry.builder().setDefaultNativeColorsForTesting().build());
 
-  private CompilerPass processor;
+  private @Nullable CompilerPass processor;
   private DiGraph<ColorGraphNode, Object> result;
+  private LinkedHashMap<String, ColorId> labelToId;
 
   @Override
   protected Compiler createCompiler() {
@@ -101,9 +104,12 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
   }
 
   private ColorGraphBuilder createBuilderIncludingCode(
-      @Nullable StubLcaFinder optLcaFinder, String src) {
+      // takes a Supplier<StubLcaFinder> so that callers may lazily create this StubLcaFinder after
+      // the labelToId map has been populated.
+      @Nullable Supplier<StubLcaFinder> optLcaFinder, String src) {
     ColorGraphNodeFactory graphNodeFactory = this.graphNodeFactory;
     LinkedHashMap<String, ColorGraphNode> testTypes = new LinkedHashMap<>();
+    this.labelToId = new LinkedHashMap<>();
 
     /** Flatten and collect the types of all NAMEs that start with "test". */
     this.processor =
@@ -117,13 +123,24 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                     if (n.isName() && n.getString().startsWith("test")) {
                       testTypes.put(n.getString(), graphNodeFactory.createNode(n.getColor()));
                     }
+
+                    if (n.isLabel()) {
+                      String labelName = n.getFirstChild().getString();
+                      Node labeledExpr =
+                          n.getSecondChild().isExprResult()
+                              ? n.getSecondChild().getOnlyChild()
+                              : n.getSecondChild();
+                      labelToId.put(labelName, labeledExpr.getColor().getId());
+                    }
                   }
                 });
     this.testSame(srcs(src));
+
     this.processor = null;
 
     ColorGraphBuilder graphBuilder =
-        this.createBuilder(optLcaFinder, this.compiler.getColorRegistry());
+        this.createBuilder(
+            optLcaFinder != null ? optLcaFinder.get() : null, this.compiler.getColorRegistry());
     graphBuilder.addAll(testTypes.values());
     return graphBuilder;
   }
@@ -138,14 +155,18 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "/** @interface */", //
                 "class IFoo { }",
                 "",
-                "let /** !IFoo */ test;"));
+                "let /** !IFoo */ test;",
+                "",
+                "IFOO_PROTOTYPE: IFoo.prototype",
+                "IFOO: test;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("top_object", "IFoo.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("IFoo.prototype", "IFoo", CAN_HOLD);
+    this.assertThatResultAsTable()
+        .containsCell(StandardColors.TOP_OBJECT.getId(), id("IFOO_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("IFOO_PROTOTYPE"), id("IFOO"), CAN_HOLD);
   }
 
   @Test
@@ -157,14 +178,18 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
             lines(
                 "class Foo { }", //
                 "",
-                "const test = new Foo();"));
+                "const test = new Foo();",
+                "",
+                "FOO_PROTOTYPE: Foo.prototype;",
+                "FOO: new Foo();"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("top_object", "Foo.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo.prototype", "Foo", CAN_HOLD);
+    this.assertThatResultAsTable()
+        .containsCell(StandardColors.TOP_OBJECT.getId(), id("FOO_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO_PROTOTYPE"), id("FOO"), CAN_HOLD);
   }
 
   @Test
@@ -177,15 +202,21 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Foo { }", //
                 "class Bar extends Foo { }",
                 "",
-                "const test = new Bar();"));
+                "const test = new Bar();",
+                "",
+                "FOO_PROTOTYPE: Foo.prototype;",
+                "FOO: new Foo();",
+                "BAR_PROTOTYPE: Bar.prototype;",
+                "FOO_PROTOTYPE: Foo.prototype;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("top_object", "Foo.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo.prototype", "Foo", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo", "Bar.prototype", CAN_HOLD);
+    this.assertThatResultAsTable()
+        .containsCell(StandardColors.TOP_OBJECT.getId(), id("FOO_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO_PROTOTYPE"), id("FOO"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO"), id("BAR_PROTOTYPE"), CAN_HOLD);
   }
 
   @Test
@@ -200,17 +231,24 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Qux extends Foo { }", //
                 "",
                 "const testBar = new Bar();",
-                "const testQux = new Qux();"));
+                "const testQux = new Qux();",
+                "",
+                "FOO_PROTOTYPE: Foo.prototype;",
+                "FOO: new Foo();",
+                "BAR_PROTOTYPE: Bar.prototype;",
+                "BAR: new Bar();",
+                "QUX_PROTOTYPE: Qux.prototype;",
+                "QUX: new Qux();"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Foo.prototype", "Foo", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo", "Bar.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Bar.prototype", "Bar", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo", "Qux.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Qux.prototype", "Qux", CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO_PROTOTYPE"), id("FOO"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO"), id("BAR_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("BAR_PROTOTYPE"), id("BAR"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO"), id("QUX_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("QUX_PROTOTYPE"), id("QUX"), CAN_HOLD);
   }
 
   @Test
@@ -222,14 +260,19 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
             lines(
                 "class Foo { }", //
                 "",
-                "const test = Foo;"));
+                "const test = Foo;",
+                "",
+                "FOO_PROTOTYPE: Foo.prototype;",
+                "FOO: new Foo();",
+                "BAR_PROTOTYPE: Bar.prototype;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("top_object", "Foo.prototype", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("Foo.prototype", "Foo", CAN_HOLD);
+    this.assertThatResultAsTable()
+        .containsCell(StandardColors.TOP_OBJECT.getId(), id("FOO_PROTOTYPE"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO_PROTOTYPE"), id("FOO"), CAN_HOLD);
   }
 
   @Test
@@ -242,13 +285,16 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "/** @interface */", //
                 "class IFoo { }",
                 "",
-                "let /** !IFoo */ test;"));
+                "let /** !IFoo */ test;",
+                "",
+                "IFOO: test;",
+                "IFOO_PROTOTYPE: IFoo.prototype;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("IFoo.prototype", "IFoo", CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("IFOO_PROTOTYPE"), id("IFOO"), CAN_HOLD);
   }
 
   @Test
@@ -262,22 +308,26 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Foo1 extends Foo0 { }", //
                 "class Foo2 extends Foo1 { }",
                 "",
-                "let /** !(typeof Foo2) */ test;"));
+                "let /** !(typeof Foo2) */ test;",
+                "FOO0_CTOR: Foo0;",
+                "FOO1_CTOR: Foo1;",
+                "FOO2_CTOR: Foo2;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("top_object", "(typeof Foo0)", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("(typeof Foo0)", "(typeof Foo1)", CAN_HOLD);
-    this.assertThatResultAsTable().containsCell("(typeof Foo1)", "(typeof Foo2)", CAN_HOLD);
+    this.assertThatResultAsTable()
+        .containsCell(StandardColors.TOP_OBJECT.getId(), id("FOO0_CTOR"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO0_CTOR"), id("FOO1_CTOR"), CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(id("FOO1_CTOR"), id("FOO2_CTOR"), CAN_HOLD);
   }
 
   @Test
   public void disambiguationSupertypes_createConnection() {
     // Given
-    Color parent = colorWithName("Parent").build();
-    Color child = colorWithName("Child").build();
+    Color parent = colorWithId(ColorId.fromUnsigned(100)).build();
+    Color child = colorWithId(ColorId.fromUnsigned(101)).build();
 
     ColorGraphBuilder builder =
         this.createBuilder(
@@ -293,16 +343,18 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Parent", "Child", CAN_HOLD);
+    this.assertThatResultAsTable().containsCell(parent.getId(), child.getId(), CAN_HOLD);
   }
 
   @Test
   public void unions_connectedAboveMembers() {
     // Given
-    StubLcaFinder stubFinder =
-        new StubLcaFinder()
-            .addStub(
-                ImmutableSet.of("Foo", "Bar", "Qux"), ImmutableSet.of("(Bar|Foo|Qux)", "unknown"));
+    Supplier<StubLcaFinder> stubFinder =
+        () ->
+            new StubLcaFinder()
+                .addStub(
+                    ImmutableSet.of(id("FOO"), id("BAR"), id("QUX")),
+                    ImmutableSet.of(id("FOO", "BAR", "QUX"), StandardColors.UNKNOWN.getId()));
     ColorGraphBuilder builder =
         this.createBuilderIncludingCode(
             stubFinder,
@@ -311,23 +363,31 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Bar { }",
                 "class Qux { }",
                 "",
-                "let /** (!Foo|!Bar|!Qux) */ test;"));
+                "let /** (!Foo|!Bar|!Qux) */ test;",
+                "",
+                "FOO: new Foo();",
+                "BAR: new Bar();",
+                "QUX: new Qux();"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("(Bar|Foo|Qux)", "Bar", ALGEBRAIC);
-    this.assertThatResultAsTable().containsCell("(Bar|Foo|Qux)", "Foo", ALGEBRAIC);
-    this.assertThatResultAsTable().containsCell("(Bar|Foo|Qux)", "Qux", ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(id("FOO", "BAR", "QUX"), id("BAR"), ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(id("FOO", "BAR", "QUX"), id("FOO"), ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(id("FOO", "BAR", "QUX"), id("QUX"), ALGEBRAIC);
   }
 
   @Test
   public void unions_connectBelowLca() {
     // Given
-    StubLcaFinder stubFinder =
-        new StubLcaFinder()
-            .addStub(ImmutableSet.of("Foo", "Bar", "Qux"), ImmutableSet.of("(Bar|Foo|Qux)", "Kif"));
+    ColorId kifId = ColorId.fromUnsigned(100);
+    Supplier<StubLcaFinder> stubFinder =
+        () ->
+            new StubLcaFinder()
+                .addStub(
+                    ImmutableSet.of(id("FOO"), id("BAR"), id("QUX")),
+                    ImmutableSet.of(id("FOO", "BAR", "QUX"), kifId));
     ColorGraphBuilder builder =
         this.createBuilderIncludingCode(
             stubFinder,
@@ -336,24 +396,31 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Bar { }",
                 "class Qux { }",
                 "",
-                "let /** (!Foo|!Bar|!Qux) */ test;"));
-    builder.add(this.graphNodeFactory.createNode(colorWithName("Kif").build()));
+                "let /** (!Foo|!Bar|!Qux) */ test;",
+                "",
+                "FOO: new Foo();",
+                "BAR: new Bar();",
+                "QUX: new Qux();"));
+    builder.add(this.graphNodeFactory.createNode(colorWithId(kifId).build()));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Kif", "(Bar|Foo|Qux)", ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(kifId, id("FOO", "BAR", "QUX"), ALGEBRAIC);
   }
 
   @Test
   public void unions_connectBelowLca_withMultipleLcas() {
     // Given
-    StubLcaFinder stubFinder =
-        new StubLcaFinder()
-            .addStub(
-                ImmutableSet.of("Foo", "Bar", "Qux"),
-                ImmutableSet.of("(Bar|Foo|Qux)", "Kif", "Lop"));
+    ColorId kixId = ColorId.fromUnsigned(100);
+    ColorId lopId = ColorId.fromUnsigned(101);
+    Supplier<StubLcaFinder> stubFinder =
+        () ->
+            new StubLcaFinder()
+                .addStub(
+                    ImmutableSet.of(id("FOO"), id("BAR"), id("QUX")),
+                    ImmutableSet.of(id("FOO", "BAR", "QUX"), kixId, lopId));
     ColorGraphBuilder builder =
         this.createBuilderIncludingCode(
             stubFinder,
@@ -362,26 +429,35 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Bar { }",
                 "class Qux { }",
                 "",
-                "let /** (!Foo|!Bar|!Qux) */ test;"));
-    builder.add(this.graphNodeFactory.createNode(colorWithName("Kif").build()));
-    builder.add(this.graphNodeFactory.createNode(colorWithName("Lop").build()));
+                "let /** (!Foo|!Bar|!Qux) */ test;",
+                "",
+                "FOO: new Foo();",
+                "BAR: new Bar();",
+                "QUX: new Qux();"));
+    builder.add(this.graphNodeFactory.createNode(colorWithId(kixId).build()));
+    builder.add(this.graphNodeFactory.createNode(colorWithId(lopId).build()));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Kif", "(Bar|Foo|Qux)", ALGEBRAIC);
-    // this.assertThatResultAsTable().containsCell("Lop", "(Bar|Foo|Qux
-    // )", ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(kixId, id("BAR", "FOO", "QUX"), ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(lopId, id("BAR", "FOO", "QUX"), ALGEBRAIC);
   }
 
   @Test
   public void unions_connectBelowLca_whichIsAlsoUnion() {
     // Given
-    StubLcaFinder stubFinder =
-        new StubLcaFinder()
-            .addStub(ImmutableSet.of("Foo", "Bar", "Qux"), ImmutableSet.of("(Bar|Foo|Qux)", "Kif"))
-            .addStub(ImmutableSet.of("Foo", "Bar"), ImmutableSet.of("(Bar|Foo)", "(Bar|Foo|Qux)"));
+    ColorId kifId = ColorId.fromUnsigned(100);
+    Supplier<StubLcaFinder> stubFinder =
+        () ->
+            new StubLcaFinder()
+                .addStub(
+                    ImmutableSet.of(id("FOO"), id("BAR"), id("QUX")),
+                    ImmutableSet.of(id("FOO", "BAR", "QUX"), kifId))
+                .addStub(
+                    ImmutableSet.of(id("FOO"), id("BAR")),
+                    ImmutableSet.of(id("FOO", "BAR"), id("FOO", "BAR", "QUX")));
     ColorGraphBuilder builder =
         this.createBuilderIncludingCode(
             stubFinder,
@@ -391,25 +467,31 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Qux { }",
                 "",
                 "let /** (!Foo|!Bar|!Qux) */ testA;",
-                "let /** (!Foo|!Bar) */ testB;"));
-    builder.add(this.graphNodeFactory.createNode(colorWithName("Kif").build()));
+                "let /** (!Foo|!Bar) */ testB;",
+                "",
+                "FOO: new Foo();",
+                "BAR: new Bar();",
+                "QUX: new Qux();"));
+    builder.add(this.graphNodeFactory.createNode(colorWithId(kifId).build()));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Kif", "(Bar|Foo|Qux)", ALGEBRAIC);
-    this.assertThatResultAsTable().containsCell("(Bar|Foo|Qux)", "(Bar|Foo)", ALGEBRAIC);
+    this.assertThatResultAsTable().containsCell(kifId, id("FOO", "BAR", "QUX"), ALGEBRAIC);
+    this.assertThatResultAsTable()
+        .containsCell(id("FOO", "BAR", "QUX"), id("FOO", "BAR"), ALGEBRAIC);
   }
 
   @Test
   public void unions_connectBelowLac_whichHasSameDescendantCount() {
     // Given
-    StubLcaFinder stubFinder =
-        new StubLcaFinder()
-            .addStub(
-                ImmutableSet.of("Foo.prototype", "Bar.prototype"),
-                ImmutableSet.of("(Bar.prototype|Foo.prototype)", "Kif"));
+    Supplier<StubLcaFinder> stubFinder =
+        () ->
+            new StubLcaFinder()
+                .addStub(
+                    ImmutableSet.of(id("FOO_PROTOTYPE"), id("BAR_PROTOTYPE")),
+                    ImmutableSet.of(id("FOO_PROTOTYPE", "BAR_PROTOTYPE"), id("KIF")));
     ColorGraphBuilder builder =
         this.createBuilderIncludingCode(
             stubFinder,
@@ -418,13 +500,18 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
                 "class Foo extends Kif { }",
                 "class Bar extends Kif { }",
                 "",
-                "let /** ((typeof Foo.prototype)|(typeof Bar.prototype)) */ test;"));
+                "let /** ((typeof Foo.prototype)|(typeof Bar.prototype)) */ test;",
+                "",
+                "KIF: new Kif();",
+                "FOO_PROTOTYPE: Foo.prototype;",
+                "BAR_PROTOTYPE: Bar.prototype;"));
 
     // When
     this.result = builder.build();
 
     // Then
-    this.assertThatResultAsTable().containsCell("Kif", "(Bar.prototype|Foo.prototype)", ALGEBRAIC);
+    this.assertThatResultAsTable()
+        .containsCell(id("KIF"), id("FOO_PROTOTYPE", "BAR_PROTOTYPE"), ALGEBRAIC);
 
     // Also check post-conditions.
   }
@@ -435,8 +522,8 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
             this.result.getNodes().stream()
                 .filter((n) -> n.getInEdges().isEmpty())
                 .collect(toImmutableSet()))
-        .comparingElementsUsing(NODE_HAS_TYPENAME)
-        .containsExactly("unknown");
+        .comparingElementsUsing(NODE_HAS_ID)
+        .containsExactly(StandardColors.UNKNOWN.getId());
   }
 
   @After
@@ -468,7 +555,7 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
   }
 
   private TableSubject assertThatResultAsTable() {
-    ImmutableTable.Builder<String, String, EdgeReason> table = ImmutableTable.builder();
+    ImmutableTable.Builder<ColorId, ColorId, EdgeReason> table = ImmutableTable.builder();
     for (DiGraphEdge<ColorGraphNode, Object> edge : this.result.getEdges()) {
       table.put(
           nameOf(edge.getSource()), nameOf(edge.getDestination()), (EdgeReason) edge.getValue());
@@ -485,7 +572,7 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
   private static final class StubLcaFinder
       extends LowestCommonAncestorFinder<ColorGraphNode, Object> {
     private DiGraph<ColorGraphNode, Object> graph;
-    private final LinkedHashMap<ImmutableSet<String>, ImmutableSet<String>> stubs =
+    private final LinkedHashMap<ImmutableSet<ColorId>, ImmutableSet<ColorId>> stubs =
         new LinkedHashMap<>();
     private final LinkedHashMap<Runnable, Integer> preconditions = new LinkedHashMap<>();
 
@@ -498,7 +585,7 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
       return this;
     }
 
-    StubLcaFinder addStub(ImmutableSet<String> from, ImmutableSet<String> to) {
+    StubLcaFinder addStub(ImmutableSet<ColorId> from, ImmutableSet<ColorId> to) {
       this.stubs.put(from, to);
       return this;
     }
@@ -510,10 +597,10 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
         entry.setValue(entry.getValue() - 1);
       }
 
-      ImmutableSet<String> rootNames =
+      ImmutableSet<ColorId> rootIds =
           roots.stream().map(ColorGraphBuilderTest::nameOf).collect(toImmutableSet());
-      assertThat(this.stubs).containsKey(rootNames);
-      ImmutableSet<String> resultNames = this.stubs.get(rootNames);
+      assertThat(this.stubs).containsKey(rootIds);
+      ImmutableSet<ColorId> resultNames = this.stubs.get(rootIds);
 
       ImmutableSet<ColorGraphNode> results =
           this.graph.getNodes().stream()
@@ -526,25 +613,31 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
     }
   }
 
-  private static String nameOf(DiGraphNode<ColorGraphNode, Object> node) {
+  private static ColorId nameOf(DiGraphNode<ColorGraphNode, Object> node) {
     return nameOf(node.getValue());
   }
 
-  private static String nameOf(ColorGraphNode flat) {
-    return nameOf(flat.getColor());
+  private static ColorId nameOf(ColorGraphNode flat) {
+    return flat.getColor().getId();
   }
 
-  private static String nameOf(Color color) {
-    return color.getDebugInfo().getCompositeTypename();
+  private static Color.Builder colorWithId(ColorId id) {
+    return Color.singleBuilder().setId(id);
   }
 
-  private static Color.Builder colorWithName(String name) {
-    return Color.singleBuilder()
-        .setId(ColorId.fromAscii(name))
-        .setDebugInfo(DebugInfo.builder().setCompositeTypename(name).build());
+  private static final Correspondence<DiGraphNode<ColorGraphNode, Object>, ColorId> NODE_HAS_ID =
+      Correspondence.transforming(ColorGraphBuilderTest::nameOf, "in a node with type");
+
+  private ColorId id(String labelName) {
+    return Preconditions.checkNotNull(
+        this.labelToId.get(labelName), "Could not find label %s", labelName);
   }
 
-  private static final Correspondence<DiGraphNode<ColorGraphNode, Object>, String>
-      NODE_HAS_TYPENAME =
-          Correspondence.transforming(ColorGraphBuilderTest::nameOf, "in a node with type");
+  private ColorId id(String... idSources) {
+    ImmutableSet.Builder<ColorId> ids = ImmutableSet.builder();
+    for (String idSource : idSources) {
+      ids.add(id(idSource));
+    }
+    return ColorId.union(ids.build());
+  }
 }
diff --git a/test/com/google/javascript/jscomp/disambiguate/DisambiguatePropertiesTest.java b/test/com/google/javascript/jscomp/disambiguate/DisambiguatePropertiesTest.java
index 61caef5..e636a12 100644
--- a/test/com/google/javascript/jscomp/disambiguate/DisambiguatePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/DisambiguatePropertiesTest.java
@@ -1064,6 +1064,178 @@ public final class DisambiguatePropertiesTest extends CompilerTestCase {
                 "}")));
   }
 
+  @Test
+  public void classStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  static {",
+                "    this.x = 1;",
+                "  }",
+                "}",
+                "Foo.x;",
+                "class Bar {",
+                "  static {",
+                "    this.x = 2;",
+                "  }",
+                "}")),
+        expected(
+            lines(
+                "class Foo {",
+                "  static {",
+                "    this.JSC$1_x = 1;",
+                "  }",
+                "}",
+                "Foo.JSC$1_x;",
+                "class Bar {",
+                "  static {",
+                "    this.JSC$2_x = 2;",
+                "  }",
+                "}")));
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  static x = 0;",
+                "  x = 0;",
+                "  static {",
+                "    this.x = 1;",
+                "  }",
+                "}",
+                "Foo.x;",
+                "let f = new Foo();",
+                "f.x;",
+                "class Bar {",
+                "  static x = 0;",
+                "  x = 0;",
+                "  static {",
+                "    this.x = 2;",
+                "  }",
+                "}")),
+        expected(
+            lines(
+                "class Foo {",
+                "  static JSC$1_x = 0;",
+                "  JSC$2_x = 0;",
+                "  static {",
+                "    this.JSC$1_x = 1;",
+                "  }",
+                "}",
+                "Foo.JSC$1_x;",
+                "let f = new Foo();",
+                "f.JSC$2_x;",
+                "class Bar {",
+                "  static JSC$3_x = 0;",
+                "  JSC$4_x = 0;",
+                "  static {",
+                "    this.JSC$3_x = 2;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void classStaticBlock_method() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  m() { }",
+                "}",
+                "",
+                "class Baz {",
+                "  static {",
+                "    let f = new Foo();",
+                "    f.m();",
+                "  }",
+                "}",
+                "class Bar {",
+                "  m() { }",
+                "}")),
+        expected(
+            lines(
+                "class Foo {",
+                "  JSC$1_m() { }",
+                "}",
+                "",
+                "class Baz {",
+                "  static {",
+                "    let f = new Foo();",
+                "    f.JSC$1_m();",
+                "  }",
+                "}",
+                "class Bar {",
+                "  JSC$5_m() { }",
+                "}")));
+
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  static m() { }",
+                "}",
+                "",
+                "class Baz {",
+                "  static m() { }",
+                "  static {",
+                "    Foo.m();",
+                "  }",
+                "}",
+                "class Bar {",
+                "  static m() { }",
+                "}")),
+        expected(
+            lines(
+                "class Foo {",
+                "  static JSC$1_m() { }",
+                "}",
+                "",
+                "class Baz {",
+                "  static JSC$2_m() { }",
+                "  static {",
+                "    Foo.JSC$1_m();",
+                "  }",
+                "}",
+                "class Bar {",
+                "  static JSC$3_m() { }",
+                "}")));
+  }
+
+  @Test
+  public void testClassStaticBlock_function() {
+    test(
+        srcs(
+            lines(
+                "/** @constructor */",
+                "function Foo() { };",
+                "",
+                "class Foo2 extends Foo {",
+                "  static z() { }",
+                "  static {",
+                "    Foo.z = 0;",
+                "  }",
+                "}",
+                "",
+                "class Other {",
+                "  z() { }",
+                "}")),
+        expected(
+            lines(
+                "/** @constructor */",
+                "function Foo() { };",
+                "",
+                "class Foo2 extends Foo {",
+                "  static JSC$1_z() { }",
+                "  static {",
+                "    Foo.JSC$1_z = 0;",
+                "  }",
+                "}",
+                "",
+                "class Other {",
+                "  JSC$3_z() { }",
+                "}")));
+  }
+
   private static final class SilenceNoiseGuard extends WarningsGuard {
     private static final ImmutableSet<DiagnosticType> RELEVANT_DIAGNOSTICS =
         ImmutableSet.of(DisambiguateProperties.PROPERTY_INVALIDATION);
diff --git a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
index 06a5bf5..61b3ff9 100644
--- a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
+++ b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
@@ -18,6 +18,7 @@ package com.google.javascript.jscomp.graph;
 
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,8 +29,8 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class GraphReachabilityTest {
-  GraphReachability<String, String> reachability = null;
-  DiGraph<String, String> graph = null;
+  @Nullable GraphReachability<String, String> reachability = null;
+  @Nullable DiGraph<String, String> graph = null;
 
   @Test
   public void testSimple() {
diff --git a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
index 104901c..9203cc9 100644
--- a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
+++ b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
@@ -1420,6 +1420,10 @@ public final class ConvertToTypedInterfaceTest extends CompilerTestCase {
     test("while (i++ < 10) { var /** number */ field = i; }", "/** @type {number} */ var field;");
 
     test(
+        "label: while (i++ < 10) { var /** number */ field = i; }",
+        "/** @type {number} */ var field;");
+
+    test(
         "do { var /** number */ field = i; } while (i++ < 10);",
         "/** @type {number} */ var field;");
 
@@ -2058,4 +2062,29 @@ public final class ConvertToTypedInterfaceTest extends CompilerTestCase {
             "  properties: 0",
             "};"));
   }
+
+  @Test
+  public void testGoogModuleGet() {
+    test(
+        lines(
+            "goog.provide('a.b.c');",
+            "goog.provide('a.b.c.d');",
+            "goog.require('x.y.z');",
+            "",
+            "/** @const */",
+            "a.b.c = {};",
+            "/** @const */",
+            "a.b.c.d = goog.module.get('x.y.z').d;",
+            ""),
+        lines(
+            "goog.provide('a.b.c');",
+            "goog.provide('a.b.c.d');",
+            "goog.require('x.y.z');",
+            "",
+            "/** @const */",
+            "a.b.c = {};",
+            "/** @const */",
+            "a.b.c.d = goog.module.get('x.y.z').d;",
+            ""));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java b/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
index cbd0481..7a5b8d7 100644
--- a/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
+++ b/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
@@ -31,10 +31,10 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Test compiler by comparing output to data files aka golden files.
- * Always start with the options object from this class.
+ * Test compiler by comparing output to data files aka golden files. Always start with the options
+ * object from this class.
  */
-public class GoldenFileComparer {
+public final class GoldenFileComparer {
 
   private static final String DATA_DIR =
       "test/"
@@ -115,8 +115,8 @@ public class GoldenFileComparer {
    */
   public static void compileAndCompareSubsetOfActualToExpected(
       String goldenFileName, CompilerOptions options, String sourceFileName) throws Exception {
-    List<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
-    List<SourceFile> externsFiles = ImmutableList.of();
+    ImmutableList<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
+    ImmutableList<SourceFile> externsFiles = ImmutableList.of();
     String compiledSource = compile(externsFiles, sourceFiles, options);
     String goldenSource = readFile(toFullPath(goldenFileName));
 
@@ -144,8 +144,8 @@ public class GoldenFileComparer {
    */
   public static void compileAndCompare(
       String goldenFileName, CompilerOptions options, String sourceFileName) throws Exception {
-    List<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
-    List<SourceFile> externsFiles = ImmutableList.of();
+    ImmutableList<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
+    ImmutableList<SourceFile> externsFiles = ImmutableList.of();
     compileAndCompare(goldenFileName, options, sourceFiles, externsFiles);
   }
 
@@ -161,10 +161,10 @@ public class GoldenFileComparer {
       String externsFileName)
       throws Exception {
     // Prepare sources
-    List<SourceFile> sourceFiles =
+    ImmutableList<SourceFile> sourceFiles =
         ImmutableList.of(readSource(sourceFileName1), readSource(sourceFileName2));
 
-    List<SourceFile> externsFiles =
+    ImmutableList<SourceFile> externsFiles =
         ImmutableList.of(SourceFile.fromFile(toFullPath(externsFileName)));
 
     compileAndCompare(goldenFileName, options, sourceFiles, externsFiles);
@@ -178,4 +178,6 @@ public class GoldenFileComparer {
     options.setPrettyPrint(true);
     return options;
   }
+
+  private GoldenFileComparer() {}
 }
diff --git a/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java b/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
index 7f2bcf3..4e8cc11 100644
--- a/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/AdvancedOptimizationsIntegrationTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp.integration;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.jscomp.base.JSCompStrings.lines;
+import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Joiner;
@@ -377,6 +378,19 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
   }
 
   @Test
+  public void testGithubIssue3940_logicalOrAssignCallee() {
+
+    CompilerOptions options = createCompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
+
+    test(
+        options,
+        "window['bug'] = function() { var arr; (arr || (arr = [])).push(0); return arr; }",
+        "window.bug = function() { var a; (a ||= []).push(0); return a; }");
+  }
+
+  @Test
   public void testBigInt() {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
@@ -679,14 +693,79 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
               "use(new Foo().method());",
               "")
         },
+        new String[] {"", "", "use(1)"});
+  }
+
+  @Test
+  public void testSourceInfoForReferenceToImportedSymbol() {
+    CompilerOptions options = createCompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    options.setLanguageOut(LanguageMode.NO_TRANSPILE);
+    options.setEmitUseStrict(false); // 'use strict'; is just noise here
+    options.setPrettyPrint(true);
+    options.setPrintSourceAfterEachPass(true);
+
+    externs =
+        ImmutableList.of(
+            new TestExternsBuilder().addExtra("function use(x) {}").buildExternsFile("externs"));
+    test(
+        options,
         new String[] {
-          "",
-          "",
+          TestExternsBuilder.getClosureExternsAsSource(),
           lines(
-              // TODO(bradfordcsmith): Why is `new class {};` left behind?
-              "new class {};", //
-              "use(1)"),
-        });
+              "goog.module('a.b.c');",
+              "/** @noinline */",
+              "function foo() {}",
+              "exports.foo = foo;",
+              ""),
+          lines(
+              "", //
+              "goog.module('a.b.d');",
+              "const {foo} = goog.require('a.b.c');",
+              "use(foo());",
+              "")
+        },
+        new String[] {"", "", "function a() {} use(a())"});
+
+    // first child is externs tree, second is sources tree
+    final Node srcsRoot = lastCompiler.getRoot().getLastChild();
+    final Node closureExternsAsSourceScriptNode = srcsRoot.getFirstChild();
+    final Node definitionScript = closureExternsAsSourceScriptNode.getNext();
+    final Node usageScript = definitionScript.getNext();
+
+    // Find the `a` node of `use(a());` which originally was `use(foo())`
+    final Node referenceToFoo =
+        usageScript
+            .getLastChild() // `use(a());` EXPR_RESULT statement
+            .getOnlyChild() // `use(a())` CALL expression
+            .getSecondChild() // `a()` CALL expression
+            .getFirstChild(); // `a`
+
+    // Original usageScript line 4: `foo` of `use(foo());`
+    // Compiled usageScript statement: `a` of `use(a());`
+    assertNode(referenceToFoo)
+        .isName("a")
+        .hasSourceFileName(usageScript.getSourceFileName())
+        .hasLineno(4)
+        .hasCharno(4); // `use(` is 4 chars
+  }
+
+  @Test
+  public void testClassExpressionExtendingSuperclassSideEffectingConstructor() {
+    CompilerOptions options = createCompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setTypeBasedOptimizationOptions(options);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2015);
+
+    externs =
+        ImmutableList.of(
+            new TestExternsBuilder().addExtra("function use(x) {}").buildExternsFile("externs"));
+
+    test(
+        options,
+        "class Parent { constructor() { use(42); } } new class extends Parent {}",
+        // we could do better simplifying this code, but at least the output is correct.
+        "class a { constructor() { use(42); } } new class extends a {}");
   }
 
   @Test
@@ -2666,4 +2745,49 @@ public final class AdvancedOptimizationsIntegrationTest extends IntegrationTestC
             "  return c(a) + b(a) + c(e);",
             "};"));
   }
+
+  @Test
+  public void testRetainSideeffectCallInBuilder() {
+    CompilerOptions options = createCompilerOptions();
+    options.setPropertyRenaming(PropertyRenamingPolicy.ALL_UNQUOTED);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2020);
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+
+    externs =
+        ImmutableList.of(
+            new TestExternsBuilder()
+                .addClosureExterns()
+                .addExtra("/** @type {function(): string} */", "var retrieveElementRef;")
+                .buildExternsFile("externs.js"));
+
+    // regression test for bad dead code elimination:
+    // compiler used to keep the first 'retrieveElementRef();' call but then delete the second
+    // one called via `Selector.create().build();`
+    test(
+        options,
+        lines(
+            "goog.module('main');",
+            "",
+            "retrieveElementRef();",
+            "class SelectorBuilder {",
+            "    /** @return {!Selector} */",
+            "    build() {",
+            "        return new Selector(retrieveElementRef());",
+            "    }",
+            "}",
+            "class Selector {",
+            "    /** @param {string} s */",
+            "    constructor(s) {",
+            "        /** @type {string} */",
+            "        this.s = s;",
+            "    }",
+            "    /** @return {!SelectorBuilder} */",
+            "    static create() {",
+            "        return new SelectorBuilder();",
+            "    }",
+            "}",
+            "Selector.create().build();",
+            ""),
+        "retrieveElementRef(); class a { constructor() { retrieveElementRef(); } } new a();");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java b/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
index 7c76466..8aeb7fa 100644
--- a/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
 public final class ES2021IntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setDevMode(DevMode.EVERY_PASS);
diff --git a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
index 9569f1b..816f990 100644
--- a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
@@ -37,9 +37,9 @@ import org.junit.runners.JUnit4;
 public final class ES2022IntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
-    options.setLanguageIn(LanguageMode.UNSTABLE);
+    options.setLanguage(LanguageMode.UNSUPPORTED);
     options.setDevMode(DevMode.EVERY_PASS);
     options.setCodingConvention(new GoogleCodingConvention());
     return options;
@@ -47,7 +47,6 @@ public final class ES2022IntegrationTest extends IntegrationTestCase {
 
   private CompilerOptions checksOnlyCompilerOptions() {
     CompilerOptions options = createCompilerOptions();
-    options.setLanguageOut(LanguageMode.NO_TRANSPILE);
     options.setChecksOnly(true);
     WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
 
@@ -58,8 +57,6 @@ public final class ES2022IntegrationTest extends IntegrationTestCase {
     CompilerOptions options = createCompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setTypeBasedOptimizationOptions(options);
-
-    options.setLanguageOut(LanguageMode.ECMASCRIPT_NEXT);
     WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
 
     return options;
@@ -327,4 +324,65 @@ public final class ES2022IntegrationTest extends IntegrationTestCase {
             "  f6 = alert(1);",
             "}"));
   }
+
+  @Test
+  public void computedFieldExecutionOrderAndDeadAssignmentElimination() {
+    CompilerOptions options = fullyOptimizedCompilerOptions();
+
+    externs =
+        ImmutableList.of(
+            new TestExternsBuilder()
+                .addConsole()
+                .addExtra("var window;")
+                .buildExternsFile("externs"));
+
+    test(
+        options,
+        lines(
+            "window.test = function() {",
+            "var x = 0;",
+            "/** @unrestricted */",
+            "class MyClass {", //
+            "  static f1 = x;",
+            "  static [(x = 1)] = 1;", // (x = 1) executes before assigning 'static f1 = x'
+            "}",
+            "console.log(MyClass.f1);", // prints 1
+            "};"),
+        // TODO(b/189993301): this should be logging '1' instead
+        lines("window.a = function() { console.log(0); };"));
+  }
+
+  @Test
+  public void computedMethodExecutionOrderAndDeadAssignmentElimination() {
+    CompilerOptions options = fullyOptimizedCompilerOptions();
+
+    externs =
+        ImmutableList.of(
+            new TestExternsBuilder()
+                .addConsole()
+                .addExtra("var window;")
+                .buildExternsFile("externs"));
+
+    test(
+        options,
+        lines(
+            "window.test = function() {",
+            "var x = 0;",
+            "/** @unrestricted */",
+            "class MyClass {", //
+            "  static f1 = x;",
+            "  static [(x = 1)]() {};", // (x = 1) executes before assigning 'static f1 = x'
+            "}",
+            "console.log(MyClass.f1);", // prints 1
+            "};"),
+        lines(
+            "window.b=function(){",
+            "  var a=0;",
+            "  class c {",
+            "    static a=a;",
+            "    static [a=1](){}",
+            "  }",
+            "  console.log(c.a)",
+            "};"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/IntegrationTest.java b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
index e253be8..af3bf08 100644
--- a/test/com/google/javascript/jscomp/integration/IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
@@ -461,6 +461,160 @@ public final class IntegrationTest extends IntegrationTestCase {
   }
 
   @Test
+  public void testCheckProvideAlias() {
+    CompilerOptions options = createCompilerOptions();
+
+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
+    options.setChecksOnly(true);
+    options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.ERROR);
+    options.setClosurePass(true);
+    options.setBadRewriteModulesBeforeTypecheckingThatWeWantToGetRidOf(false);
+
+    externs =
+        ImmutableList.of(
+            SourceFile.fromCode("externs", lines("var arguments;", "arguments.callee;")));
+
+    String base = TestExternsBuilder.getClosureExternsAsSource();
+
+    String code =
+        lines(
+            "goog.provide('cycle.a.Widget');",
+            "goog.provide('cycle.a.Widget.Item');",
+            "",
+            "cycle.a.Widget = class {};",
+            "cycle.a.Widget.Item = class {};",
+            "",
+            "goog.provide('a.Widget');",
+            "/** @provideAlreadyProvided */",
+            "goog.provide('a.Widget.Item');",
+            "",
+            "/** @const */",
+            "a.Widget = cycle.a.Widget;",
+            "",
+            "(() => {",
+            "  const Item = goog.module.get('a.Widget.Item');",
+            "",
+            "  /** @const {typeof cycle.a.Widget.Item} */",
+            "  const x = a.Widget.Item;",
+            "})();",
+            "");
+
+    String result =
+        lines(
+            "goog.provide('cycle.a.Widget');",
+            "goog.provide('cycle.a.Widget.Item');",
+            "",
+            "cycle.a.Widget = class {};",
+            "cycle.a.Widget.Item = class {};",
+            "",
+            "goog.provide('a.Widget');",
+            "/** @provideAlreadyProvided */",
+            "goog.provide('a.Widget.Item');",
+            "",
+            "a.Widget = cycle.a.Widget;",
+            "",
+            "(() => {",
+            "  const Item = a.Widget.Item;",
+            "  const x = a.Widget.Item;",
+            "})();",
+            "");
+
+    test(options, new String[] {base, code}, new String[] {base, result});
+  }
+
+  @Test
+  public void testCheckProvideAlias2() {
+    CompilerOptions options = createCompilerOptions();
+
+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
+    options.setChecksOnly(true);
+    options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.ERROR);
+    options.setClosurePass(true);
+    options.setBadRewriteModulesBeforeTypecheckingThatWeWantToGetRidOf(false);
+
+    externs =
+        ImmutableList.of(
+            SourceFile.fromCode("externs", lines("var arguments;", "arguments.callee;")));
+
+    String base = TestExternsBuilder.getClosureExternsAsSource();
+    String code =
+        lines(
+            "goog.provide('cycle.a.Widget');",
+            "goog.provide('cycle.a.Widget.Item');",
+            "",
+            "cycle.a.Widget = class {};",
+            "cycle.a.Widget.Item = class {};",
+            "",
+            "goog.provide('a.Widget');",
+            "/** @provideAlreadyProvided */",
+            "goog.provide('a.Widget.Item');",
+            "",
+            "/** @const */",
+            "a.Widget = cycle.a.Widget;",
+            "",
+            "/** @param {!null} a */ function fn(a) {}",
+            "fn(goog.module.get('a.Widget.Item'));",
+            "");
+
+    // Expect:
+    // JSC_TYPE_MISMATCH. actual parameter 1 of fn does not match formal parameter
+    // found   : (typeof cycle.a.Widget.Item)
+    // required: None
+    test(options, new String[] {base, code}, DiagnosticGroups.CHECK_TYPES);
+  }
+
+  @Test
+  public void testCheckProvideAlias3() {
+    CompilerOptions options = createCompilerOptions();
+
+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
+    options.setChecksOnly(true);
+    options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.ERROR);
+    options.setClosurePass(true);
+    options.setBadRewriteModulesBeforeTypecheckingThatWeWantToGetRidOf(false);
+
+    externs =
+        ImmutableList.of(
+            SourceFile.fromCode("externs", lines("var arguments;", "arguments.callee;")));
+
+    String base = TestExternsBuilder.getClosureExternsAsSource();
+    String code1 =
+        lines(
+            "goog.provide('cycle.a.Widget');",
+            "goog.provide('cycle.a.Widget.Item');",
+            "",
+            "cycle.a.Widget = class {};",
+            "cycle.a.Widget.Item = class {};",
+            "",
+            "");
+    String code2 =
+        lines(
+            "goog.provide('a.Widget');",
+            "/** @provideAlreadyProvided */",
+            "goog.provide('a.Widget.Item');",
+            "",
+            "/** @const */",
+            "a.Widget = cycle.a.Widget;",
+            "");
+    String code3 =
+        lines(
+            "goog.module('usage');",
+            "const Item = goog.require('a.Widget.Item');",
+            "",
+            "/** @param {!null} a */ function fn(a) {}",
+            "fn(Item);",
+            "");
+
+    // Expect:
+    // JSC_TYPE_MISMATCH. actual parameter 1 of fn does not match formal parameter
+    // found   : (typeof cycle.a.Widget.Item)
+    // required: None
+    // test(options, new String[] {base, code1, code2}, DiagnosticGroups.CHECK_TYPES);
+
+    test(options, new String[] {base, code1, code2, code3}, DiagnosticGroups.CHECK_TYPES);
+  }
+
+  @Test
   public void testExportedNames() {
     CompilerOptions options = createCompilerOptions();
     options.setClosurePass(true);
@@ -1103,6 +1257,17 @@ public final class IntegrationTest extends IntegrationTestCase {
 
     options.setWarningLevel(DiagnosticGroups.CHECK_USELESS_CODE, CheckLevel.ERROR);
     test(options, code, DiagnosticGroups.CHECK_USELESS_CODE);
+
+    // http://b/194615750
+    test(
+        options,
+        lines(
+            "function foo() {", //
+            "  return;",
+            "  for (const n of [1, 2]) {",
+            "  }",
+            "}"),
+        DiagnosticGroups.CHECK_USELESS_CODE);
   }
 
   @Test
@@ -2280,7 +2445,7 @@ public final class IntegrationTest extends IntegrationTestCase {
     String code = "var a;";
 
     options.setSkipNonTranspilationPasses(true);
-    options.sourceMapOutputPath = "./src.map";
+    options.setSourceMapOutputPath("./src.map");
 
     Compiler compiler = compile(options, code);
     compiler.toSource();
@@ -4039,12 +4204,13 @@ public final class IntegrationTest extends IntegrationTestCase {
   @Test
   @GwtIncompatible("AbstractCommandLineRunner.getBuiltinExterns()")
   public void testEs6ModuleEntryPoint() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index.js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index"));
 
     CompilerOptions options = new CompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
@@ -4064,12 +4230,13 @@ public final class IntegrationTest extends IntegrationTestCase {
   @Test
   @GwtIncompatible("AbstractCommandLineRunner.getBuiltinExterns()")
   public void testEs6ModuleEntryPointWithSquareBracketsInFilename() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index[0].js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
 
     CompilerOptions options = new CompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
@@ -4332,4 +4499,67 @@ public final class IntegrationTest extends IntegrationTestCase {
             "var $jscomp$scope$98447280$0$fn = function(a, b) {};",
             "$jscomp$scope$98447280$0$fn[\"$inject\"] = [\"a\", \"b\"];"));
   }
+
+  @Test
+  public void testGitHubIssue3861() {
+    CompilerOptions options = createCompilerOptions();
+    options.setCheckTypes(true);
+
+    test(
+        options,
+        lines(
+            "(function () {", //
+            "  arguments (628);",
+            "})"),
+        DiagnosticGroups.CHECK_TYPES);
+  }
+
+  @Test
+  public void forceClassTranspilationKeepAsync_withNoTranspile() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.NO_TRANSPILE);
+    options.setForceClassTranspilation(true);
+
+    // test transpiling classes but leave async functions untranspiled
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { async f(p) { await p; return 0; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = async function(p) { await p; return 0 };",
+            "window['C'] = i0$classdecl$var0"));
+  }
+
+  @Test
+  public void forceClassTranspilationKeepAsyncFunctions_withEs2021Out() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2021);
+    options.setForceClassTranspilation(true);
+
+    // test transpiling classes but leave async functions untranspiled
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { async f(p) { await p; return 0; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = async function(p) { await p; return 0 };",
+            "window['C'] = i0$classdecl$var0"));
+  }
+
+  @Test
+  public void forceClassTranspilationKeepDestructuring_withEs2015Out() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2015);
+    options.setForceClassTranspilation(true);
+
+    // check that we can transpile the ES2016 `**` + classes, but leave the ES2015 destructuring
+    // parameter behind.
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { f({num}) { return num ** 3; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = function({num}) { return Math.pow(num, 3); };",
+            "window['C'] = i0$classdecl$var0"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java b/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
index 1b654a4..fb39d50 100644
--- a/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
+++ b/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
@@ -40,6 +40,7 @@ import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /** Framework for end-to-end test cases. */
@@ -117,20 +118,20 @@ abstract class IntegrationTestCase {
                       "/**",
                       " * @constructor",
                       " * @return {!TypeError}",
-                      " * @param {*=} opt_message",
-                      " * @param {*=} opt_file",
-                      " * @param {*=} opt_line",
+                      " * @param {*=} message",
+                      " * @param {*=} fileNameOrOptions",
+                      " * @param {*=} line",
                       " */",
-                      "function TypeError(opt_message, opt_file, opt_line) {}",
+                      "function TypeError(message, fileNameOrOptions, line) {}",
                       "/**",
                       " * @constructor",
-                      " * @param {*=} opt_message",
-                      " * @param {*=} opt_file",
-                      " * @param {*=} opt_line",
+                      " * @param {*=} message",
+                      " * @param {*=} fileNameOrOptions",
+                      " * @param {*=} line",
                       " * @return {!Error}",
                       " * @nosideeffects",
                       " */",
-                      "function Error(opt_message, opt_file, opt_line) {}",
+                      "function Error(message, fileNameOrOptions, line) {}",
                       "",
                       "/** @constructor */",
                       "var HTMLElement = function() {};",
@@ -140,7 +141,7 @@ abstract class IntegrationTestCase {
   protected List<SourceFile> externs = DEFAULT_EXTERNS;
 
   // The most recently used compiler.
-  protected Compiler lastCompiler;
+  protected @Nullable Compiler lastCompiler;
 
   protected boolean useNoninjectingCompiler = false;
 
@@ -239,7 +240,10 @@ abstract class IntegrationTestCase {
 
   /** Asserts that when compiling with the given compiler options, there is an error or warning. */
   protected void test(
-      CompilerOptions options, String[] original, String[] compiled, DiagnosticGroup warnings) {
+      CompilerOptions options,
+      String[] original,
+      String @Nullable [] compiled,
+      DiagnosticGroup warnings) {
     Compiler compiler = compile(options, original);
     checkUnexpectedErrorsOrWarnings(compiler, 1);
 
@@ -269,11 +273,9 @@ abstract class IntegrationTestCase {
     testParseError(options, original, null);
   }
 
-  /**
-   * Asserts that there is at least one parse error.
-   */
-  protected void testParseError(CompilerOptions options,
-      String original, String compiled) {
+  /** Asserts that there is at least one parse error. */
+  protected void testParseError(
+      CompilerOptions options, String original, @Nullable String compiled) {
     Compiler compiler = compile(options, original);
     for (JSError error : compiler.getErrors()) {
       if (!DiagnosticGroups.PARSING.matches(error)) {
diff --git a/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java b/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
index bb0c46b..760d68d 100644
--- a/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
 public final class OptionalChainingIntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setLanguageOut(LanguageMode.NO_TRANSPILE);
diff --git a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
index 16779e0..75c4f99 100644
--- a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
@@ -26,7 +26,10 @@ import com.google.javascript.jscomp.CompilationLevel;
 import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
 import com.google.javascript.jscomp.CompilerOptions.IncrementalCheckMode;
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.jscomp.CrossChunkMethodMotion;
 import com.google.javascript.jscomp.DiagnosticGroups;
+import com.google.javascript.jscomp.JSChunk;
 import com.google.javascript.jscomp.SourceFile;
 import com.google.javascript.jscomp.VariableRenamingPolicy;
 import com.google.javascript.jscomp.WarningLevel;
@@ -147,6 +150,31 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
   }
 
   @Test
+  public void disambiguatesAndDeletesMethodsAcrossLibraries_withTranspilation() throws IOException {
+    SourceFile lib1 = code("class Lib1 { m() { return 'lib1'; } n() { return 'delete me'; } }");
+    SourceFile lib2 = code("class Lib2 { m() { return 'delete me'; } n() { return 'lib2'; } }");
+    precompileLibrary(lib1);
+    precompileLibrary(lib2);
+    precompileLibrary(
+        extern(new TestExternsBuilder().addAlert().build()),
+        typeSummary(lib1),
+        typeSummary(lib2),
+        code("alert(new Lib1().m()); alert(new Lib2().n());"));
+
+    CompilerOptions options = new CompilerOptions();
+    CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
+    options.setDisambiguateProperties(true);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT5);
+
+    Compiler compiler = compileTypedAstShards(options);
+
+    Node expectedRoot = parseExpectedCode("", "", "alert('lib1'); alert('lib2')");
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
+  @Test
   public void lateFulfilledGlobalVariableIsRenamed() throws IOException {
     SourceFile lib1 =
         code(
@@ -380,6 +408,57 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
         .isEqualTo(expectedRoot);
   }
 
+  @Test
+  public void testCrossChunkMethodMotion() throws IOException {
+    // run checks & serialize .typedasts
+    SourceFile f1 =
+        SourceFile.fromCode(
+            "f1.js",
+            lines(
+                "/** @constructor */",
+                "var Foo = function() {};",
+                "Foo.prototype.bar = function() {};",
+                "/** @type {!Foo} */",
+                "var x = new Foo();"));
+    SourceFile f2 = SourceFile.fromCode("f2.js", "x.bar();");
+    precompileLibrary(f1);
+    precompileLibrary(typeSummary(f1), f2);
+
+    Compiler compiler = new Compiler();
+    // create two chunks, where chunk 2 depends on chunk 1, and they contain f1 and f2
+    CompilerOptions options = new CompilerOptions();
+    options.setCrossChunkMethodMotion(true);
+    JSChunk chunk1 = new JSChunk("chunk1");
+    chunk1.add(f1);
+    JSChunk chunk2 = new JSChunk("chunk2");
+    chunk2.add(f2);
+    chunk2.addDependency(chunk1);
+
+    // run compilation
+    try (InputStream inputStream = toInputStream(this.shards)) {
+      compiler.initModulesWithTypedAstFilesystem(
+          ImmutableList.copyOf(this.externFiles),
+          ImmutableList.of(chunk1, chunk2),
+          options,
+          inputStream);
+    }
+    compiler.parse();
+    compiler.stage2Passes();
+    compiler.stage3Passes();
+
+    String[] expected =
+        new String[] {
+          CrossChunkMethodMotion.STUB_DECLARATIONS
+              + "var Foo = function() {};"
+              + "Foo.prototype.bar=JSCompiler_stubMethod(0); var x=new Foo;",
+          "Foo.prototype.bar=JSCompiler_unstubMethod(0,function(){}); x.bar()",
+        };
+    Node expectedRoot = parseExpectedCode(expected);
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
   // use over 'compileTypedAstShards' if you want to validate reported errors or warnings in your
   // @Test case.
   private Compiler compileTypedAstShardsWithoutErrorChecks(CompilerOptions options)
diff --git a/test/com/google/javascript/jscomp/lint/CheckConstPrivatePropertiesTest.java b/test/com/google/javascript/jscomp/lint/CheckConstPrivatePropertiesTest.java
index d8444cf..8a872ec 100644
--- a/test/com/google/javascript/jscomp/lint/CheckConstPrivatePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/lint/CheckConstPrivatePropertiesTest.java
@@ -251,6 +251,14 @@ public final class CheckConstPrivatePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassPropModified_destructuring() {
+    testSame("class C { constructor() { /** @private */ this.a = 2; [this.a] = []; } }");
+    testSame("class C { constructor() { /** @private */ this.a = 2; ({a: this.a} = {}); } }");
+    testSame("class C { constructor() { /** @private */ this.a = 2; [{a: this.a}] = [{}]; } }");
+    testSame("class C { constructor() { /** @private */ this.a = 2; [this.a = 0] = []; } }");
+  }
+
+  @Test
   public void testPrototype_Property() {
     testSame("/** @constructor */ function C() {} /** @private */ C.prototype.prop = 1;");
     testSame(
diff --git a/test/com/google/javascript/jscomp/lint/CheckVarTest.java b/test/com/google/javascript/jscomp/lint/CheckVarTest.java
index f239187..516086f 100644
--- a/test/com/google/javascript/jscomp/lint/CheckVarTest.java
+++ b/test/com/google/javascript/jscomp/lint/CheckVarTest.java
@@ -53,6 +53,20 @@ public class CheckVarTest extends CompilerTestCase {
   }
 
   @Test
+  public void testSuppressWarning() {
+    testSame(
+        lines(
+            "/**",
+            " * @fileoverview",
+            " * @suppress {lintVarDeclarations}",
+            " */",
+            "var x;",
+            "var x12 = 12;",
+            "export var x;",
+            "function f() { var x = 12; return x; }"));
+  }
+
+  @Test
   public void testNoWarning() {
     testSame("function f() { return 'var'; }");
     testSame("let x;");
diff --git a/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java b/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
index 2de289a..bc2730d 100644
--- a/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
+++ b/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
@@ -37,7 +37,7 @@ import org.junit.runners.JUnit4;
 /** Ported from rhino/testsrc/org/mozilla/javascript/tests/AttachJsDocsTest.java */
 @RunWith(JUnit4.class)
 public final class AttachJsdocsTest extends BaseJSTypeTestCase {
-  private Config.LanguageMode mode;
+  private LanguageMode mode;
 
   @Before
   public void setUp() throws Exception {
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index 433b55c..d161b9b 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -2249,6 +2249,17 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testParseNoDts1() {
+    JSDocInfo doc = parse("@nodts*/", true);
+    assertThat(doc.isNoDts()).isTrue();
+  }
+
+  @Test
+  public void testParseNoDts2() {
+    parse("@nodts\n@nodts*/", JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE, "extra @nodts tag");
+  }
+
+  @Test
   public void testBugAnnotation() {
     parse("@bug */");
   }
@@ -2863,7 +2874,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             "@suppress {x,y} Some description.",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
     assertThat(info.getSuppressionsAndTheirDescription())
         .containsEntry(ImmutableSet.of("x", "y"), "Some description.");
@@ -2878,7 +2889,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             " * Spans across lines.",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
     assertThat(info.getSuppressionsAndTheirDescription())
         .containsEntry(ImmutableSet.of("x", "y"), "Some description. Spans across lines.");
@@ -2895,7 +2906,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             " * @override",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getAuthors()).contains("XYZ");
     assertThat(info.isOverride()).isTrue();
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
@@ -2910,7 +2921,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   public void testSuppressWithDescription_repeatedWarnings1() {
     String jsDocComment =
         lines("@suppress {x} Some description.", " * @suppress {x} Another description.", "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x"));
     assertThat(info.getSuppressionsAndTheirDescription()).hasSize(1);
     assertThat(info.getSuppressionsAndTheirDescription())
@@ -2922,7 +2933,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   public void testSuppressWithDescription_repeatedWarnings2() {
     String jsDocComment =
         lines("@suppress {x} Some description.", " * @suppress {x, y} Another description.", "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y"));
     assertThat(info.getSuppressionsAndTheirDescription()).hasSize(2);
     assertThat(info.getSuppressionsAndTheirDescription())
@@ -3247,7 +3258,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     JSDocInfo jsdoc =
         parse("@return {Foo} some long \n * multiline" + " \n * description */", true);
 
-    JSDocInfo.Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0);
+    Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0);
     assertDocumentationInMarker(returnDoc, "some long multiline description", 14, 2, 15);
     assertThat(returnDoc.getType().getPositionOnStartLine()).isEqualTo(8);
     assertThat(returnDoc.getType().getPositionOnEndLine()).isEqualTo(12);
@@ -5174,7 +5185,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     String comment = "* @desc This is a comment */";
     JSDocInfo info = parse(comment);
     assertThat(info.getOriginalCommentString()).isNull();
-    info = parse(comment, true /* parseDocumentation */);
+    info = parse(comment, /* parseDocumentation= */ true);
     assertThat(info.getOriginalCommentString()).isEqualTo(comment);
   }
 
@@ -5660,8 +5671,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param endCharno The ending character of the text.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertDocumentationInMarker(
-      JSDocInfo.Marker marker, String description, int startCharno, int endLineno, int endCharno) {
+  private static Marker assertDocumentationInMarker(
+      Marker marker, String description, int startCharno, int endLineno, int endCharno) {
     assertThat(marker.getDescription()).isNotNull();
     assertThat(marker.getDescription().getItem()).isEqualTo(description);
 
@@ -5683,8 +5694,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param hasBrackets Whether the type in the type field is expected to have brackets.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertTypeInMarker(
-      JSDocInfo.Marker marker,
+  private static Marker assertTypeInMarker(
+      Marker marker,
       String typeName,
       int startLineno,
       int startCharno,
@@ -5716,8 +5727,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param startCharno The starting character of the text.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertNameInMarker(
-      JSDocInfo.Marker marker, String name, int startLine, int startCharno) {
+  private static Marker assertNameInMarker(
+      Marker marker, String name, int startLine, int startCharno) {
     assertThat(marker.getNameNode()).isNotNull();
     assertThat(marker.getNameNode().getItem().getString()).isEqualTo(name);
 
@@ -5740,7 +5751,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param startCharno The expected character on the starting line.
    * @return The marker found, for further testing.
    */
-  private static JSDocInfo.Marker assertAnnotationMarker(
+  private static Marker assertAnnotationMarker(
       JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno) {
     return assertAnnotationMarker(jsdoc, annotationName, startLineno, startCharno, 0);
   }
@@ -5757,16 +5768,16 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param index The index of the marker.
    * @return The marker found, for further testing.
    */
-  private static JSDocInfo.Marker assertAnnotationMarker(
+  private static Marker assertAnnotationMarker(
       JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno, int index) {
 
-    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();
+    Collection<Marker> markers = jsdoc.getMarkers();
 
     assertThat(markers).isNotEmpty();
 
     int counter = 0;
 
-    for (JSDocInfo.Marker marker : markers) {
+    for (Marker marker : markers) {
       if (marker.getAnnotation() != null) {
         if (annotationName.equals(marker.getAnnotation().getItem())) {
 
@@ -5831,8 +5842,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     return parse(
         comment,
         parseDocumentation
-            ? Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE
-            : Config.JsDocParsing.TYPES_ONLY,
+            ? JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE
+            : JsDocParsing.TYPES_ONLY,
         warnings);
   }
 
@@ -5855,7 +5866,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             .setClosurePrimitiveNames(extraPrimitives)
             .setLanguageMode(LanguageMode.ECMASCRIPT3)
             .setParseInlineSourceMaps(true)
-            .setStrictMode(Config.StrictMode.SLOPPY)
+            .setStrictMode(StrictMode.SLOPPY)
             .build();
 
     StaticSourceFile file = new SimpleSourceFile("testcode", SourceKind.STRONG);
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
index d5a333d..d8af5b9 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
@@ -51,9 +51,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization1() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, LEFT_CURLY, STRING, RIGHT_CURLY, EOL, STAR, ANNOTATION);
-    List<String> strings = ImmutableList.of("type", "string", "private");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STAR, ANNOTATION, LEFT_CURLY, STRING, RIGHT_CURLY, EOL, STAR, ANNOTATION);
+    ImmutableList<String> strings = ImmutableList.of("type", "string", "private");
     testJSDocTokenStream(" * @type {string}\n * @private", tokens, strings);
     testJSDocTokenStream(" *    @type { string } \n * @private",
         tokens, strings);
@@ -65,9 +65,18 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization2() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, LEFT_ANGLE, STRING, PIPE, STRING, RIGHT_ANGLE, RIGHT_CURLY);
-    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            ANNOTATION,
+            LEFT_CURLY,
+            STRING,
+            LEFT_ANGLE,
+            STRING,
+            PIPE,
+            STRING,
+            RIGHT_ANGLE,
+            RIGHT_CURLY);
+    ImmutableList<String> strings = ImmutableList.of("param", "Array", "string", "null");
     testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
     testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
     testJSDocTokenStream("@param {Array.<string |null>}", tokens, strings);
@@ -84,10 +93,21 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization4() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, LEFT_ANGLE, LEFT_PAREN, STRING, COMMA,
-        STRING, RIGHT_PAREN, RIGHT_ANGLE, RIGHT_CURLY, EOF);
-    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            ANNOTATION,
+            LEFT_CURLY,
+            STRING,
+            LEFT_ANGLE,
+            LEFT_PAREN,
+            STRING,
+            COMMA,
+            STRING,
+            RIGHT_PAREN,
+            RIGHT_ANGLE,
+            RIGHT_CURLY,
+            EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Array", "string", "null");
     testJSDocTokenStream("@param {Array.<(string,null)>}", tokens, strings);
     testJSDocTokenStream("@param {Array  .<(string,null)> } ", tokens, strings);
     testJSDocTokenStream(" @param {Array.<  (  string,null)>}",
@@ -101,8 +121,8 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization5() {
-    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "foo.Bar");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "foo.Bar");
     testJSDocTokenStream("@param foo.Bar*/", tokens, strings);
     testJSDocTokenStream(" @param   foo.Bar*/", tokens, strings);
     testJSDocTokenStream(" @param foo.Bar   */", tokens, strings);
@@ -110,9 +130,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization6() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);
-    List<String> strings = ImmutableList.of("hidden", "static", "desc");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);
+    ImmutableList<String> strings = ImmutableList.of("hidden", "static", "desc");
     testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings);
     testJSDocTokenStream("@hidden\n @static\n@desc*/", tokens, strings);
     testJSDocTokenStream("@hidden\n@static\n @desc*/", tokens, strings);
@@ -125,9 +145,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization7() {
-    List<JsDocToken> tokens =
+    ImmutableList<JsDocToken> tokens =
         ImmutableList.of(ITER_REST, ITER_REST, ITER_REST, ITER_REST, ITER_REST, LEFT_ANGLE, EOC);
-    List<String> strings = ImmutableList.of();
+    ImmutableList<String> strings = ImmutableList.of();
 
     testJSDocTokenStream("................<*/", tokens, strings);
     testJSDocTokenStream("............... .<*/", tokens, strings);
@@ -139,11 +159,11 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization8() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING,
-        STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(
-        "param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING, STRING, EOL, EOC);
+    ImmutableList<String> strings =
+        ImmutableList.of("param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name");
     testJSDocTokenStream(
         " * @param foo.Bar opt_name this parameter is a name\n" +
         " */", tokens, strings);
@@ -154,12 +174,12 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization9() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION,
-        STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(
-        "param", "foo.Bar", "opt_name", "this", "parameter", "does",
-        "media", "blah");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION, STRING, EOL, EOC);
+    ImmutableList<String> strings =
+        ImmutableList.of(
+            "param", "foo.Bar", "opt_name", "this", "parameter", "does", "media", "blah");
     testJSDocTokenStream(
         " * @param foo.Bar opt_name this parameter does @media blah\n" +
         " */", tokens, strings);
@@ -167,16 +187,17 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization10() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_ANGLE, STRING, RIGHT_ANGLE, EOC);
-    List<String> strings = ImmutableList.of("Array", "String");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STRING, LEFT_ANGLE, STRING, RIGHT_ANGLE, EOC);
+    ImmutableList<String> strings = ImmutableList.of("Array", "String");
     testJSDocTokenStream("Array<String>*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization11() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, QMARK, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "string");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STRING, QMARK, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "string");
     testJSDocTokenStream("@param {string?}*/", tokens, strings);
     testJSDocTokenStream(" @param {string?}*/", tokens, strings);
     testJSDocTokenStream("@param { string?}*/", tokens, strings);
@@ -188,16 +209,17 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization12() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, ITER_REST, EOC);
-    List<String> strings = ImmutableList.of("function");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, ITER_REST, EOC);
+    ImmutableList<String> strings = ImmutableList.of("function");
 
     testJSDocTokenStream("function ...*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization13() {
-    List<JsDocToken> tokens = ImmutableList.of(ITER_REST, LEFT_SQUARE, STRING, RIGHT_SQUARE, EOC);
-    List<String> strings = ImmutableList.of("number");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ITER_REST, LEFT_SQUARE, STRING, RIGHT_SQUARE, EOC);
+    ImmutableList<String> strings = ImmutableList.of("number");
 
     testJSDocTokenStream("...[number]*/", tokens, strings);
   }
@@ -208,16 +230,17 @@ public final class JsDocTokenStreamTest {
     // followed by a comma (,) we are allowing this case to parse this way.
     // This is a simplification of the tokenizer, but the extra complexity is
     // never used.
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar...");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, EOC);
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar...");
 
     testJSDocTokenStream("foo[ bar...*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization15() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, COMMA, ITER_REST, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STRING, LEFT_SQUARE, STRING, COMMA, ITER_REST, EOC);
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar");
 
     testJSDocTokenStream("foo[ bar,...*/", tokens, strings);
     testJSDocTokenStream("foo[ bar ,...*/", tokens, strings);
@@ -228,42 +251,43 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization16() {
-    List<JsDocToken> tokens =
+    ImmutableList<JsDocToken> tokens =
         ImmutableList.of(STRING, COLON, COLON, COLON, ITER_REST, STRING, COLON, STRING, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar", "bar2");
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar", "bar2");
 
     testJSDocTokenStream("foo:::...bar:bar2*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization17() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of("..");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    ImmutableList<String> strings = ImmutableList.of("..");
 
     testJSDocTokenStream("..\n*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization18() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(".");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    ImmutableList<String> strings = ImmutableList.of(".");
 
     testJSDocTokenStream(".\n*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization19() {
-    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, LEFT_CURLY, STAR, RIGHT_CURLY, EOC);
-    List<String> strings = ImmutableList.of("type", "*");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STAR, RIGHT_CURLY, EOC);
+    ImmutableList<String> strings = ImmutableList.of("type", "*");
 
     testJSDocTokenStream("@type {*}*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization20() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, BANG, STRING, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "Object");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, BANG, STRING, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Object");
     testJSDocTokenStream("@param {!Object}*/", tokens, strings);
     testJSDocTokenStream(" @param {!Object}*/", tokens, strings);
     testJSDocTokenStream("@param {! Object}*/", tokens, strings);
@@ -275,9 +299,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization21() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, EQUALS, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "Object");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STRING, EQUALS, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Object");
     testJSDocTokenStream("@param {Object=}*/", tokens, strings);
     testJSDocTokenStream(" @param {Object=}*/", tokens, strings);
     testJSDocTokenStream("@param { Object =}*/", tokens, strings);
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index 9410083..f5b1f0b 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -74,7 +74,11 @@ public final class ParserTest extends BaseJSTypeTestCase {
   private static final String UNEXPECTED_RETURN = "return must be inside function";
 
   private static final String UNEXPECTED_LABELLED_CONTINUE =
-      "continue can only use labeles of iteration statements";
+      "continue can only use labels of iteration statements";
+
+  private static final String UNEXPECTED_YIELD = "yield must be inside generator function";
+
+  private static final String UNEXPECTED_AWAIT = "await must be inside asynchronous function";
 
   private static final String UNDEFINED_LABEL = "undefined label";
 
@@ -88,8 +92,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   private static final String SEMICOLON_EXPECTED = "Semi-colon expected";
 
-  private Config.LanguageMode mode;
-  private Config.JsDocParsing parsingMode;
+  private LanguageMode mode;
+  private JsDocParsing parsingMode;
   private Config.StrictMode strictMode;
   private boolean isIdeMode = false;
   private FeatureSet expectedFeatures;
@@ -1604,7 +1608,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(exprResultA).hasType(Token.EXPR_RESULT);
     assertThat(exprResultA.getNonJSDocCommentString()).isEqualTo("// comment before GETPROP");
 
-    Node nodeB = exprResultA.getFirstChild().getFirstChild();
+    Node nodeB = exprResultA.getFirstFirstChild();
     assertNode(nodeB).hasType(Token.GETPROP);
     assertThat(nodeB.getNonJSDocCommentString()).isEqualTo("// comment on GETPROP");
 
@@ -1855,7 +1859,6 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(fn).hasType(Token.FUNCTION);
     Node xNode = fn.getSecondChild().getFirstChild();
     assertThat(xNode.getNonJSDocCommentString()).contains("/* blah */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isFalse();
   }
 
   @Test
@@ -1866,7 +1869,6 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(fn).hasType(Token.FUNCTION);
     Node xNode = fn.getSecondChild().getFirstChild();
     assertThat(xNode.getNonJSDocCommentString()).contains("// blah");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isFalse();
   }
 
   @Test
@@ -1880,10 +1882,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = paramListNode.getFirstChild();
     Node yNode = paramListNode.getSecondChild();
 
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* first */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("/* first */");
     assertThat(yNode.getNonJSDocCommentString()).isEqualTo("/* second */");
-    assertThat(yNode.getNonJSDocComment().isTrailing()).isFalse();
   }
 
   @Test
@@ -1897,8 +1897,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = paramListNode.getFirstChild();
     Node yNode = xNode.getNext();
 
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* first */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("/* first */");
+    ;
     assertThat(yNode.getNonJSDocCommentString()).isEmpty();
   }
 
@@ -1912,8 +1912,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node paramListNode = fn.getSecondChild();
     Node xNode = paramListNode.getFirstChild();
     assertNode(xNode).hasType(Token.NAME);
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* first */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("/* first */");
   }
 
   // Tests that same-line trailing comments attach to the same line param
@@ -1938,11 +1937,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = paramListNode.getFirstChild();
     Node yNode = paramListNode.getSecondChild();
 
-    assertThat(xNode.getNonJSDocCommentString()).isEqualTo("// first");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).isEqualTo("// first");
 
-    assertThat(yNode.getNonJSDocCommentString()).isEqualTo("// second");
-    assertThat(yNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(yNode.getTrailingNonJSDocCommentString()).isEqualTo("// second");
   }
 
   // Tests that same-line trailing comments attach to the same line param
@@ -1967,11 +1964,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = paramListNode.getFirstChild();
     Node yNode = paramListNode.getSecondChild();
 
-    assertThat(xNode.getNonJSDocCommentString()).isEqualTo("/* first */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).isEqualTo("/* first */");
 
-    assertThat(yNode.getNonJSDocCommentString()).isEqualTo("/* second */");
-    assertThat(yNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(yNode.getTrailingNonJSDocCommentString()).isEqualTo("/* second */");
   }
 
   // Tests that same-line trailing comments attach to the same line param
@@ -1995,12 +1990,170 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = paramListNode.getFirstChild();
     Node yNode = paramListNode.getSecondChild();
 
-    assertThat(xNode.getNonJSDocCommentString()).isEqualTo("/* first */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(xNode.getTrailingNonJSDocCommentString()).isEqualTo("/* first */");
 
     assertThat(yNode.getNonJSDocComment()).isNull();
   }
 
+  @Test
+  public void testNonJSDocTrailingCommentOnConstant() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1; // comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantNoWhitespace() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1;// comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantWithMoreWhitespace() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1;   // comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantFollowedByConstant() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse(lines("const A = 1; // comment", "", "const B = 2;")).getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testMultipleNonJSDocTrailingComments() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("const A = 1; /* A1 */ /* A2 */ // A3", "", "const B = 2;"));
+    Node a = n.getFirstChild();
+    assertNode(a).hasType(Token.CONST);
+    Node b = n.getLastChild();
+    assertNode(a).hasType(Token.CONST);
+    assertThat(b.getNonJSDocCommentString()).isEqualTo("/* A2 */// A3");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunction() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse("function foo(){} // comment").getFirstChild();
+    assertNode(n).hasType(Token.FUNCTION);
+
+    assertThat(n.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunctionCall() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("function g(){ f(); // comment", "f();}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunctionCallInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n =
+        parse(
+            lines(
+                "if (true) {",
+                "  f1(); // comment1 on f1()",
+                "  // comment2",
+                "  // comment3",
+                "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString())
+        .isEqualTo("// comment1 on f1()\n// comment2\n// comment3");
+  }
+
+  @Test
+  public void testLastNonJSDocCommentInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f();", "  /* comment */", "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testLastNonJSDocCommentInBlockWithBlankLines() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f();", "", "", "  /* comment */", "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    // TODO(b/242294987): This should keep the blank lines.
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testInlineCommentInFunctionCallInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f(0, 1 /* comment */);}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+    // TODO(b/242294987): This should not be an "end of block" comment (which we treat as trailing
+    // comment on the last child), but a comment on the argument.
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testNonJSDocBigCommentInbetween() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("let x = 0; // comment on x", "//", "// more comment", "let y = 1;"));
+
+    Node fstLetDecl = n.getFirstChild();
+    Node sndLetDecl = n.getLastChild();
+
+    assertNode(fstLetDecl).hasType(Token.LET);
+    assertThat(fstLetDecl.getTrailingNonJSDocCommentString()).isEqualTo("// comment on x");
+    assertNode(sndLetDecl).hasType(Token.LET);
+    assertThat(sndLetDecl.getNonJSDocCommentString()).isEqualTo("//\n// more comment");
+  }
+
+  @Test
+  public void testInlineNonJSDocCommentsOnSeparateLetDeclarations() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+
+    Node n = parse("let a /* leading a */ = {c} /* trailing */; let /* leading b */ b  = {d};");
+    Node letADecl = n.getFirstChild();
+    Node letBDecl = n.getLastChild();
+
+    assertNode(letADecl).hasType(Token.LET);
+    assertNode(letBDecl).hasType(Token.LET);
+    assertThat(letADecl.getFirstFirstChild().getNonJSDocCommentString())
+        .contains("/* leading a */");
+    assertThat(letADecl.getTrailingNonJSDocCommentString()).contains("/* trailing */");
+    assertThat(letBDecl.getFirstChild().getNonJSDocCommentString()).contains("/* leading b */");
+  }
+
   // function f( // blah1
   //              x,
   //             // blah2
@@ -2022,11 +2175,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
     Node xNode = fn.getSecondChild().getFirstChild();
     assertThat(xNode.getNonJSDocCommentString()).contains("// blah1");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isFalse();
 
     Node yNode = fn.getSecondChild().getSecondChild();
     assertThat(yNode.getNonJSDocCommentString()).isEqualTo("// blah2");
-    assertThat(yNode.getNonJSDocComment().isTrailing()).isFalse();
   }
 
   // function f( /* blah1 */ x,
@@ -2049,11 +2200,9 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
     Node xNode = fn.getSecondChild().getFirstChild();
     assertThat(xNode.getNonJSDocCommentString()).contains("/* blah1 */");
-    assertThat(xNode.getNonJSDocComment().isTrailing()).isFalse();
 
     Node yNode = fn.getSecondChild().getSecondChild();
     assertThat(yNode.getNonJSDocCommentString()).isEqualTo("// blah2");
-    assertThat(yNode.getNonJSDocComment().isTrailing()).isFalse();
   }
 
   @Test
@@ -2082,7 +2231,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(fn).hasType(Token.FUNCTION);
 
     Node xNode = fn.getSecondChild().getFirstChild();
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* blah1 */// blah");
+    assertThat(xNode.getNonJSDocCommentString()).contains("/* blah1 */");
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("// blah");
   }
 
   @Test
@@ -2102,8 +2252,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node exprNode = scriptNode.getLastChild();
     assertNode(exprNode).hasType(Token.EXPR_RESULT);
 
-    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("// second");
-    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(scriptNode.getTrailingNonJSDocCommentString()).isEqualTo("// second");
   }
 
   @Test
@@ -2123,8 +2272,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node exprNode = scriptNode.getLastChild();
     assertNode(exprNode).hasType(Token.EXPR_RESULT);
 
-    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("/* second */");
-    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+    assertThat(scriptNode.getTrailingNonJSDocCommentString()).isEqualTo("/* second */");
   }
 
   @Test
@@ -2146,9 +2294,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node exprNode = scriptNode.getLastChild();
     assertNode(exprNode).hasType(Token.EXPR_RESULT);
 
-    assertThat(scriptNode.getNonJSDocCommentString())
+    assertThat(scriptNode.getTrailingNonJSDocCommentString())
         .isEqualTo("// second\n/* third */\n// fourth");
-    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
   }
 
   @Test
@@ -2169,15 +2316,12 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
     Node exprNode = scriptNode.getLastChild().getLastChild().getFirstChild();
     assertNode(exprNode).hasType(Token.EXPR_RESULT);
-    // Ideally, exprNode contains "// first\n// second".
     assertThat(exprNode.getNonJSDocCommentString()).isEqualTo("// first");
-    assertThat(exprNode.getNonJSDocComment().isTrailing()).isFalse();
 
-    // TODO(rishipal): the comments `// second` and `// third` do not have an AST node to attach to
-    // that "starts" after them (the `if(true) {..}` block starts before the comments).
-    // Hence both comments get attached to the SCRIPT node as a trailing comment.
-    assertThat(scriptNode.getNonJSDocCommentString()).isEqualTo("// second\n\n// third");
-    assertThat(scriptNode.getNonJSDocComment().isTrailing()).isTrue();
+    Node callNode = scriptNode.getLastChild().getLastChild().getLastChild();
+    assertThat(callNode.getTrailingNonJSDocCommentString()).isEqualTo("// second");
+
+    assertThat(scriptNode.getTrailingNonJSDocCommentString()).isEqualTo("// third");
   }
 
   @Test
@@ -2193,7 +2337,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(fn).hasType(Token.FUNCTION);
 
     Node xNode = fn.getSecondChild().getFirstChild();
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* blah1 */// blah");
+    assertThat(xNode.getNonJSDocCommentString()).contains("/* blah1 */");
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("/ blah");
   }
 
   @Test
@@ -2236,7 +2381,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node xNode = fn.getSecondChild().getOnlyChild();
     Node yNode = fn.getLastChild().getFirstChild();
 
-    assertThat(xNode.getNonJSDocCommentString()).contains("/* first */");
+    assertThat(xNode.getTrailingNonJSDocCommentString()).contains("/* first */");
     assertThat(yNode.getNonJSDocCommentString()).contains("/* second */");
   }
 
@@ -2268,7 +2413,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node oneArgNode = call.getSecondChild();
     Node twoArgNode = oneArgNode.getNext();
 
-    assertThat(oneArgNode.getNonJSDocCommentString()).contains("/* first */");
+    assertThat(oneArgNode.getTrailingNonJSDocCommentString()).contains("/* first */");
     assertThat(twoArgNode.getNonJSDocCommentString()).isEmpty();
   }
 
@@ -2284,7 +2429,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     Node call = exprRes.getFirstChild();
     Node oneArgNode = call.getSecondChild();
 
-    assertThat(oneArgNode.getNonJSDocCommentString()).contains("/* first */");
+    assertThat(oneArgNode.getTrailingNonJSDocCommentString()).contains("/* first */");
   }
 
   @Test
@@ -2521,7 +2666,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     strictMode = SLOPPY;
     Node a = Node.newString(Token.NAME, "a");
     a.addChildToFront(Node.newString(Token.NAME, "b"));
-    List<ParserResult> testCases =
+    ImmutableList<ParserResult> testCases =
         ImmutableList.of(
             new ParserResult("3;", createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),
             new ParserResult("var a = b;", createScript(new Node(Token.VAR, a))));
@@ -3670,6 +3815,20 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testIndividualCommentsAroundClasses() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse("// comment A \n class A{} // trailing a \n // comment B \n  class Bar{}");
+    Node classA = n.getFirstChild();
+    Node classB = n.getSecondChild();
+    assertNode(classA).hasType(Token.CLASS);
+    assertThat(classA.getNonJSDocCommentString()).isEqualTo("// comment A");
+    assertThat(classA.getTrailingNonJSDocCommentString()).isEqualTo("// trailing a");
+    assertNode(classB).hasType(Token.CLASS);
+    assertThat(classB.getNonJSDocCommentString()).isEqualTo("// comment B");
+  }
+
+  @Test
   public void testMultipleLinedCommentsAttachedToSameNode() {
     isIdeMode = true;
     parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
@@ -5146,6 +5305,26 @@ public final class ParserTest extends BaseJSTypeTestCase {
         requiresLanguageModeMessage(Feature.REGEXP_FLAG_S));
   }
 
+  /** New RegExp flag 'd' added in ES2022. */
+  @Test
+  public void testES2022RegExpFlagD() {
+    expectFeatures(Feature.REGEXP_FLAG_D);
+    parse("/a/d");
+
+    mode = LanguageMode.ECMASCRIPT_2015;
+    expectFeatures(Feature.REGEXP_FLAG_D);
+    parseWarning("/a/d", requiresLanguageModeMessage(Feature.REGEXP_FLAG_D));
+    parseWarning(
+        "/a/ud", // 'u' added in es6
+        requiresLanguageModeMessage(Feature.REGEXP_FLAG_D));
+
+    mode = LanguageMode.ECMASCRIPT5;
+    parseWarning(
+        "/a/ud", // 'u' added in es6
+        requiresLanguageModeMessage(Feature.REGEXP_FLAG_U),
+        requiresLanguageModeMessage(Feature.REGEXP_FLAG_D));
+  }
+
   @Test
   public void testDefaultParameters() {
     strictMode = SLOPPY;
@@ -5669,6 +5848,197 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testEmptyClassStaticBlock() {
+    parse("class C { static { } }");
+    parse("let a = class { static { } };");
+  }
+
+  @Test
+  public void testReturnInClassStaticBlock() {
+    parseError("function f() {class C { static { return; } }}", "return must be inside function");
+    parseError("class C { static { return; } }", "return must be inside function");
+    parse("class C {static {function f() {return;}}}");
+  }
+
+  @Test
+  public void testContinueInClassStaticBlock() {
+    parseError("class C {static {continue;}}", UNEXPECTED_CONTINUE);
+    parseError("for (let i = 1; i < 2; i++) {class C {static {continue;}}}", UNEXPECTED_CONTINUE);
+    parseError("while (true) {class C {static {continue;}}}", UNEXPECTED_CONTINUE);
+    parse("class C {static {while (true) {continue;}}}");
+    parse("class C {static {for (let i = 1; i < 2; i++) {continue;}}}");
+    parseError(
+        "x: for (let i = 1; i < 2; i++) {class C {static {continue x;}}}",
+        UNDEFINED_LABEL + " \"x\"");
+    parseError("x: while (true) {class C {static {continue x;}}}", UNDEFINED_LABEL + " \"x\"");
+    parse("class C {static {x: while (true) {continue x;}}}");
+    parse("class C {static {x: for (let i = 1; i < 2; i++) {continue x;}}}");
+    parseError("class C {static {x: { while (true) {continue x;}}}}", UNEXPECTED_LABELLED_CONTINUE);
+    parseError(
+        "class C {static {x: {for (let i = 1; i < 2; i++) {continue x;}}}}",
+        UNEXPECTED_LABELLED_CONTINUE);
+  }
+
+  @Test
+  public void testBreakInClassStaticBlock() {
+    parseError("class C {static {break;}}", UNLABELED_BREAK);
+    parseError("for (let i = 1; i < 2; i++) {class C {static {break;}}}", UNLABELED_BREAK);
+    parseError("while (true) {class C {static {break;}}}", UNLABELED_BREAK);
+    parse("class C {static {while (true) {break;}}}");
+    parse("class C {static {for (let i = 1; i < 2; i++) {break;}}}");
+    parseError(
+        "x: for (let i = 1; i < 2; i++) {class C {static {break x;}}}", UNDEFINED_LABEL + " \"x\"");
+    parseError("x: while (true) {class C {static {break x;}}}", UNDEFINED_LABEL + " \"x\"");
+    parse("class C {static {x: while (true) {break x;}}}");
+    parse("class C {static {x: for (let i = 1; i < 2; i++) {break x;}}}");
+    parse("class C {static {x: { while (true) {break x;}}}}");
+    parse("class C {static {x: {for (let i = 1; i < 2; i++) {break x;}}}}");
+  }
+
+  @Test
+  public void testYieldInClassStaticBlock() {
+    parseError("class C {static {var ind; yield;}}", "primary expression expected");
+    parseError("function* f(ind) {class C{ static {yield ind; ind++;}}}", UNEXPECTED_YIELD);
+    parse("class C{ static {function* f(ind) {yield ind; ind++;}}}");
+  }
+
+  @Test
+  public void testAwaitInClassStaticBlock() {
+    parseError("class C {static {await 1;}}", UNEXPECTED_AWAIT);
+    parseError("async function f() {class C{ static {await 1;}}}", UNEXPECTED_AWAIT);
+    parse("class C{ static {async function f() {await 1;}}}");
+    parseError("async () => {class C{ static {await 1;}}}", UNEXPECTED_AWAIT);
+    parse("class C{ static {async ()=>{await 1;}}}");
+  }
+
+  @Test
+  public void testClassStaticBlock_this() {
+    // multiple fields
+    parse(
+        lines(
+            "class C { ",
+            "static field1 = 1; static field2 = 2; static field3 = 3;",
+            "static { ",
+            "let x = this.field1; let y = this.field2; let z = this.field3;",
+            "}",
+            "}"));
+    parse("class C { static { this.field1 = 1; this.field2 = 2; this.field3 = 3; } }");
+    parse(
+        lines(
+            "let a = class { ",
+            "static field1 = 1; static field2 = 2; static field3 = 3;",
+            "static {",
+            "let x = this.field1; let y = this.field2; let z = this.field3;",
+            "}",
+            "};"));
+    parse("let a = class { static { this.field1 = 1; this.field2 = 2; this.field3 = 3; } };");
+    // functions
+    parse(
+        lines(
+            "class C {",
+            "static field1 = 1;",
+            "static {",
+            "function incr() { return ++A.field1; }",
+            "console.log(incr());",
+            "if(incr()) {",
+            "this.field2 = 2;",
+            "}",
+            "}",
+            "}"));
+    // try catch
+    parse(
+        lines(
+            "class C {",
+            "static field1 = 1;",
+            "static {",
+            "try {",
+            "this.field1 = 2;",
+            "}",
+            "catch {",
+            "}",
+            "}",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticBlock_inheritance() {
+    // It is a syntax error to call super() in a class static initialization block.
+    // Must get reported in CheckSuper.java.
+    parse("class Base {} class C extends Base { static { super(); } }");
+    // allow accessing static properties of the base class
+    parse("class Base { static y; } class C extends Base { static { super.y; } }");
+    // allow accessing non-static properties of the base class
+    parse("class Base { y; } class C extends Base { static { super.y; } }");
+  }
+
+  @Test
+  public void testMultipleClassStaticBlocks() {
+    // empty
+    parse("class C { static { } static { } }");
+    parse("let a = class { static { } static { } };");
+    // multiple fields
+    parse(
+        lines(
+            "class C {",
+            "static field1 = 1; static field2 = 2; static field3 = 3;",
+            "static { ",
+            "let x = this.field1; let y = this.field2; ",
+            "} ",
+            "static {",
+            "let z = this.field3;",
+            "} ",
+            "}"));
+    parse("class C { static { this.field1 = 1; this.field2 = 2; } static { this.field3 = 3; } }");
+    parse(
+        lines(
+            "let a = class { ",
+            "static field1 = 1; static field2 = 2; static field3 = 3;",
+            "static {",
+            "let x = this.field1; let y = this.field2;",
+            "}",
+            "static {",
+            "let z = this.field3;",
+            "}",
+            "};"));
+    parse(
+        lines(
+            "let a = class {",
+            "static {",
+            "this.field1 = 1; this.field2 = 2;",
+            "}",
+            "static {",
+            " this.field3 = 3;",
+            "}",
+            "};"));
+  }
+
+  @Test
+  public void testClassStaticBlock_linenocharno() {
+    Node n = parse("class C {\n static {}\n }").getFirstChild();
+
+    assertNode(n).hasType(Token.CLASS);
+    assertNode(n).hasLineno(1);
+    assertNode(n).hasCharno(0);
+
+    Node members = NodeUtil.getClassMembers(n);
+    assertNode(members).hasType(Token.CLASS_MEMBERS);
+
+    Node staticBlock = members.getFirstChild();
+
+    assertNode(staticBlock).hasType(Token.BLOCK);
+    assertNode(staticBlock).hasLineno(2);
+    assertNode(staticBlock).hasCharno(8);
+    assertNode(staticBlock).hasLength(2);
+  }
+
+  @Test
+  public void testClassStaticBlock_invalid() {
+    parseError("class { {} }", "'identifier' expected");
+    parseError("class { static { static { } } }", "'identifier' expected");
+    parseError("var o = { static {} };", "Cannot use keyword in short object literal");
+  }
+
+  @Test
   public void testSuper1() {
     expectFeatures(Feature.SUPER);
     strictMode = SLOPPY;
@@ -6001,14 +6371,20 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   @Test
   public void testInvalidAwait() {
-    parseError("await 15;", "'await' used in a non-async function context");
-    parseError("function f() { return await 5; }", "'await' used in a non-async function context");
+    parseError("await 15;", UNEXPECTED_AWAIT);
+    parseError("function f() { return await 5; }", UNEXPECTED_AWAIT);
     parseError(
         "async function f(x = await 15) { return x; }",
         "`await` is illegal in parameter default value.");
   }
 
   @Test
+  public void testInvalidAwaitInsideNestedFunction() {
+    parse("async function f() { async function f2() { return await 5; } }");
+    parseError("async function f() { function f2() { return await 5; } }", UNEXPECTED_AWAIT);
+  }
+
+  @Test
   public void testAsyncFunction() {
     String asyncFunctionExpressionSource = "f = async function() {};";
     String asyncFunctionDeclarationSource = "async function f() {}";
@@ -6721,7 +7097,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   @Test
   public void testDynamicImport() {
-    List<String> dynamicImportUses =
+    ImmutableList<String> dynamicImportUses =
         ImmutableList.of(
             "import('foo')",
             "import('foo').then(function(a) { return a; })",
@@ -6750,7 +7126,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   @Test
   public void testAwaitDynamicImport() {
-    List<String> awaitDynamicImportUses =
+    ImmutableList<String> awaitDynamicImportUses =
         ImmutableList.of(
             "(async function() { return await import('foo'); })()",
             "(async function() { await import('foo').then(function(a) { return a; }); })()",
@@ -7093,11 +7469,10 @@ public final class ParserTest extends BaseJSTypeTestCase {
     return doParse(string, warnings).ast;
   }
 
-  private ParserRunner.ParseResult doParse(String string, String... warnings) {
+  private ParseResult doParse(String string, String... warnings) {
     TestErrorReporter testErrorReporter = new TestErrorReporter().expectAllWarnings(warnings);
     StaticSourceFile file = new SimpleSourceFile("input", SourceKind.STRONG);
-    ParserRunner.ParseResult result =
-        ParserRunner.parse(file, string, createConfig(), testErrorReporter);
+    ParseResult result = ParserRunner.parse(file, string, createConfig(), testErrorReporter);
 
     // check expected features if specified
     assertFS(result.features).contains(expectedFeatures);
diff --git a/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java b/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
index b78576b..e6dd2f2 100644
--- a/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
+++ b/test/com/google/javascript/jscomp/parsing/parser/FeatureSetTest.java
@@ -103,12 +103,12 @@ public final class FeatureSetTest {
     // This could be es_XXX, es_next, etc. and will change as new features are added and removed
     // from these `FeatureSet`s.
     assertThat(FeatureSet.ES_NEXT.version()).isEqualTo("es_next");
-    assertThat(FeatureSet.ES_UNSTABLE.version()).isEqualTo("es_next");
-    assertThat(FeatureSet.ES_UNSUPPORTED.version()).isEqualTo("es_next");
+    assertThat(FeatureSet.ES_UNSTABLE.version()).isEqualTo("es_unstable");
+    assertThat(FeatureSet.ES_UNSUPPORTED.version())
+        .isEqualTo("es_unstable"); // no unsupported features at this time
   }
 
   @Test
-
   public void testValueOf() {
     assertFS(FeatureSet.valueOf("es3")).equals(FeatureSet.ES3);
     assertFS(FeatureSet.valueOf("es5")).equals(FeatureSet.ES5);
diff --git a/test/com/google/javascript/jscomp/runtime_tests/class_static_method_super_prop_test.js b/test/com/google/javascript/jscomp/runtime_tests/class_static_method_super_prop_test.js
new file mode 100644
index 0000000..38eb167
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/class_static_method_super_prop_test.js
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.require('goog.testing.jsunit');
+
+function testSuperPropertiesStaticMethod() {
+  class Foo {}
+
+  Foo.x = 2;
+  Foo[2] = 3;
+
+
+  class Bar extends Foo {
+    /**
+     * A dummy function used to test super calls in static methods
+     * @return {number}
+     */
+    static f() {
+      Bar.y = super.x;
+      Bar[3] = super[2];
+      assertEquals(2, super.x);
+      assertEquals(3, super[2]);
+      assertEquals(2, Bar.y);
+      assertEquals(3, Bar[3]);
+      return 6;
+    }
+  }
+  assertEquals(6, Bar.f());
+}
+
+
+function testSuperInStaticMethod() {
+  class C1 {
+    static foo() {
+      return 42;
+    }
+  }
+  class D extends C1 {
+    static foo() {
+      return super.foo() + 1;
+    }
+  }
+  assertEquals(43, D.foo());
+}
+
+function testSuperInDifferentStaticMethod() {
+  class C2 {
+    static foo() {
+      return 12;
+    }
+  }
+  class D extends C2 {
+    static foo() {
+      throw new Error('unexpected');
+    }
+    static bar() {
+      return super.foo() + 2;
+    }
+  }
+  assertEquals(14, D.bar());
+}
\ No newline at end of file
diff --git a/test/com/google/javascript/jscomp/runtime_tests/class_test.js b/test/com/google/javascript/jscomp/runtime_tests/class_test.js
index 9a0ba64..38969fc 100644
--- a/test/com/google/javascript/jscomp/runtime_tests/class_test.js
+++ b/test/com/google/javascript/jscomp/runtime_tests/class_test.js
@@ -219,27 +219,6 @@ function testExtendsObject() {
   assertEquals(withConstructor, withConstructor.superResult);
 }
 
-function testSuperInStaticMethod() {
-  class C1 {
-    static foo() { return 42; }
-  }
-  class D extends C1 {
-    static foo() { return super.foo() + 1; }
-  }
-  assertEquals(43, D.foo());
-}
-
-function testSuperInDifferentStaticMethod() {
-  class C2 {
-    static foo() { return 12; }
-  }
-  class D extends C2 {
-    static foo() { throw new Error('unexpected'); }
-    static bar() { return super.foo() + 2; }
-  }
-  assertEquals(14, D.bar());
-}
-
 // Confirm that extension of native classes works.
 // Use Map, because it's a class users are likely to want to extend.
 function testExtendMapClass() {
diff --git a/test/com/google/javascript/jscomp/runtime_tests/error_cause_test.js b/test/com/google/javascript/jscomp/runtime_tests/error_cause_test.js
new file mode 100644
index 0000000..e2894ce
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/error_cause_test.js
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+goog.module('jscomp.runtime_tests.error_cause_test');
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+const userAgent = goog.require('goog.userAgent');
+
+goog.require('goog.testing.jsunit');
+
+testSuite({
+  shouldRunTests() {
+    // Disable tests for IE
+    return !userAgent.IE && (userAgent.GECKO && userAgent.isVersionOrHigher(91) ||
+      userAgent.CHROME && userAgent.isVersionOrHigher(93) ||
+      userAgent.EDGE && userAgent.isVersionOrHigher(93))
+      ;
+  },
+
+  testCause() {
+    const errorOne = Error("error1");
+    const errorTwo = Error("error2", {cause: errorOne});
+    assertEquals(errorTwo.cause, errorOne);
+  }
+});
+
+
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
index 08d495b..06fd44e 100644
--- a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/force_polyfills.js
@@ -67,6 +67,7 @@ delete Object.fromEntries;
 delete Object.is;
 delete Object.setPrototypeOf;
 delete Object.values;
+delete Object.hasOwn;
 
 delete Promise;
 delete Reflect;
diff --git a/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/object_hasOwn_test.js b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/object_hasOwn_test.js
new file mode 100644
index 0000000..4e403a1
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/polyfill_tests/object_hasOwn_test.js
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+goog.module('jscomp.runtime_tests.polyfill_tests.object_hasOwn_test');
+
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+
+testSuite({
+  testHasOwn1() {
+    let object1 = {'foo': false};
+    assertEquals(true, Object.hasOwn(object1, 'foo'));
+    assertEquals(false, Object.hasOwn(object1, 'bar'));
+  },
+
+  testHasOwn2() {
+    let object2 = Object.create({'foo': true});
+    assertEquals(false, Object.hasOwn(object2, 'foo'));
+    assertEquals(false, Object.hasOwn(object2, 'bar'));
+  },
+
+  testHasOwn3() {
+    let object3 = Object.create(null);
+    assertEquals(false, Object.hasOwn(object3, 'foo'));
+
+    object3['bar'] = false;
+    assertEquals(true, Object.hasOwn(object3, 'bar'));
+  }
+
+});
diff --git a/test/com/google/javascript/jscomp/runtime_tests/regexp_match_indices_test.js b/test/com/google/javascript/jscomp/runtime_tests/regexp_match_indices_test.js
new file mode 100644
index 0000000..5702391
--- /dev/null
+++ b/test/com/google/javascript/jscomp/runtime_tests/regexp_match_indices_test.js
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2022 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+/**
+ * @fileoverview Test for RegExp Indices field (es_2022 feature)
+ * @suppress {untranspilableFeatures} ignore autogenerated targets that compile down to es5
+ */
+
+goog.module('jscomp.runtime_tests.regexp_match_indices_test');
+goog.setTestOnly();
+
+const testSuite = goog.require('goog.testing.testSuite');
+
+goog.require('goog.testing.jsunit');
+
+testSuite({
+  /**
+   * @suppress {uselessCode}
+   * @return {boolean}
+   */
+  shouldRunTests() {
+    try {
+      new RegExp('', 'd');
+      return true;
+    } catch (e) {
+      return false;
+    }
+  },
+
+  testRegExp() {
+    let re = new RegExp('(?<firstname>jeannie)ren', 'd');
+    let str = '11jeannieren11';
+    const result = re.exec(str);
+    assertNotNull(result);
+    assertEquals(result[0], 'jeannieren');
+    assertEquals(result[1], 'jeannie');
+    assertEquals(result.groups['firstname'], 'jeannie');
+
+    let indices = result.indices;
+    assertNotNull(indices);
+    assertArrayEquals(indices[0], [2, 12]);
+    assertArrayEquals(indices[1], [2, 9]);
+    assertArrayEquals(indices.groups['firstname'], [2, 9]);
+  }
+});
diff --git a/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java b/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
index 2726136..4c0866e 100644
--- a/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
+++ b/test/com/google/javascript/jscomp/serialization/ColorPoolTest.java
@@ -27,7 +27,6 @@ import com.google.common.collect.ImmutableSetMultimap;
 import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.ColorId;
 import com.google.javascript.jscomp.colors.ColorRegistry;
-import com.google.javascript.jscomp.colors.DebugInfo;
 import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.protobuf.ByteString;
 import org.junit.Test;
@@ -72,9 +71,6 @@ public class ColorPoolTest {
                     .setObject(
                         ObjectTypeProto.newBuilder()
                             .setUuid(StandardColors.NUMBER_OBJECT_ID.asByteString())
-                            .setDebugInfo(
-                                ObjectTypeProto.DebugInfo.newBuilder()
-                                    .addTypenamePointer(stringPool.put("Number")))
                             .setIsInvalidating(true))
                     .build())
             .addType(
@@ -96,7 +92,7 @@ public class ColorPoolTest {
         .hasDisambiguationSupertypesThat(colorPool.getRegistry())
         .containsExactly(view.getColor(poolPointer(1)));
     assertThat(numberObject).isSameInstanceAs(view.getColor(poolPointer(0)));
-    assertThat(numberObject.getDebugInfo().getCompositeTypename()).isEqualTo("Number");
+    assertThat(numberObject.getId()).isEqualTo(StandardColors.NUMBER_OBJECT_ID);
   }
 
   @Test
@@ -486,7 +482,6 @@ public class ColorPoolTest {
         () -> ColorPool.fromOnlyShard(typePool, StringPool.empty()));
   }
 
-
   @Test
   public void uuid_mustBeSet() {
     // Given
@@ -529,7 +524,6 @@ public class ColorPoolTest {
     assertThat(defaultColor.isConstructor()).isFalse();
     assertThat(defaultColor.isInvalidating()).isFalse();
     assertThat(defaultColor.getPropertiesKeepOriginalName()).isFalse();
-    assertThat(defaultColor.getDebugInfo()).isSameInstanceAs(DebugInfo.EMPTY);
   }
 
   @Test
@@ -794,41 +788,6 @@ public class ColorPoolTest {
   }
 
   @Test
-  public void reconcile_debugNames() {
-    StringPool.Builder stringPool0 = StringPool.builder();
-    StringPool.Builder stringPool1 = StringPool.builder();
-    // Given
-    TypePool typePool0 =
-        singleObjectPool(
-            ObjectTypeProto.newBuilder()
-                .setUuid(TEST_ID.asByteString())
-                .setDebugInfo(
-                    ObjectTypeProto.DebugInfo.newBuilder()
-                        .addTypenamePointer(stringPool0.put("A"))
-                        .addTypenamePointer(stringPool0.put("C"))));
-
-    TypePool typePool1 =
-        singleObjectPool(
-            ObjectTypeProto.newBuilder()
-                .setUuid(TEST_ID.asByteString())
-                .setDebugInfo(
-                    ObjectTypeProto.DebugInfo.newBuilder()
-                        .addTypenamePointer(stringPool1.put("B"))
-                        .addTypenamePointer(stringPool1.put("A"))));
-
-    // When
-    ColorPool colorPool =
-        ColorPool.builder()
-            .addShardAnd(typePool0, stringPool0.build())
-            .addShardAnd(typePool1, stringPool1.build())
-            .build();
-
-    // Then
-    assertThat(colorPool.getColor(TEST_ID).getDebugInfo().getCompositeTypename())
-        .isEqualTo("A/B/C");
-  }
-
-  @Test
   public void reconcile_debugInfo_mismatches() {
     // Given
     TypePool typePool0 =
diff --git a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
index 916fe28..2f6391d 100644
--- a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
@@ -31,14 +31,13 @@ import com.google.common.collect.SetMultimap;
 import com.google.common.truth.extensions.proto.ProtoSubject;
 import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.ColorId;
-import com.google.javascript.jscomp.colors.DebugInfo;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -185,7 +184,6 @@ public class ColorSerializerTest {
             // 1 => explicitly added child class constructor
             // Then this instance color gets added implicitly
             .setTrimmedPoolOffset(2)
-            .setTypeName(basePooledString)
             .addOwnProperty(baseFieldPooledString)
             .build();
     final TestColor baseClassPrototypeTestColor =
@@ -193,7 +191,6 @@ public class ColorSerializerTest {
             .setColorId("Base.pro")
             // This is implicitly added after the instance color above.
             .setTrimmedPoolOffset(3)
-            .setTypeName(typeofBasePrototypePooledString)
             .build();
     final PooledString baseStaticFieldPooledString = PooledString.create("baseStaticField", 0);
     final TestColor baseClassConstructorTestColor =
@@ -201,7 +198,6 @@ public class ColorSerializerTest {
             .setColorId("Base.con")
             // This is the first explicitly-added type.
             .setTrimmedPoolOffset(0)
-            .setTypeName(typeofBasePooledString)
             .setConstructor(true)
             .addPrototypeTestColor(baseClassPrototypeTestColor)
             .addInstanceTestColor(baseClassInstanceTestColor)
@@ -229,7 +225,6 @@ public class ColorSerializerTest {
             // 3 => implicitly added base class prototype color
             // Then this instance color gets added implicitly
             .setTrimmedPoolOffset(4)
-            .setTypeName(childPooledString)
             .addOwnProperty(childFieldPooledString)
             .build();
     final TestColor childClassPrototypeTestColor =
@@ -237,7 +232,6 @@ public class ColorSerializerTest {
             .setColorId("Child.pr")
             // This is implicitly added after the instance color above.
             .setTrimmedPoolOffset(5)
-            .setTypeName(typeofChildPrototypePooledString)
             .build();
     final PooledString childStaticFieldPooledString = PooledString.create("childStaticField", 2);
     final TestColor childClassConstructorTestColor =
@@ -245,7 +239,6 @@ public class ColorSerializerTest {
             .setColorId("Child.co")
             // This is the second explicitly-added type
             .setTrimmedPoolOffset(1)
-            .setTypeName(typeofChildPooledString)
             .setConstructor(true)
             .addPrototypeTestColor(childClassPrototypeTestColor)
             .addInstanceTestColor(childClassInstanceTestColor)
@@ -303,37 +296,17 @@ public class ColorSerializerTest {
   }
 
   @Test
-  public void includeMismatchesAndTypenames() {
-    PooledString typeName1 = PooledString.create("typeName1", 1);
-    PooledString typeName2 = PooledString.create("typeName2", 2);
-    PooledString typeName3 = PooledString.create("typeName3", 3);
-    PooledString typeName4 = PooledString.create("typeName4", 4);
+  public void includeMismatches() {
     TestColor testColor1 =
-        new TestObjectColorBuilder()
-            .setColorId("color001")
-            .setTrimmedPoolOffset(0)
-            .setTypeName(typeName1)
-            .build();
+        new TestObjectColorBuilder().setColorId("color001").setTrimmedPoolOffset(0).build();
     TestColor testColor2 =
-        new TestObjectColorBuilder()
-            .setColorId("color002")
-            .setTrimmedPoolOffset(1)
-            .setTypeName(typeName2)
-            .build();
+        new TestObjectColorBuilder().setColorId("color002").setTrimmedPoolOffset(1).build();
     TestMismatch testMismatch1 = TestMismatch.create("location1", testColor1, testColor2);
 
     TestColor testColor3 =
-        new TestObjectColorBuilder()
-            .setColorId("color003")
-            .setTrimmedPoolOffset(2)
-            .setTypeName(typeName3)
-            .build();
+        new TestObjectColorBuilder().setColorId("color003").setTrimmedPoolOffset(2).build();
     TestColor testColor4 =
-        new TestObjectColorBuilder()
-            .setColorId("color004")
-            .setTrimmedPoolOffset(3)
-            .setTypeName(typeName4)
-            .build();
+        new TestObjectColorBuilder().setColorId("color004").setTrimmedPoolOffset(3).build();
     TestMismatch testMismatch2 = TestMismatch.create("location2", testColor3, testColor4);
 
     final TypePool expectedTypePool =
@@ -354,34 +327,22 @@ public class ColorSerializerTest {
         .addColors(testColor1, testColor2, testColor3, testColor4)
         .addMismatch(testMismatch1)
         .addMismatch(testMismatch2)
-        .addPooledString(typeName1)
-        .addPooledString(typeName2)
-        .addPooledString(typeName3)
-        .addPooledString(typeName4)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
   }
 
   @Test
-  public void skipMismatchesAndTypenames() {
-    PooledString typeName1 = PooledString.create("typeName1", 1);
-    PooledString typeName2 = PooledString.create("typeName2", 2);
-    PooledString typeName3 = PooledString.create("typeName3", 3);
-    PooledString typeName4 = PooledString.create("typeName4", 4);
+  public void skipMismatches() {
     TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             .setTrimmedPoolOffset(0)
-            .setTypeName(typeName1)
-            .setIncludeDebugInfoInProto(false)
             .build();
     TestColor testColor2 =
         new TestObjectColorBuilder()
             .setColorId("color002")
             .setTrimmedPoolOffset(1)
-            .setTypeName(typeName2)
-            .setIncludeDebugInfoInProto(false)
             .build();
     TestMismatch testMismatch1 = TestMismatch.create("location1", testColor1, testColor2);
 
@@ -389,15 +350,11 @@ public class ColorSerializerTest {
         new TestObjectColorBuilder()
             .setColorId("color003")
             .setTrimmedPoolOffset(2)
-            .setTypeName(typeName3)
-            .setIncludeDebugInfoInProto(false)
             .build();
     TestColor testColor4 =
         new TestObjectColorBuilder()
             .setColorId("color004")
             .setTrimmedPoolOffset(3)
-            .setTypeName(typeName4)
-            .setIncludeDebugInfoInProto(false)
             .build();
     TestMismatch testMismatch2 = TestMismatch.create("location2", testColor3, testColor4);
 
@@ -455,21 +412,14 @@ public class ColorSerializerTest {
 
   @Test
   public void addUnionImplicitlyAddsMembers() {
-    PooledString testTypeName1 = PooledString.create("testColor1", 1);
-    PooledString testTypeName2 = PooledString.create("testColor2", 2);
     final TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             // We will explicitly add this color first
             .setTrimmedPoolOffset(1)
-            .setTypeName(testTypeName1)
             .build();
     final TestColor testColor2 =
-        new TestObjectColorBuilder()
-            .setColorId("color002")
-            .setTrimmedPoolOffset(2)
-            .setTypeName(testTypeName2)
-            .build();
+        new TestObjectColorBuilder().setColorId("color002").setTrimmedPoolOffset(2).build();
     final TestColor unionTestColor =
         new TestUnionColorBuilder()
             .setTrimmedPoolOffset(0)
@@ -489,8 +439,6 @@ public class ColorSerializerTest {
     new Tester()
         .init()
         .addColor(unionTestColor)
-        .addPooledString(testTypeName1)
-        .addPooledString(testTypeName2)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
@@ -498,21 +446,14 @@ public class ColorSerializerTest {
 
   @Test
   public void avoidAddingDuplicateUnions() {
-    PooledString testTypeName1 = PooledString.create("testColor1", 1);
-    PooledString testTypeName2 = PooledString.create("testColor2", 2);
     final TestColor testColor1 =
         new TestObjectColorBuilder()
             .setColorId("color001")
             // We will explicitly add this color first
             .setTrimmedPoolOffset(1)
-            .setTypeName(testTypeName1)
             .build();
     final TestColor testColor2 =
-        new TestObjectColorBuilder()
-            .setColorId("color002")
-            .setTrimmedPoolOffset(2)
-            .setTypeName(testTypeName2)
-            .build();
+        new TestObjectColorBuilder().setColorId("color002").setTrimmedPoolOffset(2).build();
     final TestColor unionTestColor =
         new TestUnionColorBuilder()
             .setTrimmedPoolOffset(0)
@@ -543,8 +484,6 @@ public class ColorSerializerTest {
         .addColor(unionTestColor)
         // Try to add the duplicate union color. It should be ignored.
         .addColor(duplicateUnionTestColor)
-        .addPooledString(testTypeName1)
-        .addPooledString(testTypeName2)
         .generateTypePool()
         .assertThatTypePool()
         .isEqualTo(expectedTypePool);
@@ -575,10 +514,7 @@ public class ColorSerializerTest {
 
     private ColorId colorId;
     private int trimmedPoolOffset = -1;
-    // An empty string indicates that the type has no name.
-    private PooledString typeName = PooledString.create("", 0);
     private boolean isConstructor = false;
-    private boolean includeDebugInfoInProto = true;
 
     public TestObjectColorBuilder setColorId(String colorIdString) {
       checkArgument(colorIdString.length() <= 8, "color ID string too long: %s", colorIdString);
@@ -601,11 +537,6 @@ public class ColorSerializerTest {
       return this;
     }
 
-    public TestObjectColorBuilder setTypeName(PooledString typeName) {
-      this.typeName = typeName;
-      return this;
-    }
-
     public TestObjectColorBuilder addInstanceTestColor(TestColor instanceTestColor) {
       this.instanceTestColors.add(instanceTestColor);
       return this;
@@ -621,11 +552,6 @@ public class ColorSerializerTest {
       return this;
     }
 
-    public TestObjectColorBuilder setIncludeDebugInfoInProto(boolean includeDebugInfoInProto) {
-      this.includeDebugInfoInProto = includeDebugInfoInProto;
-      return this;
-    }
-
     TestColor build() {
       checkState(trimmedPoolOffset >= 0, "call setTrimmedPoolOffset() first");
       // There's no testing benefit to varying these values
@@ -665,13 +591,6 @@ public class ColorSerializerTest {
                   .collect(Collectors.toList()))
           .addAllOwnProperty(
               ownProperties.stream().map(PooledString::getPoolOffset).collect(Collectors.toList()));
-      if (!typeName.getValue().isEmpty()) {
-        colorBuilder.setDebugInfo(
-            DebugInfo.builder().setCompositeTypename(typeName.getValue()).build());
-        if (includeDebugInfoInProto) {
-          objectTypeProtoBuilder.getDebugInfoBuilder().addTypenamePointer(typeName.getPoolOffset());
-        }
-      }
       return TestColor.create(colorBuilder.build(), typeProtoBuilder.build(), typePointer);
     }
   }
@@ -730,8 +649,7 @@ public class ColorSerializerTest {
      * `TypeProto`. Generally test code should call `getExpectedTypeProto()` instead in order to get
      * an exception if an attempt is made to serialize an axiomatic color.
      */
-    @Nullable
-    public abstract TypeProto getNullableExpectedTypeProto();
+    public abstract @Nullable TypeProto getNullableExpectedTypeProto();
 
     // The Integer we expect ColorSerializer to create for this Color.
     public abstract Integer getExpectedTypePointer();
@@ -741,7 +659,7 @@ public class ColorSerializerTest {
     }
 
     static TestColor create(
-        Color color, TypeProto expectedTypeProto, Integer nullableExpectedTypePointer) {
+        Color color, @Nullable TypeProto expectedTypeProto, Integer nullableExpectedTypePointer) {
       return new AutoValue_ColorSerializerTest_TestColor(
           color, expectedTypeProto, nullableExpectedTypePointer);
     }
diff --git a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
index c5316bd..8b8d191 100644
--- a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
@@ -17,13 +17,12 @@
 package com.google.javascript.jscomp.serialization;
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
-import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 import static com.google.javascript.jscomp.serialization.TypePointers.isAxiomatic;
 import static com.google.javascript.jscomp.serialization.TypePointers.trimOffset;
-import static com.google.javascript.jscomp.serialization.TypePointers.untrimOffset;
 import static java.util.Arrays.stream;
 
+import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.Compiler;
@@ -37,8 +36,10 @@ import com.google.javascript.rhino.Node;
 import com.google.protobuf.Descriptors.FieldDescriptor;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.function.Predicate;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,24 +49,23 @@ import org.junit.runners.JUnit4;
 public final class JSTypeReconserializerTest extends CompilerTestCase {
 
   // individual test cases may override this
-  private ImmutableSet<String> typesToForwardDeclare = null;
+  private @Nullable ImmutableSet<String> typesToForwardDeclare = null;
   private Predicate<String> shouldSerializeProperty;
 
   private TypePool typePool;
   private StringPool.Builder stringPoolBuilder;
+  private LinkedHashMap<String, Integer> labelToPointer;
 
   // Proto fields commonly ignored in tests because hardcoding their values is brittle
   private static final FieldDescriptor OBJECT_UUID =
       ObjectTypeProto.getDescriptor().findFieldByName("uuid");
   private static final FieldDescriptor OBJECT_PROPERTIES =
       ObjectTypeProto.getDescriptor().findFieldByName("own_property");
-  private static final FieldDescriptor OBJECT_TYPENAME =
-      ObjectTypeProto.DebugInfo.getDescriptor().findFieldByName("typename_pointer");
   private static final FieldDescriptor IS_INVALIDATING =
       ObjectTypeProto.getDescriptor().findFieldByName("is_invalidating");
 
   private static final ImmutableList<FieldDescriptor> BRITTLE_TYPE_FIELDS =
-      ImmutableList.of(OBJECT_UUID, OBJECT_PROPERTIES, OBJECT_TYPENAME);
+      ImmutableList.of(OBJECT_UUID, OBJECT_PROPERTIES);
 
   @Override
   @Before
@@ -80,6 +80,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     this.stringPoolBuilder = StringPool.builder();
+    this.labelToPointer = new LinkedHashMap<>();
 
     return (externs, root) -> {
       JSTypeReconserializer serializer =
@@ -98,7 +99,12 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
             @Override
             public void visit(NodeTraversal t, Node n, Node parent) {
               if (n.getJSType() != null) {
-                serializer.serializeType(n.getJSType());
+                int pointer = serializer.serializeType(n.getJSType());
+
+                if (n.getParent().isExprResult() && n.getGrandparent().isLabel()) {
+                  String labelName = n.getParent().getPrevious().getString();
+                  labelToPointer.put(labelName, pointer);
+                }
               }
             }
           },
@@ -151,28 +157,35 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
 
   @Test
   public void testObjectTypeSerializationFormat() {
-    List<TypeProto> typePool = compileToTypes("class Foo { m() {} } new Foo().m();");
+    List<TypeProto> typePool =
+        compileToTypes(
+            lines(
+                "class Foo { m() {} }",
+                "new Foo().m();",
+                "",
+                "FOO: new Foo();",
+                "FOO_PROTOTYPE: Foo.prototype;"));
 
     assertThat(typePool)
         .ignoringFieldDescriptors(OBJECT_UUID)
         .containsAtLeast(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("(typeof Foo)")
-                        .addPrototype(pointerForType("Foo.prototype"))
-                        .addInstanceType(pointerForType("Foo"))
+                    ObjectTypeProto.newBuilder()
+                        .addPrototype(pointerForLabel("FOO_PROTOTYPE"))
+                        .addInstanceType(pointerForLabel("FOO"))
                         .setMarkedConstructor(true)
                         .addOwnProperty(findInStringPool("prototype")))
                 .build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo")).build(),
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build(),
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("Foo.prototype")
+                    ObjectTypeProto.newBuilder()
                         .addOwnProperty(findInStringPool("constructor"))
                         .addOwnProperty(findInStringPool("m")))
                 .build(),
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("Foo.prototype.m").setIsInvalidating(true))
+                .setObject(ObjectTypeProto.newBuilder().setIsInvalidating(true))
                 .build());
   }
 
@@ -196,7 +209,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("Foo.prototype")
+                    ObjectTypeProto.newBuilder()
                         .addOwnProperty(findInStringPool("constructor"))
                         .addOwnProperty(findInStringPool("serializeMe")))
                 // the "doNotSerializeMe" property is not present
@@ -205,11 +218,11 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
 
   @Test
   public void testDisambiguationEdges_pointFromInstanceToPrototype() {
-    TypePool typePool = compileToTypePool("class Foo { m() {} } new Foo().m();");
+    TypePool typePool = compileToTypePool("class Foo { m() {} } new Foo().m(); FOO: new Foo();");
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "Foo"))
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "FOO"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
-        .contains(TypeProto.newBuilder().setObject(namedObjectBuilder("Foo.prototype")).build());
+        .contains(TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
@@ -218,47 +231,52 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         compileToTypePool(
             lines(
                 "/** @interface */ class IFoo { m() {} }", //
-                "let /** !IFoo */ x;"));
+                "let /** !IFoo */ x;",
+                "IFOO: x;"));
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "IFoo"))
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "IFOO"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
-        .contains(TypeProto.newBuilder().setObject(namedObjectBuilder("IFoo.prototype")).build());
+        .contains(TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
   public void testDisambiguationEdges_pointFromInstanceToInterface() {
     TypePool typePool =
         compileToTypePool(
-            lines("/** @interface */ class IFoo {}", "/** @implements {IFoo} */ class Foo {}"));
+            lines(
+                "/** @interface */ class IFoo {}",
+                "/** @implements {IFoo} */ class Foo {}",
+                "FOO: new Foo();"));
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "Foo"))
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "FOO"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .ignoringFieldDescriptors(
             ObjectTypeProto.getDescriptor().findFieldByName("prototype"),
             ObjectTypeProto.getDescriptor().findFieldByName("instance_type"))
-        .contains(TypeProto.newBuilder().setObject(namedObjectBuilder("IFoo")).build());
+        .contains(TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
   public void testDisambiguationEdges_pointFromSubctorToSuperctor() {
-    TypePool typePool = compileToTypePool("class Foo {} class Bar extends Foo {}");
+    TypePool typePool = compileToTypePool("class Foo {} class Bar extends Foo {} BAR_CTOR: Bar;");
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "(typeof Bar)"))
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "BAR_CTOR"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .ignoringFieldDescriptors(
             ObjectTypeProto.getDescriptor().findFieldByName("prototype"),
             ObjectTypeProto.getDescriptor().findFieldByName("instance_type"))
         .containsExactly(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("(typeof Foo)").setMarkedConstructor(true))
+                .setObject(ObjectTypeProto.newBuilder().setMarkedConstructor(true))
                 .build());
   }
 
   @Test
   public void testDisambiguationEdges_dont_pointFromPrototypeToInstance() {
-    TypePool typePool = compileToTypePool("class Foo { m() {} } new Foo().m();");
+    TypePool typePool =
+        compileToTypePool("class Foo { m() {} } new Foo().m(); FOO_PROTOTYPE: Foo.prototype;");
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "Foo.prototype")).isEmpty();
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "FOO_PROTOTYPE")).isEmpty();
   }
 
   @Test
@@ -278,7 +296,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 "",
                 "let /** symbol|!Bar|string */ x;"));
 
-    List<UnionTypeProto> unionsContainingUnions =
+    ImmutableList<UnionTypeProto> unionsContainingUnions =
         typePool.stream()
             .filter(TypeProto::hasUnion)
             .map(TypeProto::getUnion)
@@ -307,7 +325,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
   public void testSerializedInstanceTypeHasClassName() {
     assertThat(compileToTypes("/** @constructor */ function Foo() {} new Foo;"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
-        .contains(TypeProto.newBuilder().setObject(namedObjectBuilder("Foo")).build());
+        .contains(TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
@@ -317,7 +335,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .contains(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("enum{E}").setPropertiesKeepOriginalName(true))
+                .setObject(ObjectTypeProto.newBuilder().setPropertiesKeepOriginalName(true))
                 .build());
   }
 
@@ -328,7 +346,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .contains(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("enum{E}").setPropertiesKeepOriginalName(true))
+                .setObject(ObjectTypeProto.newBuilder().setPropertiesKeepOriginalName(true))
                 .build());
   }
 
@@ -346,12 +364,12 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .containsAtLeast(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("assert").setClosureAssert(true).setIsInvalidating(true))
+                    ObjectTypeProto.newBuilder().setClosureAssert(true).setIsInvalidating(true))
                 .build(),
             TypeProto.newBuilder()
                 .setObject(
                     // ClosurePrimitive.ASSERTS_FAIL is not a removable Closure assertion
-                    namedObjectBuilder("fail").setClosureAssert(false).setIsInvalidating(true))
+                    ObjectTypeProto.newBuilder().setClosureAssert(false).setIsInvalidating(true))
                 .build());
   }
 
@@ -363,7 +381,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("{x: string}")
+                    ObjectTypeProto.newBuilder()
                         .setIsInvalidating(true)
                         .addOwnProperty(findInStringPool("x")))
                 .build());
@@ -378,18 +396,22 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 "class Foo {",
                 // Add in this reference to `T` so that it is seen by the serializer.
                 "  constructor() { /** @type {T} */ this.x; }",
-                "}"));
+                "}",
+                "",
+                "/** @type {!Foo<string>} */ let foo;",
+                "FOO: foo;",
+                "FOO_PROTOTYPE: Foo.prototype;"));
     assertThat(typePool)
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .containsAtLeast(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("(typeof Foo)")
-                        .addPrototype(pointerForType("Foo.prototype"))
-                        .addInstanceType(pointerForType("Foo")))
+                    ObjectTypeProto.newBuilder()
+                        .addPrototype(pointerForLabel("FOO_PROTOTYPE"))
+                        .addInstanceType(pointerForLabel("FOO")))
                 .build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo")).build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo.prototype")).build());
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build(),
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
     // Verify no additional objects were serialized to represent the template type: we only have
     // the well-known types and the three TypeProtos tested for above.
     assertThat(typePool).hasSize(nativeObjects().size() + 3);
@@ -415,7 +437,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("ns.f")
+                    ObjectTypeProto.newBuilder()
                         .setIsInvalidating(true)
                         .addAllOwnProperty(findAllInStringPool("a", "b", "c")))
                 .build());
@@ -429,19 +451,22 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 "/** @interface @template T */",
                 "class Foo {}",
                 "var /** !Foo<string> */ fooString;",
-                "var /** !Foo<number> */ fooNumber;"));
+                "var /** !Foo<number> */ fooNumber;",
+                "",
+                "FOO: fooString;",
+                "FOO_PROTOTYPE: Foo.prototype;"));
 
     assertThat(typePool)
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .containsAtLeast(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("(typeof Foo)")
-                        .addPrototype(pointerForType("Foo.prototype"))
-                        .addInstanceType(pointerForType("Foo")))
+                    ObjectTypeProto.newBuilder()
+                        .addPrototype(pointerForLabel("FOO_PROTOTYPE"))
+                        .addInstanceType(pointerForLabel("FOO")))
                 .build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo")).build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo.prototype")).build());
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build(),
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
@@ -457,7 +482,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("function(new:*): ?")
+                    ObjectTypeProto.newBuilder()
                         .setIsInvalidating(true)
                         .addPrototype(PrimitiveType.UNKNOWN_TYPE.getNumber())
                         .addInstanceType(PrimitiveType.UNKNOWN_TYPE.getNumber())
@@ -482,18 +507,21 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
             " * @extends {RecordType}",
             " * @suppress {checkTypes}",
             "*/",
-            "class Baz {}");
+            "class Baz {}",
+            "",
+            "let /** !Baz */ baz;",
+            "BAZ: baz;");
     TypePool typePool = compileToTypePool(source);
 
-    assertThat(getNonPrimitiveSupertypesFor(typePool, "Baz"))
+    assertThat(getNonPrimitiveSupertypesFor(typePool, "BAZ"))
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .containsExactly(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("{x: string}").setIsInvalidating(true))
+                .setObject(ObjectTypeProto.newBuilder().setIsInvalidating(true))
                 .build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Foo")).build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Bar")).build(),
-            TypeProto.newBuilder().setObject(namedObjectBuilder("Baz.prototype")).build());
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build(),
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build(),
+            TypeProto.newBuilder().setObject(ObjectTypeProto.getDefaultInstance()).build());
   }
 
   @Test
@@ -535,7 +563,10 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 "class Bar { }",
                 "",
                 "let /** function(new:Foo) */ x;",
-                "let /** function(new:Bar) */ y;"));
+                "let /** function(new:Bar) */ y;",
+                "",
+                "FOO: new Foo();",
+                "BAR: new Bar();"));
 
     // Then
     assertThat(typePool)
@@ -544,10 +575,10 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("function(new:Bar): ?", "function(new:Foo): ?")
+                    ObjectTypeProto.newBuilder()
                         .setMarkedConstructor(true)
-                        .addInstanceType(pointerForType("Foo"))
-                        .addInstanceType(pointerForType("Bar"))
+                        .addInstanceType(pointerForLabel("FOO"))
+                        .addInstanceType(pointerForLabel("BAR"))
                         .addPrototype(PrimitiveType.UNKNOWN_TYPE.getNumber()))
                 .build());
   }
@@ -572,7 +603,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .contains(
             TypeProto.newBuilder()
                 .setObject(
-                    namedObjectBuilder("Foo.prototype")
+                    ObjectTypeProto.newBuilder()
                         .addOwnProperty(findInStringPool("a"))
                         .addOwnProperty(findInStringPool("b"))
                         .addOwnProperty(findInStringPool("constructor")))
@@ -600,7 +631,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .ignoringFieldDescriptors(IS_INVALIDATING)
         .contains(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("assertFoo").setClosureAssert(true))
+                .setObject(ObjectTypeProto.newBuilder().setClosureAssert(true))
                 .build());
   }
 
@@ -627,7 +658,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
         .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
         .contains(
             TypeProto.newBuilder()
-                .setObject(namedObjectBuilder("Foo").setIsInvalidating(true))
+                .setObject(ObjectTypeProto.newBuilder().setIsInvalidating(true))
                 .build());
   }
 
@@ -650,33 +681,32 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 " * @suppress {checkTypes}",
                 " * @type {(!A|!B)}",
                 " */",
-                "const x = new C();"));
+                "const x = new C();",
+                "",
+                "A_CTOR: A;",
+                "B_CTOR: B;",
+                "C_CTOR: C;"));
+
+    ObjectTypeProto aCtor =
+        this.typePool.getType(trimOffset(pointerForLabel("A_CTOR"))).getObject();
+    ObjectTypeProto bCtor =
+        this.typePool.getType(trimOffset(pointerForLabel("B_CTOR"))).getObject();
+    ObjectTypeProto cCtor =
+        this.typePool.getType(trimOffset(pointerForLabel("C_CTOR"))).getObject();
 
     assertThat(typePool.getDebugInfo().getMismatchList())
         .contains(
             TypePool.DebugInfo.Mismatch.newBuilder()
                 .setSourceRef("testcode:9:10")
-                .addInvolvedColor(pointerForType("(typeof A)"))
-                .addInvolvedColor(pointerForType("A"))
-                .addInvolvedColor(pointerForType("A.prototype"))
-                .addInvolvedColor(pointerForType("(typeof B)"))
-                .addInvolvedColor(pointerForType("B"))
-                .addInvolvedColor(pointerForType("B.prototype"))
-                .addInvolvedColor(pointerForType("(typeof C)"))
-                .addInvolvedColor(pointerForType("C"))
-                .addInvolvedColor(pointerForType("C.prototype"))
-                .build());
-  }
-
-  private ObjectTypeProto.Builder namedObjectBuilder(String... classNames) {
-    ImmutableList.Builder<Integer> typeNamePointers = ImmutableList.builder();
-    for (String className : classNames) {
-      typeNamePointers.add(this.stringPoolBuilder.put(className));
-    }
-    return ObjectTypeProto.newBuilder()
-        .setDebugInfo(
-            ObjectTypeProto.DebugInfo.newBuilder()
-                .addAllTypenamePointer(typeNamePointers.build())
+                .addInvolvedColor(pointerForLabel("A_CTOR"))
+                .addInvolvedColor(aCtor.getInstanceTypeList().get(0))
+                .addInvolvedColor(aCtor.getPrototypeList().get(0))
+                .addInvolvedColor(pointerForLabel("B_CTOR"))
+                .addInvolvedColor(bCtor.getInstanceTypeList().get(0))
+                .addInvolvedColor(bCtor.getPrototypeList().get(0))
+                .addInvolvedColor(pointerForLabel("C_CTOR"))
+                .addInvolvedColor(cCtor.getInstanceTypeList().get(0))
+                .addInvolvedColor(cCtor.getPrototypeList().get(0))
                 .build());
   }
 
@@ -701,19 +731,9 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
     return stream(str).map(this::findInStringPool).collect(toImmutableList());
   }
 
-  private int pointerForType(String className) {
-    List<TypeProto> types = this.typePool.getTypeList();
-    StringPool stringPool = this.stringPoolBuilder.build();
-    for (int i = 0; i < types.size(); i++) {
-      ImmutableSet<String> typeNames =
-          types.get(i).getObject().getDebugInfo().getTypenamePointerList().stream()
-              .map(stringPool::get)
-              .collect(toImmutableSet());
-      if (typeNames.contains(className)) {
-        return untrimOffset(i);
-      }
-    }
-    throw new AssertionError("Unable to find type '" + className + "' in " + this.typePool);
+  private int pointerForLabel(String label) {
+    Preconditions.checkState(this.labelToPointer.containsKey(label), "Cannot find label %s", label);
+    return this.labelToPointer.get(label);
   }
 
   /** Returns the types that are serialized for every compilation, even given an empty source */
@@ -721,20 +741,13 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
     return ImmutableList.copyOf(compileToTypes(""));
   }
 
-  private List<TypeProto> getNonPrimitiveSupertypesFor(TypePool typePool, String className) {
+  /** Accepts a label name in source code, and finds its primitive supertypes. */
+  private List<TypeProto> getNonPrimitiveSupertypesFor(TypePool typePool, String labelName) {
     ArrayList<TypeProto> supertypes = new ArrayList<>();
-    StringPool stringPool = this.stringPoolBuilder.build();
+    int typeOffset = pointerForLabel(labelName);
+
     for (SubtypingEdge edge : typePool.getDisambiguationEdgesList()) {
-      TypeProto subtype = typePool.getType(trimOffset(edge.getSubtype()));
-      if (!subtype.hasObject()) {
-        continue;
-      }
-      ObjectTypeProto objectSubtype = subtype.getObject();
-      ImmutableList<String> typeNames =
-          objectSubtype.getDebugInfo().getTypenamePointerList().stream()
-              .map(stringPool::get)
-              .collect(toImmutableList());
-      if (!typeNames.get(0).equals(className)) {
+      if (edge.getSubtype() != typeOffset) {
         continue;
       }
       if (isAxiomatic(edge.getSupertype())) {
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java b/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
index 9378ff4..075085e 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
@@ -47,6 +47,7 @@ import java.time.Instant;
 import java.util.function.Consumer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -64,7 +65,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class SerializeAndDeserializeAstTest extends CompilerTestCase {
 
-  private Consumer<TypedAst> consumer = null;
+  private @Nullable Consumer<TypedAst> consumer = null;
   private boolean includeTypes;
 
   @Override
@@ -252,6 +253,55 @@ public final class SerializeAndDeserializeAstTest extends CompilerTestCase {
   }
 
   @Test
+  public void testEmptyClassStaticBlock() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticBlock_variables() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    this.x=1;",
+            "    let y =2;",
+            "    var z =3;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticBlock_function() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    function x() {",
+            "    }",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testMultipleClassStaticBlocks() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static {",
+            "    this.x=1;",
+            "  }",
+            "  static {",
+            "    this.y=2;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testVanillaFunctionDeclaration() {
     testSame("function f(x, y) { return x ** y; }");
   }
@@ -631,12 +681,10 @@ public final class SerializeAndDeserializeAstTest extends CompilerTestCase {
     final DeserializedAst ast;
     final ColorRegistry registry;
     final Node sourceRoot;
-    final Node externRoot;
 
     Result(DeserializedAst ast, ColorRegistry registry, Node externRoot, Node sourceRoot) {
       this.ast = ast;
       this.registry = registry;
-      this.externRoot = externRoot;
       this.sourceRoot = sourceRoot;
     }
   }
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java b/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
index 2317a25..2b05fae 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
@@ -43,6 +43,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +54,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
 
   private Consumer<TypedAst> astConsumer;
   // individual test cases may override this
-  private ImmutableSet<String> typesToForwardDeclare = null;
+  private @Nullable ImmutableSet<String> typesToForwardDeclare = null;
 
   // Proto fields commonly ignored in tests because hardcoding their values is brittle
   private static final ImmutableList<FieldDescriptor> BRITTLE_TYPE_FIELDS =
@@ -209,7 +210,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.TAGGED_TEMPLATELIT)
-                                .addBooleanProperty(NodeProperty.FREE_CALL)
+                                .setBooleanProperties(1L << NodeProperty.FREE_CALL.getNumber())
                                 .addChild(
                                     AstNode.newBuilder()
                                         .setKind(NodeKind.IDENTIFIER)
@@ -253,8 +254,9 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.NUMBER_LITERAL)
-                                .addBooleanProperty(NodeProperty.IS_PARENTHESIZED)
-                                .addBooleanProperty(NodeProperty.COLOR_FROM_CAST)
+                                .setBooleanProperties(
+                                    (1L << NodeProperty.IS_PARENTHESIZED.getNumber())
+                                        | (1L << NodeProperty.COLOR_FROM_CAST.getNumber()))
                                 .setDoubleValue(1)
                                 .setType(unknownType)
                                 .build())
@@ -280,7 +282,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.FUNCTION_LITERAL)
-                                .addBooleanProperty(NodeProperty.ARROW_FN)
+                                .setBooleanProperties(1L << NodeProperty.ARROW_FN.getNumber())
                                 .addChild(
                                     AstNode.newBuilder()
                                         .setKind(NodeKind.IDENTIFIER)
@@ -313,12 +315,12 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
         .isEqualTo(
             AstNode.newBuilder()
                 .setKind(NodeKind.SOURCE_FILE)
-                .addBooleanProperty(NodeProperty.GOOG_MODULE)
+                .setBooleanProperties(1L << NodeProperty.GOOG_MODULE.getNumber())
                 // `/** @const */ var module$exports$a$b$c = {};`
                 .addChild(
                     AstNode.newBuilder()
                         .setKind(NodeKind.VAR_DECLARATION)
-                        .addBooleanProperty(NodeProperty.IS_NAMESPACE)
+                        .setBooleanProperties(1L << NodeProperty.IS_NAMESPACE.getNumber())
                         .setJsdoc(OptimizationJsdoc.newBuilder().addKind(JsdocTag.JSDOC_CONST))
                         .addChild(
                             AstNode.newBuilder()
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java b/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
index accdeaa..fdd3cce 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeTypesToPointersTest.java
@@ -18,7 +18,6 @@ package com.google.javascript.jscomp.serialization;
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 import static com.google.javascript.jscomp.CompilerTestCase.lines;
 import static java.util.Arrays.stream;
 
@@ -68,11 +67,8 @@ public final class SerializeTypesToPointersTest {
                 .getTypePool()
                 .getType(TypePointers.trimOffset(fooCtorPointer))
                 .getObject()
-                .getDebugInfo())
-        .isEqualTo(
-            ObjectTypeProto.DebugInfo.newBuilder()
-                .addTypenamePointer(stringPoolBuilder.put("(typeof Foo)"))
-                .build());
+                .getMarkedConstructor())
+        .isTrue();
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
index c633739..a1a4bd4 100644
--- a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
@@ -16,18 +16,21 @@
 
 package com.google.javascript.jscomp.serialization;
 
-import static com.google.common.truth.Truth.assertWithMessage;
+import static com.google.common.truth.extensions.proto.ProtoTruth.assertThat;
 
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerPass;
 import com.google.javascript.jscomp.CompilerTestCase;
 import com.google.javascript.rhino.Node;
+import com.google.protobuf.Descriptors.FieldDescriptor;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -74,8 +77,15 @@ public class TypedAstSerializerTest extends CompilerTestCase {
               "var console;",
               ""));
 
+  // Proto fields commonly ignored in tests because hardcoding their values is brittle
+  private static final FieldDescriptor OBJECT_UUID =
+      ObjectTypeProto.getDescriptor().findFieldByName("uuid");
+
+  private static final ImmutableList<FieldDescriptor> BRITTLE_TYPE_FIELDS =
+      ImmutableList.of(OBJECT_UUID);
+
   /** Holds the serialized AST created by the last executed test method. */
-  private TypedAst testResult = null;
+  private @Nullable TypedAst testResult = null;
 
   @Override
   @Before
@@ -126,30 +136,19 @@ public class TypedAstSerializerTest extends CompilerTestCase {
   @Test
   public void emptySourcesWithTypeChecking() {
     enableTypeCheck();
-    // When serializing from an AST which has *not* been converted to Colors, the "global this"
-    // and "?.prototype" types are automatically included in the proto.
-    new Tester()
-        .expectTypeNamed("global this")
-        .expectTypeNamed("global this.prototype")
-        .expectTypeNamed("?.prototype")
-        .expectTypeNamed("Console")
-        .expectTypeWithProperties("Console.prototype", "log")
-        .expectTypeNamed("Console.prototype.log")
-        .test("console.log(1);");
+
+    // No code, so no types referenced to be serialized.
+    new Tester().test("");
   }
 
   @Test
   public void consoleDotLogWithTypeChecking() {
     enableTypeCheck();
-    // When serializing from an AST which has *not* been converted to Colors, the "global this"
-    // and "?.prototype" types are automatically included in the proto.
+
     new Tester()
-        .expectTypeNamed("global this")
-        .expectTypeNamed("global this.prototype")
-        .expectTypeNamed("?.prototype")
-        .expectTypeNamed("Console")
-        .expectTypeWithProperties("Console.prototype", "log")
-        .expectTypeNamed("Console.prototype.log")
+        .expectType(ObjectTypeProto.newBuilder()) // Console
+        .expectTypeWithProperties(ObjectTypeProto.newBuilder(), "log") // Console.prototype
+        .expectType(ObjectTypeProto.newBuilder().setIsInvalidating(true)) // Console.prototype.log
         .test("console.log(1);");
   }
 
@@ -166,54 +165,55 @@ public class TypedAstSerializerTest extends CompilerTestCase {
   public void consoleDotLogWithColorizedAst() {
     enableTypeCheck();
     replaceTypesWithColors();
+
     new Tester()
-        .expectTypeNamed("Console")
-        .expectTypeWithProperties("Console.prototype", "log")
-        .expectTypeNamed("Console.prototype.log")
+        .expectType(ObjectTypeProto.newBuilder()) // Console
+        .expectTypeWithProperties(ObjectTypeProto.newBuilder(), "log") // Console.prototype
+        .expectType(ObjectTypeProto.newBuilder().setIsInvalidating(true)) // Console.prototype.log
         .test("console.log(1);");
   }
 
   private class Tester {
-    final Map<String, ImmutableSet<String>> expectedTypeNameToPropertyNamesMap = new HashMap<>();
+    final Map<ObjectTypeProto.Builder, ImmutableSet<String>> expectedTypeToPropertyNamesMap =
+        new HashMap<>();
 
-    Tester expectTypeNamed(String typeName) {
-      expectedTypeNameToPropertyNamesMap.put(typeName, ImmutableSet.of());
+    Tester expectType(ObjectTypeProto.Builder type) {
+      this.expectedTypeToPropertyNamesMap.put(type, ImmutableSet.of());
       return this;
     }
 
-    Tester expectTypeWithProperties(String typeName, String... propertyNames) {
-      expectedTypeNameToPropertyNamesMap.put(typeName, ImmutableSet.copyOf(propertyNames));
+    // pass 'ownPropertyNames' here rather than using the ObjectTypeProto.Builder to avoid needing
+    // to go through the StringPool
+    Tester expectTypeWithProperties(ObjectTypeProto.Builder type, String... propertyNames) {
+      this.expectedTypeToPropertyNamesMap.put(type, ImmutableSet.copyOf(propertyNames));
       return this;
     }
 
     void test(String code) {
       testSame(CONSOLE_EXTERNS, srcs(code));
 
-      final StringPool stringPool = StringPool.fromProto(testResult.getStringPool());
-      final List<TypeProto> typeProtos = testResult.getTypePool().getTypeList();
-      final Map<String, Integer> typeNameToTrimmedPoolOffset = new HashMap<>();
-      for (int i = 0; i < typeProtos.size(); ++i) {
-        final TypeProto typeProto = typeProtos.get(i);
-        // none of our test cases use unions, so we know it's an object type
-        final ObjectTypeProto typeProtoObject = typeProto.getObject();
-        final String typeName =
-            stringPool.get(typeProtoObject.getDebugInfo().getTypenamePointer(0));
-        typeNameToTrimmedPoolOffset.put(typeName, i);
-
-        // check actual property names against the expected ones
-        final Set<String> actualPropertyNames =
-            typeProtoObject.getOwnPropertyList().stream()
-                .map(stringPool::get)
-                .collect(Collectors.toSet());
-        final ImmutableSet<String> expectedPropertyNames =
-            expectedTypeNameToPropertyNamesMap.getOrDefault(typeName, ImmutableSet.of());
-        assertWithMessage("property names for type \"%s\"", typeName)
-            .that(actualPropertyNames)
-            .containsExactlyElementsIn(expectedPropertyNames);
+      final HashMap<String, Integer> stringPoolOffsets = new HashMap<>();
+      StringPool stringPool = StringPool.fromProto(testResult.getStringPool());
+      for (int i = 0; i < testResult.getStringPool().getStringsCount(); ++i) {
+        stringPoolOffsets.put(stringPool.get(i), i);
+      }
+      final List<TypeProto> expectedTypes = new ArrayList<>();
+      for (Map.Entry<ObjectTypeProto.Builder, ImmutableSet<String>> expectedTypeWithProperties :
+          expectedTypeToPropertyNamesMap.entrySet()) {
+        ObjectTypeProto.Builder ex = expectedTypeWithProperties.getKey();
+        for (String propertyName : expectedTypeWithProperties.getValue()) {
+          Preconditions.checkState(
+              stringPoolOffsets.containsKey(propertyName),
+              "Missing property '%s' in string pool",
+              propertyName);
+          ex.addOwnProperty(stringPoolOffsets.get(propertyName));
+        }
+        expectedTypes.add(TypeProto.newBuilder().setObject(ex).build());
       }
-      assertWithMessage("Serialized type names")
-          .that(typeNameToTrimmedPoolOffset.keySet())
-          .containsExactlyElementsIn(expectedTypeNameToPropertyNamesMap.keySet());
+      final List<TypeProto> actualTypes = testResult.getTypePool().getTypeList();
+      assertThat(actualTypes)
+          .ignoringFieldDescriptors(BRITTLE_TYPE_FIELDS)
+          .containsExactlyElementsIn(expectedTypes);
     }
   }
 }
diff --git a/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java b/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
index 04f9fa7..457c2bd 100644
--- a/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
+++ b/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
@@ -27,8 +27,6 @@ import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
 import com.google.javascript.jscomp.SourceFile;
 import com.google.javascript.rhino.Node;
-import java.util.List;
-import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -41,7 +39,7 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_overlapsAreErrors() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 10, ""), CodeReplacement.create(5, 3, ""));
     try {
       ApplySuggestedFixes.applyCodeReplacements(replacements, "");
@@ -51,21 +49,21 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_overlapsAreErrors_unlessEqual() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 3, "A"), CodeReplacement.create(0, 3, "A"));
     ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
   }
 
   @Test
   public void testApplyCodeReplacements_noOverlapsSucceed() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 3, ""), CodeReplacement.create(5, 3, ""));
     ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
   }
 
   @Test
   public void testApplyCodeReplacements() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 1, "z"), CodeReplacement.create(3, 2, "qq"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("zbcqqf", newCode);
@@ -73,28 +71,31 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_insertion() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(0, 0, "z"));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(0, 0, "z"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("zabcdef", newCode);
   }
 
   @Test
   public void testApplyCodeReplacements_deletion() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(0, 6, ""));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(0, 6, ""));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertThat(newCode).isEmpty();
   }
 
   @Test
   public void testApplyCodeReplacements_boundaryCases() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(5, 1, "z"));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(5, 1, "z"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("abcdez", newCode);
   }
 
   @Test
   public void testApplyCodeReplacements_multipleReplacements() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(
             CodeReplacement.create(0, 2, "z"),
             CodeReplacement.create(2, 1, "y"),
@@ -108,10 +109,11 @@ public class ApplySuggestedFixesTest {
     String code = "var someNode;";
     Compiler compiler = getCompiler(code);
     Node root = compileToScriptRoot(compiler);
-    List<SuggestedFix> fixes = ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes =
+        ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap).containsEntry("test", "");
   }
@@ -127,10 +129,10 @@ public class ApplySuggestedFixesTest {
     SuggestedFix fix = new SuggestedFix.Builder()
         .insertBefore(jsdocRoot, "!")
         .build();
-    List<SuggestedFix> fixes = ImmutableList.of(fix);
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of(fix);
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap).containsEntry("test", "/** @type {!Foo} */\nvar foo = new Foo()");
   }
@@ -150,10 +152,10 @@ public class ApplySuggestedFixesTest {
     SuggestedFix fix2 = new SuggestedFix.Builder()
         .insertBefore(foo, "!")
         .build();
-    List<SuggestedFix> fixes = ImmutableList.of(fix1, fix2);
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of(fix1, fix2);
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap)
         .containsEntry("test", "/** @type {!Array<!Foo>} */\nvar arr = [new Foo()];");
@@ -161,23 +163,25 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplySuggestedFixes_noFixes() throws Exception {
-    Map<String, String> codeMap = ImmutableMap.of(
-        "file1", "abcdef",
-        "file2", "abcdef");
-    Map<String, String> expectedNewCodeMap = ImmutableMap.of();
-    List<SuggestedFix> fixes = ImmutableList.of();
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableMap<String, String> codeMap =
+        ImmutableMap.of(
+            "file1", "abcdef",
+            "file2", "abcdef");
+    ImmutableMap<String, String> expectedNewCodeMap = ImmutableMap.of();
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of();
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertEquals(expectedNewCodeMap, newCodeMap);
   }
 
   @Test
   public void testApplySuggestedFixes_missingCodeForFile() throws Exception {
-    Map<String, String> codeMap = ImmutableMap.of();
+    ImmutableMap<String, String> codeMap = ImmutableMap.of();
     String code = "var someNode;";
     Compiler compiler = getCompiler(code);
     Node root = compileToScriptRoot(compiler);
-    List<SuggestedFix> fixes = ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
+    ImmutableList<SuggestedFix> fixes =
+        ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
     try {
       ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
       fail("applySuggestedFixesToCode should have failed since file is missing from code map.");
@@ -192,7 +196,7 @@ public class ApplySuggestedFixesTest {
     System.out.println(root.toStringTree());
     Node var = root.getFirstChild();
 
-    List<SuggestedFix> fixes =
+    ImmutableList<SuggestedFix> fixes =
         ImmutableList.of(
             new SuggestedFix.Builder()
                 .rename(var.getLastChild(), "newShared")
@@ -203,7 +207,7 @@ public class ApplySuggestedFixesTest {
                 .rename(var.getSecondChild(), "newSecond")
                 .build());
 
-    Map<String, String> newCodeMap =
+    ImmutableMap<String, String> newCodeMap =
         ApplySuggestedFixes.applySuggestedFixesToCode(fixes, ImmutableMap.of("test", code));
     assertThat(newCodeMap).containsExactly("test", "var newFirst, newSecond, newShared;");
   }
diff --git a/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java b/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
index 175da72..14701e2 100644
--- a/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
+++ b/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
@@ -34,7 +34,7 @@ import com.google.javascript.jscomp.GoogleCodingConvention;
 import com.google.javascript.jscomp.JSError;
 import com.google.javascript.jscomp.SourceFile;
 import java.util.Collection;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -75,8 +75,7 @@ public class ErrorToFixMapperTest {
   @AutoValue
   abstract static class ExpectedFix {
     /** Optional string describing the fix. */
-    @Nullable
-    abstract String description();
+    abstract @Nullable String description();
     /** What the code should look like after applying the fix. */
     abstract String fixedCode();
 
diff --git a/test/com/google/javascript/refactoring/SuggestedFixTest.java b/test/com/google/javascript/refactoring/SuggestedFixTest.java
index 960ab3d..a71adae 100644
--- a/test/com/google/javascript/refactoring/SuggestedFixTest.java
+++ b/test/com/google/javascript/refactoring/SuggestedFixTest.java
@@ -60,7 +60,7 @@ public class SuggestedFixTest {
 
   @Test
   public void testInsertBeforeWithNonJSDocBlockComment() {
-    String before = "var someRandomCode = {};";
+    String before = "var someRandomCode = {};\n";
     String after = "/* some comment */\ngoog.foo();";
     Compiler compiler = getCompiler(before + after);
     Node root = compileToScriptRoot(compiler);
@@ -75,7 +75,7 @@ public class SuggestedFixTest {
 
   @Test
   public void testInsertBeforeWithNonJSDocLineComment() {
-    String before = "var someRandomCode = {};";
+    String before = "var someRandomCode = {};\n";
     String after = "// some comment \ngoog.foo();";
     Compiler compiler = getCompiler(before + after);
     Node root = compileToScriptRoot(compiler);
diff --git a/test/com/google/javascript/rhino/HamtPMapTest.java b/test/com/google/javascript/rhino/HamtPMapTest.java
index 759f7f6..63fd562 100644
--- a/test/com/google/javascript/rhino/HamtPMapTest.java
+++ b/test/com/google/javascript/rhino/HamtPMapTest.java
@@ -194,6 +194,7 @@ public class HamtPMapTest {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void testReconcile_rejectsNullResult() {
     PMap<Integer, Integer> left = build(1, 3, 5, 7);
     PMap<Integer, Integer> right = build(2, 4, 6, 8);
diff --git a/test/com/google/javascript/rhino/JSDocInfoTest.java b/test/com/google/javascript/rhino/JSDocInfoTest.java
index ca0ba6a..e33c572 100644
--- a/test/com/google/javascript/rhino/JSDocInfoTest.java
+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java
@@ -155,7 +155,7 @@ public class JSDocInfoTest {
     mockedModuleLocals.add("AnotherItem");
 
     JSTypeExpression newExpr = jsTypeExpression.replaceNamesWithUnknownType(mockedModuleLocals);
-    Set<String> replacedNames = newExpr.getAllTypeNames();
+    ImmutableSet<String> replacedNames = newExpr.getAllTypeNames();
     assertThat(replacedNames).doesNotContain("Item");
     assertThat(replacedNames).contains("string");
     assertThat(replacedNames).contains("boolean");
@@ -742,7 +742,7 @@ public class JSDocInfoTest {
     JSDocInfo info = builder.build();
 
     // Then
-    Collection<Node> upperBoundRoots =
+    ImmutableList<Node> upperBoundRoots =
         info.getTemplateTypes().values().stream()
             .map(JSTypeExpression::getRoot)
             .collect(toImmutableList());
diff --git a/test/com/google/javascript/rhino/NodeTest.java b/test/com/google/javascript/rhino/NodeTest.java
index 65c6014..a39d1e7 100644
--- a/test/com/google/javascript/rhino/NodeTest.java
+++ b/test/com/google/javascript/rhino/NodeTest.java
@@ -43,13 +43,14 @@ import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.javascript.jscomp.serialization.NodeProperty;
+import com.google.javascript.rhino.Node.SideEffectFlags;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.testing.TestErrorReporter;
 import java.math.BigInteger;
-import java.util.EnumSet;
 import java.util.function.Consumer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -76,6 +77,34 @@ public class NodeTest {
   }
 
   @Test
+  public void testSideEffectFlagsSerialization() {
+    // Test each individual flag
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_GLOBAL_STATE);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_THIS);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_ARGUMENTS);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.THROWS);
+    // Test an arbitrary combination of 2 flags
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.THROWS | SideEffectFlags.MUTATES_THIS);
+  }
+
+  public void checkSideEffectFlagsRoundTrip(int testFlags) {
+    final Node original = IR.call(IR.name("f"));
+    // serialization only works for nodes that actually have a source file,
+    // because in actual execution they always must have that.
+    original.setSourceFileForTesting("sourcefile");
+
+    // Simulate the situation where we've deserialized the node itself, but not its non-source-file
+    // properties yet, by cloning the orignal node before adding the side effect flags to it.
+    final Node restored = original.cloneNode();
+
+    original.setSideEffectFlags(testFlags);
+    final long serializedProperties = original.serializeProperties();
+
+    restored.deserializeProperties(serializedProperties);
+    assertThat(restored.getSideEffectFlags()).isEqualTo(testFlags);
+  }
+
+  @Test
   public void testValidatePropertiesForIsParenthesized() {
     Node n = IR.string("");
     n.setSourceFileForTesting("file.js"); // avoid error about missing source file
@@ -684,39 +713,53 @@ public class NodeTest {
     assertThat(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME)).isTrue();
   }
 
+  private long bitsetFromNodeProperties(ImmutableSet<NodeProperty> props) {
+    long bitset = 0;
+    for (NodeProperty prop : props) {
+      bitset = Node.setNodePropertyBit(bitset, prop);
+    }
+    return bitset;
+  }
+
   @Test
   public void testSerializeProperties() {
     Node node = IR.function(IR.name(""), IR.paramList(), IR.block());
     node.setIsAsyncFunction(true);
     node.setIsGeneratorFunction(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.GENERATOR_FN, NodeProperty.ASYNC_FN);
+    long result = node.serializeProperties();
+
+    assertThat(result)
+        .isEqualTo(
+            bitsetFromNodeProperties(
+                ImmutableSet.of(NodeProperty.GENERATOR_FN, NodeProperty.ASYNC_FN)));
   }
 
   @Test
   public void testSerializeProperties_isDeclaredConstant() {
     Node node = new Node(Token.NAME);
     node.setDeclaredConstantVar(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.IS_DECLARED_CONSTANT);
+    long result = node.serializeProperties();
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.IS_DECLARED_CONSTANT)));
   }
 
   @Test
   public void testSerializeProperties_isInferredConstant() {
     Node node = new Node(Token.NAME);
     node.setInferredConstantVar(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.IS_INFERRED_CONSTANT);
+    long result = node.serializeProperties();
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.IS_INFERRED_CONSTANT)));
   }
 
   @Test
   public void testSerializeProperties_untranslatableRhinoProp() {
     Node node = getCall("A");
-    node.setSideEffectFlags(2);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    // Rhino node prop SIDE_EFFECT_FLAGS does not have a corresponding NodeProperty
-    assertThat(node.getSideEffectFlags()).isEqualTo(2);
-    assertThat(result).isEmpty();
+    node.setUseStrict(true);
+    long result = node.serializeProperties();
+    // Rhino node prop USE_STRICT does not have a corresponding NodeProperty
+    assertThat(node.isUseStrict()).isTrue();
+    assertThat(result).isEqualTo(0);
   }
 
   @Test
@@ -725,9 +768,10 @@ public class NodeTest {
     JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);
     Node node = Node.newString(Token.NAME, "f");
     node.setJSTypeBeforeCast(registry.getNativeType(JSTypeNative.NUMBER_TYPE));
-    EnumSet<NodeProperty> result = node.serializeProperties();
+    long result = node.serializeProperties();
     // Special case: Rhino node prop TYPE_BEFORE_CAST is converted to NodeProperty.COLOR_FROM_CAST
-    assertThat(result).containsExactly(NodeProperty.COLOR_FROM_CAST);
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.COLOR_FROM_CAST)));
   }
 
   @Test
diff --git a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
index 328e145..cb587d4 100644
--- a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
+++ b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
@@ -40,9 +40,9 @@ package com.google.javascript.rhino.jstype;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.rhino.jstype.FunctionType.Parameter;
 import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
-import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -62,7 +62,7 @@ public class FunctionParamBuilderTest extends BaseJSTypeTestCase {
     assertThat(builder.addOptionalParams(BOOLEAN_TYPE)).isTrue();
     assertThat(builder.addVarArgs(STRING_TYPE)).isTrue();
 
-    List<Parameter> params = builder.build();
+    ImmutableList<Parameter> params = builder.build();
     assertTypeEquals(NUMBER_TYPE, params.get(0).getJSType());
     assertTypeEquals(registry.createOptionalType(BOOLEAN_TYPE), params.get(1).getJSType());
     assertTypeEquals(STRING_TYPE, params.get(2).getJSType());
diff --git a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
index a2b0386..1dbd293 100644
--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
@@ -56,6 +56,7 @@ import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;
 import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.rhino.IR;
@@ -66,9 +67,9 @@ import com.google.javascript.rhino.testing.AbstractStaticScope;
 import com.google.javascript.rhino.testing.MapBasedScope;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -84,12 +85,11 @@ public class JSTypeRegistryTest {
   // now much larger
 
   private final JSTypeRegistry registry = new JSTypeRegistry(null, null);
-  private JSTypeResolver.Closer closer;
 
   @Before
   @SuppressWarnings({"MustBeClosedChecker"})
   public void setUp() throws Exception {
-    this.closer = registry.getResolver().openForDefinition();
+    JSTypeResolver.Closer unused = registry.getResolver().openForDefinition();
   }
 
   @Test
@@ -154,7 +154,7 @@ public class JSTypeRegistryTest {
     // Test that it takes one parameter of type
     // function(function((IThenable<TYPE>|TYPE|null|{then: ?})=): ?, function(*=): ?): ?
     FunctionType promiseCtor = promiseType.getConstructor();
-    List<FunctionType.Parameter> paramList = promiseCtor.getParameters();
+    ImmutableList<FunctionType.Parameter> paramList = promiseCtor.getParameters();
     assertThat(paramList).hasSize(1);
     FunctionType.Parameter firstParameter = paramList.get(0);
     FunctionType paramType = firstParameter.getJSType().toMaybeFunctionType();
@@ -315,7 +315,7 @@ public class JSTypeRegistryTest {
   /** Returns a scope that overrides a few methods from {@link AbstractStaticScope} */
   private StaticTypedScope createStaticTypedScope(
       Node root,
-      StaticTypedScope parentScope,
+      @Nullable StaticTypedScope parentScope,
       Map<String, StaticTypedSlot> slots,
       Set<String> reservedNames) {
     return new AbstractStaticScope() {
diff --git a/test/com/google/javascript/rhino/jstype/JSTypeTest.java b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
index 04da8ad..98fedee 100644
--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java
+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
@@ -92,11 +92,10 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   private static final StaticTypedScope EMPTY_SCOPE = MapBasedScope.emptyScope();
 
   /**
-   * A non exhaustive list of representative types used to test simple
-   * properties that should hold for all types (such as the reflexivity
-   * of subtyping).
+   * A non exhaustive list of representative types used to test simple properties that should hold
+   * for all types (such as the reflexivity of subtyping).
    */
-  private List<JSType> types;
+  private ImmutableList<JSType> types;
 
   @Before
   @SuppressWarnings({"MustBeClosedChecker"})
@@ -2506,7 +2505,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   private void assertReturnTypeEquals(JSType expectedReturnType,
       JSType function) {
-    assertThat(function instanceof FunctionType).isTrue();
+    assertThat(function).isInstanceOf(FunctionType.class);
     assertTypeEquals(expectedReturnType,
         ((FunctionType) function).getReturnType());
   }
@@ -3076,7 +3075,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertTypeEquals("apply should have the same return type as its function",
         NUMBER_TYPE, applyFn.getReturnType());
 
-    List<FunctionType.Parameter> params = applyFn.getParameters();
+    ImmutableList<FunctionType.Parameter> params = applyFn.getParameters();
     assertWithMessage("apply takes two args").that(params).hasSize(2);
     assertTypeEquals(
         "apply's first arg is the @this type",
@@ -3100,7 +3099,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertTypeEquals("call should have the same return type as its function",
         NUMBER_TYPE, callFn.getReturnType());
 
-    List<FunctionType.Parameter> params = callFn.getParameters();
+    ImmutableList<FunctionType.Parameter> params = callFn.getParameters();
     assertWithMessage("call takes one argument in this case").that(params).hasSize(1);
     assertTypeEquals(
         "call's first arg is the @this type",
@@ -3183,9 +3182,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(stringMethodEmpty.isSubtype(dateMethodEmpty)).isFalse();
 
     // Systemic tests.
-    List<FunctionType> allFunctions = ImmutableList.of(
-        dateMethodEmpty, dateMethodWithParam, dateMethodWithReturn,
-        stringMethodEmpty, stringMethodWithParam, stringMethodWithReturn);
+    ImmutableList<FunctionType> allFunctions =
+        ImmutableList.of(
+            dateMethodEmpty,
+            dateMethodWithParam,
+            dateMethodWithReturn,
+            stringMethodEmpty,
+            stringMethodWithParam,
+            stringMethodWithReturn);
     for (int i = 0; i < allFunctions.size(); i++) {
       for (int j = 0; j < allFunctions.size(); j++) {
         FunctionType typeA = allFunctions.get(i);
@@ -3263,9 +3267,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(googBarMethod.isSubtype(googSubBarMethod)).isTrue();
     assertThat(googBarReturnFn.isSubtype(googSubBarReturnFn)).isTrue();
 
-    List<FunctionType> allFunctions = ImmutableList.of(
-        googBarMethod, googBarParamFn, googBarReturnFn,
-        googSubBarMethod, googSubBarParamFn, googSubBarReturnFn);
+    ImmutableList<FunctionType> allFunctions =
+        ImmutableList.of(
+            googBarMethod,
+            googBarParamFn,
+            googBarReturnFn,
+            googSubBarMethod,
+            googSubBarParamFn,
+            googSubBarReturnFn);
     for (int i = 0; i < allFunctions.size(); i++) {
       for (int j = 0; j < allFunctions.size(); j++) {
         FunctionType typeA = allFunctions.get(i);
@@ -3347,11 +3356,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(subclassCtor.getOwnPropertyJSDocInfo("prototype")).isNull();
   }
 
-  /**
-   * Tests operation of {@code isVoidable}.
-   *
-   * @throws Exception
-   */
+  /** Tests operation of {@code isVoidable}. */
   @Test
   public void testIsVoidable() {
     assertThat(VOID_TYPE.isVoidable()).isTrue();
@@ -4528,8 +4533,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testSymmetryOfTestForEquality() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         Tri aOnB = typeA.testForEquality(typeB);
@@ -4553,8 +4558,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getLeastSupertype is a symmetric relation. */
   @Test
   public void testSymmetryOfLeastSupertype() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         JSType aOnB = typeA.getLeastSupertype(typeB);
@@ -4589,8 +4594,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getGreatestSubtype is a symmetric relation. */
   @Test
   public void testSymmetryOfGreatestSubtype() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         JSType aOnB = typeA.getGreatestSubtype(typeB);
@@ -4618,7 +4623,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getLeastSupertype is a reflexive relation. */
   @Test
   public void testReflexivityOfLeastSupertype() {
-    List<JSType> list = getTypesToTestForSymmetry();
+    ImmutableList<JSType> list = getTypesToTestForSymmetry();
     for (JSType type : list) {
       assertTypeEquals("getLeastSupertype not reflexive",
           type, type.getLeastSupertype(type));
@@ -4628,7 +4633,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getGreatestSubtype is a reflexive relation. */
   @Test
   public void testReflexivityOfGreatestSubtype() {
-    List<JSType> list = getTypesToTestForSymmetry();
+    ImmutableList<JSType> list = getTypesToTestForSymmetry();
     for (JSType type : list) {
       assertTypeEquals("getGreatestSubtype not reflexive",
           type, type.getGreatestSubtype(type));
@@ -4888,18 +4893,19 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testNamedSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        googBar.getPrototype(),
-        googBar.getInstanceType(),
-        googSubBar.getPrototype(),
-        googSubBar.getInstanceType(),
-        googSubSubBar.getPrototype(),
-        googSubSubBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            googBar.getPrototype(),
+            googBar.getInstanceType(),
+            googSubBar.getPrototype(),
+            googSubBar.getInstanceType(),
+            googSubSubBar.getPrototype(),
+            googSubSubBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4926,16 +4932,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("c", NUMBER_TYPE, null);
     JSType abcType = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        aType,
-        abOrAcType,
-        abType,
-        abcType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            aType,
+            abOrAcType,
+            abType,
+            abcType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4945,12 +4952,13 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("date", DATE_TYPE, null);
     JSType hasDateProperty = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        hasDateProperty,
-        googBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            hasDateProperty,
+            googBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4960,89 +4968,84 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("date", UNKNOWN_TYPE, null);
     JSType hasUnknownDateProperty = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        hasUnknownDateProperty,
-        googBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            hasUnknownDateProperty,
+            googBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testNullableNamedTypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.ALL_TYPE)),
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)),
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.OBJECT_TYPE)),
-        registry.createOptionalNullableType(googBar.getPrototype()),
-        registry.createOptionalNullableType(googBar.getInstanceType()),
-        registry.createNullableType(googSubBar.getPrototype()),
-        registry.createNullableType(googSubBar.getInstanceType()),
-        googSubSubBar.getPrototype(),
-        googSubSubBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.ALL_TYPE)),
+            registry.createOptionalNullableType(
+                registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)),
+            registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.OBJECT_TYPE)),
+            registry.createOptionalNullableType(googBar.getPrototype()),
+            registry.createOptionalNullableType(googBar.getInstanceType()),
+            registry.createNullableType(googSubBar.getPrototype()),
+            registry.createNullableType(googSubBar.getInstanceType()),
+            googSubSubBar.getPrototype(),
+            googSubSubBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testEnumTypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        enumType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            enumType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testFunctionSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE),
-        dateMethod,
-        registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE),
+            dateMethod,
+            registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testFunctionUnionSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        createUnionType(
-            OBJECT_TYPE,
-            STRING_TYPE),
-        createUnionType(
-            GREATEST_FUNCTION_TYPE,
-            googBarInst,
-            STRING_TYPE),
-        createUnionType(
-            STRING_TYPE,
-            registry.createFunctionType(
-                createUnionType(STRING_TYPE, NUMBER_TYPE)),
-            googBarInst),
-        createUnionType(
-            registry.createFunctionType(NUMBER_TYPE),
-            googSubBarInst),
-        LEAST_FUNCTION_TYPE,
-        NO_OBJECT_TYPE,
-        NO_TYPE);
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            createUnionType(OBJECT_TYPE, STRING_TYPE),
+            createUnionType(GREATEST_FUNCTION_TYPE, googBarInst, STRING_TYPE),
+            createUnionType(
+                STRING_TYPE,
+                registry.createFunctionType(createUnionType(STRING_TYPE, NUMBER_TYPE)),
+                googBarInst),
+            createUnionType(registry.createFunctionType(NUMBER_TYPE), googSubBarInst),
+            LEAST_FUNCTION_TYPE,
+            NO_OBJECT_TYPE,
+            NO_TYPE);
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testConstructorSubtypeChain() throws Exception {
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.ALL_TYPE),
             registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
@@ -5056,7 +5059,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testGoogBarSubtypeChain() throws Exception {
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.FUNCTION_TYPE),
             googBar,
@@ -5090,7 +5093,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
                     null,
                     /* isAbstract= */ false));
 
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.FUNCTION_TYPE),
             googBarArgConstructor,
@@ -5101,16 +5104,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testInterfaceInstanceSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        OBJECT_TYPE,
-        interfaceInstType,
-        googBar.getPrototype(),
-        googBarInst,
-        googSubBar.getPrototype(),
-        googSubBarInst,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            OBJECT_TYPE,
+            interfaceInstType,
+            googBar.getPrototype(),
+            googBarInst,
+            googSubBar.getPrototype(),
+            googSubBarInst,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5128,27 +5132,29 @@ public class JSTypeTest extends BaseJSTypeTestCase {
                     /* isAbstract= */ false));
     tempType.setImplementedInterfaces(
         Lists.<ObjectType>newArrayList(subInterfaceInstType));
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        OBJECT_TYPE,
-        interfaceInstType,
-        subInterfaceInstType,
-        tempType.getPrototype(),
-        tempType.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            OBJECT_TYPE,
+            interfaceInstType,
+            subInterfaceInstType,
+            tempType.getPrototype(),
+            tempType.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testAnonymousObjectChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        createNullableType(OBJECT_TYPE),
-        OBJECT_TYPE,
-        registry.createAnonymousObjectType(null),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            createNullableType(OBJECT_TYPE),
+            OBJECT_TYPE,
+            registry.createAnonymousObjectType(null),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5160,13 +5166,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
             .setElementType(registry.createAnonymousObjectType(null))
             .build()
             .getElementsType();
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        createNullableType(OBJECT_TYPE),
-        OBJECT_TYPE,
-        enumElemType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            createNullableType(OBJECT_TYPE),
+            OBJECT_TYPE,
+            enumElemType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5181,15 +5188,16 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType arrayOfAllType = createTemplatizedType(
         ARRAY_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        arrayOfAllType,
-        arrayOfStringOrNumber,
-        arrayOfString,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            arrayOfAllType,
+            arrayOfStringOrNumber,
+            arrayOfString,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5206,16 +5214,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType arrayOfAllType = createTemplatizedType(
         ARRAY_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        arrayOfAllType,
-        arrayOfObject,
-        arrayOfArray,
-        arrayOfNoObjectType,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            arrayOfAllType,
+            arrayOfObject,
+            arrayOfArray,
+            arrayOfNoObjectType,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5230,15 +5239,16 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType objectOfAllType = createTemplatizedType(
         OBJECT_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        objectOfAllType,
-        objectOfStringOrNumber,
-        objectOfString,
-        objectOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            objectOfAllType,
+            objectOfStringOrNumber,
+            objectOfString,
+            objectOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5255,16 +5265,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType objectOfAllType = createTemplatizedType(
         OBJECT_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        objectOfAllType,
-        objectOfStringOrNumber,
-        objectOfString,
-        arrayOfString,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            objectOfAllType,
+            objectOfStringOrNumber,
+            objectOfString,
+            arrayOfString,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5394,11 +5405,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6220,11 +6231,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE, STRING_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6259,11 +6270,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6280,6 +6291,57 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testTemplatizedTypeWithSubclass() {
+    TemplateType parentKeyA = registry.createTemplateType("A");
+    TemplateType childKeyA = registry.createTemplateType("A");
+    TemplateType childKeyB = registry.createTemplateType("B");
+
+    FunctionType templatizedCtor =
+        withOpenRegistry(
+            () -> {
+              FunctionType parent =
+                  FunctionType.builder(registry)
+                      .withName("ParentType")
+                      .forConstructor()
+                      .withTemplateKeys(ImmutableList.of(parentKeyA))
+                      .build();
+              ObjectType baseType =
+                  registry.createTemplatizedType(
+                      parent.getInstanceType(), ImmutableList.of(NULL_TYPE));
+              // create a subclass that `@extends {ParentType<null>}`
+              // and has a template key with the same name 'A' as the parent.
+              FunctionType child =
+                  FunctionType.builder(registry)
+                      .withPrototypeBasedOn(baseType)
+                      .withName("TestingType")
+                      .forConstructor()
+                      .withTemplateKeys(ImmutableList.of(childKeyA, childKeyB))
+                      .build();
+              child.getInstanceType().mergeSupertypeTemplateTypes(baseType);
+              return child;
+            });
+
+    JSType templatizedInstance =
+        registry.createTemplatizedType(
+            templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE));
+
+    TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();
+
+    assertThat(templateTypeMap.getLastTemplateTypeKeyByName("A")).isEqualTo(childKeyA);
+    assertThat(templateTypeMap.getLastTemplateTypeKeyByName("B")).isEqualTo(childKeyB);
+
+    assertThat(templateTypeMap.hasTemplateKey(parentKeyA)).isTrue();
+    assertThat(templateTypeMap.hasTemplateKey(childKeyA)).isTrue();
+    assertThat(templateTypeMap.hasTemplateKey(childKeyB)).isTrue();
+
+    assertThat(templateTypeMap.getResolvedTemplateType(parentKeyA)).isEqualTo(NULL_TYPE);
+    assertThat(templateTypeMap.getResolvedTemplateType(childKeyA)).isEqualTo(NUMBER_TYPE);
+    assertThat(templateTypeMap.getResolvedTemplateType(childKeyB)).isEqualTo(STRING_TYPE);
+
+    assertThat(templatizedInstance.toString()).isEqualTo("TestingType<number,string>");
+  }
+
+  @Test
   public void testTemplateTypeValidator() {
     // The template type setValidator() will see the TemplateType, not the referenced unknown type
     // like other ProxyObjectTypes do.
diff --git a/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java b/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
index 1a2a71c..5e6e306 100644
--- a/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
+++ b/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
@@ -40,6 +40,7 @@ package com.google.javascript.rhino.jstype;
 
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.TemplateTypeMapSubject.assertThat;
+import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -241,6 +242,18 @@ public final class TemplateTypeMapTest extends BaseJSTypeTestCase {
     assertThat(result).isSameInstanceAs(existing);
   }
 
+  @Test
+  public void testGetLastTemplateTypeKeyByName_returnsLastKeyIfDuplicates() {
+    TemplateType key1 = key("A");
+    TemplateType key2 = key("A");
+
+    TemplateTypeMap map = createMap(ImmutableList.of(key1, key2), ImmutableList.of(NUMBER_TYPE));
+
+    TemplateType result = map.getLastTemplateTypeKeyByName("A");
+
+    assertType(result).isSameInstanceAs(key2);
+  }
+
   private TemplateTypeMap createMap(
       ImmutableList<TemplateType> keys, ImmutableList<JSType> values) {
     return emptyMap.copyWithExtension(keys, values);

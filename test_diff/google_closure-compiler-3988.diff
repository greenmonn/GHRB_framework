diff --git a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
index c9f4b2b..27d9878 100644
--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java
@@ -47,7 +47,7 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
 
   @Override
   protected Format getSourceMapFormat() {
-    return SourceMap.Format.V3;
+    return Format.V3;
   }
 
   private static String getEncodedFileName() {
@@ -409,10 +409,11 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
   public void testWriteMetaMap() throws IOException {
     StringWriter out = new StringWriter();
     String name = "./app.js";
-    List<SourceMapSection> appSections = ImmutableList.of(
-        SourceMapSection.forURL("src1", 0, 0),
-        SourceMapSection.forURL("src2", 100, 10),
-        SourceMapSection.forURL("src3", 150, 5));
+    ImmutableList<SourceMapSection> appSections =
+        ImmutableList.of(
+            SourceMapSection.forURL("src1", 0, 0),
+            SourceMapSection.forURL("src2", 100, 10),
+            SourceMapSection.forURL("src3", 150, 5));
 
     SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();
     generator.appendIndexMapTo(out, name, appSections);
@@ -458,10 +459,11 @@ public final class SourceMapGeneratorV3Test extends SourceMapTestCase {
   public void testWriteMetaMap2() throws IOException {
     StringWriter out = new StringWriter();
     String name = "./app.js";
-    List<SourceMapSection> appSections = ImmutableList.of(
-        // Map and URLs can be mixed.
-        SourceMapSection.forMap(getEmptyMapFor("./part.js"), 0, 0),
-        SourceMapSection.forURL("src2", 100, 10));
+    ImmutableList<SourceMapSection> appSections =
+        ImmutableList.of(
+            // Map and URLs can be mixed.
+            SourceMapSection.forMap(getEmptyMapFor("./part.js"), 0, 0),
+            SourceMapSection.forURL("src2", 100, 10));
 
     SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();
     generator.appendIndexMapTo(out, name, appSections);
diff --git a/test/com/google/debugging/sourcemap/SourceMapTestCase.java b/test/com/google/debugging/sourcemap/SourceMapTestCase.java
index de8465a..b464a9c 100644
--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java
+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java
@@ -35,7 +35,6 @@ import com.google.javascript.jscomp.SourceMap.DetailLevel;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import org.junit.Before;
@@ -57,7 +56,7 @@ public abstract class SourceMapTestCase {
   static final ImmutableList<SourceFile> EXTERNS =
       ImmutableList.of(SourceFile.fromCode("externs", ""));
 
-  protected DetailLevel detailLevel = SourceMap.DetailLevel.ALL;
+  protected DetailLevel detailLevel = DetailLevel.ALL;
   protected boolean sourceMapIncludeSourcesContent = false;
 
   private static final Joiner LINE_JOINER = Joiner.on('\n');
@@ -85,7 +84,7 @@ public abstract class SourceMapTestCase {
 
   @Before
   public void setUp() {
-    detailLevel = SourceMap.DetailLevel.ALL;
+    detailLevel = DetailLevel.ALL;
   }
 
   /**
@@ -290,7 +289,7 @@ public abstract class SourceMapTestCase {
 
     options.setChecksOnly(true);
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(fileName1, js1));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode(fileName1, js1));
 
     if (js2 != null && fileName2 != null) {
       inputs =
diff --git a/test/com/google/javascript/jscomp/AstAnalyzerTest.java b/test/com/google/javascript/jscomp/AstAnalyzerTest.java
index 7b7e0ec..061b5ae 100644
--- a/test/com/google/javascript/jscomp/AstAnalyzerTest.java
+++ b/test/com/google/javascript/jscomp/AstAnalyzerTest.java
@@ -89,6 +89,7 @@ import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import java.util.ArrayDeque;
 import java.util.Optional;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
@@ -151,7 +152,7 @@ public final class AstAnalyzerTest {
 
   /** Provides methods for parsing and accessing the compiler used for the parsing. */
   private static final class ParseHelper {
-    private Compiler compiler = null;
+    private @Nullable Compiler compiler = null;
 
     private void resetCompiler() {
       CompilerOptions options = new CompilerOptions();
@@ -231,7 +232,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           kase().js("i++").token(INC).expect(true),
           kase().js("[b, [a, i++]]").token(ARRAYLIT).expect(true),
@@ -358,7 +359,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           // Cases in need of differentiation.
           kase().expect(false).js("[1]"),
@@ -683,7 +684,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static Iterable<AnalysisCase> cases() {
+    public static ImmutableList<AnalysisCase> cases() {
       return ImmutableList.of(
           kase().js("x = y").token(ASSIGN).expect(true),
           kase().js("x += y").token(ASSIGN_ADD).expect(true),
@@ -962,7 +963,7 @@ public final class AstAnalyzerTest {
 
     // Always include the index. If two cases have the same name, only one will be executed.
     @Parameters(name = "#{index} {0}")
-    public static final Iterable<Object[]> cases() {
+    public static final ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             {"Array"}, {"Date"}, {"Error"}, {"Object"}, {"RegExp"}, {"XMLHttpRequest"}
diff --git a/test/com/google/javascript/jscomp/AstValidatorTest.java b/test/com/google/javascript/jscomp/AstValidatorTest.java
index 45fa6bc..1fe704b 100644
--- a/test/com/google/javascript/jscomp/AstValidatorTest.java
+++ b/test/com/google/javascript/jscomp/AstValidatorTest.java
@@ -53,8 +53,7 @@ import org.junit.runners.JUnit4;
 public final class AstValidatorTest extends CompilerTestCase {
 
   private List<String> lastCheckViolationMessages;
-  private AstValidator.TypeInfoValidation typeInfoValidationMode =
-      AstValidator.TypeInfoValidation.JSTYPE;
+  private TypeInfoValidation typeInfoValidationMode = TypeInfoValidation.JSTYPE;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
@@ -96,7 +95,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testParenthesizedProperty() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.string("a");
     n.setIsParenthesized(true);
@@ -308,7 +307,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testClassStaticBlock_this() {
     // TODO (user): re-enable TypeInfoValidation and TypeCheck
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     disableTypeCheck();
     valid(
         lines(
@@ -323,7 +322,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testClassStaticBlock_superProperty() {
     // TODO (user): re-enable TypeInfoValidation and TypeCheck
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     disableTypeCheck();
     valid(
         lines(
@@ -341,7 +340,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testClassStaticBlock_invalidSuperConstructorCall() {
     // TODO (user): re-enable TypeInfoValidation and TypeCheck
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     disableTypeCheck();
     invalid(
         lines(
@@ -385,7 +384,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("for(a in {});");
 
     // Test that initializers are banned (except for simple vars - see testQuestionableForIn)
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_IN, IR.constNode(IR.name("a"), IR.number(1)), IR.name("b")),
         Check.STATEMENT);
@@ -409,7 +408,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("for (const {} of b);");
 
     // Test that initializers are banned
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_OF, IR.var(IR.name("a"), IR.number(1)), IR.name("b")), Check.STATEMENT);
     expectInvalid(
@@ -434,7 +433,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("async () => { for await(a of /** @type {!Iterable<?>} */ ({})); }");
 
     // Test that initializers are banned
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(
         new Node(Token.FOR_AWAIT_OF, IR.var(IR.name("a"), IR.number(1)), IR.name("b")),
         Check.STATEMENT);
@@ -459,7 +458,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("a['b']++");
     valid("/** @type {number} */ (x)++;");
 
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(new Node(Token.INC, IR.name("x"), IR.name("x")), Check.EXPRESSION);
     expectInvalid(new Node(Token.INC, IR.arrayPattern()), Check.EXPRESSION);
     expectInvalid(new Node(Token.INC, IR.objectPattern()), Check.EXPRESSION);
@@ -472,7 +471,7 @@ public final class AstValidatorTest extends CompilerTestCase {
     valid("const a = {b: 0}; a.b += 1;");
     valid("const a = {b: '0'}; /** @type {?} */ (a.b) += 1;");
 
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     expectInvalid(new Node(Token.ASSIGN_ADD, IR.arrayPattern(), IR.number(0)), Check.EXPRESSION);
     expectInvalid(new Node(Token.ASSIGN_ADD, IR.objectPattern(), IR.number(0)), Check.EXPRESSION);
   }
@@ -492,7 +491,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidScript() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.SCRIPT);
     expectInvalid(n, Check.SCRIPT);
@@ -506,7 +505,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidStatement1() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.RETURN);
     setTestSourceLocationForTree(n);
@@ -518,7 +517,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidExpression1() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.ARRAYLIT, new Node(Token.EMPTY));
     setTestSourceLocationForTree(n);
@@ -530,7 +529,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidExpression2() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.NOT, new Node(Token.TRUE));
     setTestSourceLocationForTree(n);
@@ -567,7 +566,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidConstLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.constNode(IR.name("x"), IR.number(3));
     setTestSourceLocationForTree(n);
@@ -582,7 +581,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidLetLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.let(IR.name("x"), IR.number(3));
     setTestSourceLocationForTree(n);
@@ -597,7 +596,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testNewTargetIsValidExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.NEW_TARGET);
     setTestSourceLocationForTree(n);
@@ -607,7 +606,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testImportMetaIsValidExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = new Node(Token.IMPORT_META);
     setTestSourceLocationForTree(n);
@@ -617,7 +616,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testCastOnLeftSideOfAssign() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     JSDocInfo.Builder jsdoc = JSDocInfo.builder();
     jsdoc.recordType(new JSTypeExpression(IR.string("number"), "<AstValidatorTest>"));
@@ -639,7 +638,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidNumberStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.number(1);
     setTestSourceLocationForTree(n);
@@ -652,7 +651,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidBigIntStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.bigint(BigInteger.ONE);
     setTestSourceLocationForTree(n);
@@ -678,7 +677,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testAwaitExpression() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node awaitNode = new Node(Token.AWAIT);
@@ -694,7 +693,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   public void testNoAwaitExpressionInDefaultParams() {
     // We're inserting our own Nodes below, and we won't be bothering to put valid type
     // information on them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     Node scriptNode =
         parseValidScript(
             lines(
@@ -722,7 +721,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   public void testNoYieldExpressionInDefaultParams() {
     // We're inserting our own Nodes below, and we won't be bothering to put valid type
     // information on them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     Node scriptNode =
         parseValidScript(
             lines(
@@ -770,7 +769,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testAwaitExpressionNoFunction() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node n = new Node(Token.AWAIT);
@@ -781,7 +780,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testYieldExpressionNoFunction() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setLanguage(LanguageMode.ECMASCRIPT_NEXT, LanguageMode.ECMASCRIPT5);
     Node n = new Node(Token.YIELD);
@@ -792,7 +791,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidArrayPattern0() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -885,7 +884,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidObjectRestForLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.assign(IR.objectPattern(IR.objectRest(IR.name("x"))), IR.objectlit());
     setTestSourceLocationForTree(n);
@@ -900,7 +899,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidArrayRestForLanguageLevel() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node n = IR.assign(IR.arrayPattern(IR.iterRest(IR.name("x"))), IR.arraylit());
     setTestSourceLocationForTree(n);
@@ -915,7 +914,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidDestructuringDeclaration() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -943,7 +942,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testInvalidDestructuringAssignment() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -978,7 +977,7 @@ public final class AstValidatorTest extends CompilerTestCase {
             ""));
 
     // Since we're modifying the AST by hand below, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node c = new Node(Token.CLASS, IR.name("C"), IR.empty());
     Node members = new Node(Token.CLASS_MEMBERS);
@@ -1233,7 +1232,7 @@ public final class AstValidatorTest extends CompilerTestCase {
 
     // Since we're modifying the AST by hand below, there won't be types on some nodes that need
     // them.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     Node c = new Node(Token.CLASS, IR.name("C"), IR.empty());
     Node members = new Node(Token.CLASS_MEMBERS);
@@ -1456,7 +1455,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testFeatureValidation_logicalAssignmentOp() {
     // TODO (user): re-enable TypeInfoValidation and TypeCheck
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
     disableTypeCheck();
     testFeatureValidation("x ||= y", Feature.LOGICAL_ASSIGNMENT);
     testFeatureValidation("x &&= y", Feature.LOGICAL_ASSIGNMENT);
@@ -1501,7 +1500,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testValidFeatureInScript() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     setAcceptedLanguage(LanguageMode.ECMASCRIPT_2015);
 
@@ -1566,7 +1565,7 @@ public final class AstValidatorTest extends CompilerTestCase {
   @Test
   public void testSwitchStatement() {
     // Since we're building the AST by hand, there won't be any types on it.
-    typeInfoValidationMode = AstValidator.TypeInfoValidation.NONE;
+    typeInfoValidationMode = TypeInfoValidation.NONE;
 
     String switchStatement =
         lines(
diff --git a/test/com/google/javascript/jscomp/ChangeVerifierTest.java b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
index 87502f4..86e312e 100644
--- a/test/com/google/javascript/jscomp/ChangeVerifierTest.java
+++ b/test/com/google/javascript/jscomp/ChangeVerifierTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,7 +47,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class ChangeVerifierTest {
-  private Compiler compiler;
+  private @Nullable Compiler compiler;
 
   @Before
   public void setup() {
diff --git a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
index b7d47f2..a7fe75e 100644
--- a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
+++ b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java
@@ -267,6 +267,41 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testNoWarningOnClassField_deprecated1() {
+    // TODO(b/239747805): Should throw deprecatedProp warning
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /**",
+                "   * @type {number}",
+                "   * @deprecated No.",
+                "   */",
+                "  static x=1;",
+                "}",
+                "Foo.x;")));
+  }
+
+  @Test
+  public void testNoWarningOnClassField_deprecated2() {
+    // TODO(b/239747805): Should say "Property x of type number" not "super"
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /**",
+                "   * @type {number}",
+                "   * @deprecated No.",
+                "   */",
+                "  static x = 1;",
+                "}",
+                "class Bar extends Foo {",
+                "  static y = super.x;",
+                "}")),
+        deprecatedProp("Property x of type super has been deprecated: No."));
+  }
+
+  @Test
   public void testNoWarningInDeprecatedClass() {
     test(
         srcs(
@@ -339,6 +374,81 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testWarningInClassStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "/** @deprecated Oh No! */",
+                "function f() {}",
+                "",
+                "class Foo {",
+                "  static { f(); }",
+                "}")),
+        deprecatedName("Variable f has been deprecated: Oh No!"));
+  }
+
+  @Test
+  public void testWarningInClassStaticBlock1() {
+    test(
+        srcs(
+            lines(
+                "/** @deprecated Woah! */", //
+                "var x;",
+                "",
+                "class Foo {",
+                "  static { x; }",
+                "}")),
+        deprecatedName("Variable x has been deprecated: Woah!"));
+  }
+
+  @Test
+  public void testWarningInClassStaticBlock2() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "  /** @deprecated Bad :D */",
+                "   static x = 1;",
+                "   static {",
+                "      var y = this.x;",
+                "   }",
+                "}")),
+        deprecatedProp("Property x of type this has been deprecated: Bad :D"));
+  }
+
+  @Test
+  public void testNoWarningInClassStaticBlock() {
+    // TODO(b/235871861): Compiler should throw warning as it doesn't make sense to deprecate a
+    // static block
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @deprecated D: */",
+                "  static {",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoWarningInClassStaticBlock1() {
+    // TODO(b/239747805): Should say "Property x of type number" not "super"
+    test(
+        srcs(
+            lines(
+                "class A {",
+                "  /** @deprecated Meow! */",
+                "  static x = 1;",
+                "}",
+                "class B extends A {",
+                "  static {",
+                "    this.y = super.x;",
+                "  }",
+                "}")),
+        deprecatedProp("Property x of type super has been deprecated: Meow!"));
+  }
+
+  @Test
   public void testWarningForSubclassMethod() {
     test(
         srcs(
@@ -948,6 +1058,38 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testPrivateAccessForStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @private */",
+                "  static bar = 2",
+                "  static {",
+                "    this.bar = 4;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoPrivateAccessForStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @private */",
+                "  static bar = 2;",
+                "}"),
+            lines(
+                "class Bar extends Foo{", //
+                "  static {",
+                "    this.bar = 4;",
+                "  }",
+                "}")),
+        error(BAD_PRIVATE_PROPERTY_ACCESS));
+  }
+
+  @Test
   public void testProtectedAccessForProperties1() {
     test(
         srcs(
@@ -1719,6 +1861,87 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testProtectedAccessForStaticBlocks() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStaticBlocks_sameFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}",
+                "class SubFoo extends Foo {",
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStaticBlocks_sameFile1() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}",
+                "class Bar {",
+                "  static {",
+                "    Foo.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testProtectedAccessForStatic_differentFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}"),
+            lines(
+                "class SubFoo extends Foo {", //
+                "  static {",
+                "    this.bar;",
+                "  }",
+                "}")));
+  }
+
+  @Test
+  public void testNoProtectedAccessForStaticBlocks_differentFile() {
+    test(
+        srcs(
+            lines(
+                "class Foo {", //
+                "  /** @protected */",
+                "  static bar",
+                "}"),
+            lines(
+                "class Bar {", //
+                "  static {",
+                "    Foo.bar;",
+                "  }",
+                "}")),
+        error(BAD_PROTECTED_PROPERTY_ACCESS));
+  }
+
+  @Test
   public void testPackagePrivateAccessForProperties1() {
     test(
         srcs(
@@ -3356,6 +3579,21 @@ public final class CheckAccessControlsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testConstantPropertyReassignmentInClassStaticBlock() {
+    test(
+        srcs(
+            lines(
+                "class Foo {",
+                "/** @const */",
+                "  static x = 2;",
+                "  static {",
+                "    this.x = 3;",
+                "  }",
+                "}")),
+        error(CONST_PROPERTY_REASSIGNED_VALUE));
+  }
+
+  @Test
   public void testFinalClassCannotBeSubclassed() {
     test(
         srcs(
diff --git a/test/com/google/javascript/jscomp/CheckConformanceTest.java b/test/com/google/javascript/jscomp/CheckConformanceTest.java
index df07afa..a236415 100644
--- a/test/com/google/javascript/jscomp/CheckConformanceTest.java
+++ b/test/com/google/javascript/jscomp/CheckConformanceTest.java
@@ -3285,6 +3285,18 @@ public final class CheckConformanceTest extends CompilerTestCase {
 
     testWarning(
         externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS(null, 'SRc', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSetAttribute Message");
+
+    testWarning(
+        externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS('ns', 'data-random', 'xxx')"),
+        CheckConformance.CONFORMANCE_VIOLATION,
+        "Violation: BanSetAttribute Message");
+
+    testWarning(
+        externs(externs),
         srcs("var attr = 'unknown'; (new HTMLScriptElement).setAttributeNS(null, attr, 'xxx')"),
         CheckConformance.CONFORMANCE_VIOLATION,
         "Violation: BanSetAttribute Message");
@@ -3292,6 +3304,10 @@ public final class CheckConformanceTest extends CompilerTestCase {
     testNoWarning(
         externs(externs), srcs("(new HTMLScriptElement).setAttribute('data-random', 'xxx')"));
 
+    testNoWarning(
+        externs(externs),
+        srcs("(new HTMLScriptElement).setAttributeNS(null, 'data-random', 'xxx')"));
+
     testWarning(
         externs(externs),
         srcs("(new HTMLScriptElement)['SRc'] = 'xxx';"),
diff --git a/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java b/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
index 6631bc6..ca70392 100644
--- a/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
+++ b/test/com/google/javascript/jscomp/CheckDebuggerStatementTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,7 +28,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class CheckDebuggerStatementTest extends CompilerTestCase {
 
-  private CheckLevel checkLevel;
+  private @Nullable CheckLevel checkLevel;
 
   @Override
   @After
diff --git a/test/com/google/javascript/jscomp/CheckRegExpTest.java b/test/com/google/javascript/jscomp/CheckRegExpTest.java
index 6dc7171..3aae955 100644
--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java
+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java
@@ -18,6 +18,7 @@ package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -26,7 +27,7 @@ import org.junit.runners.JUnit4;
 /** @author johnlenz@google.com (John Lenz) */
 @RunWith(JUnit4.class)
 public final class CheckRegExpTest extends CompilerTestCase {
-  CheckRegExp last = null;
+  @Nullable CheckRegExp last = null;
   boolean reportErrors;
 
   public CheckRegExpTest() {
diff --git a/test/com/google/javascript/jscomp/CheckSuperTest.java b/test/com/google/javascript/jscomp/CheckSuperTest.java
index f36bf54..d7762e5 100644
--- a/test/com/google/javascript/jscomp/CheckSuperTest.java
+++ b/test/com/google/javascript/jscomp/CheckSuperTest.java
@@ -108,6 +108,14 @@ public final class CheckSuperTest extends CompilerTestCase {
         error(THIS_BEFORE_SUPER));
   }
 
+  @Test
+  public void testThisAndSuperPropAccessBeforeSuperCall_inSuperConstructorArgs() {
+    test(
+        srcs("class C extends D { constructor() { super(this.foo(), super.foo()); } }"),
+        error(SUPER_ACCESS_BEFORE_SUPER_CONSTRUCTOR),
+        error(THIS_BEFORE_SUPER));
+  }
+
   // We could require that the super() call is the first statement in the constructor, except that
   // doing so breaks J2CL-compiled code, which needs to do the static initialization for the class
   // before anything else.
diff --git a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
index 54247dd..f7a529f 100644
--- a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java
@@ -26,6 +26,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Outcome;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSType;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -98,8 +99,8 @@ public final class ClosureReverseAbstractInterpreterTest extends CompilerTypeTes
         getNativeCheckedUnknownType());
   }
 
-  private void testClosureFunction(String function, JSType type,
-      JSType trueType, JSType falseType) {
+  private void testClosureFunction(
+      String function, @Nullable JSType type, JSType trueType, @Nullable JSType falseType) {
     // function(a) where a : type
     Node n = compiler.parseTestCode("var a; " + function + "(a)");
     Node call = n.getLastChild().getLastChild();
diff --git a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
index 8e23111..806faf8 100644
--- a/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
+++ b/test/com/google/javascript/jscomp/ClosureRewriteModuleTest.java
@@ -1754,6 +1754,52 @@ public final class ClosureRewriteModuleTest extends CompilerTestCase {
   }
 
   @Test
+  public void testExport_initializedWithVar() {
+    test(
+        // TODO(lharker): should `var exports = ...` be banned?
+        lines(
+            "goog.module('ns.a');", //
+            "/** @suppress {checkTypes} */",
+            // this statement causes a "type mismatch" error
+            "var exports = {};"),
+        lines(
+            "/** @const */ var module$exports$ns$a = {};",
+            "/** @suppress {checkTypes} */",
+            "var module$contents$ns$a_exports = {};"));
+  }
+
+  @Test
+  public void testExport_dontMangleLocalVariableNamedExports() {
+    test(
+        lines(
+            "goog.module('ns.a');",
+            "",
+            "function f(exports, a) {",
+            // test the various syntactic froms of doing goog.module exports
+            "  exports.prop = 0;",
+            "  exports = {a};",
+            "  exports = function() {};",
+            "  if (true) {",
+            "    const exports = {};",
+            "  }",
+            "  return exports;",
+            "}"),
+        lines(
+            "/** @const */",
+            "var module$exports$ns$a = {};",
+            "",
+            "function module$contents$ns$a_f(exports, a) {",
+            "  exports.prop = 0;",
+            "  exports = {a};",
+            "  exports = function() {};",
+            "  if (true) {",
+            "    const exports = {};",
+            "  }",
+            "  return exports;",
+            "}"));
+  }
+
+  @Test
   public void testExportEnhancedObjectLiteral() {
     test(
         lines("goog.module('ns.a');", "class Something {}", "exports = { Something };"),
diff --git a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
index dda5fa1..3f772d6 100644
--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java
@@ -373,7 +373,6 @@ public final class CoalesceVariableNamesTest extends CompilerTestCase {
 
   @Test
   public void testCoalesceVarinStaticBlock() {
-    // TODO(b/235871861): Wrong replacement of var names.
     test(
         lines(
             "function foo() {",
@@ -388,15 +387,14 @@ public final class CoalesceVariableNamesTest extends CompilerTestCase {
         lines(
             "function foo() {",
             "   var x = 0;",
-            "   x = 2;",
-            "   x = class{",
+            "   var y = 2;",
+            "   y = class{",
             "     static{",
             "      print(x);",
             "     }",
             "   }",
             "}"));
 
-    // test var replacment for inner functions as comparison for class static blocks
     test(
         lines(
             "function foo() {",
diff --git a/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java b/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
index 84b3a9d..801da0e 100644
--- a/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterEs6TypedTest.java
@@ -21,8 +21,6 @@ import static com.google.javascript.rhino.TypeDeclarationsIR.namedType;
 import static com.google.javascript.rhino.TypeDeclarationsIR.parameterizedType;
 
 import com.google.common.collect.ImmutableList;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet.Feature;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -50,8 +48,7 @@ public final class CodePrinterEs6TypedTest extends CodePrinterTestBase {
                         options.setPrettyPrint(true);
                         options.setPreferLineBreakAtEndOfFile(false);
                         options.setPreferSingleQuotes(true);
-                        options.setOutputFeatureSet(
-                            FeatureSet.ES_NEXT.with(Feature.TYPE_ANNOTATION));
+                        options.setGentsMode(true);
                       }
                     }))
             .build();
diff --git a/test/com/google/javascript/jscomp/CodePrinterTest.java b/test/com/google/javascript/jscomp/CodePrinterTest.java
index 3a707e8..9fa54d3 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTest.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java
@@ -1973,7 +1973,7 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "  // first",
             "  f1();",
             "}",
-            " // second"));
+            " // second\n"));
   }
 
   @Test
@@ -1991,8 +1991,8 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "function f1() {\n}", //
             "if (true) {",
             "  // first",
-            "  f1();",
-            "   /* second */",
+            "  f1(); ",
+            "  /* second */",
             "}\n"));
   }
 
@@ -2013,8 +2013,8 @@ public final class CodePrinterTest extends CodePrinterTestBase {
             "function f1() {\n}", //
             "if (true) {",
             "  // first",
-            "  f1();",
-            "   // second",
+            "  f1(); ",
+            "  // second",
             "  /* third */",
             "  // fourth",
             "}\n"));
@@ -3215,6 +3215,8 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("function*f(){yield(a=0)}");
     assertPrintSame("function*f(){a=yield 0}");
     assertPrintSame("function*f(){(yield 1)+(yield 1)}");
+    // Parens required for evaluating arrow function expression i.e. `yield (() => expr)`
+    assertPrintSame("function*f(){yield(()=>({}))}");
   }
 
   @Test
@@ -3336,6 +3338,20 @@ public final class CodePrinterTest extends CodePrinterTestBase {
     assertPrintSame("pwait=async promise=>await promise");
   }
 
+  /** Regression test for b/235871063 - necessary parens dropped around awaited arrow function. */
+  @Test
+  public void testParansAroudAwaitArrowFunction() {
+    // Parens required for evaluating arrow function expression i.e. `await (() => expr)`
+    assertPrint(
+        "async function f(){return await (()=>new Promise((resolve)=>setTimeout(resolve,0)));}",
+        "async function f(){return await (()=>new Promise(resolve=>setTimeout(resolve,0)))}");
+    System.out.println("--------------");
+    // Parens not required for evaluating new
+    assertPrint(
+        "async function f(){return await new Promise((resolve)=>setTimeout(resolve,0));}",
+        "async function f(){return await new Promise(resolve=>setTimeout(resolve,0))}");
+  }
+
   /**
    * Regression test for b/28633247 - necessary parens dropped around arrow functions.
    *
diff --git a/test/com/google/javascript/jscomp/CodePrinterTestBase.java b/test/com/google/javascript/jscomp/CodePrinterTestBase.java
index fe3ed27..c162321 100644
--- a/test/com/google/javascript/jscomp/CodePrinterTestBase.java
+++ b/test/com/google/javascript/jscomp/CodePrinterTestBase.java
@@ -24,6 +24,7 @@ import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.parsing.Config;
 import com.google.javascript.rhino.Node;
 import java.nio.charset.Charset;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /** Base class for tests that exercise {@link CodePrinter}. */
@@ -35,8 +36,8 @@ public abstract class CodePrinterTestBase {
   protected boolean preserveTypeAnnotations = false;
   protected boolean preserveNonJSDocComments = false;
   protected LanguageMode languageMode = LanguageMode.ECMASCRIPT5;
-  protected Compiler lastCompiler = null;
-  protected Charset outputCharset = null;
+  protected @Nullable Compiler lastCompiler = null;
+  protected @Nullable Charset outputCharset = null;
 
   @Before
   public void setUp() throws Exception {
diff --git a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
index 90e40f3..605cf7d 100644
--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java
@@ -30,6 +30,7 @@ import com.google.common.base.Joiner;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.io.Files;
@@ -60,6 +61,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -74,16 +76,16 @@ public final class CommandLineRunnerTest {
   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
   private static final Joiner LINE_JOINER = Joiner.on('\n');
 
-  private Compiler lastCompiler = null;
-  private CommandLineRunner lastCommandLineRunner = null;
-  private List<Integer> exitCodes = null;
-  private ByteArrayOutputStream outReader = null;
-  private ByteArrayOutputStream errReader = null;
+  private @Nullable Compiler lastCompiler = null;
+  private @Nullable CommandLineRunner lastCommandLineRunner = null;
+  private @Nullable List<Integer> exitCodes = null;
+  private @Nullable ByteArrayOutputStream outReader = null;
+  private @Nullable ByteArrayOutputStream errReader = null;
   private Map<Integer, String> filenames;
 
   // If set, this will be appended to the end of the args list.
   // For testing args parsing.
-  private String lastArg = null;
+  private @Nullable String lastArg = null;
 
   // If set to true, uses comparison by string instead of by AST.
   private boolean useStringComparison = false;
@@ -140,7 +142,7 @@ public final class CommandLineRunnerTest {
                       "/** @param {...*} x */ function alert(x) {}",
                       "function Symbol() {}")));
 
-  private List<SourceFile> externs;
+  private ImmutableList<SourceFile> externs;
 
   @Before
   public void setUp() throws Exception {
@@ -1711,7 +1713,7 @@ public final class CommandLineRunnerTest {
     args.add("--source_map_input=input2|input2.sourcemap");
     testSame("var x = 3;");
 
-    Map<String, SourceMapInput> inputMaps = lastCompiler.getOptions().inputSourceMaps;
+    ImmutableMap<String, SourceMapInput> inputMaps = lastCompiler.getOptions().inputSourceMaps;
     assertThat(inputMaps).hasSize(2);
     assertThat(inputMaps.get("input1").getOriginalPath()).isEqualTo("input1.sourcemap");
     assertThat(inputMaps.get("input2").getOriginalPath()).isEqualTo("input2.sourcemap");
@@ -3056,6 +3058,15 @@ public final class CommandLineRunnerTest {
     assertThat(lastCompiler.getOptions().getIsolatePolyfills()).isTrue();
   }
 
+  @Test
+  public void testCrossChunkCodeMotionNoStubMethods() {
+    testSame("");
+    assertThat(lastCompiler.getOptions().crossChunkCodeMotionNoStubMethods).isFalse();
+    args.add("--assume_no_prototype_method_enumeration=true");
+    testSame("");
+    assertThat(lastCompiler.getOptions().crossChunkCodeMotionNoStubMethods).isTrue();
+  }
+
   /* Helper functions */
 
   private void testSame(String original) {
@@ -3083,7 +3094,7 @@ public final class CommandLineRunnerTest {
    * into {@code compiled}. If {@code warning} is non-null, we will also check if the given warning
    * type was emitted.
    */
-  private void test(String[] original, String[] compiled, DiagnosticType warning) {
+  private void test(String[] original, String[] compiled, @Nullable DiagnosticType warning) {
     exitCodes.clear();
     Compiler compiler = compile(original);
 
@@ -3242,7 +3253,7 @@ public final class CommandLineRunnerTest {
     compileArgs(expectedOutput, null);
   }
 
-  private void compileArgs(String expectedOutput, DiagnosticType expectedError) {
+  private void compileArgs(String expectedOutput, @Nullable DiagnosticType expectedError) {
     String[] argStrings = args.toArray(new String[] {});
 
     CommandLineRunner runner =
@@ -3295,22 +3306,24 @@ public final class CommandLineRunnerTest {
     Supplier<List<SourceFile>> inputsSupplier = null;
     Supplier<List<JSChunk>> modulesSupplier = null;
 
-    if (useModules == ModulePattern.NONE) {
-      List<SourceFile> inputs = new ArrayList<>();
-      for (int i = 0; i < original.length; i++) {
-        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));
-      }
-      inputsSupplier = Suppliers.ofInstance(inputs);
-    } else if (useModules == ModulePattern.STAR) {
-      modulesSupplier =
-          Suppliers.<List<JSChunk>>ofInstance(
-              ImmutableList.copyOf(JSChunkGraphBuilder.forStar().addChunks(original).build()));
-    } else if (useModules == ModulePattern.CHAIN) {
-      modulesSupplier =
-          Suppliers.<List<JSChunk>>ofInstance(
-              ImmutableList.copyOf(JSChunkGraphBuilder.forChain().addChunks(original).build()));
-    } else {
-      throw new IllegalArgumentException("Unknown module type: " + useModules);
+    switch (useModules) {
+      case NONE:
+        List<SourceFile> inputs = new ArrayList<>();
+        for (int i = 0; i < original.length; i++) {
+          inputs.add(SourceFile.fromCode(getFilename(i), original[i]));
+        }
+        inputsSupplier = Suppliers.ofInstance(inputs);
+        break;
+      case STAR:
+        modulesSupplier =
+            Suppliers.<List<JSChunk>>ofInstance(
+                ImmutableList.copyOf(JSChunkGraphBuilder.forStar().addChunks(original).build()));
+        break;
+      case CHAIN:
+        modulesSupplier =
+            Suppliers.<List<JSChunk>>ofInstance(
+                ImmutableList.copyOf(JSChunkGraphBuilder.forChain().addChunks(original).build()));
+        break;
     }
 
     runner.enableTestMode(
diff --git a/test/com/google/javascript/jscomp/CompilerOptionsTest.java b/test/com/google/javascript/jscomp/CompilerOptionsTest.java
index e03d67c..026b97b 100644
--- a/test/com/google/javascript/jscomp/CompilerOptionsTest.java
+++ b/test/com/google/javascript/jscomp/CompilerOptionsTest.java
@@ -19,13 +19,13 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
+import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.util.Map;
 import java.util.regex.Pattern;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -64,7 +64,7 @@ public final class CompilerOptionsTest {
     options.setDefineToNumberLiteral("threeVar", 3);
     options.setDefineToStringLiteral("strVar", "str");
 
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
     assertEquivalent(new Node(Token.TRUE), actual.get("trueVar"));
     assertEquivalent(new Node(Token.FALSE), actual.get("falseVar"));
     assertEquivalent(Node.newNumber(3), actual.get("threeVar"));
@@ -117,7 +117,7 @@ public final class CompilerOptionsTest {
     options =
         CompilerOptions.deserialize(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));
 
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
     assertEquivalent(new Node(Token.TRUE), actual.get("trueVar"));
     assertEquivalent(new Node(Token.FALSE), actual.get("falseVar"));
     assertEquivalent(Node.newNumber(3), actual.get("threeVar"));
diff --git a/test/com/google/javascript/jscomp/CompilerTest.java b/test/com/google/javascript/jscomp/CompilerTest.java
index b946a7d..ff42ed0 100644
--- a/test/com/google/javascript/jscomp/CompilerTest.java
+++ b/test/com/google/javascript/jscomp/CompilerTest.java
@@ -66,6 +66,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -111,7 +112,7 @@ public final class CompilerTest {
 
   @Test
   public void testCyclicalDependencyInInputs() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("gin", "goog.provide('gin'); goog.require('tonic'); var gin = {};"),
             SourceFile.fromCode(
@@ -134,7 +135,7 @@ public final class CompilerTest {
 
   @Test
   public void testPrintExterns() {
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(SourceFile.fromCode("extern", "/** @externs */ function alert(x) {}"));
     CompilerOptions options = new CompilerOptions();
     options.setPreserveTypeAnnotations(true);
@@ -180,7 +181,7 @@ public final class CompilerTest {
                 normalize("../original/source.html"),
                 originalSourcePosition));
     String origSourceName = normalize("original/source.html");
-    List<SourceFile> originalSources =
+    ImmutableList<SourceFile> originalSources =
         ImmutableList.of(SourceFile.fromCode(origSourceName, "<div ng-show='foo()'>"));
 
     CompilerOptions options = new CompilerOptions();
@@ -450,7 +451,7 @@ public final class CompilerTest {
     options.setPrintInputDelimiter(true);
 
     String fileOverview = "/** @fileoverview Foo */";
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(SourceFile.fromCode("i1", ""), SourceFile.fromCode("i2", fileOverview));
 
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -515,7 +516,7 @@ public final class CompilerTest {
   public void testNormalInputs() {
     CompilerOptions options = new CompilerOptions();
     Compiler compiler = new Compiler();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(SourceFile.fromCode("in1", ""), SourceFile.fromCode("in2", ""));
     compiler.compile(EMPTY_EXTERNS, inputs, options);
 
@@ -526,7 +527,7 @@ public final class CompilerTest {
 
   @Test
   public void testRebuildInputsFromModule() {
-    List<JSChunk> modules = ImmutableList.of(new JSChunk("m1"), new JSChunk("m2"));
+    ImmutableList<JSChunk> modules = ImmutableList.of(new JSChunk("m1"), new JSChunk("m2"));
     modules.get(0).add(SourceFile.fromCode("in1", ""));
     modules.get(1).add(SourceFile.fromCode("in2", ""));
 
@@ -564,7 +565,7 @@ public final class CompilerTest {
 
   @Test
   public void testFileoverviewTwice() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode("foo", "/** @fileoverview */ var x; /** @fileoverview */ var y;"));
     assertThat(new Compiler().compile(EMPTY_EXTERNS, input, new CompilerOptions()).success)
@@ -583,7 +584,7 @@ public final class CompilerTest {
   // Make sure we output license text even if followed by @fileoverview.
   @Test
   public void testImportantCommentAndOverviewDirectiveWarning() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode(
                 "foo",
@@ -683,7 +684,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -700,7 +701,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -721,7 +722,7 @@ public final class CompilerTest {
   // Make sure we output license text even if followed by @fileoverview.
   @Test
   public void testLicenseAndOverviewDirectiveWarning() {
-    List<SourceFile> input =
+    ImmutableList<SourceFile> input =
         ImmutableList.of(
             SourceFile.fromCode(
                 "foo",
@@ -820,7 +821,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -841,7 +842,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1),
             SourceFile.fromCode("testcode2", js2),
@@ -860,7 +861,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("testcode1", js1), SourceFile.fromCode("testcode2", js2));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
@@ -878,10 +879,10 @@ public final class CompilerTest {
 
   @Test
   public void testDefineOverriding1() {
-    List<String> defines =
+    ImmutableList<String> defines =
         ImmutableList.of(
             "COMPILED", "DEF_TRUE=true", "DEF_FALSE=false", "DEF_NUMBER=5.5", "DEF_STRING='bye'");
-    Map<String, Node> expected =
+    ImmutableMap<String, Node> expected =
         ImmutableMap.of(
             "COMPILED", new Node(Token.TRUE),
             "DEF_TRUE", new Node(Token.TRUE),
@@ -893,33 +894,33 @@ public final class CompilerTest {
 
   @Test
   public void testDefineOverriding2() {
-    List<String> defines = ImmutableList.of("DEF_STRING='='");
-    Map<String, Node> expected = ImmutableMap.of("DEF_STRING", Node.newString("="));
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING='='");
+    ImmutableMap<String, Node> expected = ImmutableMap.of("DEF_STRING", Node.newString("="));
     assertDefineOverrides(expected, defines);
   }
 
   @Test
   public void testDefineOverriding3() {
-    List<String> defines = ImmutableList.of("a.DEBUG");
-    Map<String, Node> expected = ImmutableMap.of("a.DEBUG", new Node(Token.TRUE));
+    ImmutableList<String> defines = ImmutableList.of("a.DEBUG");
+    ImmutableMap<String, Node> expected = ImmutableMap.of("a.DEBUG", new Node(Token.TRUE));
     assertDefineOverrides(expected, defines);
   }
 
   @Test
   public void testBadDefineOverriding1() {
-    List<String> defines = ImmutableList.of("DEF_STRING=");
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING=");
     assertCreateDefinesThrowsException(defines);
   }
 
   @Test
   public void testBadDefineOverriding2() {
-    List<String> defines = ImmutableList.of("=true");
+    ImmutableList<String> defines = ImmutableList.of("=true");
     assertCreateDefinesThrowsException(defines);
   }
 
   @Test
   public void testBadDefineOverriding3() {
-    List<String> defines = ImmutableList.of("DEF_STRING='''");
+    ImmutableList<String> defines = ImmutableList.of("DEF_STRING='''");
     assertCreateDefinesThrowsException(defines);
   }
 
@@ -937,7 +938,7 @@ public final class CompilerTest {
   static void assertDefineOverrides(Map<String, Node> expected, List<String> defines) {
     CompilerOptions options = new CompilerOptions();
     AbstractCommandLineRunner.createDefineReplacements(defines, options);
-    Map<String, Node> actual = options.getDefineReplacements();
+    ImmutableMap<String, Node> actual = options.getDefineReplacements();
 
     // equality of nodes compares by reference, so instead,
     // compare the maps manually using Node.checkTreeEqualsSilent
@@ -952,10 +953,10 @@ public final class CompilerTest {
     }
   }
 
-  static Result test(String js, String expected, DiagnosticType error) {
+  static Result test(String js, String expected, @Nullable DiagnosticType error) {
     Compiler compiler = new Compiler();
     CompilerOptions options = createNewFlagBasedOptions();
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     if (error == null) {
@@ -1004,7 +1005,7 @@ public final class CompilerTest {
     options.setVariableRenaming(VariableRenamingPolicy.ALL);
 
     String js = "var goog, x; goog.exportSymbol('a', x);";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(result.success).isTrue();
@@ -1021,7 +1022,7 @@ public final class CompilerTest {
     options.setGenerateExports(true);
 
     String js = "var goog; /** @export */ var a={};";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     Result result = compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(result.success).isTrue();
@@ -1080,7 +1081,7 @@ public final class CompilerTest {
     }
   }
 
-  private boolean hasOutput(String showWarningsOnlyFor, String path, CheckLevel level) {
+  private boolean hasOutput(@Nullable String showWarningsOnlyFor, String path, CheckLevel level) {
     TestErrorManager errorManager = new TestErrorManager();
     Compiler compiler = new Compiler(errorManager);
     CompilerOptions options = createNewFlagBasedOptions();
@@ -1122,7 +1123,7 @@ public final class CompilerTest {
         });
 
     String js = "var x = 1;";
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("testcode", js));
     compiler.compile(EMPTY_EXTERNS, inputs, options);
 
     assertThat(before[0]).isTrue(); // should run these custom passes
@@ -1143,7 +1144,7 @@ public final class CompilerTest {
 
   @Test
   public void testExternsDependencySorting() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("leaf", "/** @fileoverview @typeSummary */ goog.require('beer');"),
             SourceFile.fromCode(
@@ -1154,7 +1155,7 @@ public final class CompilerTest {
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.sortOnly());
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
 
@@ -1480,8 +1481,8 @@ public final class CompilerTest {
     options.setDoLateLocalization(true);
 
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
-    List<SourceFile> externs = ImmutableList.of();
-    List<SourceFile> srcs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> srcs = ImmutableList.of();
     compiler.init(externs, srcs, options);
 
     compiler.parse();
@@ -1691,7 +1692,7 @@ public final class CompilerTest {
 
   @Test
   public void testExternsDependencyPruning() {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "unused", "/** @fileoverview @typeSummary */ goog.provide('unused');"),
@@ -1703,7 +1704,7 @@ public final class CompilerTest {
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(ImmutableList.of()));
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
 
@@ -1721,7 +1722,7 @@ public final class CompilerTest {
   // https://github.com/google/closure-compiler/issues/2692
   @Test
   public void testGoogNamespaceEntryPoint() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/index.js",
@@ -1733,15 +1734,15 @@ public final class CompilerTest {
                     "foo('hello');")),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(ModuleIdentifier.forClosure("goog:foobar"));
 
     CompilerOptions options = createNewFlagBasedOptions();
-    options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT_2017);
-    options.setLanguageOut(CompilerOptions.LanguageMode.ECMASCRIPT5);
+    options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
+    options.setLanguageOut(LanguageMode.ECMASCRIPT5);
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(entryPoints));
     options.setProcessCommonJSModules(true);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addAlert().buildExternsFile("default_externs.js"));
 
@@ -1757,16 +1758,17 @@ public final class CompilerTest {
   public void testEs6ModulePathWithOddCharacters() throws Exception {
     // Note that this is not yet compatible with transpilation, since the generated goog.provide
     // statements are not valid identifiers.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index[0].js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneLegacyForEntryPoints(entryPoints));
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addAlert().buildExternsFile("default_externs.js"));
 
@@ -1782,18 +1784,19 @@ public final class CompilerTest {
     // Test that you can specify externs as entry points.
     // This allows all inputs to be passed to the compiler under the --js flag,
     // relying on dependency management to sort out which ones are externs or weak files
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(0);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1809,18 +1812,19 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint2() throws Exception {
     // Test code reference to an extern that doesn't exist,
     // but the extern is still the sole entry point.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(nonexistentExtern);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1836,20 +1840,20 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint3() throws Exception {
     // Test code reference to an extern that doesn't exist,
     // but the extern and source files are both entry points
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(nonexistentExtern);"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(
             ModuleIdentifier.forFile("/externs.js"), ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1865,20 +1869,20 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint4() throws Exception {
     // Test that has a code reference to an extern that does exist,
     // and the extern and source files are both entry points
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(bar);"));
 
-    List<ModuleIdentifier> entryPoints =
+    ImmutableList<ModuleIdentifier> entryPoints =
         ImmutableList.of(
             ModuleIdentifier.forFile("/externs.js"), ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1894,18 +1898,19 @@ public final class CompilerTest {
   public void testExternsFileAsEntryPoint5() throws Exception {
     // Test that has a code reference to an extern that does exist,
     // and only the source source file is an entry point
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js", "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;"),
             SourceFile.fromCode("/foo.js", "console.log(bar);"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/foo.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/foo.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
 
@@ -1920,19 +1925,20 @@ public final class CompilerTest {
   @Test
   public void testWeakExternsFileAsEntryPointNoError() throws Exception {
     // Test that if a weak extern file is passed in as entry point, there is no error thrown.
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode(
                 "/externs.js",
                 "/** @fileoverview @externs */ /** @const {number} */ var bar = 1;",
                 SourceKind.WEAK));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/externs.js"));
 
     CompilerOptions options = createNewFlagBasedOptions();
     options.setDependencyOptions(DependencyOptions.pruneForEntryPoints(entryPoints));
 
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     compiler.compile(externs, inputs, options);
@@ -2205,7 +2211,7 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, ImmutableList.copyOf(sources), options);
@@ -2249,7 +2255,7 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, sources.build(), options);
@@ -2294,10 +2300,10 @@ public final class CompilerTest {
     options.setDependencyOptions(
         DependencyOptions.pruneLegacyForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forFile("entry.js"))));
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     for (int iterationCount = 0; iterationCount < 10; iterationCount++) {
-      java.util.Collections.shuffle(sources);
+      Collections.shuffle(sources);
       Compiler compiler = new Compiler();
       Result result = compiler.compile(externs, ImmutableList.copyOf(sources), options);
       assertThat(result.success).isTrue();
@@ -2342,7 +2348,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2387,7 +2393,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2431,7 +2437,7 @@ public final class CompilerTest {
             ImmutableList.of(ModuleIdentifier.forFile("/entry.js"))));
     options.setProcessCommonJSModules(true);
     options.setModuleResolutionMode(ResolutionMode.WEBPACK);
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(
             new TestExternsBuilder().addConsole().buildExternsFile("default_externs.js"));
     Compiler compiler = new Compiler();
@@ -2449,9 +2455,9 @@ public final class CompilerTest {
 
   @Test
   public void testCodeReferenceToTypeImport() throws Exception {
-    List<SourceFile> externs =
+    ImmutableList<SourceFile> externs =
         ImmutableList.of(SourceFile.fromCode("extern.js", "/** @externs */ function alert(x) {}"));
-    List<SourceFile> sources =
+    ImmutableList<SourceFile> sources =
         ImmutableList.of(
             SourceFile.fromCode(
                 "type.js",
@@ -2485,7 +2491,7 @@ public final class CompilerTest {
 
   @Test
   public void testWeakSources() throws Exception {
-    List<SourceFile> sources =
+    ImmutableList<SourceFile> sources =
         ImmutableList.of(
             SourceFile.fromCode("weak1.js", "goog.provide('a');", SourceKind.WEAK),
             SourceFile.fromCode("strong1.js", "goog.provide('a.b');", SourceKind.STRONG),
@@ -2931,7 +2937,7 @@ public final class CompilerTest {
     options.setCheckTypes(false);
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
@@ -2958,7 +2964,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
@@ -2988,7 +2994,7 @@ public final class CompilerTest {
 
     Compiler compiler = new Compiler();
 
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", ""));
     compiler.init(ImmutableList.of(), inputs, options);
 
     compiler.parse();
diff --git a/test/com/google/javascript/jscomp/CompilerTestCase.java b/test/com/google/javascript/jscomp/CompilerTestCase.java
index 7f91d19..c2e00ff 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCase.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java
@@ -29,6 +29,7 @@ import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.truth.Correspondence;
 import com.google.errorprone.annotations.ForOverride;
@@ -36,7 +37,6 @@ import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import com.google.javascript.jscomp.AccessorSummary.PropertyAccessKind;
 import com.google.javascript.jscomp.AstValidator.TypeInfoValidation;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
-import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.modules.ModuleMapCreator;
 import com.google.javascript.jscomp.parsing.Config.JsDocParsing;
@@ -59,7 +59,7 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Function;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /**
@@ -170,7 +170,7 @@ public abstract class CompilerTestCase {
   private boolean expectParseWarningsInThisTest;
 
   /** An expected symbol table error. Only useful for testing the symbol table error-handling. */
-  private DiagnosticType expectedSymbolTableError;
+  private @Nullable DiagnosticType expectedSymbolTableError;
 
   /** Whether the PureFunctionIdentifier pass runs before the pass being tested */
   private boolean computeSideEffects;
@@ -193,10 +193,10 @@ public abstract class CompilerTestCase {
 
   private LanguageMode languageOut;
 
-  private Integer browserFeaturesetYear;
+  private @Nullable Integer browserFeaturesetYear;
 
   /** How to interpret ES6 module imports */
-  private ModuleLoader.ResolutionMode moduleResolutionMode;
+  private ResolutionMode moduleResolutionMode;
 
   /** How to parse JS Documentation. */
   private JsDocParsing parseJsDocDocumentation;
@@ -621,7 +621,7 @@ public abstract class CompilerTestCase {
     // TODO(sdh): Initialize *all* the options here, but first we must ensure no subclass
     // is changing them in the constructor, rather than in their own setUp method.
     this.acceptedLanguage = LanguageMode.UNSUPPORTED;
-    this.moduleResolutionMode = ModuleLoader.ResolutionMode.BROWSER;
+    this.moduleResolutionMode = ResolutionMode.BROWSER;
     this.parseJsDocDocumentation = JsDocParsing.TYPES_ONLY;
     this.allowExternsChanges = false;
     this.allowSourcelessWarnings = false;
@@ -790,7 +790,7 @@ public abstract class CompilerTestCase {
     this.browserFeaturesetYear = year;
   }
 
-  protected final void setModuleResolutionMode(ModuleLoader.ResolutionMode moduleResolutionMode) {
+  protected final void setModuleResolutionMode(ResolutionMode moduleResolutionMode) {
     checkState(this.setUpRan, "Attempted to configure before running setUp().");
     this.moduleResolutionMode = moduleResolutionMode;
   }
@@ -1009,7 +1009,7 @@ public abstract class CompilerTestCase {
     gatherExternPropertiesEnabled = true;
   }
 
-  protected final Set<String> getGatheredExternProperties() {
+  protected final ImmutableSet<String> getGatheredExternProperties() {
     checkState(this.gatherExternPropertiesEnabled, "Must enable gatherExternProperties");
     return lastCompiler.getExternProperties();
   }
@@ -1270,21 +1270,22 @@ public abstract class CompilerTestCase {
     return compiler;
   }
 
-  private static ImmutableList<SourceFile> maybeCreateSources(String name, String srcText) {
+  private static @Nullable ImmutableList<SourceFile> maybeCreateSources(
+      String name, String srcText) {
     if (srcText != null) {
       return ImmutableList.of(SourceFile.fromCode(name, srcText));
     }
     return null;
   }
 
-  protected static List<SourceFile> createSources(String name, String... sources) {
+  protected static @Nullable List<SourceFile> createSources(String name, String... sources) {
     if (sources == null) {
       return null;
     }
     return createSources(name, ImmutableList.copyOf(sources));
   }
 
-  private static List<SourceFile> createSources(String name, List<String> sources) {
+  private static @Nullable List<SourceFile> createSources(String name, List<String> sources) {
     if (sources == null) {
       return null;
     }
@@ -1335,9 +1336,9 @@ public abstract class CompilerTestCase {
     List<SourceFile> inputs =
         (inputsObj instanceof FlatSources) ? ((FlatSources) inputsObj).sources : null;
     List<SourceFile> expected = expectedObj != null ? expectedObj.expected : null;
-    List<Diagnostic> expectedErrors =
+    ImmutableList<Diagnostic> expectedErrors =
         diagnostics.stream().filter(d -> d.level == CheckLevel.ERROR).collect(toImmutableList());
-    List<Diagnostic> expectedWarnings =
+    ImmutableList<Diagnostic> expectedWarnings =
         diagnostics.stream().filter(d -> d.level == CheckLevel.WARNING).collect(toImmutableList());
     checkState(
         expectedErrors.isEmpty() || expectedWarnings.isEmpty(),
@@ -1555,7 +1556,7 @@ public abstract class CompilerTestCase {
         // Transpilation passes are allowed to leave the AST in a bad state when there is a halting
         // error.
         if (astValidationEnabled && !compiler.hasHaltingErrors()) {
-          AstValidator.TypeInfoValidation typeValidationMode =
+          TypeInfoValidation typeValidationMode =
               typeInfoValidationEnabled
                   ? compiler.hasOptimizationColors()
                       ? TypeInfoValidation.COLOR
@@ -1624,10 +1625,15 @@ public abstract class CompilerTestCase {
         }
       }
 
-      // If we ran normalize on the AST, we must also run normalize on the
-      // clone before checking for changes.
+      // If we ran normalize on the AST, we must also run normalize on th clone before checking for
+      // changes.
       if (normalizeEnabled) {
+        boolean hasTypecheckingRun = compiler.hasTypeCheckingRun();
+        // we don't run type inference over the clone of the AST, so need to mark that in the
+        // compiler or Normalize will crash due to lack of inferred types on the clone AST nodes.
+        compiler.setTypeCheckingHasRun(false);
         normalizeActualCode(compiler, externsRootClone, mainRootClone);
+        compiler.setTypeCheckingHasRun(hasTypecheckingRun);
       }
 
       boolean codeChange = !mainRootClone.isEquivalentWithSideEffectsTo(mainRoot);
@@ -2194,7 +2200,7 @@ public abstract class CompilerTestCase {
   protected static final class Expected implements TestPart {
     final List<SourceFile> expected;
 
-    Expected(List<SourceFile> files) {
+    Expected(@Nullable List<SourceFile> files) {
       this.expected = files;
     }
   }
@@ -2239,7 +2245,9 @@ public abstract class CompilerTestCase {
     final NamedPredicate<String> messagePredicate;
 
     Diagnostic(
-        CheckLevel level, DiagnosticType diagnostic, NamedPredicate<String> messagePredicate) {
+        CheckLevel level,
+        DiagnosticType diagnostic,
+        @Nullable NamedPredicate<String> messagePredicate) {
       this.level = level;
       this.diagnostic = diagnostic;
       this.messagePredicate = messagePredicate;
diff --git a/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java b/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
index 4c47968..fe8def1 100644
--- a/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
+++ b/test/com/google/javascript/jscomp/CompilerTestCaseUtils.java
@@ -21,7 +21,7 @@ import java.io.ByteArrayOutputStream;
 import java.util.List;
 
 /** CompilerTestCase utilities that can be super sourced out for GWT/J2CL implementation. */
-public class CompilerTestCaseUtils {
+public final class CompilerTestCaseUtils {
   @GwtIncompatible
   public static Compiler multistageSerializeAndDeserialize(
       CompilerTestCase testCase,
@@ -53,4 +53,6 @@ public class CompilerTestCaseUtils {
   @GwtIncompatible
   public static void setDebugLogDirectoryOn(CompilerOptions options) {
   }
+
+  private CompilerTestCaseUtils() {}
 }
diff --git a/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java b/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
index 276baa5..5fd4abe 100644
--- a/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
+++ b/test/com/google/javascript/jscomp/ConformanceAllowlisterTest.java
@@ -23,7 +23,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.javascript.rhino.Node;
 import java.io.IOException;
-import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -155,7 +154,7 @@ public class ConformanceAllowlisterTest {
     options.setCheckTypes(true);
     // TODO(bangert): Support banned property on OBJECT even if types are not checked.
     options.setChecksOnly(true);
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
     Compiler compiler = new Compiler();
     Result result = compiler.compile(externs, sources, options);
     assertThat(result.success).isTrue();
diff --git a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
index 307ad10..d6b6855 100644
--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java
@@ -50,7 +50,7 @@ public final class CreateSyntheticBlocksTest extends CompilerTestCase {
                 getName(),
                 new MinimizeExitPoints(),
                 new PeepholeRemoveDeadCode(),
-                new PeepholeMinimizeConditions(true /* late */),
+                new PeepholeMinimizeConditions(/* late= */ true),
                 new PeepholeFoldConstants(true, false /* useTypes */))
             .process(externs, js);
         new Denormalize(compiler, FeatureSet.BARE_MINIMUM).process(externs, js);
diff --git a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
index a9125c5..f815827 100644
--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.rhino.Token;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -953,14 +954,14 @@ public final class DataFlowAnalysisTest {
     assertThat(e).hasMessageThat().startsWith("Dataflow analysis appears to diverge around: ");
   }
 
-  static void verifyInHas(GraphNode<Instruction, Branch> node, Variable var,
-      Integer constant) {
+  static void verifyInHas(
+      GraphNode<Instruction, Branch> node, Variable var, @Nullable Integer constant) {
     LinearFlowState<ConstPropLatticeElement> fState = node.getAnnotation();
     veritfyLatticeElementHas(fState.getIn(), var, constant);
   }
 
-  static void verifyOutHas(GraphNode<Instruction, Branch> node, Variable var,
-      Integer constant) {
+  static void verifyOutHas(
+      GraphNode<Instruction, Branch> node, Variable var, @Nullable Integer constant) {
     LinearFlowState<ConstPropLatticeElement> fState = node.getAnnotation();
     veritfyLatticeElementHas(fState.getOut(), var, constant);
   }
diff --git a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
index 2f9f2d4..cd41891 100644
--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java
@@ -710,9 +710,7 @@ public final class DeadAssignmentsEliminationTest extends CompilerTestCase {
             "  }",
             "}"));
 
-    // TODO(b/235871861): Need to fix bug before supporting class static blocks, x=1 is not
-    // preserved.
-    inFunction(
+    testSame(
         lines(
             " var x = 0;",
             " print(x);",
@@ -721,16 +719,7 @@ public final class DeadAssignmentsEliminationTest extends CompilerTestCase {
             "   static {",
             "    print(x);",
             "    }",
-            "  }"),
-        lines(
-            " var x = 0;",
-            " print(x);",
-            " 1;",
-            " class C {",
-            "  static {",
-            "  print(x);",
-            "}",
-            "}"));
+            "  }"));
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java b/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
index 5899318..3ca62a1 100644
--- a/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
+++ b/test/com/google/javascript/jscomp/DevirtualizeMethodsTest.java
@@ -27,16 +27,13 @@ import com.google.javascript.jscomp.colors.Color;
 import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import com.google.javascript.rhino.Node;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for {@link DevirtualizeMethods}
- *
- */
+/** Tests for {@link DevirtualizeMethods} */
 @RunWith(JUnit4.class)
 public final class DevirtualizeMethodsTest extends CompilerTestCase {
   private static final String EXTERNAL_SYMBOLS =
@@ -60,10 +57,8 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     disableTypeCheck();
   }
 
-  /**
-   * Combine source strings using ';' as the separator.
-   */
-  private static String semicolonJoin(String ... parts) {
+  /** Combine source strings using ';' as the separator. */
+  private static String semicolonJoin(String... parts) {
     return Joiner.on(";").join(parts);
   }
 
@@ -138,8 +133,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
         label);
   }
 
-  @Nullable
-  private static Node getLabelledExpressionIfPresent(String label, Node root) {
+  private static @Nullable Node getLabelledExpressionIfPresent(String label, Node root) {
     if (root.isLabel() && root.getFirstChild().getString().equals(label)) {
       Node labelledBlock = root.getSecondChild();
       checkState(labelledBlock.isBlock(), labelledBlock);
@@ -179,9 +173,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     test(source, expected);
   }
 
-  /**
-   * Inputs for declaration used as an r-value tests.
-   */
+  /** Inputs for declaration used as an r-value tests. */
   private static class NoRewriteDeclarationUsedAsRValue {
     static final String DECL = "a.prototype.foo = function() {}";
     static final String CALL = "o.foo()";
@@ -191,23 +183,27 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
 
   @Test
   public void testRewriteDeclIsExpressionStatement() {
-    test(semicolonJoin(NoRewriteDeclarationUsedAsRValue.DECL,
-                       NoRewriteDeclarationUsedAsRValue.CALL),
-         "var JSCompiler_StaticMethods_foo =" +
-         "function(JSCompiler_StaticMethods_foo$self) {};" +
-         "JSCompiler_StaticMethods_foo(o)");
+    test(
+        semicolonJoin(NoRewriteDeclarationUsedAsRValue.DECL, NoRewriteDeclarationUsedAsRValue.CALL),
+        "var JSCompiler_StaticMethods_foo ="
+            + "function(JSCompiler_StaticMethods_foo$self) {};"
+            + "JSCompiler_StaticMethods_foo(o)");
   }
 
   @Test
   public void testNoRewriteDeclUsedAsAssignmentRhs() {
-    testSame(semicolonJoin("var c = " + NoRewriteDeclarationUsedAsRValue.DECL,
-                           NoRewriteDeclarationUsedAsRValue.CALL));
+    testSame(
+        semicolonJoin(
+            "var c = " + NoRewriteDeclarationUsedAsRValue.DECL,
+            NoRewriteDeclarationUsedAsRValue.CALL));
   }
 
   @Test
   public void testNoRewriteDeclUsedAsCallArgument() {
-    testSame(semicolonJoin("f(" + NoRewriteDeclarationUsedAsRValue.DECL + ")",
-                           NoRewriteDeclarationUsedAsRValue.CALL));
+    testSame(
+        semicolonJoin(
+            "f(" + NoRewriteDeclarationUsedAsRValue.DECL + ")",
+            NoRewriteDeclarationUsedAsRValue.CALL));
   }
 
   @Test
@@ -543,9 +539,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "alert(x.getFoo());"));
   }
 
-  /**
-   * Inputs for object literal tests.
-   */
+  /** Inputs for object literal tests. */
   private static class NoRewritePrototypeObjectLiteralsTestInput {
     static final String REGULAR = "b.prototype.foo = function() { return 1; }";
     static final String OBJ_LIT = "a.prototype = {foo : function() { return 2; }}";
@@ -583,9 +577,11 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
 
   @Test
   public void testNoRewrite_multipleDefinitions_definedUsingProtoObjectLit_definedUsingGetProp() {
-    testSame(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,
-                           NoRewritePrototypeObjectLiteralsTestInput.REGULAR,
-                           NoRewritePrototypeObjectLiteralsTestInput.CALL));
+    testSame(
+        semicolonJoin(
+            NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT,
+            NoRewritePrototypeObjectLiteralsTestInput.REGULAR,
+            NoRewritePrototypeObjectLiteralsTestInput.CALL));
   }
 
   @Test
@@ -691,9 +687,7 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
     testSame(source);
   }
 
-  /**
-   * Inputs for invalidating reference tests.
-   */
+  /** Inputs for invalidating reference tests. */
   private static class NoRewriteNonCallReferenceTestInput {
     static final String BASE =
         lines(
@@ -800,34 +794,30 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "new o.foo();"));
   }
 
-  /**
-   * Inputs for nested definition tests.
-   */
+  /** Inputs for nested definition tests. */
   private static class NoRewriteNestedFunctionTestInput {
     static final String PREFIX = "a.prototype.foo = function() {";
     static final String SUFFIX = "o.foo()";
     static final String INNER = "a.prototype.bar = function() {}; o.bar()";
     static final String EXPECTED_PREFIX =
-        "var JSCompiler_StaticMethods_foo=" +
-        "function(JSCompiler_StaticMethods_foo$self){";
-    static final String EXPECTED_SUFFIX =
-        "JSCompiler_StaticMethods_foo(o)";
+        "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self){";
+    static final String EXPECTED_SUFFIX = "JSCompiler_StaticMethods_foo(o)";
 
     private NoRewriteNestedFunctionTestInput() {}
   }
 
   @Test
   public void testRewriteNoNestedFunction() {
-    test(semicolonJoin(
-             NoRewriteNestedFunctionTestInput.PREFIX + "}",
-             NoRewriteNestedFunctionTestInput.SUFFIX,
-             NoRewriteNestedFunctionTestInput.INNER),
-         semicolonJoin(
-             NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + "}",
-             NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX,
-             "var JSCompiler_StaticMethods_bar=" +
-             "function(JSCompiler_StaticMethods_bar$self){}",
-             "JSCompiler_StaticMethods_bar(o)"));
+    test(
+        semicolonJoin(
+            NoRewriteNestedFunctionTestInput.PREFIX + "}",
+            NoRewriteNestedFunctionTestInput.SUFFIX,
+            NoRewriteNestedFunctionTestInput.INNER),
+        semicolonJoin(
+            NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + "}",
+            NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX,
+            "var JSCompiler_StaticMethods_bar=" + "function(JSCompiler_StaticMethods_bar$self){}",
+            "JSCompiler_StaticMethods_bar(o)"));
   }
 
   @Test
@@ -1372,6 +1362,36 @@ public final class DevirtualizeMethodsTest extends CompilerTestCase {
             "console.log(new Foo().a);"));
   }
 
+  @Test
+  public void testStaticClassFieldNoRHS() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a;",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
+  @Test
+  public void testStaticClassFieldNonFunction() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a = 2;",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
+  @Test
+  public void testStaticClassFieldFunction() {
+    testSame(
+        lines(
+            "class Foo {", //
+            "  static a = function x() { return 5; };",
+            "}",
+            "console.log(Foo.a);"));
+  }
+
   private static class ModuleTestInput {
     static final String DEFINITION = "a.prototype.foo = function() {}";
     static final String USE = "x.foo()";
diff --git a/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java b/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
index 91cdd67..1b66bf4 100644
--- a/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
+++ b/test/com/google/javascript/jscomp/DiagnosticGroupsTest.java
@@ -37,9 +37,14 @@ public final class DiagnosticGroupsTest {
   public void lintChecksGroupIsDisjointFromEveryOtherGroup() throws Exception {
     DiagnosticGroup lintChecks = DiagnosticGroups.LINT_CHECKS;
     for (DiagnosticGroup group : DiagnosticGroups.getRegisteredGroups().values()) {
-      // TODO(lharker): stop ignoring USE_OF_GOOG_PROVIDE after migrating rules_closure
-      // code to suppress useOfGoogProvide instead of lintChecks.
-      if (group.equals(lintChecks) || group.equals(DiagnosticGroups.USE_OF_GOOG_PROVIDE)) {
+      if (group.equals(lintChecks)
+          // TODO(lharker): stop ignoring USE_OF_GOOG_PROVIDE after migrating rules_closure
+          // code to suppress useOfGoogProvide instead of lintChecks.
+          || group.equals(DiagnosticGroups.USE_OF_GOOG_PROVIDE)
+          // We need a separate group for "lintVarDeclarations" so code that really cannot be
+          // updated to use only `let` and `const` can suppress the warnings about `var` without
+          // suppressing all lint checks.
+          || group.equals(DiagnosticGroups.LINT_VAR_DECLARATIONS)) {
         continue;
       }
       assertWithMessage(
diff --git a/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java b/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
index b7b3f6e..4dd60cb 100644
--- a/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
+++ b/test/com/google/javascript/jscomp/Es6RelativizeImportPathsTest.java
@@ -22,7 +22,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +32,7 @@ public class Es6RelativizeImportPathsTest extends CompilerTestCase {
 
   private ImmutableMap<String, String> prefixReplacements;
   private ResolutionMode moduleResolutionMode;
-  private List<String> moduleRoots;
+  private ImmutableList<String> moduleRoots;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
index 5a93638..54e2628 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesBeforeTypeCheckingTest.java
@@ -20,6 +20,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
 import com.google.javascript.jscomp.modules.ModuleMapCreator;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesBeforeTypeCheckingTest extends CompilerTestCase {
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
 
   private static final SourceFile other =
       SourceFile.fromCode(
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
index f686196..26cf064 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesTest.java
@@ -23,6 +23,7 @@ import com.google.javascript.jscomp.CompilerOptions.ChunkOutputType;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -39,7 +40,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesTest extends CompilerTestCase {
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
   private ChunkOutputType chunkOutputType = ChunkOutputType.GLOBAL_NAMESPACE;
 
   private static final SourceFile other =
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
index 8155a71..01298d5 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesToCommonJsModulesTest.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.deps.ModuleLoader;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,7 +27,7 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class Es6RewriteModulesToCommonJsModulesTest extends CompilerTestCase {
-  private List<String> moduleRoots;
+  private ImmutableList<String> moduleRoots;
   private ModuleLoader.ResolutionMode resolutionMode;
   private ImmutableMap<String, String> prefixReplacements;
   private PathEscaper pathEscaper;
diff --git a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
index 262f83d..b999e9f 100644
--- a/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
+++ b/test/com/google/javascript/jscomp/Es6RewriteModulesWithGoogInteropTest.java
@@ -28,7 +28,6 @@ import static com.google.javascript.jscomp.RhinoErrorReporter.UNRECOGNIZED_TYPE_
 import static com.google.javascript.jscomp.TypeCheck.INEXISTENT_PROPERTY;
 import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY;
 import static com.google.javascript.jscomp.modules.EsModuleProcessor.NAMESPACE_IMPORT_CANNOT_USE_STAR;
-import static com.google.javascript.jscomp.modules.ModuleMapCreator.MISSING_NAMESPACE_IMPORT;
 
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
@@ -1099,8 +1098,7 @@ public final class Es6RewriteModulesWithGoogInteropTest extends CompilerTestCase
 
   @Test
   public void testMissingRequireAssumesGoogProvide() {
-    ignoreWarnings(
-        MISSING_MODULE_OR_PROVIDE, MISSING_NAMESPACE_IMPORT, POSSIBLE_INEXISTENT_PROPERTY);
+    ignoreWarnings(MISSING_MODULE_OR_PROVIDE, POSSIBLE_INEXISTENT_PROPERTY);
 
     test(
         srcs(
diff --git a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
index 19b3d1b..6ede713 100644
--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java
@@ -36,7 +36,7 @@ import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.function.Function;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,7 +49,7 @@ public final class ExpressionDecomposerTest {
   private final Set<String> knownConstants = new HashSet<>();
 
   /** The language out to set in the compiler options. If null, use the default. */
-  @Nullable private LanguageMode languageOut;
+  private @Nullable LanguageMode languageOut;
   // Whether we should run type checking and test the type information in the output expression
   private boolean shouldTestTypes;
 
@@ -1418,6 +1418,25 @@ public final class ExpressionDecomposerTest {
   }
 
   @Test
+  public void testExposeTemplateLiteralFreeCall() {
+    helperExposeExpression(
+        "foo`${x()}${y()}`",
+        exprMatchesStr("y()"),
+        lines(
+            "var temp_const$jscomp$1 = foo;",
+            "var temp_const$jscomp$0 = x();",
+            "temp_const$jscomp$1`${temp_const$jscomp$0}${y()}`;"));
+  }
+
+  @Test
+  public void testCanExposeTaggedTemplateLiteralInterpolation() {
+    helperCanExposeExpression(DecompositionType.DECOMPOSABLE, "x`${y()}`", exprMatchesStr("y()"));
+    // TODO(b/251958225): Implement decomposition for this case.
+    helperCanExposeExpression(
+        DecompositionType.UNDECOMPOSABLE, "x.foo`${y()}`", exprMatchesStr("y()"));
+  }
+
+  @Test
   public void testExposeExpression18() {
     helperExposeExpression(
         lines("const {a, b, c} = condition ?", "  y() :", "  {a: 0, b: 0, c: 1};"),
@@ -2190,8 +2209,7 @@ public final class ExpressionDecomposerTest {
     compiler.setTypeCheckingHasRun(true);
   }
 
-  @Nullable
-  private static Node findClass(Node n) {
+  private static @Nullable Node findClass(Node n) {
     if (n.isClass()) {
       return n;
     }
diff --git a/test/com/google/javascript/jscomp/ExternExportsPassTest.java b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
index 9dcebcf..494912a 100644
--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java
+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java
@@ -19,6 +19,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import java.util.function.Consumer;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -1723,14 +1724,15 @@ public final class ExternExportsPassTest extends CompilerTestCase {
   }
 
   /**
-   * Compiles the passed in JavaScript with the passed in externs and returns
-   * the new externs exported by the this pass.
+   * Compiles the passed in JavaScript with the passed in externs and returns the new externs
+   * exported by the this pass.
    *
    * @param js the source to be compiled
    * @param externs the externs the {@code js} source needs
    * @param consumer consumer for the externs generated from {@code js}
    */
-  private void compileAndExportExterns(String js, String externs, final Consumer<String> consumer) {
+  private void compileAndExportExterns(
+      String js, String externs, final @Nullable Consumer<String> consumer) {
     js = lines(
         "/** @const */ var goog = {};",
         "goog.exportSymbol = function(a, b) {};",
diff --git a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
index f90072a..b1cdaf9 100644
--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.jscomp.deps.ModuleLoader.LOAD_WARNING;
 import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;
 import com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormat;
 import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -362,7 +363,7 @@ public final class ExtractPrototypeMemberDeclarationsTest extends CompilerTestCa
     return generateExtractedDeclarations(num, null);
   }
 
-  private String generateExtractedDeclarations(int num, Integer fileIndex) {
+  private String generateExtractedDeclarations(int num, @Nullable Integer fileIndex) {
     StringBuilder builder = new StringBuilder();
 
     String alias = TMP;
diff --git a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
index f9bbe22..da4bf36 100644
--- a/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
+++ b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java
@@ -54,7 +54,11 @@ public final class FixedPointGraphTraversalTest {
 
   private DiGraph<Counter, String> graph;
 
-  private Counter A, B, C, D, E;
+  private Counter A;
+  private Counter B;
+  private Counter C;
+  private Counter D;
+  private Counter E;
   private final CounterIncrementer callback = new CounterIncrementer();
   private FixedPointGraphTraversal<Counter, String> traversal =
       FixedPointGraphTraversal.newTraversal(callback);
diff --git a/test/com/google/javascript/jscomp/FunctionInjectorTest.java b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
index 4b9ebcd..a35675c 100644
--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java
@@ -30,7 +30,6 @@ import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;
 import com.google.javascript.jscomp.FunctionInjector.InliningMode;
 import com.google.javascript.jscomp.FunctionInjector.Reference;
 import com.google.javascript.rhino.Node;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -46,7 +45,7 @@ public final class FunctionInjectorTest {
   static final InliningMode INLINE_DIRECT = InliningMode.DIRECT;
   static final InliningMode INLINE_BLOCK = InliningMode.BLOCK;
   private boolean assumeStrictThis = false;
-  private final boolean assumeMinimumCapture = false;
+  private static final boolean ASSUME_MINIMUM_CAPTURE = false;
   private boolean allowDecomposition;
 
   @Before
@@ -1855,7 +1854,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .functionArgumentInjector(functionArgumentInjector)
             .build();
     final Node tree = parse(compiler, code);
@@ -1904,8 +1903,7 @@ public final class FunctionInjectorTest {
       String code, final String expectedResult,
       final String fnName, final InliningMode mode) {
     final Compiler compiler = new Compiler();
-    List<SourceFile> externsInputs = ImmutableList.of(
-        SourceFile.fromCode("externs", ""));
+    ImmutableList<SourceFile> externsInputs = ImmutableList.of(SourceFile.fromCode("externs", ""));
 
     CompilerOptions options = new CompilerOptions();
     options.setCodingConvention(new GoogleCodingConvention());
@@ -1918,7 +1916,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .functionArgumentInjector(functionArgumentInjector)
             .build();
 
@@ -2006,7 +2004,7 @@ public final class FunctionInjectorTest {
         new FunctionInjector.Builder(compiler)
             .allowDecomposition(allowDecomposition)
             .assumeStrictThis(assumeStrictThis)
-            .assumeMinimumCapture(assumeMinimumCapture)
+            .assumeMinimumCapture(ASSUME_MINIMUM_CAPTURE)
             .build();
     final Node tree = parse(compiler, code);
 
diff --git a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
index 025df58..e957d6b 100644
--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java
@@ -22,6 +22,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -273,7 +274,8 @@ public final class FunctionToBlockMutatorTest {
     helperMutate(code, expectedResult, fnName, "result");
   }
 
-  public void helperMutate(String code, String expectedResult, String fnName, String resultName) {
+  public void helperMutate(
+      String code, String expectedResult, String fnName, @Nullable String resultName) {
     final Compiler compiler = new Compiler();
     compiler.initCompilerOptionsIfTesting();
     final FunctionToBlockMutator mutator = new FunctionToBlockMutator(
diff --git a/test/com/google/javascript/jscomp/GatherRawExportsTest.java b/test/com/google/javascript/jscomp/GatherRawExportsTest.java
index 09fb38e..8c6e5f3 100644
--- a/test/com/google/javascript/jscomp/GatherRawExportsTest.java
+++ b/test/com/google/javascript/jscomp/GatherRawExportsTest.java
@@ -19,7 +19,6 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -234,7 +233,7 @@ public final class GatherRawExportsTest extends CompilerTestCase {
   }
 
   private void assertExported(String js, String ... names) {
-    Set<String> setNames = ImmutableSet.copyOf(names);
+    ImmutableSet<String> setNames = ImmutableSet.copyOf(names);
     testSame(js);
     assertThat(last.getExportedVariableNames()).isEqualTo(setNames);
   }
diff --git a/test/com/google/javascript/jscomp/GenerateExportsTest.java b/test/com/google/javascript/jscomp/GenerateExportsTest.java
index 9036b05..81f6c1c 100644
--- a/test/com/google/javascript/jscomp/GenerateExportsTest.java
+++ b/test/com/google/javascript/jscomp/GenerateExportsTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -35,8 +36,8 @@ public final class GenerateExportsTest extends CompilerTestCase {
           "goog.exportProperty = function(a, b, c) {};");
 
   private boolean allowNonGlobalExports = true;
-  private String exportSymbolFunction;
-  private String exportPropertyFunction;
+  private @Nullable String exportSymbolFunction;
+  private @Nullable String exportPropertyFunction;
 
   public GenerateExportsTest() {
     super(EXTERNS);
diff --git a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
index d6640bb..f209d2f 100644
--- a/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
+++ b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java
@@ -26,6 +26,7 @@ import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.GlobalNamespace.AstChange;
 import com.google.javascript.jscomp.GlobalNamespace.Inlinability;
@@ -39,8 +40,7 @@ import com.google.javascript.rhino.JSTypeExpression;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.jstype.JSType;
-import java.util.Collection;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -49,7 +49,8 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class GlobalNamespaceTest {
 
-  @Nullable private Compiler lastCompiler = null;
+  private @Nullable Compiler lastCompiler = null;
+  private boolean assumeStaticInheritanceIsNotUsed = true;
 
   @Test
   public void detectsPropertySetsInAssignmentOperators() {
@@ -529,9 +530,9 @@ public final class GlobalNamespaceTest {
     Name foo = namespace.getOwnSlot("Foo");
     Name bar = namespace.getOwnSlot("Bar");
     Name baz = namespace.getOwnSlot("Baz");
-    Collection<Ref> originalFooRefs = ImmutableList.copyOf(foo.getRefs());
-    Collection<Ref> originalBarRefs = ImmutableList.copyOf(bar.getRefs());
-    Collection<Ref> originalBazRefs = ImmutableList.copyOf(baz.getRefs());
+    ImmutableList<Ref> originalFooRefs = ImmutableList.copyOf(foo.getRefs());
+    ImmutableList<Ref> originalBarRefs = ImmutableList.copyOf(bar.getRefs());
+    ImmutableList<Ref> originalBazRefs = ImmutableList.copyOf(baz.getRefs());
 
     // Rescan all of the nodes for which we got refs as if they were newly added
     Node root = lastCompiler.getJsRoot();
@@ -1237,6 +1238,19 @@ public final class GlobalNamespaceTest {
   }
 
   @Test
+  public void testCannotCollapseOrInlineDeletedProperty() {
+    GlobalNamespace namespace =
+        parse(
+            lines(
+                "const global = window;", //
+                "delete global.HTMLElement;",
+                "global.HTMLElement = (class {});"));
+
+    Name deletedProp = namespace.getSlot("global.HTMLElement");
+    assertThat(deletedProp.canCollapseOrInline()).isEqualTo(Inlinability.DO_NOT_INLINE);
+  }
+
+  @Test
   public void testCanCollapse_objectLitProperty_declaredBeforeASpread() {
     GlobalNamespace namespace = parse("var foo = {prop: 0, ...bar}; use(foo.prop);");
 
@@ -1469,20 +1483,11 @@ public final class GlobalNamespaceTest {
     assertThat(x.getDeclaration()).isNotNull();
   }
 
-  private boolean assumeStaticInheritanceIsNotUsed = true;
-
   // This method exists for testing module metadata lookups.
   private GlobalNamespace parseAndGatherModuleData(String js) {
-    Compiler compiler = new Compiler();
-    CompilerOptions options = new CompilerOptions();
-    // Don't optimize, because we want to know how GlobalNamespace responds to the original code
-    // in `js`.
-    options.setSkipNonTranspilationPasses(true);
-    options.setWrapGoogModulesForWhitespaceOnly(false);
-    // Test the latest features supported for input and don't transpile, because we want to test how
-    // GlobalNamespace deals with the language features actually present in `js`.
-    options.setAssumeStaticInheritanceIsNotUsed(assumeStaticInheritanceIsNotUsed);
-    compiler.compile(SourceFile.fromCode("ex.js", ""), SourceFile.fromCode("test.js", js), options);
+    CompilerOptions options = getDefaultOptions();
+    Compiler compiler = compile(js, options);
+
     // Disabling transpilation also disables these passes that we need to have run when
     // testing behavior related to module metadata.
     new GatherModuleMetadata(
@@ -1492,24 +1497,34 @@ public final class GlobalNamespaceTest {
         .process(compiler.getExternsRoot(), compiler.getJsRoot());
     assertThat(compiler.getErrors()).isEmpty();
     this.lastCompiler = compiler;
-
     return new GlobalNamespace(compiler, compiler.getRoot());
   }
 
   private GlobalNamespace parse(String js) {
-    Compiler compiler = new Compiler();
+    CompilerOptions options = getDefaultOptions();
+    compile(js, options);
+    return new GlobalNamespace(this.lastCompiler, this.lastCompiler.getRoot());
+  }
+
+  private CompilerOptions getDefaultOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguage(LanguageMode.UNSUPPORTED);
     // Don't optimize, because we want to know how GlobalNamespace responds to the original code
     // in `js`.
     options.setSkipNonTranspilationPasses(true);
+    options.setWrapGoogModulesForWhitespaceOnly(false);
     // Test the latest features supported for input and don't transpile, because we want to test how
     // GlobalNamespace deals with the language features actually present in `js`.
     options.setAssumeStaticInheritanceIsNotUsed(assumeStaticInheritanceIsNotUsed);
+    return options;
+  }
+
+  @CanIgnoreReturnValue
+  private Compiler compile(String js, CompilerOptions options) {
+    Compiler compiler = new Compiler();
     compiler.compile(SourceFile.fromCode("ex.js", ""), SourceFile.fromCode("test.js", js), options);
     assertThat(compiler.getErrors()).isEmpty();
     this.lastCompiler = compiler;
-
-    return new GlobalNamespace(compiler, compiler.getRoot());
+    return compiler;
   }
 }
diff --git a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
index bf17238..1e9089a 100644
--- a/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
+++ b/test/com/google/javascript/jscomp/GoogleCodingConventionTest.java
@@ -56,7 +56,7 @@ public final class GoogleCodingConventionTest {
   }
 
   @Test
-  public void testInlineName() {
+  public void testIsConstant() {
     assertThat(conv.isConstant("a")).isFalse();
     assertThat(conv.isConstant("XYZ123_")).isTrue();
     assertThat(conv.isConstant("ABC")).isTrue();
@@ -72,6 +72,21 @@ public final class GoogleCodingConventionTest {
     assertThat(conv.isConstant("a$b$aBC")).isFalse();
     assertThat(conv.isConstant("a$b$")).isFalse();
     assertThat(conv.isConstant("$")).isFalse();
+    assertThat(conv.isConstant("$A")).isTrue();
+    assertThat(conv.isConstant("$a")).isFalse();
+  }
+
+  @Test
+  public void testIsConstantKey() {
+    assertThat(conv.isConstantKey("a")).isFalse();
+    assertThat(conv.isConstantKey("XYZ123_")).isTrue();
+    assertThat(conv.isConstantKey("ABC")).isTrue();
+    assertThat(conv.isConstantKey("ABCdef")).isFalse();
+    assertThat(conv.isConstantKey("aBC")).isFalse();
+    assertThat(conv.isConstantKey("A")).isTrue();
+    assertThat(conv.isConstantKey("_XYZ123")).isFalse();
+    assertThat(conv.isConstantKey("a$b$ABC")).isFalse();
+    assertThat(conv.isConstantKey("$")).isFalse();
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/GuardedCallbackTest.java b/test/com/google/javascript/jscomp/GuardedCallbackTest.java
index aadb2d0..81fa1fd 100644
--- a/test/com/google/javascript/jscomp/GuardedCallbackTest.java
+++ b/test/com/google/javascript/jscomp/GuardedCallbackTest.java
@@ -40,7 +40,7 @@ public final class GuardedCallbackTest extends CompilerTestCase {
    * Replaces all guarded name and property references with "GUARDED_NAME" and "GUARDED_PROP",
    * respectively.
    */
-  private class GuardSwitchingCallback extends GuardedCallback<String> {
+  private static class GuardSwitchingCallback extends GuardedCallback<String> {
 
     GuardSwitchingCallback(AbstractCompiler compiler) {
       super(compiler);
diff --git a/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java b/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
index 5bd8eba..1315969 100644
--- a/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
+++ b/test/com/google/javascript/jscomp/InjectTranspilationRuntimeLibrariesTest.java
@@ -16,11 +16,14 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.javascript.jscomp.base.JSCompStrings.lines;
+import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DIAGNOSTIC_EQUALITY;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
-import java.util.Set;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,16 +31,24 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public class InjectTranspilationRuntimeLibrariesTest {
 
+  private NoninjectingCompiler compiler;
+  private LanguageMode languageOut;
+
+  @Before
+  public void setup() {
+    compiler = new NoninjectingCompiler();
+    languageOut = LanguageMode.ECMASCRIPT5;
+  }
+
   /**
    * Parses the given code and runs the {@link InjectTranspilationRuntimeLibraries} pass over the
    * resulting AST
    *
    * @return the set of paths to all the injected libraries
    */
-  private Set<String> parseAndRunInjectionPass(String js) {
-    NoninjectingCompiler compiler = new NoninjectingCompiler();
+  private ImmutableSet<String> parseAndRunInjectionPass(String js) {
     CompilerOptions options = new CompilerOptions();
-    options.setLanguageOut(LanguageMode.ECMASCRIPT5);
+    options.setLanguageOut(this.languageOut);
 
     compiler.init(
         ImmutableList.of(SourceFile.fromCode("externs", "")),
@@ -52,62 +63,96 @@ public class InjectTranspilationRuntimeLibrariesTest {
 
   @Test
   public void testEmptyInjected() {
-    Set<String> injected = parseAndRunInjectionPass("");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("");
 
     assertThat(injected).isEmpty();
   }
 
   @Test
   public void testMakeIteratorAndObjectAssignInjectedForObjectPatternRest() {
-    Set<String> injected = parseAndRunInjectionPass("const {a, ...rest} = something();");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("const {a, ...rest} = something();");
     assertThat(injected).containsExactly("es6/util/makeiterator", "es6/object/assign");
   }
 
   @Test
   public void testObjectAssignInjectedForObjectSpread() {
-    Set<String> injected = parseAndRunInjectionPass("const obj = {a, ...rest};");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("const obj = {a, ...rest};");
     assertThat(injected).containsExactly("es6/object/assign");
   }
 
   @Test
   public void testForOf_injectsMakeIterator() {
-    Set<String> injected = parseAndRunInjectionPass("for (x of []) {}");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("for (x of []) {}");
 
     assertThat(injected).containsExactly("es6/util/makeiterator");
   }
 
   @Test
   public void testArrayPattern_injectsMakeIterator() {
-    Set<String> injected = parseAndRunInjectionPass("var [a] = [];");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var [a] = [];");
 
     assertThat(injected).containsExactly("es6/util/makeiterator");
   }
 
   @Test
   public void testObjectPattern_injectsNothing() {
-    Set<String> injected = parseAndRunInjectionPass("var {a} = {};");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var {a} = {};");
 
     assertThat(injected).isEmpty();
   }
 
   @Test
   public void testArrayPatternRest_injectsArrayFromIterator() {
-    Set<String> injected = parseAndRunInjectionPass("var [...a] = [];");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("var [...a] = [];");
 
     assertThat(injected).containsExactly("es6/util/makeiterator", "es6/util/arrayfromiterator");
   }
 
   @Test
   public void testArrayPatternRest_injectsExecuteAsyncFunctionSupport() {
-    Set<String> injected = parseAndRunInjectionPass("async function foo() {}");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("async function foo() {}");
 
     assertThat(injected).containsExactly("es6/execute_async_generator");
   }
 
   @Test
   public void testTaggedTemplateFirstArgCreaterInjected() {
-    Set<String> injected = parseAndRunInjectionPass("function tag(...a) {}; tag`hello`;");
+    ImmutableSet<String> injected = parseAndRunInjectionPass("function tag(...a) {}; tag`hello`;");
     assertThat(injected)
         .containsExactly("es6/util/createtemplatetagfirstarg", "es6/util/restarguments");
   }
+
+  @Test
+  public void testAllowsEs5GetterSetterWithEs5Out() {
+    this.languageOut = LanguageMode.ECMASCRIPT5;
+    parseAndRunInjectionPass(
+        lines(
+            "var o = {", //
+            "  get x() {},",
+            "  set x(val) {}",
+            "};"));
+
+    assertThat(compiler.getErrors()).isEmpty();
+    assertThat(compiler.getInjected()).isEmpty();
+  }
+
+  @Test
+  public void testCannotConvertEs5GetterToEs3() {
+    this.languageOut = LanguageMode.ECMASCRIPT3;
+    parseAndRunInjectionPass("var o = {get x() {}};");
+
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
+        .containsExactly(TranspilationUtil.CANNOT_CONVERT);
+  }
+
+  @Test
+  public void testCannotConvertEs5SetterToEs3() {
+    this.languageOut = LanguageMode.ECMASCRIPT3;
+    parseAndRunInjectionPass("var o = {set x(val) {}};");
+
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
+        .containsExactly(TranspilationUtil.CANNOT_CONVERT);
+  }
 }
diff --git a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
index ff62080..e1e8785 100644
--- a/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/InlineAndCollapsePropertiesTest.java
@@ -42,6 +42,8 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
           "/** @constructor */ function String() {};",
           "var arguments");
 
+  private boolean assumeStaticInheritanceIsNotUsed = true;
+
   public InlineAndCollapsePropertiesTest() {
     super(EXTERNS);
   }
@@ -53,6 +55,7 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
         .setChunkOutputType(ChunkOutputType.GLOBAL_NAMESPACE)
         .setHaveModulesBeenRewritten(false)
         .setModuleResolutionMode(ResolutionMode.BROWSER)
+        .setAssumeStaticInheritanceIsNotUsed(this.assumeStaticInheritanceIsNotUsed)
         .build();
   }
 
@@ -65,6 +68,16 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDoNotCollapseDeletedProperty() {
+    testSame(
+        srcs(
+            lines(
+                "const global = window;", //
+                "delete global.HTMLElement;",
+                "global.HTMLElement = (class {});")));
+  }
+
+  @Test
   public void testConstObjRefInTemplateLiteralComputedPropKey() {
     test(
         srcs(
@@ -2724,6 +2737,69 @@ public final class InlineAndCollapsePropertiesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticMemberAccessedWithSuperAndThis() {
+    assumeStaticInheritanceIsNotUsed = false;
+    testSame(
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${super.classname} - is a subclass`;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testClassStaticMemberAccessedWithSuperAndThis2() {
+    assumeStaticInheritanceIsNotUsed = true;
+    test(
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${super.classname} - is a subclass`;",
+            "  }",
+            "}"),
+        lines(
+            "class Bar {", //
+            "  static get name() {",
+            "    return 'Bar';",
+            "  }",
+            "  static get classname() {",
+            "    return `${this.name} class`;",
+            "  }",
+            "}",
+            "class Baz extends Bar {",
+            "  static get name() {",
+            "    return 'Baz';",
+            "  }",
+            "  static get classname() {",
+            "    return `${Bar.classname} - is a subclass`;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testCommaCallAliasing1() {
     test(
         lines(
diff --git a/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
index eb7423e..71b8871 100644
--- a/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
+++ b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java
@@ -32,6 +32,7 @@ public final class InlineSimpleMethodsTest extends CompilerTestCase {
   @Before
   public void setUp() throws Exception {
     super.setUp();
+    enableGatherExternProperties();
     enableNormalize();
   }
 
@@ -44,6 +45,38 @@ public final class InlineSimpleMethodsTest extends CompilerTestCase {
   }
 
   @Test
+  public void testDoesNotInlineMethodOnBaseClass() {
+    String baseClassJS =
+        lines(
+            "class Base {",
+            "  constructor() {",
+            "    /** @const */",
+            "    this.prop_ =",
+            "        Math.random() > .5;",
+            "  }",
+            "  method() {",
+            "    return this.prop_;",
+            "  }",
+            "}");
+
+    String derivedClassJS =
+        lines(
+            "class Derived extends Base {",
+            "  constructor() {",
+            "    super();",
+            "  }",
+            "  derivedMethod() {",
+            "    super.method();",
+            "  }",
+            "}",
+            "",
+            "(new Derived()).derivedMethod();");
+
+    String source = baseClassJS + derivedClassJS;
+    testSame(source);
+  }
+
+  @Test
   public void testSimpleInline1() {
     testWithPrefix("function Foo(){}" +
         "Foo.prototype.bar=function(){return this.baz};",
diff --git a/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java b/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
index 805e01a..02cd934 100644
--- a/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
+++ b/test/com/google/javascript/jscomp/IsolatePolyfillsTest.java
@@ -27,6 +27,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,7 +47,7 @@ public final class IsolatePolyfillsTest extends CompilerTestCase {
 
   private boolean enablePropertyFlattening = false;
 
-  private void addLibrary(String name, String from, String to, String library) {
+  private void addLibrary(String name, String from, String to, @Nullable String library) {
     polyfillTable.add(String.format("%s %s %s %s", name, from, to, nullToEmpty(library)));
     polyfillsToInject.add(name);
   }
diff --git a/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java b/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
index f972add..bcd3fb2 100644
--- a/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
+++ b/test/com/google/javascript/jscomp/J2clEqualitySameRewriterPassTest.java
@@ -24,8 +24,6 @@ import org.junit.runners.JUnit4;
 public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
   private static final String EXTERN =
       "Equality.$same = function(opt_a, opt_b) {};\n"
-          // TODO(b/240961496): Remove old mangling scheme after migration is done.
-          + "String.m_equals__java_lang_String__java_lang_Object = function(opt_a, opt_b){}\n"
           + "String.m_equals__java_lang_String__java_lang_Object__boolean = function(opt_a,"
           + " opt_b) {};";
   ;
@@ -226,20 +224,6 @@ public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
             "'ABC' === a;"));
   }
 
-  // TODO(b/240961496): Remove test for old mangling scheme after migration is done.
-  @Test
-  public void testRewriteStringEquals_old() {
-    test(
-        LINE_JOINER.join(
-            "String.m_equals__java_lang_String__java_lang_Object('', 0);",
-            "var a = 'ABC';",
-            "String.m_equals__java_lang_String__java_lang_Object('ABC', a);"),
-        LINE_JOINER.join(
-            "'' === 0;", //
-            "var a = 'ABC';",
-            "'ABC' === a;"));
-  }
-
   @Test
   public void testNotRewriteStringEquals() {
     testSame(
@@ -248,10 +232,6 @@ public class J2clEqualitySameRewriterPassTest extends CompilerTestCase {
             "var b = null;",
             "String.m_equals__java_lang_String__java_lang_Object__boolean(b, null);",
             "String.m_equals__java_lang_String__java_lang_Object__boolean(null, b);",
-            "String.m_equals__java_lang_String__java_lang_Object__boolean(c, d);",
-            // TODO(b/240961496): Remove test for old mangling scheme after migration is done.
-            "String.m_equals__java_lang_String__java_lang_Object(b, null);",
-            "String.m_equals__java_lang_String__java_lang_Object(null, b);",
-            "String.m_equals__java_lang_String__java_lang_Object(c, d);"));
+            "String.m_equals__java_lang_String__java_lang_Object__boolean(c, d);"));
   }
 }
diff --git a/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java b/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
index 2bf61fb..fc7cfcd 100644
--- a/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
+++ b/test/com/google/javascript/jscomp/J2clStringValueOfRewriterPassTest.java
@@ -88,30 +88,4 @@ public final class J2clStringValueOfRewriterPassTest extends CompilerTestCase {
             "module$exports$java$lang$String$impl",
             "    .m_valueOf__java_lang_Object__java_lang_String([])"));
   }
-
-  @Test
-  public void testRemoveStringValueOf_old() {
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('')", "String('')");
-    test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(null)", "String(null)");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(undefined)", "'null'");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(void 0)", "'null'");
-    test(
-        lines(
-            "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('foo' +",
-            "    module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(bar))"),
-        "String('foo' + module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(bar))");
-    test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(foo + 'bar' + baz)",
-        "String(foo + 'bar' + baz)");
-    test(
-        "foo + module$exports$java$lang$String$impl.m_valueOf__java_lang_Object('bar' + baz)",
-        "foo + String('bar' + baz)");
-    test("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(1)", "String(1)");
-    test(
-        "module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(null + foo)",
-        "String(null + foo)");
-    testSame("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object(window)");
-    testSame("module$exports$java$lang$String$impl.m_valueOf__java_lang_Object([])");
-  }
 }
diff --git a/test/com/google/javascript/jscomp/JSChunkGraphTest.java b/test/com/google/javascript/jscomp/JSChunkGraphTest.java
index 8f745d6..bf895bc 100644
--- a/test/com/google/javascript/jscomp/JSChunkGraphTest.java
+++ b/test/com/google/javascript/jscomp/JSChunkGraphTest.java
@@ -34,6 +34,7 @@ import java.util.BitSet;
 import java.util.HashMap;
 import java.util.List;
 import java.util.stream.Collectors;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -49,7 +50,7 @@ public final class JSChunkGraphTest {
   private JSChunk moduleD;
   private JSChunk moduleE;
   private JSChunk moduleF;
-  private JSChunkGraph graph = null;
+  private @Nullable JSChunkGraph graph = null;
 
   // For resolving dependencies only.
   private Compiler compiler;
@@ -337,7 +338,7 @@ public final class JSChunkGraphTest {
     makeGraph();
     setUpManageDependenciesTest();
     DependencyOptions depOptions = DependencyOptions.pruneLegacyForEntryPoints(ImmutableList.of());
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     assertInputs(moduleA, "a1", "a3");
     assertInputs(moduleB, "a2", "b2");
@@ -356,7 +357,7 @@ public final class JSChunkGraphTest {
     DependencyOptions depOptions =
         DependencyOptions.pruneLegacyForEntryPoints(
             ImmutableList.of(ModuleIdentifier.forClosure("c2")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     assertInputs(moduleA, "a1", "a3");
     assertInputs(moduleB, "a2", "b2");
@@ -374,7 +375,7 @@ public final class JSChunkGraphTest {
     setUpManageDependenciesTest();
     DependencyOptions depOptions =
         DependencyOptions.pruneForEntryPoints(ImmutableList.of(ModuleIdentifier.forClosure("c2")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     // Everything gets pushed up into module c, because that's
     // the only one that has entry points.
@@ -403,7 +404,7 @@ public final class JSChunkGraphTest {
 
     DependencyOptions depOptions =
         DependencyOptions.pruneForEntryPoints(ImmutableList.of(ModuleIdentifier.forClosure("a1")));
-    List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+    ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
     // Everything gets pushed up into module c, because that's
     // the only one that has entry points.
@@ -417,7 +418,8 @@ public final class JSChunkGraphTest {
     makeDeps();
     makeGraph();
     setUpManageDependenciesTest();
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
 
     assertInputs(moduleA, "a1", "a2", "a3");
     assertInputs(moduleB, "b1", "b2");
@@ -444,7 +446,8 @@ public final class JSChunkGraphTest {
       input.setCompiler(compiler);
     }
 
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
 
     assertInputs(moduleA, "base.js", "a1", "a2");
 
@@ -455,7 +458,8 @@ public final class JSChunkGraphTest {
   public void testNoFiles() throws Exception {
     makeDeps();
     makeGraph();
-    List<CompilerInput> results = graph.manageDependencies(compiler, DependencyOptions.sortOnly());
+    ImmutableList<CompilerInput> results =
+        graph.manageDependencies(compiler, DependencyOptions.sortOnly());
     assertThat(results).isEmpty();
   }
 
@@ -536,7 +540,7 @@ public final class JSChunkGraphTest {
         input.setCompiler(compiler);
       }
 
-      List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+      ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
       assertInputs(moduleA, "base.js", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "a1");
 
@@ -594,7 +598,7 @@ public final class JSChunkGraphTest {
         input.setHasFullParseDependencyInfo(true);
       }
 
-      List<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
+      ImmutableList<CompilerInput> results = graph.manageDependencies(compiler, depOptions);
 
       assertInputs(
           moduleA,
@@ -929,7 +933,7 @@ public final class JSChunkGraphTest {
     assertDeepestCommonDepOneWay(expected, m2, m1, true);
   }
 
-  private void assertDeepestCommonDep(JSChunk expected, JSChunk m1, JSChunk m2) {
+  private void assertDeepestCommonDep(@Nullable JSChunk expected, JSChunk m1, JSChunk m2) {
     assertDeepestCommonDepOneWay(expected, m1, m2, false);
     assertDeepestCommonDepOneWay(expected, m2, m1, false);
   }
diff --git a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
index 668d3a8..a8bdb7c 100644
--- a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java
@@ -17,17 +17,14 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableMap;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -36,22 +33,10 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class JsMessageExtractorTest {
 
-  private JsMessage.Style mode;
-
-  @Before
-  public void setUp() throws Exception {
-    mode = JsMessage.Style.LEGACY;
-  }
-
   private Collection<JsMessage> extractMessages(String... js) {
-    try {
-      String sourceCode = Joiner.on("\n").join(js);
-      return new JsMessageExtractor(null, mode)
-          .extractMessages(SourceFile.fromCode("testcode", sourceCode));
-    } catch (IOException e) {
-      assertWithMessage(e.getMessage()).fail();
-      return null;
-    }
+    String sourceCode = Joiner.on("\n").join(js);
+    return new JsMessageExtractor(null)
+        .extractMessages(SourceFile.fromCode("testcode", sourceCode));
   }
 
   private JsMessage extractMessage(String... js) {
@@ -84,7 +69,11 @@ public final class JsMessageExtractorTest {
   public void testExtractNewStyleMessage1() {
     // A simple message with no description.
     assertEquals(
-        new JsMessage.Builder("MSG_SILLY").appendStringPart("silly test message").build(),
+        new JsMessage.Builder()
+            .setKey("MSG_SILLY")
+            .setId("MSG_SILLY")
+            .appendStringPart("silly test message")
+            .build(),
         extractMessage("var MSG_SILLY = goog.getMsg('silly test message');"));
   }
 
@@ -92,11 +81,13 @@ public final class JsMessageExtractorTest {
   public void testOriginalCodeAndExampleMaps() {
     // A message with placeholders and original code annotations.
     assertEquals(
-        new JsMessage.Builder("MSG_WELCOME")
+        new JsMessage.Builder()
+            .setKey("MSG_WELCOME")
+            .setId("MSG_WELCOME")
             .appendStringPart("Hi ")
-            .appendPlaceholderReference("interpolation_0")
+            .appendJsPlaceholderReference("interpolation_0")
             .appendStringPart("! Welcome to ")
-            .appendPlaceholderReference("interpolation_1")
+            .appendJsPlaceholderReference("interpolation_1")
             .appendStringPart(".")
             .setPlaceholderNameToOriginalCodeMap(
                 ImmutableMap.of(
@@ -133,11 +124,13 @@ public final class JsMessageExtractorTest {
   public void testExtractNewStyleMessage2() {
     // A message with placeholders and meta data.
     assertEquals(
-        new JsMessage.Builder("MSG_WELCOME")
+        new JsMessage.Builder()
+            .setKey("MSG_WELCOME")
+            .setId("MSG_WELCOME")
             .appendStringPart("Hi ")
-            .appendPlaceholderReference("userName")
+            .appendJsPlaceholderReference("userName")
             .appendStringPart("! Welcome to ")
-            .appendPlaceholderReference("product")
+            .appendJsPlaceholderReference("product")
             .appendStringPart(".")
             .setDesc("The welcome message.")
             .build(),
@@ -152,84 +145,6 @@ public final class JsMessageExtractorTest {
   }
 
   @Test
-  public void testExtractOldStyleMessage1() {
-    // Description before the message.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendStringPart("silly test message")
-            .setDesc("Description.")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY_HELP = 'Description.';", "var MSG_SILLY = 'silly test message';"));
-  }
-
-  @Test
-  public void testExtractOldStyleMessage2() {
-    // Description after the message, broken into parts.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendStringPart("silly test message")
-            .setDesc("Description.")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY = 'silly test message';", "var MSG_SILLY_HELP = 'Descrip' + 'tion.';"));
-  }
-
-  @Test
-  public void testExtractOldStyleMessage3() {
-    // Function-style message with two placeholders and no description.
-    assertEquals(
-        new JsMessage.Builder("MSG_SILLY")
-            .appendPlaceholderReference("one")
-            .appendStringPart(", ")
-            .appendPlaceholderReference("two")
-            .appendStringPart(", buckle my shoe")
-            .build(),
-        extractMessage(
-            "var MSG_SILLY = function(one, two) {",
-            "  return one + ', ' + two + ', buckle my shoe';",
-            "};"));
-  }
-
-  @Test
-  public void testExtractMixedMessages() {
-    // Several mixed-style messages in succession, one containing newlines.
-    Iterator<JsMessage> msgs =
-        extractMessages(
-                "var MSG_MONEY = function(amount) {",
-                "  return 'You owe $' + amount +",
-                "         ' to the credit card company.';",
-                "};",
-                "var MSG_TIME = goog.getMsg('You need to finish your work in ' +",
-                "                           '{$duration} hours.', {'duration': d});",
-                "var MSG_NAG = 'Clean your room.\\n\\nWash your clothes.';",
-                "var MSG_NAG_HELP = 'Just some ' +",
-                "                   'nags.';")
-            .iterator();
-
-    assertEquals(
-        new JsMessage.Builder("MSG_MONEY")
-            .appendStringPart("You owe $")
-            .appendPlaceholderReference("amount")
-            .appendStringPart(" to the credit card company.")
-            .build(),
-        msgs.next());
-    assertEquals(
-        new JsMessage.Builder("MSG_TIME")
-            .appendStringPart("You need to finish your work in ")
-            .appendPlaceholderReference("duration")
-            .appendStringPart(" hours.")
-            .build(),
-        msgs.next());
-    assertEquals(
-        new JsMessage.Builder("MSG_NAG")
-            .appendStringPart("Clean your room.\n\nWash your clothes.")
-            .setDesc("Just some nags.")
-            .build(),
-        msgs.next());
-  }
-
-  @Test
   public void testDuplicateUnnamedVariables() {
     // Make sure that duplicate unnamed variables don't get swallowed when using
     // a Google-specific ID generator.
@@ -244,8 +159,8 @@ public final class JsMessageExtractorTest {
 
     assertThat(msgs).hasSize(2);
     final Iterator<JsMessage> iter = msgs.iterator();
-    assertThat(iter.next().toString()).isEqualTo("foo");
-    assertThat(iter.next().toString()).isEqualTo("bar");
+    assertThat(iter.next().asJsMessageString()).isEqualTo("foo");
+    assertThat(iter.next().asJsMessageString()).isEqualTo("bar");
   }
 
   @Test
@@ -271,8 +186,8 @@ public final class JsMessageExtractorTest {
   private void assertEquals(JsMessage expected, JsMessage actual) {
     assertThat(actual.getId()).isEqualTo(expected.getId());
     assertThat(actual.getKey()).isEqualTo(expected.getKey());
-    assertThat(actual.parts()).isEqualTo(expected.parts());
-    assertThat(actual.placeholders()).isEqualTo(expected.placeholders());
+    assertThat(actual.getParts()).isEqualTo(expected.getParts());
+    assertThat(actual.jsPlaceholderNames()).isEqualTo(expected.jsPlaceholderNames());
     assertThat(actual.getDesc()).isEqualTo(expected.getDesc());
     assertThat(actual.getMeaning()).isEqualTo(expected.getMeaning());
   }
diff --git a/test/com/google/javascript/jscomp/JsMessageTest.java b/test/com/google/javascript/jscomp/JsMessageTest.java
index d828ff2..b9c8487 100644
--- a/test/com/google/javascript/jscomp/JsMessageTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageTest.java
@@ -22,28 +22,59 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * @author anatol@google.com (Anatol Pomazau)
- */
 @RunWith(JUnit4.class)
 public final class JsMessageTest {
 
   @Test
+  public void testIsLowerCamelCaseWithNumericSuffixes() {
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("name")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("NAME")).isFalse();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("Name")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("a4Letter")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("startSpan_1_23")).isTrue();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("startSpan_1_23b")).isFalse();
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isFalse();
+
+    assertThat(JsMessage.isLowerCamelCaseWithNumericSuffixes("")).isFalse();
+  }
+
+  @Test
+  public void testToLowerCamelCaseWithNumericSuffixes() {
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("NAME")).isEqualTo("name");
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isEqualTo("a4Letter");
+    assertThat(JsMessage.toLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23"))
+        .isEqualTo("startSpan_1_23");
+  }
+
+  @Test
   public void testIsEmpty() {
-    assertThat(new JsMessage.Builder().build().isEmpty()).isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("").build().isEmpty()).isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("").appendStringPart("").build().isEmpty())
+    assertThat(newTestMessageBuilder("MSG_KEY").build().isEmpty()).isTrue();
+    assertThat(newTestMessageBuilder("MSG_KEY").appendStringPart("").build().isEmpty()).isTrue();
+    assertThat(
+            newTestMessageBuilder("MSG_KEY")
+                .appendStringPart("")
+                .appendStringPart("")
+                .build()
+                .isEmpty())
         .isTrue();
-    assertThat(new JsMessage.Builder().appendStringPart("s").appendStringPart("").build().isEmpty())
+    assertThat(
+            newTestMessageBuilder("MSG_KEY")
+                .appendStringPart("s")
+                .appendStringPart("")
+                .build()
+                .isEmpty())
+        .isFalse();
+    assertThat(
+            newTestMessageBuilder("MSG_KEY").appendJsPlaceholderReference("ph").build().isEmpty())
         .isFalse();
-    assertThat(new JsMessage.Builder().appendPlaceholderReference("3").build().isEmpty()).isFalse();
   }
 
-  @Test
-  public void testMeaningChangesId() {
-    String id1 = new JsMessage.Builder().appendStringPart("foo").build().getId();
-    String id2 = new JsMessage.Builder().appendStringPart("foo").setMeaning("bar").build().getId();
-    assertThat(id1.equals(id2)).isFalse();
+  /** Return a new message builder that uses the given string as both its key and its ID. */
+  private JsMessage.Builder newTestMessageBuilder(String keyAndId) {
+    return new JsMessage.Builder().setKey(keyAndId).setId(keyAndId);
   }
 
   @Test
@@ -57,43 +88,35 @@ public final class JsMessageTest {
 
   @Test
   public void testNoAlternateId() {
-    JsMessage msg = new JsMessage.Builder().setDesc("Hello.").build();
+    JsMessage msg = newTestMessageBuilder("MSG_SOME_KEY").setDesc("Hello.").build();
     assertThat(msg.getDesc()).isEqualTo("Hello.");
-    assertThat(msg.getId()).isEqualTo("MSG_12MI20AMYO9T6");
+    assertThat(msg.getId()).isEqualTo("MSG_SOME_KEY");
     assertThat(msg.getAlternateId()).isNull();
   }
 
   @Test
   public void testSelfReferentialAlternateId() {
     JsMessage msg =
-        new JsMessage.Builder().setDesc("Hello.").setAlternateId("MSG_12MI20AMYO9T6").build();
+        newTestMessageBuilder("MSG_SOME_NAME")
+            .setDesc("Hello.")
+            .setAlternateId("MSG_SOME_NAME")
+            .build();
     assertThat(msg.getDesc()).isEqualTo("Hello.");
-    assertThat(msg.getId()).isEqualTo("MSG_12MI20AMYO9T6");
+    assertThat(msg.getId()).isEqualTo("MSG_SOME_NAME");
     assertThat(msg.getAlternateId()).isNull();
   }
 
   @Test
-  public void testGenerateIdWithGoogScope() {
-    JsMessage msg1 =
-        new JsMessage.Builder().setDesc("Hello.").setKey("$jscomp$scope$12345$0$MSG_HELLO").build();
-    assertThat(msg1.getDesc()).isEqualTo("Hello.");
-    assertThat(msg1.getId()).isEqualTo("MSG_HELLO");
-
-    JsMessage msg2 =
-        new JsMessage.Builder().setDesc("Test.").setKey("$jscomp$scope$m12345$0$MSG_TEST").build();
-    assertThat(msg2.getDesc()).isEqualTo("Test.");
-    assertThat(msg2.getId()).isEqualTo("MSG_TEST");
-  }
-
-  @Test
   public void testAlternateId() {
     JsMessage msg =
         new JsMessage.Builder()
+            .setKey("MSG_KEY")
             .setDesc("Hello.")
             .setAlternateId("foo")
             .setMeaning("meaning")
-            .appendPlaceholderReference("placeholder0")
-            .appendPlaceholderReference("placeholder1")
+            .setId("meaning")
+            .appendJsPlaceholderReference("placeholder0")
+            .appendJsPlaceholderReference("placeholder1")
             .appendStringPart("part0")
             .appendStringPart("part1")
             .appendStringPart("part2")
diff --git a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
index 8f36e4a..498e011 100644
--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java
@@ -17,26 +17,24 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE;
-import static com.google.javascript.jscomp.JsMessage.Style.LEGACY;
-import static com.google.javascript.jscomp.JsMessage.Style.RELAX;
+import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY;
 import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED;
-import static com.google.javascript.jscomp.JsMessageVisitor.isLowerCamelCaseWithNumericSuffixes;
-import static com.google.javascript.jscomp.JsMessageVisitor.toLowerCamelCaseWithNumericSuffixes;
 import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DESCRIPTION_EQUALITY;
 import static com.google.javascript.jscomp.testing.JSCompCorrespondences.DIAGNOSTIC_EQUALITY;
 import static com.google.javascript.jscomp.testing.JSErrorSubject.assertError;
+import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.debugging.sourcemap.FilePosition;
 import com.google.debugging.sourcemap.SourceMapGeneratorV3;
-import com.google.javascript.jscomp.JsMessage.Style;
+import com.google.javascript.jscomp.JsMessage.Part;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -67,16 +65,16 @@ public final class JsMessageVisitorTest {
     }
   }
 
-  private CompilerOptions compilerOptions;
+  private @Nullable CompilerOptions compilerOptions;
   private Compiler compiler;
   private List<JsMessage> messages;
-  private JsMessage.Style mode;
+  private List<JsMessageDefinition> messageDefinitions;
   private boolean renameMessages = false;
 
   @Before
   public void setUp() throws Exception {
     messages = new ArrayList<>();
-    mode = JsMessage.Style.LEGACY;
+    messageDefinitions = new ArrayList<>();
     compilerOptions = null;
     renameMessages = false;
   }
@@ -200,8 +198,8 @@ public final class JsMessageVisitorTest {
     extractMessages(
         LINE_JOINER.join(
             "/**", " * @enum {number}", " */", "var MyEnum = {", "  MSG_ONE: 0", "};"));
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -237,8 +235,8 @@ public final class JsMessageVisitorTest {
   public void testInvalidJsMessageOnObjLit() {
     extractMessages(
         "" + "pint.sub = {" + "  /** @desc a */ MSG_MENU_MARK_AS_UNREAD: undefined" + "}");
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -271,8 +269,8 @@ public final class JsMessageVisitorTest {
   @Test
   public void testMessageAliasedToObject_nonMSGNameIsNotAllowed() {
     extractMessages("a.b.MSG_FOO_ALIAS = someVarName;");
-    assertThat(compiler.getErrors()).hasSize(1);
-    assertError(compiler.getErrors().get(0)).hasType(MESSAGE_TREE_MALFORMED);
+    assertThat(compiler.getWarnings()).hasSize(1);
+    assertError(compiler.getWarnings().get(0)).hasType(MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -323,10 +321,10 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testOrphanedJsMessage() {
-    extractMessagesSafely("goog.getMsg('a')");
+    extractMessages("goog.getMsg('a')");
     assertThat(messages).isEmpty();
 
-    assertThat(compiler.getWarnings())
+    assertThat(compiler.getErrors())
         .comparingElementsUsing(DIAGNOSTIC_EQUALITY)
         .containsExactly(JsMessageVisitor.MESSAGE_NODE_IS_ORPHANED);
   }
@@ -352,9 +350,9 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
 
     JSError malformedTreeError = compiler.getErrors().get(0);
-    assertError(malformedTreeError).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertError(malformedTreeError).hasType(MESSAGE_TREE_MALFORMED);
     assertThat(malformedTreeError.getDescription())
-        .isEqualTo("Message parse tree malformed. " + "STRING or ADD node expected; found: POS");
+        .isEqualTo("Message parse tree malformed. literal string or concatenation expected");
   }
 
   @Test
@@ -368,7 +366,7 @@ public final class JsMessageVisitorTest {
 
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
-    assertThat(msg.toString()).isEqualTo("hello");
+    assertThat(msg.asJsMessageString()).isEqualTo("hello");
   }
 
   @Test
@@ -381,7 +379,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
 
     JSError malformedTreeError = compiler.getErrors().get(0);
-    assertError(malformedTreeError).hasType(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertError(malformedTreeError).hasType(MESSAGE_TREE_MALFORMED);
     assertThat(malformedTreeError.getDescription())
         .isEqualTo(
             "Message parse tree malformed."
@@ -389,85 +387,6 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testEmptyMessage() {
-    // This is an edge case. Empty messages are useless, but shouldn't fail
-    extractMessagesSafely("var MSG_EMPTY = '';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_EMPTY");
-    assertThat(msg.toString()).isEmpty();
-  }
-
-  @Test
-  public void testConcatOfStrings() {
-    extractMessagesSafely("var MSG_NOTEMPTY = 'aa' + 'bbb' \n + ' ccc';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_NOTEMPTY");
-    assertThat(msg.toString()).isEqualTo("aabbb ccc");
-  }
-
-  @Test
-  public void testLegacyFormatDescription() {
-    extractMessagesSafely(
-        "var MSG_SILLY = 'silly test message';\n" + "var MSG_SILLY_HELP = 'help text';");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("silly test message");
-  }
-
-  @Test
-  public void testLegacyFormatParametizedFunction() {
-    extractMessagesSafely(
-        "var MSG_SILLY = function(one, two) {"
-            + "  return one + ', ' + two + ', buckle my shoe';"
-            + "};");
-
-    assertThat(messages).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.getDesc()).isNull();
-    assertThat(msg.toString()).isEqualTo("{$one}, {$two}, buckle my shoe");
-  }
-
-  @Test
-  public void testLegacyMessageWithDescAnnotation() {
-    // Well, is was better do not allow legacy messages with @desc annotations,
-    // but people love to mix styles so we need to check @desc also.
-    extractMessagesSafely("/** @desc The description */ var MSG_A = 'The Message';");
-
-    assertThat(messages).hasSize(1);
-    assertThat(compiler.getWarnings()).isEmpty();
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_A");
-    assertThat(msg.toString()).isEqualTo("The Message");
-    assertThat(msg.getDesc()).isEqualTo("The description");
-  }
-
-  @Test
-  public void testLegacyMessageWithDescAnnotationAndHelpVar() {
-    mode = RELAX;
-
-    // Well, is was better do not allow legacy messages with @desc annotations,
-    // but people love to mix styles so we need to check @desc also.
-    extractMessagesSafely(
-        "var MSG_A_HELP = 'This is a help var';\n"
-            + "/** @desc The description in @desc*/ var MSG_A = 'The Message';");
-
-    assertThat(messages).hasSize(1);
-    assertThat(compiler.getWarnings()).hasSize(1);
-    JsMessage msg = messages.get(0);
-    assertThat(msg.getKey()).isEqualTo("MSG_A");
-    assertThat(msg.toString()).isEqualTo("The Message");
-    assertThat(msg.getDesc()).isEqualTo("The description in @desc");
-  }
-
-  @Test
   public void testClosureMessageWithHelpPostfix() {
     extractMessagesSafely("/** @desc help text */\n" + "var MSG_FOO_HELP = goog.getMsg('Help!');");
 
@@ -475,24 +394,22 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_FOO_HELP");
     assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("Help!");
+    assertThat(msg.asJsMessageString()).isEqualTo("Help!");
   }
 
   @Test
   public void testClosureMessageWithoutGoogGetmsg() {
-    mode = CLOSURE;
 
     extractMessages("var MSG_FOO_HELP = 'I am a bad message';");
 
     assertThat(messages).isEmpty();
     assertThat(compiler.getWarnings()).hasSize(1);
     assertError(compiler.getWarnings().get(0))
-        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testAllowOneMSGtoAliasAnotherMSG() {
-    mode = CLOSURE;
 
     // NOTE: tsickle code generation can end up creating new MSG_* variables that are temporary
     // aliases of existing ones that were defined correctly using goog.getMsg(). Don't complain
@@ -507,13 +424,12 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_FOO");
-    assertThat(msg.toString()).isEqualTo("Foo message");
+    assertThat(msg.asJsMessageString()).isEqualTo("Foo message");
     assertThat(compiler.getWarnings()).isEmpty();
   }
 
   @Test
   public void testDisallowOneMSGtoAliasNONMSG() {
-    mode = CLOSURE;
 
     // NOTE: tsickle code generation can end up creating new MSG_* variables that are temporary
     // aliases of existing ones that were defined correctly using goog.getMsg(). Don't complain
@@ -528,7 +444,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).isEmpty();
     assertThat(compiler.getWarnings()).hasSize(1);
     assertError(compiler.getWarnings().get(0))
-        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        .hasType(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -542,7 +458,7 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
     assertThat(msg.getDesc()).isEqualTo("help text");
-    assertThat(msg.toString()).isEqualTo("{$adjective} message");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} message");
   }
 
   @Test
@@ -572,7 +488,7 @@ public final class JsMessageVisitorTest {
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_HUGE");
     assertThat(msg.getDesc()).isEqualTo("A message with lots of stuff.");
-    assertThat(msg.toString())
+    assertThat(msg.asJsMessageString())
         .isEqualTo(
             "{$startLink_1}Google{$endLink}{$startLink_2}blah{$endLink}"
                 + "{$boo}{$foo_001}{$boo}{$foo_002}{$xxx_001}{$image}"
@@ -591,6 +507,24 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
+  public void testMeaningGetsUsedAsIdIfTheresNoGenerator() {
+    extractMessagesSafely(
+        lines(
+            "/**", //
+            " * @desc some description",
+            " * @meaning some meaning",
+            " */",
+            "var MSG_HULLO = goog.getMsg('Hullo');"));
+
+    assertThat(messages).hasSize(1);
+    JsMessage msg = messages.get(0);
+    assertThat(msg.getDesc()).isEqualTo("some description");
+    assertThat(msg.getKey()).isEqualTo("MSG_HULLO");
+    assertThat(msg.getMeaning()).isEqualTo("some meaning");
+    assertThat(msg.getId()).isEqualTo("some meaning");
+  }
+
+  @Test
   public void testEmptyTextMessage() {
     extractMessagesSafely("/** @desc text */ var MSG_FOO = goog.getMsg('');");
 
@@ -643,10 +577,9 @@ public final class JsMessageVisitorTest {
   public void testMsgVarWithIncorrectRightSide() {
     extractMessages("var MSG_SILLY = 0;");
 
-    assertThat(compiler.getErrors())
+    assertThat(compiler.getWarnings())
         .comparingElementsUsing(DESCRIPTION_EQUALITY)
-        .containsExactly(
-            "Message parse tree malformed. Cannot parse value of " + "message MSG_SILLY");
+        .containsExactly("message not initialized using goog.getMsg");
   }
 
   @Test
@@ -654,16 +587,13 @@ public final class JsMessageVisitorTest {
     extractMessages("DP_DatePicker.MSG_DATE_SELECTION = {};");
 
     assertThat(messages).isEmpty();
-    assertThat(compiler.getErrors())
+    assertThat(compiler.getWarnings())
         .comparingElementsUsing(DESCRIPTION_EQUALITY)
-        .containsExactly(
-            "Message parse tree malformed."
-                + " Message must be initialized using goog.getMsg function.");
+        .containsExactly("message not initialized using goog.getMsg");
   }
 
   @Test
   public void testUnrecognizedFunction() {
-    mode = CLOSURE;
     extractMessages("DP_DatePicker.MSG_DATE_SELECTION = somefunc('a')");
 
     assertThat(messages).isEmpty();
@@ -687,7 +617,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.toString()).isEqualTo("{$adjective} {$someNoun}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} {$someNoun}");
     assertThat(msg.getDesc()).isEqualTo("A message that demonstrates placeholders");
   }
 
@@ -708,7 +638,7 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_SILLY");
-    assertThat(msg.toString()).isEqualTo("{$adjective} {$someNoun}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$adjective} {$someNoun}");
     assertThat(msg.getDesc()).isEqualTo("A message that demonstrates placeholders");
   }
 
@@ -741,39 +671,15 @@ public final class JsMessageVisitorTest {
 
   @Test
   public void testIsValidMessageNameStrict() {
-    JsMessageVisitor visitor = new DummyJsVisitor(CLOSURE);
+    JsMessageVisitor visitor = new DummyJsVisitor();
 
-    assertThat(visitor.isMessageName("MSG_HELLO", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_HELP", true)).isTrue();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", true)).isTrue();
+    assertThat(visitor.isMessageName("MSG_HELLO")).isTrue();
+    assertThat(visitor.isMessageName("MSG_")).isTrue();
+    assertThat(visitor.isMessageName("MSG_HELP")).isTrue();
+    assertThat(visitor.isMessageName("MSG_FOO_HELP")).isTrue();
 
-    assertThat(visitor.isMessageName("_FOO_HELP", true)).isFalse();
-    assertThat(visitor.isMessageName("MSGFOOP", true)).isFalse();
-  }
-
-  @Test
-  public void testIsValidMessageNameRelax() {
-    JsMessageVisitor visitor = new DummyJsVisitor(RELAX);
-
-    assertThat(visitor.isMessageName("MSG_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", false)).isFalse();
-  }
-
-  @Test
-  public void testIsValidMessageNameLegacy() {
-    theseAreLegacyMessageNames(new DummyJsVisitor(RELAX));
-    theseAreLegacyMessageNames(new DummyJsVisitor(LEGACY));
-  }
-
-  private void theseAreLegacyMessageNames(JsMessageVisitor visitor) {
-    assertThat(visitor.isMessageName("MSG_HELLO", false)).isTrue();
-    assertThat(visitor.isMessageName("MSG_", false)).isTrue();
-
-    assertThat(visitor.isMessageName("MSG_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSG_FOO_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("_FOO_HELP", false)).isFalse();
-    assertThat(visitor.isMessageName("MSGFOOP", false)).isFalse();
+    assertThat(visitor.isMessageName("_FOO_HELP")).isFalse();
+    assertThat(visitor.isMessageName("MSGFOOP")).isFalse();
   }
 
   @Test
@@ -784,7 +690,7 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo(
             "Message parse tree malformed. Unrecognized message " + "placeholder referenced: foo");
@@ -797,7 +703,7 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo("Message parse tree malformed. Unused message placeholder: " + "foo");
   }
@@ -810,9 +716,9 @@ public final class JsMessageVisitorTest {
     ImmutableList<JSError> errors = compiler.getErrors();
     assertThat(errors).hasSize(1);
     JSError error = errors.get(0);
-    assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
-        .isEqualTo("Message parse tree malformed. Duplicate placeholder " + "name: foo");
+        .isEqualTo("Message parse tree malformed. duplicate string key: foo");
   }
 
   @Test
@@ -821,7 +727,7 @@ public final class JsMessageVisitorTest {
 
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
-    assertThat(msg.toString()).isEqualTo("{$foo}:, {$foo}");
+    assertThat(msg.asJsMessageString()).isEqualTo("{$foo}:, {$foo}");
   }
 
   @Test
@@ -833,17 +739,38 @@ public final class JsMessageVisitorTest {
     assertThat(messages).hasSize(1);
     JsMessage msg = messages.get(0);
     assertThat(msg.getKey()).isEqualTo("MSG_WITH_CAMELCASE");
-    assertThat(msg.toString()).isEqualTo("Slide {$slideNumber}:");
-    List<CharSequence> parts = msg.parts();
+    assertThat(msg.asJsMessageString()).isEqualTo("Slide {$slideNumber}:");
+    ImmutableList<Part> parts = msg.getParts();
     assertThat(parts).hasSize(3);
-    assertThat(((JsMessage.PlaceholderReference) parts.get(1)).getName()).isEqualTo("slideNumber");
+    assertThat(parts.get(1).getJsPlaceholderName()).isEqualTo("slideNumber");
+    assertThat(parts.get(1).getCanonicalPlaceholderName()).isEqualTo("SLIDE_NUMBER");
   }
 
   @Test
-  public void testWithNonCamelcasePlaceholderNamesAreNotOk() {
+  public void testNonCamelcasePlaceholderNamesAreNotOkInMsgText() {
     extractMessages(
-        "var MSG_WITH_CAMELCASE = goog.getMsg("
-            + "'Slide {$slide_number}:', {'slide_number': opt_index + 1});");
+        lines(
+            "var MSG_WITH_CAMELCASE = goog.getMsg(",
+            "    'Slide {$SLIDE_NUMBER}:',",
+            "    {'slideNumber': opt_index + 1});"));
+
+    assertThat(messages).isEmpty();
+    ImmutableList<JSError> errors = compiler.getErrors();
+    assertThat(errors).hasSize(1);
+    JSError error = errors.get(0);
+    assertThat(error.getType()).isEqualTo(MESSAGE_TREE_MALFORMED);
+    assertThat(error.getDescription())
+        .isEqualTo(
+            "Message parse tree malformed. Placeholder name not in lowerCamelCase: SLIDE_NUMBER");
+  }
+
+  @Test
+  public void testNonCamelcasePlaceholderNamesAreNotOkInPlaceholderObject() {
+    extractMessages(
+        lines(
+            "var MSG_WITH_CAMELCASE = goog.getMsg(",
+            "    'Slide {$slideNumber}:',",
+            "    {'SLIDE_NUMBER': opt_index + 1});"));
 
     assertThat(messages).isEmpty();
     ImmutableList<JSError> errors = compiler.getErrors();
@@ -852,8 +779,8 @@ public final class JsMessageVisitorTest {
     assertThat(error.getType()).isEqualTo(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
     assertThat(error.getDescription())
         .isEqualTo(
-            "Message parse tree malformed. Placeholder name not in "
-                + "lowerCamelCase: slide_number");
+            "Message parse tree malformed. Unrecognized message placeholder referenced:"
+                + " slideNumber");
   }
 
   @Test
@@ -866,29 +793,6 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testIsLowerCamelCaseWithNumericSuffixes() {
-    assertThat(isLowerCamelCaseWithNumericSuffixes("name")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("NAME")).isFalse();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("Name")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("a4Letter")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23")).isTrue();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23b")).isFalse();
-    assertThat(isLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isFalse();
-
-    assertThat(isLowerCamelCaseWithNumericSuffixes("")).isFalse();
-  }
-
-  @Test
-  public void testToLowerCamelCaseWithNumericSuffixes() {
-    assertThat(toLowerCamelCaseWithNumericSuffixes("NAME")).isEqualTo("name");
-    assertThat(toLowerCamelCaseWithNumericSuffixes("A4_LETTER")).isEqualTo("a4Letter");
-    assertThat(toLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")).isEqualTo("startSpan_1_23");
-  }
-
-  @Test
   public void testDuplicateMessageError() {
     extractMessages(
         "(function () {/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')})"
@@ -979,7 +883,7 @@ public final class JsMessageVisitorTest {
             + "/** @desc Hello */ var MSG_HELLO_2 = goog.getMsg('hello');\n"
             + "/** @desc Hello */ "
             + "var MSG_HELLO_3 = goog.getMsgWithFallback(MSG_HELLO_1, MSG_HELLO_2);");
-    assertOneError(JsMessageVisitor.MESSAGE_TREE_MALFORMED);
+    assertOneError(MESSAGE_TREE_MALFORMED);
   }
 
   @Test
@@ -1011,14 +915,229 @@ public final class JsMessageVisitorTest {
   }
 
   @Test
-  public void testGetMsgWithHtml() {
-    extractMessagesSafely("/** @desc Hello */ var MSG_HELLO = goog.getMsg('a', {}, {html: true})");
+  public void testGetMsgWithOptions() {
+    extractMessagesSafely(
+        lines(
+            "/** @desc Hello */",
+            "var MSG_HELLO =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        {",
+            "          'name': getName(),",
+            "        },",
+            "        {",
+            "          html: false,",
+            "          unescapeHtmlEntities: true,",
+            "          example: {",
+            "            'name': 'George',",
+            "          },",
+            "          original_code: {",
+            "            'name': 'getName()',",
+            "          },",
+            "        })"));
     assertThat(compiler.getWarnings()).isEmpty();
     assertThat(messages).hasSize(1);
 
     JsMessage msg = messages.get(0);
+    // MSG_HELLO =
     assertThat(msg.getKey()).isEqualTo("MSG_HELLO");
+    // * @desc Hello
     assertThat(msg.getDesc()).isEqualTo("Hello");
+
+    JsMessageDefinition msgDefinition = messageDefinitions.get(0);
+
+    // goog.getMsg(...)
+    final Node callNode = msgDefinition.getMessageNode();
+    assertNode(callNode).isCall().hasFirstChildThat().matchesQualifiedName("goog.getMsg");
+
+    assertNode(msgDefinition.getTemplateTextNode()).isString("Hello, {$name}");
+
+    // `{ 'name': getName() }`
+    final Node placeholderValuesNode = msgDefinition.getPlaceholderValuesNode();
+    assertNode(placeholderValuesNode).isObjectLit();
+    assertThat(callNode.getChildAtIndex(2)).isSameInstanceAs(placeholderValuesNode);
+
+    // placeholder name 'name' maps to the `getName()` call in the values map
+    final ImmutableMap<String, Node> placeholderValueMap = msgDefinition.getPlaceholderValueMap();
+    assertThat(placeholderValueMap.keySet()).containsExactly("name");
+    final Node nameValueNode = placeholderValueMap.get("name");
+    assertNode(nameValueNode).isCall().hasOneChildThat().isName("getName");
+    assertThat(nameValueNode.getGrandparent()).isSameInstanceAs(placeholderValuesNode);
+
+    // `html: false`
+    assertThat(msgDefinition.shouldEscapeLessThan()).isFalse();
+    // `unescapeHtmlEntities: true`
+    assertThat(msgDefinition.shouldUnescapeHtmlEntities()).isTrue();
+
+    // `example: { 'name': 'George' }`
+    assertThat(msg.getPlaceholderNameToExampleMap()).containsExactly("name", "George");
+    // `original_code: {'name': 'getName()' }`
+    assertThat(msg.getPlaceholderNameToOriginalCodeMap()).containsExactly("name", "getName()");
+  }
+
+  @Test
+  public void testGoogGetMsgWithNoArgs() {
+    extractMessages(
+        lines(
+            "/** @desc something */",
+            "const MSG_X = goog.getMsg();", // no arguments
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Message string literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadValuesArg() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        getName());", // should be an object literal
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadValuesKey() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        {",
+            "          [name]: getName()", // a computed key is not allowed
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. string key expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithBadOptionsArg() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        options);", // options bag must be an object literal
+            ""));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithComputedKeyInOptions() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          [options]: true", // option names cannot be computed keys
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. string key expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithUnknownOption() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          unknownOption: true", // not a valid option name
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Unknown option: unknownOption");
+  }
+
+  @Test
+  public void testGoogGetMsgWithInvalidBooleanOption() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          html: 'true'", // boolean option value must be a boolean literal
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. html: Literal true or false expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithOriginalCodeForInvalidExample() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          example: 'name: something'", // not an object literal
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. object literal expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithInvalidOriginalCodeValue() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          original_code: {",
+            "            'name': getName()", // value is not a string
+            "          }",
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. literal string or concatenation expected");
+  }
+
+  @Test
+  public void testGoogGetMsgWithOriginalCodeForUnknownPlaceholder() {
+    extractMessages(
+        lines(
+            "/** @desc something */", //
+            "const MSG_X =",
+            "    goog.getMsg(",
+            "        'Hello, {$name}',",
+            "        { 'name': getName() },",
+            "        {",
+            "          original_code: {",
+            "            'unknownPlaceholder': 'something'", // not a valid placeholder name
+            "          }",
+            "        });"));
+    assertThat(compiler.getErrors())
+        .comparingElementsUsing(DESCRIPTION_EQUALITY)
+        .containsExactly("Message parse tree malformed. Unknown placeholder: unknownPlaceholder");
   }
 
   @Test
@@ -1069,19 +1188,20 @@ public final class JsMessageVisitorTest {
   private class CollectMessages extends JsMessageVisitor {
 
     private CollectMessages(Compiler compiler) {
-      super(compiler, mode, null);
+      super(compiler, null);
     }
 
     @Override
     protected void processJsMessage(JsMessage message, JsMessageDefinition definition) {
       messages.add(message);
+      messageDefinitions.add(definition);
     }
   }
 
   private static class DummyJsVisitor extends JsMessageVisitor {
 
-    private DummyJsVisitor(Style style) {
-      super(null, style, null);
+    private DummyJsVisitor() {
+      super(null, null);
     }
 
     @Override
diff --git a/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
index b251403..794e289 100644
--- a/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
+++ b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java
@@ -24,6 +24,7 @@ import com.google.javascript.jscomp.LightweightMessageFormatter.LineNumberingFor
 import com.google.javascript.jscomp.SourceExcerptProvider.SourceExcerpt;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -276,12 +277,12 @@ public final class LightweightMessageFormatterTest {
     return new LightweightMessageFormatter(source(string, originalSource));
   }
 
-  private SourceExcerptProvider source(final String source, final String originalSource) {
+  private SourceExcerptProvider source(final String source, final @Nullable String originalSource) {
     return source(source, originalSource, -1);
   }
 
   private SourceExcerptProvider source(
-      final String source, final String originalSource, final int endLineNumber) {
+      final String source, final @Nullable String originalSource, final int endLineNumber) {
     return new SourceExcerptProvider() {
       @Override
       public String getSourceLine(String sourceName, int lineNumber) {
@@ -315,7 +316,7 @@ public final class LightweightMessageFormatterTest {
     };
   }
 
-  private String format(Region region) {
+  private String format(@Nullable Region region) {
     return new LineNumberingFormatter().formatRegion(region);
   }
 
diff --git a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
index 6523a02..054e9d9 100644
--- a/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
+++ b/test/com/google/javascript/jscomp/LiveVariablesAnalysisTest.java
@@ -27,6 +27,7 @@ import com.google.javascript.jscomp.NodeUtil.AllVarsDeclaredInFunction;
 import com.google.javascript.rhino.InputId;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -38,7 +39,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class LiveVariablesAnalysisTest {
 
-  private LiveVariablesAnalysis liveness = null;
+  private @Nullable LiveVariablesAnalysis liveness = null;
 
   @Test
   public void testStraightLine() {
@@ -360,11 +361,11 @@ public final class LiveVariablesAnalysisTest {
   @Test
   public void testArgumentsArray_doesNotEscape_destructuredParams() {
     // These cases also cover a crash related to assuming all RESTs have a NAME child.
-    assertNotEscaped("function f([a]) { arguments; }", "a");
-    assertNotEscaped("function f([a] = []) { arguments; }", "a");
-    assertNotEscaped("function f(...[a]) { arguments; }", "a");
-    assertNotEscaped("function f({a}) { arguments; }", "a");
-    assertNotEscaped("function f({a} = {}) { arguments; }", "a");
+    assertNotEscaped("function f([a]) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f([a] = []) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f(...[a]) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f({a}) { arguments; }", "a", Wrapper.NONE);
+    assertNotEscaped("function f({a} = {}) { arguments; }", "a", Wrapper.NONE);
   }
 
   @Test
@@ -420,19 +421,17 @@ public final class LiveVariablesAnalysisTest {
     assertEscaped("var _x", "_x");
   }
 
-  // TODO(b/235871861): Escaped properties are currently 'NotEscaped' for Static Blocks.
   @Test
   public void testEscapedInClassStaticBlock() {
-    // Expected: Escaped
-    assertNotEscaped("var a; class C{ static{a()}}", "a");
-    assertNotEscaped("var a; class C{static{ param1() } }", "param1");
+    assertEscaped("var a; class C{ static{a()}}", "a");
+    assertEscaped("var a; class C{static{ param1() } }", "param1");
   }
 
   @Test
   public void testNotEscapedInClassStaticBlock() {
     assertNotEscaped("var a; class C{static{}} a()", "a");
+    assertNotEscaped("let a; class C{static{let a;a()}}a()", "a");
     assertNotEscaped("var a; class C{static{var c; c()}}", "c");
-    assertNotEscaped("var a; class C{static{var a;a()}}a()", "a");
   }
 
   // ES6 does not require separate handling for catch because the catch block is already recognized
@@ -601,7 +600,12 @@ public final class LiveVariablesAnalysisTest {
 
   private LinearFlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX(
       String src, boolean async) {
-    liveness = computeLiveness(src, async);
+    if (async) {
+      liveness = computeLiveness(src, Wrapper.ASYNC_FUNCTION);
+    } else {
+      liveness = computeLiveness(src, Wrapper.FUNCTION);
+    }
+
     return getFlowStateAtX(liveness.getCfg().getEntry().getValue(), liveness.getCfg());
   }
 
@@ -623,7 +627,7 @@ public final class LiveVariablesAnalysisTest {
 
   private LinearFlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtDeclaration(
       String src, String name) {
-    liveness = computeLiveness(src, false);
+    liveness = computeLiveness(src);
     return getFlowStateAtDeclaration(
         liveness.getCfg().getEntry().getValue(), liveness.getCfg(), name);
   }
@@ -650,7 +654,7 @@ public final class LiveVariablesAnalysisTest {
   }
 
   private static void assertEscaped(String src, String name) {
-    for (Var var : computeLiveness(src, false).getEscapedLocals()) {
+    for (Var var : computeLiveness(src).getEscapedLocals()) {
       if (var.getName().equals(name)) {
         return;
       }
@@ -659,12 +663,25 @@ public final class LiveVariablesAnalysisTest {
   }
 
   private static void assertNotEscaped(String src, String name) {
-    for (Var var : computeLiveness(src, false).getEscapedLocals()) {
+    assertNotEscaped(src, name, Wrapper.FUNCTION);
+  }
+
+  /**
+   * @param wrapper The kind of wrapper function the {@code src} will be placed in.
+   */
+  private static void assertNotEscaped(String src, String name, Wrapper wrapper) {
+    for (Var var : computeLiveness(src, wrapper).getEscapedLocals()) {
       assertThat(var.getName()).isNotEqualTo(name);
     }
   }
 
-  private static LiveVariablesAnalysis computeLiveness(String src, boolean async) {
+  /** Wraps {@code src} in a function and computes a LiveVariablesAnalysis. */
+  private static LiveVariablesAnalysis computeLiveness(String src) {
+    return computeLiveness(src, Wrapper.FUNCTION);
+  }
+
+  /** Optionally wraps the {@code src} in a function and computes a LiveVariablesAnalysis. */
+  private static LiveVariablesAnalysis computeLiveness(String src, Wrapper wrapper) {
     // Set up compiler
     Compiler compiler = new Compiler();
     CompilerOptions options = new CompilerOptions();
@@ -674,8 +691,16 @@ public final class LiveVariablesAnalysisTest {
     compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
 
     // Set up test case
-    src =
-        (async ? "async " : "") + "function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+    switch (wrapper) {
+      case FUNCTION:
+        src = "function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+        break;
+      case ASYNC_FUNCTION:
+        src = "async function _FUNCTION(param1, param2 = 1, ...param3){" + src + "}";
+        break;
+      default:
+        break;
+    }
     Node n = compiler.parseTestCode(src).removeFirstChild();
     checkState(n.isFunction(), n);
     Node script = new Node(Token.SCRIPT, n);
@@ -706,4 +731,13 @@ public final class LiveVariablesAnalysisTest {
     analysis.analyze();
     return analysis;
   }
+
+  /** The kinds of functions that source code can be wrapped in for testing. */
+  private enum Wrapper {
+    NONE,
+    /** e.g. <code>function f(){ ... }</code> */
+    FUNCTION,
+    /** e.g. <code>async function f(){ ... }</code> */
+    ASYNC_FUNCTION
+  }
 }
diff --git a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
index f58ab64..ac6e66a 100644
--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java
@@ -35,7 +35,7 @@ public final class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
   private boolean invert = false;
   // removeConst = true; removes const-ness of a name (e.g. If the variable name is CONST)
   private boolean removeConst = false;
-  private final String localNamePrefix = "unique_";
+  private static final String LOCAL_NAME_PREFIX = "unique_";
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
@@ -48,8 +48,15 @@ public final class MakeDeclaredNamesUniqueTest extends CompilerTestCase {
           if (useDefaultRenamer) {
             renamer = new MakeDeclaredNamesUnique();
           } else {
-            renamer = new MakeDeclaredNamesUnique(new InlineRenamer(compiler.getCodingConvention(),
-                compiler.getUniqueNameIdSupplier(), localNamePrefix, removeConst, true, null));
+            renamer =
+                new MakeDeclaredNamesUnique(
+                    new InlineRenamer(
+                        compiler.getCodingConvention(),
+                        compiler.getUniqueNameIdSupplier(),
+                        LOCAL_NAME_PREFIX,
+                        removeConst,
+                        true,
+                        null));
           }
           NodeTraversal.traverseRoots(compiler, renamer, externs, root);
         }
diff --git a/test/com/google/javascript/jscomp/MinimizedConditionTest.java b/test/com/google/javascript/jscomp/MinimizedConditionTest.java
index 860aec2..79d5b16 100644
--- a/test/com/google/javascript/jscomp/MinimizedConditionTest.java
+++ b/test/com/google/javascript/jscomp/MinimizedConditionTest.java
@@ -39,8 +39,7 @@ public final class MinimizedConditionTest {
 
   private static Node parseExpr(String code) {
     Compiler compiler = new Compiler();
-    List<SourceFile> input =
-        ImmutableList.of(SourceFile.fromCode("code", code));
+    ImmutableList<SourceFile> input = ImmutableList.of(SourceFile.fromCode("code", code));
     List<SourceFile> externs = new ArrayList<>();
     CompilerOptions options = new CompilerOptions();
     compiler.init(externs, input, options);
diff --git a/test/com/google/javascript/jscomp/ModulesTestUtils.java b/test/com/google/javascript/jscomp/ModulesTestUtils.java
index 885e363..a8d97e8 100644
--- a/test/com/google/javascript/jscomp/ModulesTestUtils.java
+++ b/test/com/google/javascript/jscomp/ModulesTestUtils.java
@@ -19,10 +19,10 @@ package com.google.javascript.jscomp;
 import com.google.common.collect.ImmutableList;
 
 /**
- * Test utilities for testing modules, used by {@link Es6RewriteModulesTest}
- * and {@link ProcessCommonJSModulesTest}.
+ * Test utilities for testing modules, used by {@link Es6RewriteModulesTest} and {@link
+ * ProcessCommonJSModulesTest}.
  */
-class ModulesTestUtils {
+final class ModulesTestUtils {
 
   static void testModules(CompilerTestCase test, String fileName, String input, String expected) {
     // Shared with ProcessCommonJSModulesTest.
@@ -58,4 +58,6 @@ class ModulesTestUtils {
             SourceFile.fromCode("other.js", ""), SourceFile.fromCode("testcode.js", input));
     test.testWarning(CompilerTestCase.srcs(inputs), CompilerTestCase.warning(warning));
   }
+
+  private ModulesTestUtils() {}
 }
diff --git a/test/com/google/javascript/jscomp/MultiPassTest.java b/test/com/google/javascript/jscomp/MultiPassTest.java
index e6778f3..ed21896 100644
--- a/test/com/google/javascript/jscomp/MultiPassTest.java
+++ b/test/com/google/javascript/jscomp/MultiPassTest.java
@@ -430,7 +430,7 @@ public final class MultiPassTest extends CompilerTestCase {
                       getName(),
                       new PeepholeMinimizeConditions(late),
                       new PeepholeSubstituteAlternateSyntax(late),
-                      new PeepholeReplaceKnownMethods(late, false /* useTypes */),
+                      new PeepholeReplaceKnownMethods(late, /* useTypes= */ false),
                       new PeepholeRemoveDeadCode(),
                       new PeepholeFoldConstants(late, false /* useTypes */),
                       new PeepholeCollectPropertyAssignments());
diff --git a/test/com/google/javascript/jscomp/NodeTraversalTest.java b/test/com/google/javascript/jscomp/NodeTraversalTest.java
index bb2291d..cc43af9 100644
--- a/test/com/google/javascript/jscomp/NodeTraversalTest.java
+++ b/test/com/google/javascript/jscomp/NodeTraversalTest.java
@@ -24,6 +24,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallbackInterface;
+import com.google.javascript.jscomp.NodeTraversal.AbstractScopedCallback;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -484,6 +485,136 @@ public final class NodeTraversalTest {
   }
 
   @Test
+  public void testTraverseAtScopeWithMemberFieldDefScope() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope();
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  a = this.a;",
+            "}",
+            "class Bar extends Foo {",
+            "  b = super.a;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node memberFieldDefA =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getFirstChild(); // member field def
+    Scope memberFieldDefAScope = creator.createScope(memberFieldDefA, globalScope);
+
+    callback.expect(memberFieldDefA, memberFieldDefA);
+    t.traverseAtScope(memberFieldDefAScope);
+    callback.assertEntered();
+
+    Node memberFieldDefB =
+        tree // script
+            .getSecondChild() // class
+            .getLastChild() // class members
+            .getFirstChild(); // member field def
+    Scope memberFieldDefBScope = creator.createScope(memberFieldDefB, globalScope);
+
+    callback.expect(memberFieldDefB, memberFieldDefB);
+    t.traverseAtScope(memberFieldDefBScope);
+    callback.assertEntered();
+  }
+
+  @Test
+  public void testTraverseAtScopeWithComputedFieldDefScope() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope();
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  x = 'hi';",
+            "  [this.x] = this.x;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node computedFieldDef =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getLastChild(); // computed field def
+    Scope computedFieldDefScope = creator.createScope(computedFieldDef, globalScope);
+
+    callback.expect(computedFieldDef, computedFieldDef);
+    t.traverseAtScope(computedFieldDefScope);
+    callback.assertEntered();
+  }
+
+  @Test
+  public void testTraverseFieldDefScopeRootsInOrder() {
+    Compiler compiler = new Compiler();
+    String code =
+        lines(
+            "class Foo {", //
+            "  x = 'hi';",
+            "  [this.x] = this.x;",
+            "}");
+    Node tree = parse(compiler, code);
+    TokenAccumulator callback = new TokenAccumulator();
+    NodeTraversal.traverse(compiler, tree, callback);
+    assertThat(callback.scopeRoots)
+        .containsExactly(
+            Token.SCRIPT, Token.CLASS, Token.MEMBER_FIELD_DEF, Token.COMPUTED_FIELD_DEF)
+        .inOrder();
+  }
+
+  @Test
+  public void testTraverseComputedFieldsInOrder() {
+    Compiler compiler = new Compiler();
+    compiler.initCompilerOptionsIfTesting();
+    TokenAccumulator callback = new TokenAccumulator();
+    SyntacticScopeCreator creator = new SyntacticScopeCreator(compiler);
+    NodeTraversal.Builder t =
+        NodeTraversal.builder()
+            .setCompiler(compiler)
+            .setCallback(callback)
+            .setScopeCreator(creator);
+
+    String code =
+        lines(
+            "class Foo {", //
+            "  [this.x] = true;",
+            "}");
+
+    Node tree = parse(compiler, code);
+    Scope globalScope = creator.createScope(tree, null);
+    Node computedFieldDef =
+        tree // script
+            .getFirstChild() // class
+            .getLastChild() // class members
+            .getLastChild(); // computed field def
+    Scope computedFieldDefScope = creator.createScope(computedFieldDef, globalScope);
+
+    t.traverseAtScope(computedFieldDefScope);
+    assertThat(callback.tokens).containsExactly(Token.TRUE, Token.COMPUTED_FIELD_DEF).inOrder();
+
+    callback.tokens.clear();
+  }
+
+  @Test
   public void testGetVarAccessible() {
     Compiler compiler = new Compiler();
     CompilerOptions options = new CompilerOptions();
@@ -725,6 +856,22 @@ public final class NodeTraversalTest {
     }
   }
 
+  private static final class TokenAccumulator extends AbstractScopedCallback {
+
+    final List<Token> tokens = new ArrayList<>();
+    final List<Token> scopeRoots = new ArrayList<>();
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      tokens.add(n.getToken());
+    }
+
+    @Override
+    public void enterScope(NodeTraversal t) {
+      scopeRoots.add(t.getScopeRoot().getToken());
+    }
+  }
+
   // Helper class used to test getCurrentNode
   private static class ExpectNodeOnEnterScope extends NodeTraversal.AbstractPreOrderCallback
       implements NodeTraversal.ScopedCallback {
diff --git a/test/com/google/javascript/jscomp/NodeUtilTest.java b/test/com/google/javascript/jscomp/NodeUtilTest.java
index 1483d92..e5ca1fd 100644
--- a/test/com/google/javascript/jscomp/NodeUtilTest.java
+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java
@@ -79,7 +79,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
@@ -103,7 +103,7 @@ public final class NodeUtilTest {
 
   /** Provides methods for parsing and accessing the compiler used for the parsing. */
   private static class ParseHelper {
-    private Compiler compiler = null;
+    private @Nullable Compiler compiler = null;
 
     private Node parse(String js) {
       CompilerOptions options = new CompilerOptions();
@@ -189,8 +189,7 @@ public final class NodeUtilTest {
    * @return the first matching node, or {@code null} if none match.
    */
   // TODO(nickreid): Consider an overload that takes a `Predicate` rather than a `Token`.
-  @Nullable
-  private static Node getNodeOrNull(Node root, Token token) {
+  private static @Nullable Node getNodeOrNull(Node root, Token token) {
     for (Node n = root.getFirstChild(); n != null; n = n.getNext()) {
       if (n.getToken() == token) {
         return n;
@@ -252,7 +251,7 @@ public final class NodeUtilTest {
     public Tri expectedResult;
 
     @Parameters(name = "getBooleanValue(\"{0}\") => {1}")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // truly literal, side-effect free values are always known
@@ -483,11 +482,11 @@ public final class NodeUtilTest {
     }
 
     private boolean isLiteralValueExcludingFunctions(String code) {
-      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions */ false);
+      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions= */ false);
     }
 
     private boolean isLiteralValue(String code) {
-      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions */ true);
+      return NodeUtil.isLiteralValue(parseExpr(code), /* includeFunctions= */ true);
     }
 
     private void assertLiteralAndImmutable(Node n) {
@@ -3627,30 +3626,30 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInNodeWithNameDeclaration() {
-      assertThat(findLhsNodesInNode("var x;")).hasSize(1);
-      assertThat(findLhsNodesInNode("var x, y;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var f = function(x, y, z) {};")).hasSize(1);
+      assertThat(visitLhsNodesInNode("var x;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("var x, y;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var f = function(x, y, z) {};")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithArrayPatternDeclaration() {
-      assertThat(findLhsNodesInNode("var [x=a => a, y = b=>b+1] = arr;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var [x=a => a, y = b=>b+1, ...z] = arr;")).hasSize(3);
-      assertThat(findLhsNodesInNode("var [ , , , y = b=>b+1, ...z] = arr;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var [x=a => a, y = b=>b+1] = arr;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var [x=a => a, y = b=>b+1, ...z] = arr;")).hasSize(3);
+      assertThat(visitLhsNodesInNode("var [ , , , y = b=>b+1, ...z] = arr;")).hasSize(2);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithObjectPatternDeclaration() {
-      assertThat(findLhsNodesInNode("var {x = a=>a, y = b=>b+1} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {p1: x = a=>a, p2: y = b=>b+1} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {[pname]: x = a=>a, [p2name]: y} = obj;")).hasSize(2);
-      assertThat(findLhsNodesInNode("var {lhs1 = a, p2: [lhs2, lhs3 = b] = [notlhs]} = obj;"))
+      assertThat(visitLhsNodesInNode("var {x = a=>a, y = b=>b+1} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {p1: x = a=>a, p2: y = b=>b+1} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {[pname]: x = a=>a, [p2name]: y} = obj;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("var {lhs1 = a, p2: [lhs2, lhs3 = b] = [notlhs]} = obj;"))
           .hasSize(3);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithCastOnLhs() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("/** @type {*} */ (a.b) = 3;");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("/** @type {*} */ (a.b) = 3;");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).matchesQualifiedName("a.b");
@@ -3658,28 +3657,28 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInNodeWithArrayPatternAssign() {
-      assertThat(findLhsNodesInNode("[this.x] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[this.x, y] = rhs;")).hasSize(2);
-      assertThat(findLhsNodesInNode("[this.x, y, this.z] = rhs;")).hasSize(3);
-      assertThat(findLhsNodesInNode("[y, this.z] = rhs;")).hasSize(2);
-      assertThat(findLhsNodesInNode("[x[y]] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[x.y.z] = rhs;")).hasSize(1);
-      assertThat(findLhsNodesInNode("[ /** @type {*} */ (x.y.z) ] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[this.x] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[this.x, y] = rhs;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("[this.x, y, this.z] = rhs;")).hasSize(3);
+      assertThat(visitLhsNodesInNode("[y, this.z] = rhs;")).hasSize(2);
+      assertThat(visitLhsNodesInNode("[x[y]] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[x.y.z] = rhs;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("[ /** @type {*} */ (x.y.z) ] = rhs;")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInNodeWithComplexAssign() {
-      assertThat(findLhsNodesInNode("x += 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y += 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x -= 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y -= 1;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x *= 2;")).hasSize(1);
-      assertThat(findLhsNodesInNode("x.y *= 2;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x += 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y += 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x -= 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y -= 1;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x *= 2;")).hasSize(1);
+      assertThat(visitLhsNodesInNode("x.y *= 2;")).hasSize(1);
     }
 
     @Test
     public void testFindLhsNodesInForOfWithDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (const {x, y} of iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (const {x, y} of iterable) {}");
       assertThat(lhsNodes).hasSize(2);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3688,7 +3687,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForOfWithoutDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for ({x, y: a.b} of iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for ({x, y: a.b} of iterable) {}");
       assertThat(lhsNodes).hasSize(2);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3697,7 +3696,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForInWithDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (const x in obj) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (const x in obj) {}");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).isName("x");
@@ -3705,7 +3704,7 @@ public final class NodeUtilTest {
 
     @Test
     public void testFindLhsNodesInForInWithoutDeclaration() {
-      Iterable<Node> lhsNodes = findLhsNodesInNode("for (a.b in iterable) {}");
+      Iterable<Node> lhsNodes = visitLhsNodesInNode("for (a.b in iterable) {}");
       assertThat(lhsNodes).hasSize(1);
       Iterator<Node> nodeIterator = lhsNodes.iterator();
       assertNode(nodeIterator.next()).matchesQualifiedName("a.b");
@@ -4420,7 +4419,7 @@ public final class NodeUtilTest {
   public static final class GoogRequireInfoTest {
 
     @Parameters(name = "src={0}, name={1}, GoogRequire={2}")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             {
@@ -4493,7 +4492,7 @@ public final class NodeUtilTest {
   @RunWith(Parameterized.class)
   public static final class ReferencesReceiverTest {
     @Parameters(name = "\"{0}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       //
       //
       ImmutableMap<String, Boolean> templateToDefinesOwnReceiver =
@@ -4610,7 +4609,7 @@ public final class NodeUtilTest {
   public static final class GetRValueOfLValueTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // CLASS_MEMBERS
@@ -4641,7 +4640,7 @@ public final class NodeUtilTest {
   public static final class IteratesImpureIterableTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // ITER_SPREAD < ARRAYLIT
@@ -4745,7 +4744,7 @@ public final class NodeUtilTest {
   public static final class CanBeSideEffectedTest {
 
     @Parameters(name = "{0} in \"{1}\"")
-    public static Iterable<Object[]> cases() {
+    public static ImmutableList<Object[]> cases() {
       return ImmutableList.copyOf(
           new Object[][] {
             // TODO: Expand test cases for more node types.
@@ -4831,17 +4830,17 @@ public final class NodeUtilTest {
     return funcNode == NodeUtil.getRValueOfLValue(nameNode);
   }
 
-  private static void testFunctionName(String js, String expected) {
+  private static void testFunctionName(String js, @Nullable String expected) {
     assertThat(NodeUtil.getNearestFunctionName(parseFirst(FUNCTION, js))).isEqualTo(expected);
   }
 
   /**
-   * @param js JavaScript node to be passed to {@code NodeUtil.findLhsNodesInNode}. Must be either
+   * @param js JavaScript node to be passed to {@code NodeUtil.visitLhsNodesInNode}. Must be either
    *     an EXPR_RESULT containing an assignment operation (e.g. =, +=, /=, etc) in which case the
-   *     assignment node will be passed to {@code NodeUtil.findLhsNodesInNode}, or a VAR, LET, or
+   *     assignment node will be passed to {@code NodeUtil.visitLhsNodesInNode}, or a VAR, LET, or
    *     CONST statement, in which case the declaration statement will be passed.
    */
-  private static Iterable<Node> findLhsNodesInNode(String js) {
+  private static Iterable<Node> visitLhsNodesInNode(String js) {
     Node root = parse(js);
     checkState(root.isScript(), root);
     root = root.getOnlyChild();
@@ -4849,7 +4848,9 @@ public final class NodeUtilTest {
       root = root.getOnlyChild();
       checkState(NodeUtil.isAssignmentOp(root), root);
     }
-    return NodeUtil.findLhsNodesInNode(root);
+    ArrayList<Node> nodes = new ArrayList<>();
+    NodeUtil.visitLhsNodesInNode(root, nodes::add);
+    return nodes;
   }
 
   private static Node getNameNode(Node n, String name) {
@@ -4895,8 +4896,7 @@ public final class NodeUtilTest {
   /**
    * @return The first node in {@code tree} that is an array pattern or object pattern.
    */
-  @Nullable
-  private static Node getPattern(Node tree) {
+  private static @Nullable Node getPattern(Node tree) {
     if (tree.isDestructuringPattern()) {
       return tree;
     }
diff --git a/test/com/google/javascript/jscomp/NormalizeTest.java b/test/com/google/javascript/jscomp/NormalizeTest.java
index 78c7c98..3343ef3 100644
--- a/test/com/google/javascript/jscomp/NormalizeTest.java
+++ b/test/com/google/javascript/jscomp/NormalizeTest.java
@@ -22,6 +22,7 @@ import com.google.javascript.jscomp.CompilerOptions.ChunkOutputType;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.CompilerOptions.PropertyCollapseLevel;
 import com.google.javascript.jscomp.deps.ModuleLoader.ResolutionMode;
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -31,7 +32,9 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** @author johnlenz@google.com (John Lenz) */
+/**
+ * @author johnlenz@google.com (John Lenz)
+ */
 @RunWith(JUnit4.class)
 public final class NormalizeTest extends CompilerTestCase {
 
@@ -59,6 +62,15 @@ public final class NormalizeTest extends CompilerTestCase {
     return 1;
   }
 
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    // Validate that Normalize copies colors onto any nodes it synthesizes
+    enableTypeInfoValidation();
+    enableTypeCheck();
+    replaceTypesWithColors();
+  }
+
   @Test
   public void testNullishCoalesce() {
     test("var a = x ?? y, b = foo()", "var a = x ?? y; var b = foo()");
@@ -204,6 +216,7 @@ public final class NormalizeTest extends CompilerTestCase {
   public void testClassField() {
     test(
         lines(
+            "/** @unrestricted */",
             "class Foo {", //
             "  f1;",
             "  ['f2'] = 1;",
@@ -220,6 +233,51 @@ public final class NormalizeTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassStaticBlock() {
+    test(
+        lines(
+            "var x;",
+            "class Foo {", //
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "  }",
+            "}",
+            "class Bar {",
+            "  static {",
+            "    var x;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "}"),
+        lines(
+            "var x;",
+            "class Foo {", //
+            "  static {",
+            "    var x$jscomp$1;",
+            "    let y;",
+            "    this.x;",
+            "  }",
+            "  static {",
+            "    var x$jscomp$2;",
+            "    let y$jscomp$1;",
+            "  }",
+            "}",
+            "class Bar {",
+            "  static {",
+            "    var x$jscomp$3;",
+            "    let y$jscomp$2;",
+            "    this.x;",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testClassInForLoop() {
     testSame("for (class a {};;) { break; }");
   }
@@ -314,7 +372,7 @@ public final class NormalizeTest extends CompilerTestCase {
     test("x /= 1;", "x = x / 1;");
     test("x %= 1;", "x = x % 1;");
 
-    test("/** @suppress {const} */ x += 1;", "/** @suppress {const} */ x = x + 1;");
+    test("/** @suppress {const} */ x += 1;", "x = x + 1;");
   }
 
   @Test
@@ -431,7 +489,7 @@ public final class NormalizeTest extends CompilerTestCase {
     test(
         externs("var extern;"),
         srcs("/** @suppress {duplicate} */ var extern = 3;"),
-        expected("/** @suppress {duplicate} */ var extern = 3;"));
+        expected("var extern = 3;"));
   }
 
   @Test
@@ -465,6 +523,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForIn1() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-in
     testSame("for(a in b) foo();");
 
@@ -480,7 +540,10 @@ public final class NormalizeTest extends CompilerTestCase {
     test("if (x) for(var a in b) foo()", "if (x) { var a; for(a in b) foo() }");
 
     // Verify names in destructuring declarations are individually declared.
-    test("for (var [a, b] in c) foo();", "var a; var b; for ([a, b] in c) foo();");
+    test(
+        externs(new TestExternsBuilder().addIterable().addString().build()),
+        srcs("for (var [a, b] in c) foo();"),
+        expected("var a; var b; for ([a, b] in c) foo();"));
 
     test("for (var {a, b} in c) foo();", "var a; var b; for ({a: a, b: b} in c) foo();");
   }
@@ -495,6 +558,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForOf() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-of
     testSame("for (a of b) foo();");
 
@@ -517,6 +582,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testForAwaitOf() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     // Verify nothing happens with simple for-await-of
     testSame("async () => { for await (a of b) foo(); }");
 
@@ -618,6 +685,9 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testMakeLocalNamesUnique() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+    disableCompareJsDoc();
+
     // Verify global names are untouched.
     testSame("var a;");
 
@@ -676,6 +746,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testMakeParamNamesUnique() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test(
         "function f(x) { x; }\nfunction g(x) { x; }",
         "function f(x) { x; }\nfunction g(x$jscomp$1) { x$jscomp$1; }");
@@ -699,6 +771,7 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testNoRenameParamNames() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
     testSame("function f(x) { x; }");
 
     testSame("function f(...x) { x; }");
@@ -732,6 +805,10 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testRemoveDuplicateVarDeclarations3() {
+    ignoreWarnings(
+        TypeCheck.FUNCTION_MASKS_VARIABLE,
+        TypeValidator.TYPE_MISMATCH_WARNING,
+        TypeValidator.DUP_VAR_DECLARATION);
     test("var f = 1; function f(){}", "f = 1; function f(){}");
     test("var f; function f(){}", "function f(){}");
 
@@ -747,6 +824,7 @@ public final class NormalizeTest extends CompilerTestCase {
   // http://blickly.github.io/closure-compiler-issues/#290
   @Test
   public void testRemoveDuplicateVarDeclarations4() {
+    disableCompareJsDoc();
     testSame("if (!Arguments) { /** @suppress {duplicate} */ var Arguments = {}; }");
   }
 
@@ -917,6 +995,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testIsConstantByDestructuringWithDefault() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     test("var {CONST = 3} = {}; var b = CONST;", "var {CONST: CONST = 3} = {}; var b = CONST;");
     Node n = getLastCompiler().getRoot();
 
@@ -1041,6 +1121,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testShadowFunctionName() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test(
         lines("function f() {", "  var f = 'test';", "  console.log(f);", "}"),
         lines("function f() {", "  var f$jscomp$1 = 'test';", "  console.log(f$jscomp$1);", "}"));
@@ -1171,26 +1253,36 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testES6ShorthandPropertySyntax05() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a = 5} = obj;", "var {a: a = 5} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax06() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a = 5, b = 3} = obj;", "var {a: a = 5, b: b = 3} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax07() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a: a = 5, b = 3} = obj;", "var {a: a = 5, b: b = 3} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax08() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("var {a, b} = obj;", "var {a: a, b: b} = obj;");
   }
 
   @Test
   public void testES6ShorthandPropertySyntax09() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     test("({a = 5} = obj);", "({a: a = 5} = obj);");
   }
 
@@ -1206,6 +1298,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testES6ShorthandPropertySyntax12() {
+    ignoreWarnings(DiagnosticGroups.GLOBALLY_MISSING_PROPERTIES);
+
     testSame("({a: a = 5} = obj)");
   }
 
@@ -1221,7 +1315,9 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testRewriteExportSpecShorthand2() {
-    test("export {a, b as c, d};", "export {a as a, b as c, d as d};");
+    test(
+        "let a, b, d; export {a, b as c, d};",
+        "let a; let b; let d;export {a as a, b as c, d as d};");
   }
 
   @Test
@@ -1238,6 +1334,8 @@ public final class NormalizeTest extends CompilerTestCase {
 
   @Test
   public void testSplitExportDeclarationWithDestructuring() {
+    ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
+
     test("export var {} = {};", "var {} = {}; export {};");
     test(
         lines("let obj = {a: 3, b: 2};", "export var {a, b: d, e: f = 2} = obj;"),
diff --git a/test/com/google/javascript/jscomp/OptimizeCallsTest.java b/test/com/google/javascript/jscomp/OptimizeCallsTest.java
index b535038..234fbf4 100644
--- a/test/com/google/javascript/jscomp/OptimizeCallsTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeCallsTest.java
@@ -24,6 +24,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import java.util.ArrayList;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -36,7 +37,7 @@ public final class OptimizeCallsTest extends CompilerTestCase {
   private OptimizeCalls.ReferenceMap references;
 
   // Whether to consider externs during the next collection. Must be explicitly set.
-  private Boolean considerExterns = null;
+  private @Nullable Boolean considerExterns = null;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/OptimizeParametersTest.java b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
index ed8fd5d..ba2ed5f 100644
--- a/test/com/google/javascript/jscomp/OptimizeParametersTest.java
+++ b/test/com/google/javascript/jscomp/OptimizeParametersTest.java
@@ -1604,6 +1604,122 @@ public final class OptimizeParametersTest extends CompilerTestCase {
   }
 
   @Test
+  public void testRewriteClassStaticBlock_removeOptional() {
+    test(
+        lines(
+            "function foo(a,b=1){",
+            "  return a * b;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(a){",
+            "  var b = 1;",
+            "  return a * b;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a,b=1){",
+            "      return(a * b);",
+            "    }",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testRewriteClassStaticBlock_trailingUndefinedLiterals() {
+    test(
+        lines(
+            "function foo(a,b){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1, undefined, 2));",
+            "    use(foo(2));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(a,b){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a,b){",
+            "      return a;",
+            "    }",
+            "    use(foo(1, undefined, 2));",
+            "    use(foo(2));",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testRewriteClassStaticBlock_inlineParameter() {
+    test(
+        lines(
+            "function foo(a){",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "  }",
+            "}"),
+        lines(
+            "function foo(){",
+            "  var a = 1;",
+            "  return a;",
+            "}",
+            "class C {",
+            "  static {",
+            "    use(foo());",
+            "    use(foo());",
+            "    use(foo());",
+            "  }",
+            "}"));
+    // TODO(b/240443227): Function parameters inside class static blocks not optimized
+    testSame(
+        lines(
+            "class C {",
+            "  static {",
+            "    function foo(a){",
+            "      return(a);",
+            "    }",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "    use(foo(1));",
+            "  }",
+            "}"));
+  }
+
+  @Test
   public void testNoRewriteUsedClassConstructorWithClassNonstaticField() {
     testSame(
         lines(
@@ -1906,7 +2022,7 @@ public final class OptimizeParametersTest extends CompilerTestCase {
     for (Node call : calls) {
       assertThat(call.getSideEffectFlags())
           .isEqualTo(
-              new Node.SideEffectFlags(SideEffectFlags.NO_SIDE_EFFECTS)
+              new SideEffectFlags(SideEffectFlags.NO_SIDE_EFFECTS)
                   .setMutatesGlobalState()
                   .valueOf());
     }
diff --git a/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java b/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java
new file mode 100644
index 0000000..a1317df
--- /dev/null
+++ b/test/com/google/javascript/jscomp/ParenthesizeFunctionsInChunksTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import java.util.HashSet;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link ParenthesizeFunctionsInChunks} in isolation. */
+@RunWith(JUnit4.class)
+public final class ParenthesizeFunctionsInChunksTest extends CompilerTestCase {
+  private final HashSet<String> chunksToParaenthesize = new HashSet<>();
+  private static final String CHUNK_NAME_FOR_TEST = "$strong$";
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    disableValidateAstChangeMarking();
+  }
+
+  @Override
+  protected CompilerPass getProcessor(final Compiler compiler) {
+    return new ParenthesizeFunctionsInChunks(compiler, chunksToParaenthesize);
+  }
+
+  @Test
+  public void testFunctionWrappingWithParens_withinChunk() {
+    chunksToParaenthesize.add(CHUNK_NAME_FOR_TEST);
+    test("function f() {}", "var f = (function() {})");
+    test("var foo = function foo() {}", "var foo = (function foo() {})");
+    test("foo = function f() {}", "foo = (function f() {})");
+    test("const fn = function() {};", "const fn = (function() {});");
+    test("if (x < 3) { var fn = function() {}; }", "if (x < 3) { var fn = (function() {}); }");
+  }
+
+  @Test
+  public void testFunctionWrappingWithParens_outsideChunk() {
+    chunksToParaenthesize.clear();
+    testSame("function f() {}");
+    testSame("var foo = function foo() {}");
+    testSame("foo = function f() {}");
+    testSame("const fn = function() {};");
+    testSame("if (x < 3) { var fn = function() {}; }");
+  }
+}
diff --git a/test/com/google/javascript/jscomp/PartialCompilationTest.java b/test/com/google/javascript/jscomp/PartialCompilationTest.java
index 58ded58..e57c143 100644
--- a/test/com/google/javascript/jscomp/PartialCompilationTest.java
+++ b/test/com/google/javascript/jscomp/PartialCompilationTest.java
@@ -29,7 +29,6 @@ import com.google.javascript.rhino.jstype.NoType;
 import com.google.javascript.rhino.jstype.ObjectType;
 import com.google.javascript.rhino.jstype.UnionType;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import org.junit.Test;
@@ -173,7 +172,7 @@ public class PartialCompilationTest {
     assertWithMessage("type %s", x.getType()).that(x.getType().isUnionType()).isTrue();
     UnionType unionType = (UnionType) x.getType();
 
-    Collection<JSType> alternatives = unionType.getAlternates();
+    ImmutableList<JSType> alternatives = unionType.getAlternates();
     assertThat(alternatives).hasSize(3);
 
     int nullTypeCount = 0;
diff --git a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
index 8a9bf7f..12323e0 100644
--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java
@@ -23,9 +23,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.rhino.Node;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -2082,7 +2079,7 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
 
   @Test
   public void testInvertibleOperators() {
-    Map<String, String> inverses =
+    ImmutableMap<String, String> inverses =
         ImmutableMap.<String, String>builder()
             .put("==", "!=")
             .put("===", "!==")
@@ -2093,10 +2090,10 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
             .put("!=", "==")
             .put("!==", "===")
             .buildOrThrow();
-    Set<String> comparators = ImmutableSet.of("<=", "<", ">=", ">");
-    Set<String> equalitors = ImmutableSet.of("==", "===");
-    Set<String> uncomparables = ImmutableSet.of("undefined", "void 0");
-    List<String> operators = ImmutableList.copyOf(inverses.values());
+    ImmutableSet<String> comparators = ImmutableSet.of("<=", "<", ">=", ">");
+    ImmutableSet<String> equalitors = ImmutableSet.of("==", "===");
+    ImmutableSet<String> uncomparables = ImmutableSet.of("undefined", "void 0");
+    ImmutableList<String> operators = ImmutableList.copyOf(inverses.values());
     for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {
       for (int iOperandB = 0;
            iOperandB < LITERAL_OPERANDS.size();
@@ -2134,16 +2131,8 @@ public final class PeepholeFoldConstantsTest extends CompilerTestCase {
   @Test
   public void testCommutativeOperators() {
     late = true;
-    List<String> operators =
-        ImmutableList.of(
-            "==",
-            "!=",
-            "===",
-            "!==",
-            "*",
-            "|",
-            "&",
-            "^");
+    ImmutableList<String> operators =
+        ImmutableList.of("==", "!=", "===", "!==", "*", "|", "&", "^");
     for (String a : LITERAL_OPERANDS) {
       for (String b : LITERAL_OPERANDS) {
         for (String op : operators) {
diff --git a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
index 38dfb92..6f4f0b3 100644
--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java
@@ -47,7 +47,7 @@ public class PeepholeIntegrationTest extends CompilerTestCase {
         new PeepholeSubstituteAlternateSyntax(late),
         new PeepholeRemoveDeadCode(),
         new PeepholeFoldConstants(late, false /* useTypes */),
-        new PeepholeReplaceKnownMethods(late, false /* useTypes */));
+        new PeepholeReplaceKnownMethods(late, /* useTypes= */ false));
   }
 
   @Override
diff --git a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
index 09cd7d7..03a6a2a 100644
--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java
@@ -1775,4 +1775,22 @@ public final class PeepholeRemoveDeadCodeTest extends CompilerTestCase {
             "  }",
             "}"));
   }
+
+  @Test
+  public void testRemoveUnreachableOptionalChainingCall() {
+    fold("(null)?.();", "");
+    fold("(void 0)?.();", "");
+    fold("(undefined)?.();", "");
+    fold("(void 0)?.(0)", "");
+    fold("(void 0)?.(function f() {})", "");
+    // arguments with unknown side effects are also removed
+    fold("(void 0)?.(f(), g())", "");
+
+    // void arguments with unknown side effects are preserved
+    fold("(void f())?.();", "f();");
+    fold("g((void f())?.());", "g(void f());");
+
+    foldSame("(f(), null)?.()");
+    foldSame("f?.()");
+  }
 }
diff --git a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
index 0814ec6..6b4f6af 100644
--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java
@@ -22,7 +22,6 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.CompilerOptions.TracerMode;
 import com.google.javascript.jscomp.PhaseOptimizer.Loop;
-import com.google.javascript.jscomp.parsing.parser.FeatureSet;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
@@ -197,11 +196,6 @@ public final class PhaseOptimizerTest {
   }
 
   private PassFactory createPassFactory(String name, final CompilerPass pass, boolean isOneTime) {
-    return createPassFactory(name, pass, isOneTime, FeatureSet.latest());
-  }
-
-  private PassFactory createPassFactory(
-      String name, final CompilerPass pass, boolean isOneTime, FeatureSet featureSet) {
     return PassFactory.builder()
         .setName(name)
         .setRunInFixedPointLoop(!isOneTime)
diff --git a/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java b/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
index 1d7edd5..db8a612 100644
--- a/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
+++ b/test/com/google/javascript/jscomp/PolyfillUsageFinderTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
 import com.google.javascript.rhino.testing.NodeSubject;
 import java.util.function.Consumer;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -235,10 +236,10 @@ public final class PolyfillUsageFinderTest {
     }
 
     static final class Builder {
-      private Polyfills polyfillsTable = null;
-      private Compiler compiler = null;
-      private PolyfillUsageFinder polyfillUsageFinder = null;
-      private Node rootNode = null;
+      private @Nullable Polyfills polyfillsTable = null;
+      private @Nullable Compiler compiler = null;
+      private @Nullable PolyfillUsageFinder polyfillUsageFinder = null;
+      private @Nullable Node rootNode = null;
 
       Builder withPolyfillTableLines(String... polyfillTableLines) {
         polyfillsTable = Polyfills.fromTable(lines(polyfillTableLines));
@@ -344,7 +345,7 @@ public final class PolyfillUsageFinderTest {
       return this;
     }
 
-    PolyfillSubject hasKind(Polyfill.Kind expectedKind) {
+    PolyfillSubject hasKind(Kind expectedKind) {
       check("kind").that(actual.kind).isEqualTo(expectedKind);
       return this;
     }
diff --git a/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java b/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
index 013ea2c..ab63eb8 100644
--- a/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
+++ b/test/com/google/javascript/jscomp/PolymerBehaviorExtractorTest.java
@@ -27,6 +27,7 @@ import com.google.javascript.jscomp.modules.ModuleMetadataMap;
 import com.google.javascript.jscomp.modules.ModuleMetadataMap.ModuleMetadata;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -38,7 +39,7 @@ import org.junit.runners.JUnit4;
 public class PolymerBehaviorExtractorTest extends CompilerTypeTestCase {
 
   private PolymerBehaviorExtractor extractor;
-  private Node behaviorArray;
+  private @Nullable Node behaviorArray;
   private ModuleMetadataMap moduleMetadataMap;
 
   @Override
@@ -580,7 +581,7 @@ public class PolymerBehaviorExtractorTest extends CompilerTypeTestCase {
    * Tests that the behaviorArray resolves to exactly one behavior, using the provided
    * ModuleMetadata for behavior extraction.
    */
-  private void assertSingleBehaviorExtractionSucceeds(ModuleMetadata metadata) {
+  private void assertSingleBehaviorExtractionSucceeds(@Nullable ModuleMetadata metadata) {
     ImmutableList<BehaviorDefinition> defs = extractor.extractBehaviors(behaviorArray, metadata);
     assertThat(compiler.getErrors()).isEmpty();
     assertThat(defs).hasSize(1);
diff --git a/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java b/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
index 83ca5ec..cfea4d5 100644
--- a/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
+++ b/test/com/google/javascript/jscomp/PolymerClassDefinitionTest.java
@@ -22,6 +22,7 @@ import com.google.javascript.jscomp.modules.ModuleMap;
 import com.google.javascript.jscomp.modules.ModuleMetadataMap;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -30,7 +31,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class PolymerClassDefinitionTest extends CompilerTypeTestCase {
 
-  private Node polymerCall;
+  private @Nullable Node polymerCall;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/PolymerPassTest.java b/test/com/google/javascript/jscomp/PolymerPassTest.java
index ceaee3b..dc79264 100644
--- a/test/com/google/javascript/jscomp/PolymerPassTest.java
+++ b/test/com/google/javascript/jscomp/PolymerPassTest.java
@@ -27,7 +27,6 @@ import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNANNOTATED
 import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNEXPECTED_PARAMS;
 import static com.google.javascript.jscomp.PolymerPassErrors.POLYMER_UNQUALIFIED_BEHAVIOR;
 import static com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING;
-import static com.google.javascript.jscomp.modules.ModuleMapCreator.MISSING_NAMESPACE_IMPORT;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.javascript.jscomp.NodeUtil.Visitor;
@@ -546,7 +545,6 @@ public class PolymerPassTest extends CompilerTestCase {
 
   @Test
   public void testPolymerRewriterGeneratesDeclaration_OutsideModule_WithRequires() {
-    ignoreWarnings(MISSING_NAMESPACE_IMPORT);
     test(
         srcs(
             TestExternsBuilder.getClosureExternsAsSource(),
@@ -574,7 +572,6 @@ public class PolymerPassTest extends CompilerTestCase {
 
   @Test
   public void testPolymerRewriterGeneratesDeclaration_OutsideModule_WithRequires2() {
-    ignoreWarnings(MISSING_NAMESPACE_IMPORT);
     test(
         srcs(
             TestExternsBuilder.getClosureExternsAsSource(),
diff --git a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
index be6f0cd..7679411 100644
--- a/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
+++ b/test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java
@@ -19,7 +19,7 @@ package com.google.javascript.jscomp;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.javascript.jscomp.deps.ModuleLoader;
-import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,7 +28,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
-  private ImmutableList<String> moduleRoots = null;
+  private @Nullable ImmutableList<String> moduleRoots = null;
   private ModuleLoader.ResolutionMode resolutionMode = ModuleLoader.ResolutionMode.NODE;
 
   @Override
@@ -1003,7 +1003,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
                 + " __WEBPACK_AMD_DEFINE_RESULT__$$module$test))",
             "})()"));
 
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
@@ -1335,7 +1335,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequire() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "2", "yet_another.js",
@@ -1354,7 +1354,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequireString() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
@@ -1373,7 +1373,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackAMDModuleShim() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "test.js",
             "2", "/webpack/buildin/module.js");
@@ -1547,7 +1547,7 @@ public final class ProcessCommonJSModulesTest extends CompilerTestCase {
 
   @Test
   public void testWebpackRequireNamespace() {
-    Map<String, String> webpackModulesById =
+    ImmutableMap<String, String> webpackModulesById =
         ImmutableMap.of(
             "1", "other.js",
             "yet_another.js", "yet_another.js",
diff --git a/test/com/google/javascript/jscomp/ProcessTweaksTest.java b/test/com/google/javascript/jscomp/ProcessTweaksTest.java
index c7b82fb..b6addf9 100644
--- a/test/com/google/javascript/jscomp/ProcessTweaksTest.java
+++ b/test/com/google/javascript/jscomp/ProcessTweaksTest.java
@@ -57,7 +57,7 @@ public final class ProcessTweaksTest extends CompilerTestCase {
           ImmutableSet<String> emptySet = ImmutableSet.of();
           final StripCode stripCode =
               new StripCode(
-                  compiler, emptySet, emptySet, emptySet, /* enableTweakStripping */ true);
+                  compiler, emptySet, emptySet, emptySet, /* enableTweakStripping= */ true);
           stripCode.process(externs, root);
         }
       }
diff --git a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
index 34bc047..dc882f9 100644
--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java
@@ -26,6 +26,7 @@ import com.google.javascript.jscomp.testing.JSCompCorrespondences;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -626,7 +627,7 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
   public void testNoSideEffectsSimple() {
     String prefix = "function f(){";
     String suffix = "} f()";
-    List<String> expected = ImmutableList.of("f");
+    ImmutableList<String> expected = ImmutableList.of("f");
 
     assertPureCallsMarked(prefix + "" + suffix, expected);
     assertPureCallsMarked(prefix + "return 1" + suffix, expected);
@@ -3033,7 +3034,8 @@ public final class PureFunctionIdentifierTest extends CompilerTestCase {
     assertPureCallsMarked(source, expected, null);
   }
 
-  void assertPureCallsMarked(String source, final List<String> expected, final Postcondition post) {
+  void assertPureCallsMarked(
+      String source, final List<String> expected, final @Nullable Postcondition post) {
     testSame(
         srcs(source),
         postcondition(
diff --git a/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java b/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
index c5a2fab..db43467 100644
--- a/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
+++ b/test/com/google/javascript/jscomp/RandomNameGeneratorTest.java
@@ -69,7 +69,7 @@ public final class RandomNameGeneratorTest {
     // mocking Random to get nicer values. Instead, let's just try to
     // verify the sanity of the results.
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     String prefix = "prefix";
     int prefixLen = prefix.length();
     // Add a prefix to avoid dropping JavaScript keywords.
@@ -130,7 +130,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testFirstCharAlphabet() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", null, random);
     // Generate all 1- and 2-character names.
@@ -162,7 +162,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testPrefix() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     String prefix = "prefix";
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, prefix, null, random);
@@ -183,7 +183,7 @@ public final class RandomNameGeneratorTest {
     // Using different seeds should return different names.
     Random random0 = new Random(0);
     Random random1 = new Random(1);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng0 = new RandomNameGenerator(
         reservedNames, "", null, random0);
     RandomNameGenerator ng1 = new RandomNameGenerator(
@@ -206,7 +206,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testReservedNames() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of("x", "ba");
+    ImmutableSet<String> reservedNames = ImmutableSet.of("x", "ba");
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", null, random);
     // Generate all 1- and 2-character names (and a couple 3-character names,
@@ -226,7 +226,7 @@ public final class RandomNameGeneratorTest {
   @Test
   public void testReservedCharacters() throws Exception {
     Random random = new Random(0);
-    Set<String> reservedNames = ImmutableSet.of();
+    ImmutableSet<String> reservedNames = ImmutableSet.of();
     RandomNameGenerator ng = new RandomNameGenerator(
         reservedNames, "", new char[]{'a', 'b'}, random);
     // Generate all 1- and 2-character names (and also many 3-character names,
diff --git a/test/com/google/javascript/jscomp/ReachingUseDefTester.java b/test/com/google/javascript/jscomp/ReachingUseDefTester.java
index 6f0ca21..5341ce6 100644
--- a/test/com/google/javascript/jscomp/ReachingUseDefTester.java
+++ b/test/com/google/javascript/jscomp/ReachingUseDefTester.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
@@ -127,8 +128,8 @@ final class ReachingUseDefTester {
   /**
    * Returns may-be-reaching uses of definition of variable `x` on the node extracted at label `D:`.
    */
-  Collection<Node> getComputedUses() {
-    return reachingUse.getUses("x", labelFinder.extractedDef);
+  ImmutableSet<Node> getComputedUses() {
+    return ImmutableSet.copyOf(reachingUse.getUses("x", labelFinder.extractedDef));
   }
 
   /**
diff --git a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
index 0a80042..2afc0ad 100644
--- a/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
+++ b/test/com/google/javascript/jscomp/RecoverableJsAstTest.java
@@ -29,6 +29,7 @@ import java.nio.file.FileSystem;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -128,7 +129,10 @@ public class RecoverableJsAstTest {
     checkCompile(realAst, ast, expected, ImmutableList.<String>of());
   }
 
-  private void checkCompile(SourceAst realAst, RecoverableJsAst ast, String expected,
+  private void checkCompile(
+      SourceAst realAst,
+      RecoverableJsAst ast,
+      @Nullable String expected,
       ImmutableList<String> expectedErrors) {
     Compiler compiler = new Compiler();
 
diff --git a/test/com/google/javascript/jscomp/ReferenceCollectorTest.java b/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
index f1484ba..6d1edaf 100644
--- a/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
+++ b/test/com/google/javascript/jscomp/ReferenceCollectorTest.java
@@ -24,6 +24,7 @@ import com.google.common.truth.Correspondence;
 import com.google.javascript.jscomp.ReferenceCollector.Behavior;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +32,7 @@ import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
 public final class ReferenceCollectorTest extends CompilerTestCase {
-  private Behavior behavior;
+  private @Nullable Behavior behavior;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java b/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
index 0391fa9..3d3d1ac 100644
--- a/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnnecessarySyntheticExternsTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
 import java.util.LinkedHashSet;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,7 +29,7 @@ import org.junit.runners.JUnit4;
 public final class RemoveUnnecessarySyntheticExternsTest extends CompilerTestCase {
 
   // use this set to simulate an earlier compiler pass declaring a synthetic extern
-  private LinkedHashSet<Node> syntheticExternsToAdd = null;
+  private @Nullable LinkedHashSet<Node> syntheticExternsToAdd = null;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
index fb5e5b9..8b5d365 100644
--- a/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
+++ b/test/com/google/javascript/jscomp/RemoveUnusedCodeTest.java
@@ -29,6 +29,7 @@ import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -2214,17 +2215,17 @@ public final class RemoveUnusedCodeTest extends CompilerTestCase {
 
     // Input source code, which will be prefixed with the polyfills.
     // A value of `null` just means this hasn't been set yet.
-    private String inputSource = null;
+    private @Nullable String inputSource = null;
 
     // Expected output source code, which will be prefixed with the output version of each polyfill.
     // A value of `null` means this value hasn't been set yet or needs to be reset because
     // inputSource has changed.
-    private String expectedSource = null;
+    private @Nullable String expectedSource = null;
 
     // Set of polyfills that are expected to be removed by RemoveUnusedCode.
     // A value of `null` indicates that no expectation has been set since the last time inputSource
     // was modified.
-    private HashSet<String> polyfillsExpectedToBeRemoved = new HashSet<>();
+    private @Nullable HashSet<String> polyfillsExpectedToBeRemoved = new HashSet<>();
 
     @CanIgnoreReturnValue
     PolyfillRemovalTester addExterns(String moreExterns) {
diff --git a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
index 4352188..0916cef 100644
--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java
@@ -16,6 +16,7 @@
 
 package com.google.javascript.jscomp;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ public final class RenameLocalVarsTest extends CompilerTestCase {
   private String prefix = DEFAULT_PREFIX;
 
   // NameGenerator to use, or null for a default.
-  private DefaultNameGenerator nameGenerator = null;
+  private @Nullable DefaultNameGenerator nameGenerator = null;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
diff --git a/test/com/google/javascript/jscomp/RenamePropertiesTest.java b/test/com/google/javascript/jscomp/RenamePropertiesTest.java
index 72324e6..c6d425b 100644
--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java
+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.collect.ImmutableList;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +39,7 @@ public final class RenamePropertiesTest extends CompilerTestCase {
 
   private RenameProperties renameProperties;
   private boolean generatePseudoNames;
-  private VariableMap prevUsedPropertyMap;
+  private @Nullable VariableMap prevUsedPropertyMap;
 
   public RenamePropertiesTest() {
     super(EXTERNS);
diff --git a/test/com/google/javascript/jscomp/RenameVarsTest.java b/test/com/google/javascript/jscomp/RenameVarsTest.java
index 751a785..6c507ab 100644
--- a/test/com/google/javascript/jscomp/RenameVarsTest.java
+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java
@@ -30,7 +30,7 @@ import com.google.javascript.rhino.testing.NodeSubject;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -52,7 +52,7 @@ public final class RenameVarsTest extends CompilerTestCase {
   private boolean withNormalize = false;
 
   // NameGenerator to use, or null for a default.
-  private DefaultNameGenerator nameGenerator = null;
+  private @Nullable DefaultNameGenerator nameGenerator = null;
 
   @Override
   protected CodingConvention getCodingConvention() {
@@ -769,7 +769,7 @@ public final class RenameVarsTest extends CompilerTestCase {
       makeVariableMap("Foo", "z", "Bar", "z");
       testSame("");
       throw new AssertionError();
-    } catch (java.lang.IllegalArgumentException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -1169,8 +1169,8 @@ public final class RenameVarsTest extends CompilerTestCase {
   }
 
   private static void assertVariableMapsEqual(VariableMap a, VariableMap b) {
-    Map<String, String> ma = a.getOriginalNameToNewNameMap();
-    Map<String, String> mb = b.getOriginalNameToNewNameMap();
+    ImmutableMap<String, String> ma = a.getOriginalNameToNewNameMap();
+    ImmutableMap<String, String> mb = b.getOriginalNameToNewNameMap();
     assertWithMessage("VariableMaps not equal").that(mb).isEqualTo(ma);
   }
 
diff --git a/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java b/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
index 21d10ed..1775831 100644
--- a/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceCssNamesTest.java
@@ -84,7 +84,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
     };
   }
 
-  protected CssRenamingMap getPartialMap() {
+  CssRenamingMap getPartialMap() {
     return new CssRenamingMap.ByPart() {
       @Override
       public String get(String value) {
@@ -93,7 +93,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
     };
   }
 
-  protected CssRenamingMap getFullMap() {
+  CssRenamingMap getFullMap() {
     return new CssRenamingMap.ByWhole() {
       @Override public String get(String value) {
         return replacementMapFull.get(value);
@@ -127,7 +127,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'goog-colorswatch-disabled'");
     test("setClass(goog.getCssName('active-buttonbar'))",
          "setClass('active-buttonbar')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("goog", 2)
             .put("footer", 1)
@@ -162,7 +162,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'c'");
     test("setClass(goog.getCssName('elephant'))",
          "setClass('e')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("buttonbar", 1)
             .put("colorswatch", 1)
@@ -183,7 +183,7 @@ public final class ReplaceCssNamesTest extends CompilerTestCase {
          "el.className = 'g-c-d'");
     test("setClass(goog.getCssName('active-buttonbar'))",
          "setClass('a-b')");
-    Map<String, Integer> expected =
+    ImmutableMap<String, Integer> expected =
         new ImmutableMap.Builder<String, Integer>()
             .put("goog", 2)
             .put("footer", 1)
diff --git a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
index 4efee02..0e838da 100644
--- a/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceIdGeneratorsTest.java
@@ -20,6 +20,7 @@ import static com.google.common.truth.Truth.assertThat;
 import static com.google.javascript.jscomp.ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER;
 
 import com.google.common.collect.ImmutableMap;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,8 +34,8 @@ import org.junit.runners.JUnit4;
 public final class ReplaceIdGeneratorsTest extends CompilerTestCase {
 
   private boolean generatePseudoNames = false;
-  private ReplaceIdGenerators lastPass = null;
-  private String previousMappings = null;
+  private @Nullable ReplaceIdGenerators lastPass = null;
+  private @Nullable String previousMappings = null;
 
   @Override
   protected CompilerPass getProcessor(final Compiler compiler) {
@@ -60,7 +61,7 @@ public final class ReplaceIdGeneratorsTest extends CompilerTestCase {
                 .buildOrThrow(),
             generatePseudoNames,
             previousMappings,
-            null /* xidHashFunction */);
+            /* xidHashFunction= */ null);
     return lastPass;
   }
 
diff --git a/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java b/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
index c88a47c..b9a1aa3 100644
--- a/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceMessagesForChromeTest.java
@@ -16,9 +16,6 @@
 
 package com.google.javascript.jscomp;
 
-import static com.google.javascript.jscomp.JsMessage.Style.RELAX;
-
-import com.google.javascript.jscomp.JsMessage.Style;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -28,11 +25,9 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ReplaceMessagesForChromeTest extends CompilerTestCase {
 
-  private Style style = RELAX;
-
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
-    return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(null), style);
+    return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(null));
   }
 
   @Override
@@ -45,7 +40,6 @@ public final class ReplaceMessagesForChromeTest extends CompilerTestCase {
   @Before
   public void setUp() throws Exception {
     super.setUp();
-    style = RELAX;
     enableTypeCheck();
     replaceTypesWithColors();
     enableTypeInfoValidation();
diff --git a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
index 3024e62..c6d7650 100644
--- a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java
@@ -17,8 +17,7 @@
 package com.google.javascript.jscomp;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE;
-import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX;
+import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_NOT_INITIALIZED_CORRECTLY;
 import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
@@ -64,7 +63,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
     final ReplaceMessages replaceMessages =
-        new ReplaceMessages(compiler, new SimpleMessageBundle(), CLOSURE, strictReplacement);
+        new ReplaceMessages(compiler, new SimpleMessageBundle(), strictReplacement);
     switch (testMode) {
       case FULL_REPLACE:
         return replaceMessages.getFullReplacementPass();
@@ -251,7 +250,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testReplaceSimpleMessage() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         lines(
@@ -273,8 +272,79 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testReplaceExternalMessage() {
+    registerMessage(getTestMessageBuilder("12345").appendStringPart("Saluton!").build());
+
+    multiPhaseTest(
+        lines(
+            "/** @desc d */", //
+            "var MSG_EXTERNAL_12345 = goog.getMsg('Hello!');"),
+        lines(
+            "/**",
+            " * @desc d",
+            " */",
+            "var MSG_EXTERNAL_12345 =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_EXTERNAL_12345\",",
+            "          \"msg_text\":\"Hello!\",",
+            "        });"),
+        lines(
+            "/** @desc d */", //
+            "var MSG_EXTERNAL_12345='Saluton!'"));
+  }
+
+  @Test
+  public void testReplaceExternalIcuSelectorMessageWithPlaceholders() {
+    // Message in the bundle is in ICU selector format with has placeholders with explicit
+    // placeholders.
+    // The JS code treats the message as a simple string without placeholders.
+    // The compiler should join the placeholder names together with the string parts in order to
+    // get the runtime string value.
+    registerMessage(
+        getTestMessageBuilder("123456")
+            .appendStringPart("{USER_GENDER,select,female{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}male{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}other{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}}")
+            .build());
+
+    multiPhaseTest(
+        lines(
+            "/** @desc ICU gender-sensitive greeting */",
+            // Message in the JS code does not define placeholders for the compiler.
+            "const MSG_EXTERNAL_123456 = goog.getMsg(",
+            "    '{USER_GENDER,select,' +",
+            "    'female{Hello {USER_IDENTIFIER}.}' +",
+            "    'male{Hello {USER_IDENTIFIER}.}' +",
+            "    'other{Hello {USER_IDENTIFIER}.}}');"),
+        lines(
+            "/** @desc ICU gender-sensitive greeting */",
+            "const MSG_EXTERNAL_123456 =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_EXTERNAL_123456\",",
+            "          \"msg_text\":",
+            "    '{USER_GENDER,select,"
+                + "female{Hello {USER_IDENTIFIER}.}"
+                + "male{Hello {USER_IDENTIFIER}.}"
+                + "other{Hello {USER_IDENTIFIER}.}}',",
+            "        });"),
+        lines(
+            "/** @desc ICU gender-sensitive greeting */", //
+            "const MSG_EXTERNAL_123456 =",
+            "    '{USER_GENDER,select,"
+                + "female{Saluton {USER_IDENTIFIER}.}"
+                + "male{Saluton {USER_IDENTIFIER}.}"
+                + "other{Saluton {USER_IDENTIFIER}.}}';"));
+  }
+
+  @Test
   public void testReplaceSimpleMessageDefinedWithAdd() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         lines(
@@ -327,12 +397,12 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testAlternateMessageWithMismatchedParts() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("1984")
             .setDesc("B desc")
             .setMeaning("B meaning")
             .appendStringPart("Hello!")
             .appendStringPart(" Welcome!")
-            .build((meaning, messageParts) -> "1984"));
+            .build());
 
     multiPhaseTest(
         lines(
@@ -362,15 +432,82 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testAlternateIcuSelectorMessageWithPlaceholders() {
+    // Message in the bundle is in ICU selector format with has placeholders with explicit
+    // placeholders.
+    // The JS code treats the message as a simple string without placeholders.
+    // The compiler should join the placeholder names together with the string parts in order to
+    // get the runtime string value.
+    // Note that we are not putting a translation for the actual message from the JS Code into the
+    // bundle here. Instead, we are providing the alternate message.
+    registerMessage(
+        getTestMessageBuilder("1984")
+            .appendStringPart("{USER_GENDER,select,female{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}male{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}other{Saluton ")
+            .appendCanonicalPlaceholderReference("USER_IDENTIFIER")
+            .appendStringPart(".}}")
+            .build());
+
+    multiPhaseTest(
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            // Message in the JS code does not define placeholders for the compiler.
+            "const MSG_ICU_SELECT = goog.getMsg(",
+            "    '{USER_GENDER,select,' +",
+            "    'female{Hello {USER_IDENTIFIER}.}' +",
+            "    'male{Hello {USER_IDENTIFIER}.}' +",
+            "    'other{Hello {USER_IDENTIFIER}.}}');"),
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            "const MSG_ICU_SELECT =",
+            "    __jscomp_define_msg__(",
+            "        {",
+            "          \"key\":    \"MSG_ICU_SELECT\",",
+            "          \"alt_id\": \"1984\",",
+            "          \"msg_text\":",
+            "    '{USER_GENDER,select,"
+                + "female{Hello {USER_IDENTIFIER}.}"
+                + "male{Hello {USER_IDENTIFIER}.}"
+                + "other{Hello {USER_IDENTIFIER}.}}',",
+            "        });"),
+        lines(
+            "/**",
+            " * @desc ICU gender-sensitive greeting",
+            " * @alternateMessageId 1984",
+            " */",
+            "const MSG_ICU_SELECT =",
+            "    '{USER_GENDER,select,"
+                + "female{Saluton {USER_IDENTIFIER}.}"
+                + "male{Saluton {USER_IDENTIFIER}.}"
+                + "other{Saluton {USER_IDENTIFIER}.}}';"));
+  }
+
+  /**
+   * Returns a message builder that will use the same string as both the key and ID of the message.
+   */
+  private JsMessage.Builder getTestMessageBuilder(String keyAndId) {
+    return new JsMessage.Builder().setKey(keyAndId).setId(keyAndId);
+  }
+
+  @Test
   public void testAlternateMessageWithMismatchedPlaceholders() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("1984")
             .setDesc("B desc")
             .setMeaning("B meaning")
             .appendStringPart("Hello, ")
-            .appendPlaceholderReference("first_name")
+            .appendJsPlaceholderReference("firstName")
             .appendStringPart("!")
-            .build((meaning, messageParts) -> "1984"));
+            .build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -401,10 +538,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testReplaceValidAlternateMessage() {
-    registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
     multiPhaseTest(
         lines(
@@ -435,12 +569,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testIgnoreUnnecessaryAlternateMessage() {
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
     registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
-    registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .setDesc("Greeting.")
             .setAlternateId("1984")
             .appendStringPart("Hi\nthere")
@@ -476,12 +607,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testAlternateTrumpsFallback() {
-    registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("Good\nmorrow, sir").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("Good\nmorrow, sir").build());
 
     multiPhaseTest(
         lines(
@@ -532,10 +660,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testFallbackWithAlternate() {
-    registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendStringPart("Howdy\npardner")
-            .build((meaning, messageParts) -> "1984"));
+    registerMessage(getTestMessageBuilder("1984").appendStringPart("Howdy\npardner").build());
 
     multiPhaseTest(
         lines(
@@ -587,9 +712,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testNameReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -613,9 +738,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testNameReplacementWithFullOptionsBag() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -659,7 +784,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testGetPropReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_C").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -683,7 +808,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testFunctionCallReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_D").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_D").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines("/** @desc d */", "var MSG_D = goog.getMsg('${$amount}', {amount: getAmt()});"),
@@ -705,7 +830,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testMethodCallReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_E").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_E").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -728,7 +853,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testMethodCallReplacementEmptyMessage() {
-    registerMessage(new JsMessage.Builder("MSG_M").build());
+    registerMessage(getTestMessageBuilder("MSG_M").build());
 
     multiPhaseTest(
         lines(
@@ -750,9 +875,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testHookReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_F")
+        getTestMessageBuilder("MSG_F")
             .appendStringPart("#")
-            .appendPlaceholderReference("amount")
+            .appendJsPlaceholderReference("amount")
             .appendStringPart(".")
             .build());
 
@@ -776,7 +901,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testAddReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_G").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_G").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTest(
         lines(
@@ -799,12 +924,12 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testPlaceholderValueReferencedTwice() {
     registerMessage(
-        new JsMessage.Builder("MSG_H")
-            .appendPlaceholderReference("dick")
+        getTestMessageBuilder("MSG_H")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(", ")
-            .appendPlaceholderReference("dick")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(" and ")
-            .appendPlaceholderReference("jane")
+            .appendJsPlaceholderReference("jane")
             .build());
 
     multiPhaseTest(
@@ -826,11 +951,66 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
+  public void testInvalidMessageStringType() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */", //
+            "const MSG_H = goog.getMsg(10);"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testPlaceholderValueDefinedTwice() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y, jane: x});"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testInvalidPlaceholderArgument() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    'this should be an object literal');"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testInvalidOptionsArgumentType() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y},",
+            "    'should be an object literal');"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
+  public void testComputedKeyInOptions() {
+    multiPhaseTestPreLookupError(
+        lines(
+            "/** @desc d */",
+            "const MSG_H = goog.getMsg(",
+            "    '{$dick}{$jane}',",
+            "    {jane: x, dick: y},",
+            "    {[computedOpt]: true});"),
+        MESSAGE_TREE_MALFORMED);
+  }
+
+  @Test
   public void testPlaceholderNameInLowerCamelCase() {
     registerMessage(
-        new JsMessage.Builder("MSG_I")
+        getTestMessageBuilder("MSG_I")
             .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amtEarned")
+            .appendJsPlaceholderReference("amtEarned")
             .build());
 
     multiPhaseTest(
@@ -856,9 +1036,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testQualifiedMessageName() {
     registerMessage(
-        new JsMessage.Builder("MSG_J")
+        getTestMessageBuilder("MSG_J")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -886,10 +1066,10 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testPlaceholderInPlaceholderValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_L")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_L")
+            .appendJsPlaceholderReference("a")
             .appendStringPart(" has ")
-            .appendPlaceholderReference("b")
+            .appendJsPlaceholderReference("b")
             .build());
 
     multiPhaseTest(
@@ -925,7 +1105,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
         lines(
             "/** @desc d */", //
             "var MSG_E = 'd*6a0@z>t'"),
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -963,9 +1143,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testStrictModeAndMessageReplacementAbsentInNonEmptyBundle() {
     registerMessage(
-        new JsMessage.Builder("MSG_J")
+        getTestMessageBuilder("MSG_J")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -994,7 +1174,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "      {});",
             "};"),
         "var MSG_F = function() {return'asdf'}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -1011,7 +1191,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"measly\":measly});",
             "    };"),
         "var MSG_G = function(measly) { return 'asdf' + measly}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
@@ -1022,7 +1202,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testBadPlaceholderReferenceInReplacement() {
-    registerMessage(new JsMessage.Builder("MSG_K").appendPlaceholderReference("amount").build());
+    registerMessage(getTestMessageBuilder("MSG_K").appendJsPlaceholderReference("amount").build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -1040,8 +1220,13 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   }
 
   @Test
-  public void testEmptyObjLit() {
-    registerMessage(new JsMessage.Builder("MSG_E").appendPlaceholderReference("amount").build());
+  public void testTranslatedMessageWithPlaceholdersForGoogGetMsgWithoutAny() {
+    registerMessage(
+        getTestMessageBuilder("MSG_E")
+            .appendStringPart("You have purchased ")
+            .appendJsPlaceholderReference("amount")
+            .appendStringPart(" items.")
+            .build());
 
     multiPhaseTestPostLookupError(
         lines(
@@ -1054,34 +1239,33 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "    __jscomp_define_msg__({\"key\":\"MSG_E\", \"msg_text\":\"no placeholders\"});",
             ""),
         MESSAGE_TREE_MALFORMED,
-        "Message parse tree malformed. "
-            + "Empty placeholder value map for a translated message "
-            + "with placeholders.");
+        "Message parse tree malformed. The translated message has placeholders, but the definition"
+            + " in the JS code does not.");
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersVarSyntaxConcat() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_A = 'abc' + 'def';", //
         "var MSG_A = __jscomp_define_msg__({\"key\":\"MSG_A\", \"msg_text\":\"abcdef\"});",
         "var MSG_A = 'Hi\\nthere'",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersVarSyntax() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_A = 'd*6a0@z>t';", //
         "var MSG_A = __jscomp_define_msg__({\"key\":\"MSG_A\", \"msg_text\":\"d*6a0@z\\x3et\"});",
         "var MSG_A='Hi\\nthere'",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleNoPlaceholdersFunctionSyntax() {
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("Hi\nthere").build());
     multiPhaseTestWarning(
         "var MSG_B = function() {return 'asdf'};", //
         lines(
@@ -1094,15 +1278,15 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {});",
             "};"),
         "var MSG_B=function(){return'Hi\\nthere'}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleOnePlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_C")
+        getTestMessageBuilder("MSG_C")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
     multiPhaseTestWarning(
@@ -1117,16 +1301,16 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"measly\":measly});",
             "};"),
         "var MSG_C=function(measly){ return 'One ' + measly + ' ph'; }",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStyleTwoPlaceholders() {
     registerMessage(
-        new JsMessage.Builder("MSG_D")
-            .appendPlaceholderReference("dick")
+        getTestMessageBuilder("MSG_D")
+            .appendJsPlaceholderReference("dick")
             .appendStringPart(" and ")
-            .appendPlaceholderReference("jane")
+            .appendJsPlaceholderReference("jane")
             .build());
     multiPhaseTestWarning(
         "var MSG_D = function(jane, dick) {return jane + dick};", //
@@ -1141,15 +1325,15 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "};",
             ""),
         "var MSG_D = function(jane,dick) { return dick + ' and ' + jane; }",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testLegacyStylePlaceholderNameInLowerCamelCase() {
     registerMessage(
-        new JsMessage.Builder("MSG_E")
+        getTestMessageBuilder("MSG_E")
             .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amtEarned")
+            .appendJsPlaceholderReference("amtEarned")
             .build());
     multiPhaseTestWarning(
         "var MSG_E = function(amtEarned) {return amtEarned + 'x'};",
@@ -1163,51 +1347,30 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "        {\"amtEarned\":amtEarned});",
             "};"),
         "var MSG_E=function(amtEarned){return'Sum: $'+amtEarned}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
-  public void testLegacyStylePlaceholderNameInLowerUnderscoreCase() {
-    registerMessage(
-        new JsMessage.Builder("MSG_F")
-            .appendStringPart("Sum: $")
-            .appendPlaceholderReference("amt_earned")
-            .build());
-
-    // Placeholder named in lower-underscore case (discouraged nowadays)
+  public void testInvalidRhs() {
+    // If the RHS of a variable named `MSG_*` is not a function call, just report a warning.
     multiPhaseTestWarning(
-        "var MSG_F = function(amt_earned) {return amt_earned + 'x'};",
-        lines(
-            "var MSG_F = function(amt_earned) {",
-            "    return __jscomp_define_msg__(",
-            "        {",
-            "          \"key\":\"MSG_F\",",
-            "          \"msg_text\":\"{$amt_earned}x\"",
-            "        },",
-            "        {\"amt_earned\":amt_earned});",
-            "};"),
-        "var MSG_F=function(amt_earned){return'Sum: $'+amt_earned}",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
-  }
+        "var MSG_A = 'string value';",
+        "var MSG_A = 'string value';",
+        "var MSG_A = 'string value';",
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
 
-  @Test
-  public void testLegacyStyleBadPlaceholderReferenceInReplacement() {
-    registerMessage(
-        new JsMessage.Builder("MSG_B")
-            .appendStringPart("Ola, ")
-            .appendPlaceholderReference("chimp")
-            .build());
-
-    testWarning(
-        "var MSG_B = function(chump) {return chump + 'x'};",
-        MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX);
+    multiPhaseTestWarning(
+        "var MSG_A = 15 * 12;",
+        "var MSG_A = 15 * 12;",
+        "var MSG_A = 15 * 12;",
+        MESSAGE_NOT_INITIALIZED_CORRECTLY);
   }
 
   @Test
   public void testTranslatedPlaceHolderMissMatch() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1217,8 +1380,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedBadBooleanOptionValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1235,8 +1398,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedMisspelledExamples() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1249,8 +1412,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedMisspelledOriginalCode() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1263,8 +1426,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithUnknownPlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1276,8 +1439,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithNonStringPlaceholderValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1289,8 +1452,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithBadValue() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1302,8 +1465,8 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTranslatedExampleWithComputedProperty() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
-            .appendPlaceholderReference("a")
+        getTestMessageBuilder("MSG_A")
+            .appendJsPlaceholderReference("a")
             .appendStringPart("!")
             .build());
 
@@ -1371,7 +1534,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testUseFallback() {
-    registerMessage(new JsMessage.Builder("MSG_B").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_B").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1446,7 +1609,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testNoUseFallback() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1484,7 +1647,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testNoUseFallback2() {
-    registerMessage(new JsMessage.Builder("MSG_C").appendStringPart("translated").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendStringPart("translated").build());
     multiPhaseTest(
         lines(
             "/** @desc d */",
@@ -1522,7 +1685,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
 
   @Test
   public void testTemplateLiteralSimple() {
-    registerMessage(new JsMessage.Builder("MSG_A").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_A").appendStringPart("Hi\nthere").build());
 
     multiPhaseTest(
         "/** @desc d */\n var MSG_A = goog.getMsg(`asdf`);",
@@ -1543,9 +1706,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTemplateLiteralNameReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("One ")
-            .appendPlaceholderReference("measly")
+            .appendJsPlaceholderReference("measly")
             .appendStringPart(" ph")
             .build());
 
@@ -1571,7 +1734,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testTemplateLiteralSubstitutions() {
     // Only allow template literals that are constant strings
-    registerMessage(new JsMessage.Builder("MSG_C").appendStringPart("Hi\nthere").build());
+    registerMessage(getTestMessageBuilder("MSG_C").appendStringPart("Hi\nthere").build());
 
     multiPhaseTestPreLookupError(
         "/** @desc d */\n var MSG_C = goog.getMsg(`asdf ${42}`);",
@@ -1668,7 +1831,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testReplaceUnescapeHtmlEntitiesMessageWithReplacement() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .appendStringPart("User")
             .appendStringPart("&")
             .appendStringPart("apos;s &")
@@ -1698,7 +1861,7 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
             "var MSG_A = 'User\\'s < email & address > are \"correct\"';"));
 
     registerMessage(
-        new JsMessage.Builder("MSG_B")
+        getTestMessageBuilder("MSG_B")
             .appendStringPart("User")
             .appendStringPart("&apos;")
             .appendStringPart("s ")
@@ -1730,14 +1893,14 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
         "/** @desc d */\n var MSG_B = 'User\\'s < email & address > are \"correct\"';");
 
     registerMessage(
-        new JsMessage.Builder("MSG_C")
-            .appendPlaceholderReference("br")
+        getTestMessageBuilder("MSG_C")
+            .appendJsPlaceholderReference("br")
             .appendStringPart("&")
             .appendStringPart("amp;")
-            .appendPlaceholderReference("x")
-            .appendPlaceholderReference("y")
+            .appendJsPlaceholderReference("x")
+            .appendJsPlaceholderReference("y")
             .appendStringPart("&ap")
-            .appendPlaceholderReference("z")
+            .appendJsPlaceholderReference("z")
             .appendStringPart("os;")
             .build());
     multiPhaseTest(
@@ -1771,9 +1934,9 @@ public final class ReplaceMessagesTest extends CompilerTestCase {
   @Test
   public void testReplaceHtmlMessageWithPlaceholder() {
     registerMessage(
-        new JsMessage.Builder("MSG_A")
+        getTestMessageBuilder("MSG_A")
             .appendStringPart("Hello <") // html option changes `<` to `&lt;
-            .appendPlaceholderReference("br")
+            .appendJsPlaceholderReference("br")
             .appendStringPart("&gt;")
             .build());
 
diff --git a/test/com/google/javascript/jscomp/ReplaceStringsTest.java b/test/com/google/javascript/jscomp/ReplaceStringsTest.java
index 1b5dff4..8b28235 100644
--- a/test/com/google/javascript/jscomp/ReplaceStringsTest.java
+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java
@@ -40,7 +40,7 @@ public final class ReplaceStringsTest extends CompilerTestCase {
   private boolean runDisambiguateProperties;
   private boolean rename;
 
-  private final ImmutableList<String> defaultFunctionsToInspect =
+  private static final ImmutableList<String> DEFAULT_FUNCTIONS_TO_INSPECT =
       ImmutableList.of(
           "Error(?)",
           "goog.debug.Trace.startTracer(*)",
@@ -92,7 +92,7 @@ public final class ReplaceStringsTest extends CompilerTestCase {
     enableTypeCheck();
     enableNormalize();
     enableParseTypeInfo();
-    functionsToInspect = defaultFunctionsToInspect;
+    functionsToInspect = DEFAULT_FUNCTIONS_TO_INSPECT;
     runDisambiguateProperties = false;
     rename = false;
   }
diff --git a/test/com/google/javascript/jscomp/RewriteClassMembersTest.java b/test/com/google/javascript/jscomp/RewriteClassMembersTest.java
index 0a42df1..e666974 100644
--- a/test/com/google/javascript/jscomp/RewriteClassMembersTest.java
+++ b/test/com/google/javascript/jscomp/RewriteClassMembersTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.javascript.jscomp;
 
+import static com.google.javascript.jscomp.TranspilationUtil.CANNOT_CONVERT_YET;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -118,20 +120,22 @@ public final class RewriteClassMembersTest extends CompilerTestCase {
 
     testError(
         lines(
-            "foo(class {", //
+            "class A {}",
+            "foo(A.b.c = class C {", //
             "  static {",
-            "    let x = 1",
+            "    C.y = 2;",
+            "    let x = C.y",
             "  }",
             "})"),
         TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
 
     testError(
         lines(
-            "let c = class {", //
+            "foo(class {", //
             "  static {",
             "    let x = 1",
             "  }",
-            "}"),
+            "})"),
         TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
 
     testError(
@@ -194,13 +198,6 @@ public final class RewriteClassMembersTest extends CompilerTestCase {
 
     testError(
         lines(
-            "let c = class {", //
-            "  static x = 1",
-            "}"),
-        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
-
-    testError(
-        lines(
             "class C {", //
             "  x = 1;",
             "  y = this.x;",
@@ -209,33 +206,90 @@ public final class RewriteClassMembersTest extends CompilerTestCase {
 
     testError(
         lines(
-            "let c = class C {", //
-            "  y = 2;",
-            "  x = C.y",
-            "}"),
-        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
-
-    testError(
-        lines(
             "foo(class C {", //
-            "  y = 2;",
+            "  static y = 2;",
             "  x = C.y",
             "})"),
         TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
 
+    test(
+        srcs(
+            lines(
+                "class C {", //
+                "  static [1] = 1;",
+                "  static [2] = this[1];",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // use of `this`
+
+    test(
+        srcs(
+            lines(
+                "let c = class C {", //
+                "  static [1] = 2;",
+                "  static [2] = C[1]",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "foo(class C {", //
+                "  static [1] = 2;",
+                "  static [2] = C[1]",
+                "})")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
     testError(
         lines(
             "foo(class {", //
-            "  x = 1",
+            "  static [1] = 1",
             "})"),
         TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
 
-    testError(
-        lines(
-            "let c = class {", //
-            "  x = 1",
-            "}"),
-        TranspilationUtil.CANNOT_CONVERT_YET); // not class decl
+    test(
+        srcs(
+            lines(
+                "class C {", //
+                "  [1] = 1;",
+                "  [2] = this[1];",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // use of `this`
+
+    test(
+        srcs(
+            lines(
+                "let c = class C {", //
+                "  static [1] = 2;",
+                "  [2] = C[1]",
+                "}")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "foo(class C {", //
+                "  static [1] = 2;",
+                "  [2] = C[1]",
+                "})")),
+        error(TranspilationUtil.CANNOT_CONVERT_YET)); // not class decl
+
+    test(
+        srcs(
+            lines(
+                "let c = class {", //
+                "  x = 1",
+                "  y = this.x",
+                "}",
+                "class B {",
+                "  [1] = 2;",
+                "  [2] = this[1]",
+                "}" // testing that the correct number of diagnostics are thrown
+                )),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET),
+        error(TranspilationUtil.CANNOT_CONVERT_YET));
   }
 
   @Test
@@ -662,7 +716,7 @@ public final class RewriteClassMembersTest extends CompilerTestCase {
   }
 
   @Test
-  public void testNonStaticInstanceWithEmptyConstructor() {
+  public void testNonComputedInstanceWithEmptyConstructor() {
     test(
         lines(
             "class C {", //
@@ -895,4 +949,330 @@ public final class RewriteClassMembersTest extends CompilerTestCase {
             "  }",
             "}"));
   }
+
+  @Test
+  public void testNonClassDeclarationsStaticBlocks() {
+    test(
+        lines(
+            "let c = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        lines("let c = class {}", "{", "  let x = 1", "}"));
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        lines("class A {}", "A.c = class {}", "{", "  let x = 1", "}"));
+
+    testError(
+        lines(
+            "class A {}",
+            "A[1] = class {", //
+            "  static {",
+            "    let x = 1",
+            "  }",
+            "}"),
+        // lines("class A {}", "A[1] = class {}", "{", "  let x = 1", "}")
+        // TODO(b/189993301): transpile computed prop = class
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsStaticNoncomputedFields() {
+    test(
+        lines(
+            "let c = class {", //
+            "  static x = 1",
+            "}"),
+        lines("let c = class {}", "c.x = 1"));
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  static x = 1",
+            "}"),
+        lines("class A {}", "A.c = class {}", "A.c.x = 1"));
+
+    testError(
+        lines(
+            "class A {}",
+            "A[1] = class {", //
+            "  static x = 1",
+            "}"),
+        // lines("class A {}", "A[1] = class {}", "A[1].x = 1")
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsInstanceNoncomputedFields() {
+    test(
+        lines(
+            "let c = class {", //
+            "  y = 2;",
+            "}"),
+        lines(
+            "let c = class {", //
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "let c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    test(
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  y = 2;",
+            "}"),
+        lines(
+            "class A {}",
+            "A.c = class {", //
+            "  constructor() {",
+            "    this.y = 2;",
+            "  }",
+            "}"));
+
+    testError(
+        lines(
+            "A[1] = class {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "A[1] = class {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "foo(class {", //
+            "  y = 2;",
+            "})"),
+        /*lines("foo(class {", "  constructor() {", "    this.y = 2;", "  }", "})")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "let c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "class A {}",
+            "A.c = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "class A {}",
+        "A.c = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "A[1] = class C {", //
+            "  y = 2;",
+            "}"),
+        /*lines(
+        "A[1] = class C {", //
+        "  constructor() {",
+        "    this.y = 2;",
+        "  }",
+        "}")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "foo(class C {", //
+            "  y = 2;",
+            "})"),
+        /*lines("foo(class C {", "  constructor() {", "    this.y = 2;", "  }", "})")*/
+        TranspilationUtil.CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testConstuctorAndStaticFieldDontConflict() {
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  static y = x",
+            "  constructor(x) {}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor(x) {}",
+            "}",
+            "C.y = x"));
+  }
+
+  @Test
+  public void testInstanceInitializerShadowsConstructorDeclaration() {
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { let x;}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { {var x;} }",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    testError(
+        lines(
+            "function f() { return 4; };", //
+            "class C {",
+            "  y = f();",
+            "  constructor() {function f() { return 'str'; }}",
+            "}"),
+        CANNOT_CONVERT_YET);
+
+    // TODO(b/189993301): Technically this has no shadowing, so we could inline without renaming
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = (x) => x;",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testInstanceInitializerDoesntShadowConstructorDeclaration() {
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() { {let x;} }",
+            "}"),
+        lines(
+            "let x = 2;",
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    {let x;}",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() {() => { let x; };}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    () => { let x; };",
+            "  }",
+            "}"));
+
+    test(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = x",
+            "  constructor() {(x) => 3;}",
+            "}"),
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  constructor() {",
+            "    this.y = x;",
+            "    (x) => 3;",
+            "  }",
+            "}"));
+  }
+
+  @Test
+  public void testInstanceFieldInitializersDontBleedOut() {
+    test(
+        lines("class C {", "  y = z", "  method() { x; }", "  constructor(x) {}", "}"),
+        lines(
+            "class C {", "  method() { x; }", "  constructor(x) {", "    this.y = z;", "  }", "}"));
+  }
+
+  @Test
+  public void testNestedClassesWithShadowingInstanceFields() {
+    testError(
+        lines(
+            "let x = 2;", //
+            "class C {",
+            "  y = () => {",
+            "    class Foo { z = x };",
+            "  };",
+            "  constructor(x) {}",
+            "}"),
+        CANNOT_CONVERT_YET);
+  }
+
+  @Test
+  public void testNonClassDeclarationsFunctionArgs() {
+    testError(
+        "A[foo()] = class {static x;}",
+        TranspilationUtil.CANNOT_CONVERT_YET); // impure computed prop
+
+    testError(
+        "foo(c = class {static x;})", TranspilationUtil.CANNOT_CONVERT_YET); // named function param
+
+    testError(
+        "function foo(c = class {static x;}) {}",
+        TranspilationUtil.CANNOT_CONVERT_YET); // default function param
+  }
 }
diff --git a/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java b/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
index fdfd5bf..de2917c 100644
--- a/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
+++ b/test/com/google/javascript/jscomp/RewriteDynamicImportsTest.java
@@ -32,6 +32,7 @@ import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
 import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -40,9 +41,9 @@ import org.junit.runners.JUnit4;
 /** Unit tests for {@link RewriteDynamicImports} */
 @RunWith(JUnit4.class)
 public class RewriteDynamicImportsTest extends CompilerTestCase {
-  private String dynamicImportAlias = "imprt_";
-  private LanguageMode language = null;
-  private LanguageMode languageIn = null;
+  private @Nullable String dynamicImportAlias = "imprt_";
+  private @Nullable LanguageMode language = null;
+  private @Nullable LanguageMode languageIn = null;
   private ChunkOutputType chunkOutputType = ChunkOutputType.GLOBAL_NAMESPACE;
 
   public RewriteDynamicImportsTest() {
diff --git a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
index b27595d..09c95c0 100644
--- a/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
+++ b/test/com/google/javascript/jscomp/RewritePolyfillsTest.java
@@ -26,6 +26,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,7 +46,7 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
   private boolean isolatePolyfills = false;
   private boolean injectPolyfills = true;
 
-  private void addLibrary(String name, String from, String to, String library) {
+  private void addLibrary(String name, String from, String to, @Nullable String library) {
     if (library != null) {
       injectableLibraries.put(
           library,
@@ -82,7 +83,7 @@ public final class RewritePolyfillsTest extends CompilerTestCase {
   @Override
   protected Compiler createCompiler() {
     return new NoninjectingCompiler() {
-      Node lastInjected = null;
+      @Nullable Node lastInjected = null;
 
       @Override
       public Node ensureLibraryInjected(String library, boolean force) {
diff --git a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
index f6dc81e..d9245c9 100644
--- a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java
@@ -22,7 +22,6 @@ import static com.google.javascript.jscomp.parsing.JsDocInfoParser.BAD_TYPE_WIKI
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -134,9 +133,8 @@ public final class RhinoErrorReporterTest {
 
     options.setLanguageIn(languageIn);
 
-    List<SourceFile> externs = ImmutableList.of();
-    List<SourceFile> inputs = ImmutableList.of(
-        SourceFile.fromCode("input", code));
+    ImmutableList<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("input", code));
     compiler.init(externs, inputs, options);
     compiler.parseInputs();
     return compiler;
diff --git a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
index f0033f1..d6411eb 100644
--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java
@@ -22,7 +22,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import com.google.javascript.jscomp.testing.NoninjectingCompiler;
 import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.Node;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class RuntimeTypeCheckTest extends CompilerTestCase {
-  @Nullable private String logFunction = null;
+  private @Nullable String logFunction = null;
 
   public RuntimeTypeCheckTest() {
     super("/** @const */ var undefined;");
diff --git a/test/com/google/javascript/jscomp/ScopedAliasesTest.java b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
index 9b8b731..d027156 100644
--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java
+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java
@@ -35,6 +35,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -1512,7 +1513,7 @@ public final class ScopedAliasesTest extends CompilerTestCase {
 
   private static class TypeVerifyingPass implements CompilerPass, NodeTraversal.Callback {
     private final Compiler compiler;
-    private List<Node> actualTypes = null;
+    private @Nullable List<Node> actualTypes = null;
 
     public TypeVerifyingPass(Compiler compiler) {
       this.compiler = compiler;
diff --git a/test/com/google/javascript/jscomp/SortingErrorManagerTest.java b/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
index 991daa1..a65f44d 100644
--- a/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
+++ b/test/com/google/javascript/jscomp/SortingErrorManagerTest.java
@@ -23,6 +23,7 @@ import com.google.javascript.jscomp.SortingErrorManager.ErrorWithLevel;
 import com.google.javascript.jscomp.SortingErrorManager.LeveledJSErrorComparator;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class SortingErrorManagerTest {
-  private static final String NULL_SOURCE = null;
+  private static final @Nullable String NULL_SOURCE = null;
 
   private final LeveledJSErrorComparator comparator = new LeveledJSErrorComparator();
 
diff --git a/test/com/google/javascript/jscomp/SourceFileTest.java b/test/com/google/javascript/jscomp/SourceFileTest.java
index 9e4ea14..5bab41b 100644
--- a/test/com/google/javascript/jscomp/SourceFileTest.java
+++ b/test/com/google/javascript/jscomp/SourceFileTest.java
@@ -91,16 +91,22 @@ public final class SourceFileTest {
     assertThat(f0.getColumnOfOffset(0)).isEqualTo(0);
     assertThat(f0.getLineOfOffset(10)).isEqualTo(1);
     assertThat(f0.getColumnOfOffset(10)).isEqualTo(10);
+    assertThat(f0.getNumBytes()).isEqualTo(0);
+    assertThat(f0.getNumLines()).isEqualTo(1);
 
     SourceFile f1 = factory.apply("'1';\n'2';\n'3'\n");
     assertThat(f1.getLineOffset(1)).isEqualTo(0);
     assertThat(f1.getLineOffset(2)).isEqualTo(5);
     assertThat(f1.getLineOffset(3)).isEqualTo(10);
+    assertThat(f1.getNumBytes()).isEqualTo(14);
+    assertThat(f1.getNumLines()).isEqualTo(4);
 
     SourceFile f2 = factory.apply("'100';\n'200;'\n'300'\n");
     assertThat(f2.getLineOffset(1)).isEqualTo(0);
     assertThat(f2.getLineOffset(2)).isEqualTo(7);
     assertThat(f2.getLineOffset(3)).isEqualTo(14);
+    assertThat(f2.getNumBytes()).isEqualTo(20);
+    assertThat(f2.getNumLines()).isEqualTo(4);
 
     String longLine = stringOfLength(300);
     SourceFile f3 = factory.apply(longLine + "\n" + longLine + "\n" + longLine + "\n");
@@ -116,6 +122,9 @@ public final class SourceFileTest {
     assertThat(f3.getLineOfOffset(902)).isEqualTo(3);
     assertThat(f3.getLineOfOffset(903)).isEqualTo(4);
 
+    assertThat(f3.getNumBytes()).isEqualTo(903);
+    assertThat(f3.getNumLines()).isEqualTo(4);
+
     // TODO(nickreid): This seems like a bug.
     assertThat(f3.getLineOfOffset(-1)).isEqualTo(0);
     assertThrows(Exception.class, () -> f3.getColumnOfOffset(-1));
@@ -124,6 +133,8 @@ public final class SourceFileTest {
     assertThat(startsWithNewline.getLineOffset(1)).isEqualTo(0);
     assertThat(startsWithNewline.getLineOffset(2)).isEqualTo(1);
     assertThat(startsWithNewline.getLineOffset(3)).isEqualTo(5);
+    assertThat(startsWithNewline.getNumBytes()).isEqualTo(8);
+    assertThat(startsWithNewline.getNumLines()).isEqualTo(3);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/SourceMapTest.java b/test/com/google/javascript/jscomp/SourceMapTest.java
index af46f49..9c4b53b 100644
--- a/test/com/google/javascript/jscomp/SourceMapTest.java
+++ b/test/com/google/javascript/jscomp/SourceMapTest.java
@@ -26,7 +26,6 @@ import com.google.debugging.sourcemap.SourceMapConsumerV3;
 import com.google.debugging.sourcemap.SourceMapTestCase;
 import com.google.javascript.jscomp.SourceMap.Format;
 import java.io.IOException;
-import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -38,7 +37,7 @@ public final class SourceMapTest extends SourceMapTestCase {
 
   public SourceMapTest() {}
 
-  private List<SourceMap.LocationMapping> mappings;
+  private ImmutableList<SourceMap.LocationMapping> mappings;
   private ImmutableMap.Builder<String, SourceMapInput> inputMaps;
 
   @Test
diff --git a/test/com/google/javascript/jscomp/SymbolTableTest.java b/test/com/google/javascript/jscomp/SymbolTableTest.java
index b1c37ad..0ed541d 100644
--- a/test/com/google/javascript/jscomp/SymbolTableTest.java
+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java
@@ -105,7 +105,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).hasSize(1);
   }
 
@@ -117,7 +117,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).isEmpty();
   }
 
@@ -128,7 +128,7 @@ public final class SymbolTableTest {
     Symbol global = getGlobalVar(table, "*global*");
     assertThat(global).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(global);
+    ImmutableList<Reference> refs = table.getReferenceList(global);
     assertThat(refs).hasSize(2);
   }
 
@@ -159,7 +159,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(2);
   }
 
@@ -167,7 +167,7 @@ public final class SymbolTableTest {
   public void testGlobalVarReferences() {
     SymbolTable table = createSymbolTable("/** @type {number} */ var x = 5; x = 6;");
     Symbol x = getGlobalVar(table, "x");
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
 
     assertThat(refs).hasSize(2);
     assertThat(refs.get(0)).isEqualTo(x.getDeclaration());
@@ -179,7 +179,7 @@ public final class SymbolTableTest {
   public void testLocalVarReferences() {
     SymbolTable table = createSymbolTable("function f(x) { return x; }");
     Symbol x = getLocalVar(table, "x");
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
 
     assertThat(refs).hasSize(2);
     assertThat(refs.get(0)).isEqualTo(x.getDeclaration());
@@ -198,7 +198,7 @@ public final class SymbolTableTest {
     Symbol t = table.getParameterInFunction(f, "this");
     assertThat(t).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(t);
+    ImmutableList<Reference> refs = table.getReferenceList(t);
     assertThat(refs).hasSize(2);
   }
 
@@ -239,7 +239,7 @@ public final class SymbolTableTest {
 
     Symbol objFn = getGlobalVar(table, "obj.fn");
     assertThat(objFn).isNotNull();
-    List<Reference> references = table.getReferenceList(objFn);
+    ImmutableList<Reference> references = table.getReferenceList(objFn);
     assertThat(references).hasSize(2);
 
     // The declaration node corresponds to "fn", not "fn() {}", in the source info.
@@ -419,7 +419,7 @@ public final class SymbolTableTest {
                 (s) -> s.getSourceFileName().equals("file1.js") && s.getName().equals(symbolName))
             .findFirst()
             .get();
-    for (SymbolTable.Reference ref : table.getReferences(symbol)) {
+    for (Reference ref : table.getReferences(symbol)) {
       if (ref.getNode().getSourceFileName().equals("file2.js")) {
         return;
       }
@@ -454,7 +454,7 @@ public final class SymbolTableTest {
             .filter((s) -> s.getSourceFileName().equals("file2.js") && s.getName().equals("one"))
             .findFirst()
             .get();
-    for (SymbolTable.Reference ref : table.getReferences(symbol)) {
+    for (Reference ref : table.getReferences(symbol)) {
       if (ref.getNode().getSourceFileName().equals("file1.js")) {
         return;
       }
@@ -666,7 +666,7 @@ public final class SymbolTableTest {
     SymbolTable table =
         createSymbolTable("customExternFn(1);", "function customExternFn(customExternArg) {}");
     Symbol fn = getGlobalVar(table, "customExternFn");
-    List<Reference> refs = table.getReferenceList(fn);
+    ImmutableList<Reference> refs = table.getReferenceList(fn);
     assertThat(refs).hasSize(3);
 
     SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode());
@@ -678,7 +678,7 @@ public final class SymbolTableTest {
   public void testLocalVarInExterns() {
     SymbolTable table = createSymbolTable("", "function customExternFn(customExternArg) {}");
     Symbol arg = getLocalVar(table, "customExternArg");
-    List<Reference> refs = table.getReferenceList(arg);
+    ImmutableList<Reference> refs = table.getReferenceList(arg);
     assertThat(refs).hasSize(1);
 
     Symbol fn = getGlobalVar(table, "customExternFn");
@@ -840,7 +840,7 @@ public final class SymbolTableTest {
     Symbol prototype = getGlobalVar(table, "DomHelper.prototype");
     assertThat(prototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
 
     // One of the refs is implicit in the declaration of the function.
     assertWithMessage(refs.toString()).that(refs).hasSize(2);
@@ -854,7 +854,7 @@ public final class SymbolTableTest {
     Symbol prototype = getGlobalVar(table, "Snork.prototype");
     assertThat(prototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
     assertThat(refs).hasSize(2);
   }
 
@@ -864,7 +864,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(fooPrototype);
+    ImmutableList<Reference> refs = table.getReferenceList(fooPrototype);
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.NAME);
 
@@ -882,7 +882,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = ImmutableList.copyOf(table.getReferences(fooPrototype));
+    ImmutableList<Reference> refs = ImmutableList.copyOf(table.getReferences(fooPrototype));
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.GETPROP);
     assertThat(refs.get(0).getNode().getQualifiedName()).isEqualTo("Foo.prototype");
@@ -895,7 +895,7 @@ public final class SymbolTableTest {
     Symbol fooPrototype = getGlobalVar(table, "goog.Foo.prototype");
     assertThat(fooPrototype).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(fooPrototype);
+    ImmutableList<Reference> refs = table.getReferenceList(fooPrototype);
     assertThat(refs).hasSize(1);
     assertThat(refs.get(0).getNode().getToken()).isEqualTo(Token.GETPROP);
 
@@ -910,7 +910,7 @@ public final class SymbolTableTest {
     SymbolTable table = createSymbolTable(lines("class DomHelper { method() {} }"));
     Symbol prototype = getGlobalVar(table, "DomHelper.prototype");
     assertThat(prototype).isNotNull();
-    List<Reference> refs = table.getReferenceList(prototype);
+    ImmutableList<Reference> refs = table.getReferenceList(prototype);
 
     // The class declaration creates an implicit .prototype reference.
     assertWithMessage(refs.toString()).that(refs).hasSize(1);
@@ -933,7 +933,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(5);
 
     assertThat(refs.get(0).getNode().getLineno()).isEqualTo(1);
@@ -960,7 +960,7 @@ public final class SymbolTableTest {
     Symbol str = getGlobalVar(table, "String");
     assertThat(str).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(str);
+    ImmutableList<Reference> refs = table.getReferenceList(str);
 
     // We're going to pick up a lot of references from the externs,
     // so it's not meaningful to check the number of references.
@@ -995,7 +995,7 @@ public final class SymbolTableTest {
     Symbol foo = getGlobalVar(table, "goog.Foo");
     assertThat(foo).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(foo);
+    ImmutableList<Reference> refs = table.getReferenceList(foo);
     assertThat(refs).hasSize(5);
 
     assertThat(refs.get(0).getNode().getLineno()).isEqualTo(2);
@@ -1022,7 +1022,7 @@ public final class SymbolTableTest {
     Symbol x = getLocalVar(table, "x");
     assertThat(x).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(x);
+    ImmutableList<Reference> refs = table.getReferenceList(x);
     assertThat(refs).hasSize(2);
 
     assertThat(refs.get(0).getNode().getCharno()).isEqualTo(code.indexOf("x) {"));
@@ -1073,7 +1073,7 @@ public final class SymbolTableTest {
                 "goog.addSingletonGetter = function(x) {};"));
 
     Symbol method = getGlobalVar(table, "goog.addSingletonGetter");
-    List<Reference> refs = table.getReferenceList(method);
+    ImmutableList<Reference> refs = table.getReferenceList(method);
     assertThat(refs).hasSize(2);
 
     // Note that the declaration should show up second.
@@ -1119,14 +1119,14 @@ public final class SymbolTableTest {
     Symbol bCtor = getGlobalVar(table, "goog.B.prototype.constructor");
     assertThat(bCtor).isNotNull();
 
-    List<Reference> bRefs = table.getReferenceList(bCtor);
+    ImmutableList<Reference> bRefs = table.getReferenceList(bCtor);
     assertThat(bRefs).hasSize(2);
     assertThat(bCtor.getDeclaration().getNode().getLineno()).isEqualTo(11);
 
     Symbol cCtor = getGlobalVar(table, "goog.C.prototype.constructor");
     assertThat(cCtor).isNotNull();
 
-    List<Reference> cRefs = table.getReferenceList(cCtor);
+    ImmutableList<Reference> cRefs = table.getReferenceList(cCtor);
     assertThat(cRefs).hasSize(2);
     assertThat(cCtor.getDeclaration().getNode().getLineno()).isEqualTo(26);
   }
@@ -1219,7 +1219,7 @@ public final class SymbolTableTest {
     Symbol good = getGlobalVar(table, "a.b.BaseClass.prototype.doSomething");
     assertThat(good).isNotNull();
 
-    List<Reference> refs = table.getReferenceList(good);
+    ImmutableList<Reference> refs = table.getReferenceList(good);
     assertThat(refs).hasSize(2);
     assertThat(refs.get(1).getNode().getQualifiedName())
         .isEqualTo("a.b.DerivedClass.superClass_.doSomething");
@@ -1632,9 +1632,6 @@ public final class SymbolTableTest {
   @Test
   public void testSymbolSuperclassStaticInheritance() {
     // set this option so that typechecking sees untranspiled classes.
-    // TODO(b/76025401): remove this option after class transpilation is always post-typechecking
-    options.setSkipUnsupportedPasses(false);
-
     SymbolTable table =
         createSymbolTable(
             lines(
@@ -1777,8 +1774,9 @@ public final class SymbolTableTest {
   }
 
   private SymbolTable createSymbolTable(String input, String externsCode) {
-    List<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", input));
-    List<SourceFile> externs = ImmutableList.of(SourceFile.fromCode("externs1", externsCode));
+    ImmutableList<SourceFile> inputs = ImmutableList.of(SourceFile.fromCode("in1", input));
+    ImmutableList<SourceFile> externs =
+        ImmutableList.of(SourceFile.fromCode("externs1", externsCode));
 
     Compiler compiler = new Compiler(new BlackHoleErrorManager());
     compiler.compile(externs, inputs, options);
@@ -1790,7 +1788,7 @@ public final class SymbolTableTest {
     for (int i = 0; i < inputs.length; i++) {
       sources.add(SourceFile.fromCode("file" + (i + 1) + ".js", inputs[i]));
     }
-    List<SourceFile> externs = ImmutableList.of();
+    ImmutableList<SourceFile> externs = ImmutableList.of();
 
     Compiler compiler = new Compiler(new BlackHoleErrorManager());
     compiler.compile(externs, sources.build(), options);
@@ -1827,7 +1825,7 @@ public final class SymbolTableTest {
     assertThat(global.getDeclaration()).isNotNull();
     assertThat(global.getDeclaration().getNode().getToken()).isEqualTo(Token.SCRIPT);
 
-    List<Reference> globalRefs = table.getReferenceList(global);
+    ImmutableList<Reference> globalRefs = table.getReferenceList(global);
 
     // The main reference list should never contain the synthetic declaration
     // for the global root.
diff --git a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
index b5b1a0c..a95d773 100644
--- a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java
@@ -686,11 +686,11 @@ public final class SyntacticScopeCreatorTest {
 
   @Test
   public void testClassFieldsThisAndSuper() {
-    // TODO(b/189993301): `this`/`super` in this case should be declared locally
     String js =
         lines(
             "class Foo {", //
             "  a = this.a;",
+            "  [this.a] = this.a;",
             "}",
             "class Bar extends Foo {",
             "  b = super.a;",
@@ -699,28 +699,38 @@ public final class SyntacticScopeCreatorTest {
     Node root = getRoot(js);
     Node classFoo = root.getFirstChild();
     Node classBar = root.getLastChild();
+    Node memberFieldDefA = classFoo.getLastChild().getFirstChild();
+    Node memberFieldDefB = classBar.getLastChild().getFirstChild();
+    Node computedFieldDef = classFoo.getLastChild().getLastChild();
+
     Scope globalScope = scopeCreator.createScope(root, null);
     Scope fooScope = scopeCreator.createScope(classFoo, globalScope);
     Scope barScope = scopeCreator.createScope(classBar, globalScope);
+    Scope memberFieldDefAScope = scopeCreator.createScope(memberFieldDefA, fooScope);
+    Scope memberFieldDefBScope = scopeCreator.createScope(memberFieldDefB, barScope);
+    Scope computedFieldDefRhsScope = scopeCreator.createScope(computedFieldDef, fooScope);
 
     assertScope(globalScope).declares("Foo").directly();
     assertScope(globalScope).declares("Bar").directly();
     assertScope(globalScope).doesNotDeclare("this");
     assertScope(fooScope).doesNotDeclare("this");
     assertScope(barScope).doesNotDeclare("this");
+    assertScope(memberFieldDefAScope).declares("this").directly();
+    assertScope(computedFieldDefRhsScope).declares("this").directly();
     assertScope(globalScope).doesNotDeclare("super");
     assertScope(fooScope).doesNotDeclare("super");
     assertScope(barScope).doesNotDeclare("super");
+    assertScope(memberFieldDefBScope).declares("super").directly();
   }
 
   @Test
-  public void testClassDeclarationWithStaticFieldThisAndSuper() {
-    // TODO(b/189993301): `this`/`super` in this case should be declared locally
+  public void testClassStaticFieldsThisAndSuper() {
     String js =
         lines(
             "class Foo {", //
             "  static a = 2;",
             "  static b = this.b;",
+            "  static [this.a] = this.a;",
             "}",
             "class Bar extends Foo {",
             "  static c = super.a + 1;",
@@ -729,18 +739,28 @@ public final class SyntacticScopeCreatorTest {
     Node root = getRoot(js);
     Node classFoo = root.getFirstChild();
     Node classBar = root.getLastChild();
+    Node memberFieldDefA = classFoo.getLastChild().getFirstChild();
+    Node memberFieldDefB = classBar.getLastChild().getFirstChild();
+    Node computedFieldDef = classFoo.getLastChild().getLastChild();
+
     Scope globalScope = scopeCreator.createScope(root, null);
     Scope fooScope = scopeCreator.createScope(classFoo, globalScope);
     Scope barScope = scopeCreator.createScope(classBar, globalScope);
+    Scope memberFieldDefAScope = scopeCreator.createScope(memberFieldDefA, fooScope);
+    Scope memberFieldDefBScope = scopeCreator.createScope(memberFieldDefB, barScope);
+    Scope computedFieldDefRhsScope = scopeCreator.createScope(computedFieldDef, fooScope);
 
     assertScope(globalScope).declares("Foo").directly();
     assertScope(globalScope).declares("Bar").directly();
     assertScope(globalScope).doesNotDeclare("this");
     assertScope(fooScope).doesNotDeclare("this");
     assertScope(barScope).doesNotDeclare("this");
+    assertScope(memberFieldDefAScope).declares("this").directly();
+    assertScope(computedFieldDefRhsScope).declares("this").directly();
     assertScope(globalScope).doesNotDeclare("super");
     assertScope(fooScope).doesNotDeclare("super");
     assertScope(barScope).doesNotDeclare("super");
+    assertScope(memberFieldDefBScope).declares("super").directly();
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java b/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java
new file mode 100644
index 0000000..898e52a
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TranspileOnlyIntegrationTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2014 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import org.jspecify.nullness.Nullable;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Test cases for transpile-only mode.
+ *
+ * <p>This class actually tests several transpilation passes together.
+ */
+@RunWith(JUnit4.class)
+public final class TranspileOnlyIntegrationTest {
+
+  private @Nullable Compiler compiler = null;
+  private @Nullable CompilerOptions options = null;
+
+  @Before
+  public void init() {
+    compiler = new Compiler();
+    options = new CompilerOptions();
+    options.setLanguage(LanguageMode.ECMASCRIPT_NEXT);
+    options.setSkipNonTranspilationPasses(true);
+    options.setEmitUseStrict(false);
+  }
+
+  @Test
+  public void esModuleNoTranspilationForSameLanguageLevel() {
+    String js = "export default function fn(){};";
+    test(js, js);
+  }
+
+  @Test
+  public void esModuleTranspilationForDifferentLanguageLevel() {
+    String js = "export default function fn() {}";
+    String transpiled =
+        "function fn$$module$in(){}var module$in={};module$in.default=fn$$module$in;";
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2020);
+    test(js, transpiled);
+  }
+
+  private void test(String js, String transpiled) {
+    compiler.compile(SourceFile.fromCode("ext.js", ""), SourceFile.fromCode("in.js", js), options);
+    assertThat(compiler.getErrors()).isEmpty();
+    assertThat(compiler.toSource()).isEqualTo(transpiled);
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java b/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java
new file mode 100644
index 0000000..ccfa159
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckBigIntTest.java
@@ -0,0 +1,528 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckBigIntTest extends TypeCheckTestCase {
+
+  @Test
+  public void testTypeofBigInt() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @param {bigint|number} i",
+            " * @return {boolean}",
+            " */",
+            "function foo(i) {",
+            "  return typeof i === 'bigint';",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testBigIntArgument() {
+    newTest().addSource("BigInt(1)").run();
+    newTest()
+        .addSource("BigInt({})")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of BigInt does not match formal parameter",
+                "found   : {}",
+                "required: (bigint|number|string)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_increment() {
+    newTest().addSource("const x = 1n; x++;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; x++;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; x++;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; x++;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_decrement() {
+    newTest().addSource("const x = 1n; x--;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; x--;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; x--;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; x--;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_logicalNot() {
+    newTest().addSource("const x = 1n; !x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; !x;").run();
+    newTest().addSource("/** @type {bigint|string} */var x; !x;").run();
+  }
+
+  @Test
+  public void testBigIntOperators_bitwiseNot() {
+    newTest().addSource("const x = 1n; ~x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; ~x;").run();
+    newTest().addSource("/** @type {?} */var x; ~x;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; ~x;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; ~x;")
+        .addDiagnostic(
+            lines(
+                "bitwise NOT", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntValueOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("var x = 1n; +x;")
+        .addDiagnostic("unary operator + cannot be applied to bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntObjectOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @type {!BigInt} */ var x; +x;")
+        .addDiagnostic("unary operator + cannot be applied to BigInt")
+        .run();
+  }
+
+  @Test
+  public void testBigIntUnionOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; +x;")
+        .addDiagnostic("unary operator + cannot be applied to (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_unaryPlusIsForbidden() {
+    newTest()
+        .addSource("/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; +BIGINTS.ONE;")
+        .addDiagnostic("unary operator + cannot be applied to BIGINTS<bigint>")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_unaryMinus() {
+    newTest().addSource("const x = 1n; -x;").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; -x;").run();
+    newTest().addSource("/** @type {?} */var x; -x;").run();
+    newTest().addSource("/** @type {bigint|number} */var x; -x;").run();
+    newTest()
+        .addSource("/** @type {bigint|string} */var x; -x;")
+        .addDiagnostic(
+            lines(
+                "unary minus operator", //
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x * y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x *= y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryBitwiseOperationWithSelf() {
+    newTest().addSource("const x = 1n; const y = 1n; x | y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_additionWithString() {
+    newTest().addSource("const x = 1n; const y = 'str'; x + y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignAddWithString() {
+    newTest().addSource("const x = 1n; const y = 'str'; x += y").run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'str'; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and string")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'str'; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and string")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithUnknown() {
+    newTest()
+        .addSource("var x = 1n; /** @type {?} */var y; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and ?")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithUnknown() {
+    newTest()
+        .addSource("var x = 1n; /** @type {?} */var y; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and ?")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryOperationWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x * y")
+        .addDiagnostic("operator * cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignOpWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x *= y")
+        .addDiagnostic("operator *= cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_binaryBitwiseOperationWithNumber() {
+    newTest()
+        .addSource("const x = 1n; const y = 1; x | y")
+        .addDiagnostic("operator | cannot be applied to bigint and number")
+        .run();
+  }
+
+  @Test
+  public void testBigIntLeftShift() {
+    newTest().addSource("1n << 2n").run();
+    newTest().addSource("let x = 1n; x <<= 2n").run();
+  }
+
+  @Test
+  public void testBigIntRightShift() {
+    newTest().addSource("2n >> 1n").run();
+    newTest().addSource("let x = 2n; x >>= 1n").run();
+  }
+
+  @Test
+  public void testBigIntOperators_unsignedRightShift() {
+    newTest()
+        .addSource("const x = 1n; x >>> x;")
+        .addDiagnostic("operator >>> cannot be applied to bigint and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOperators_assignUnsignedRightShift() {
+    newTest()
+        .addSource("let x = 1n; x >>>= x;")
+        .addDiagnostic("operator >>>= cannot be applied to bigint and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryOperationWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x * x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignOpWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x *= x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithSelf() {
+    newTest().addSource("/** @type {bigint|number} */ var x; x | x;").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryOperationWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x * y;")
+        .addDiagnostic("operator * cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignOpWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithBigInt() {
+    newTest()
+        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x | y;")
+        .addDiagnostic("operator | cannot be applied to bigint and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_unsignedRightShift() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x = 1n; x >>> x;")
+        .addDiagnostic("operator >>> cannot be applied to (bigint|number) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrNumberOperators_assignUnsignedRightShift() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x = 1n; x >>>= x;")
+        .addDiagnostic("operator >>>= cannot be applied to (bigint|number) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_binaryOperationWithBigInt() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x * y;")
+        .addDiagnostic("operator * cannot be applied to (bigint|string) and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_assignOpWithBigInt() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to (bigint|string) and bigint")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_binaryOperationWithBigIntOrNumber() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x * y;")
+        .addDiagnostic("operator * cannot be applied to (bigint|string) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherOperators_assignOpWithBigIntOrNumber() {
+    newTest()
+        .addSource(
+            "/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x *= y;")
+        .addDiagnostic("operator *= cannot be applied to (bigint|string) and (bigint|number)")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_binaryOperationWithSelf() {
+    newTest()
+        .addSource(
+            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE * BIGINTS.TWO;")
+        .run();
+  }
+
+  @Test
+  public void testBigIntEnumOperators_assignOpWithSelf() {
+    newTest()
+        .addSource(
+            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE *= BIGINTS.TWO;")
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntComparisons() {
+    newTest().addSource("var x = 1n; var y = 2n; x < y").run();
+    newTest().addSource("var x = 1n; /** @type {!BigInt} */ var y; x < y").run();
+    newTest().addSource("var x = 1n; var y = 2; x < y").run();
+    newTest().addSource("var x = 1n; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntComparisonWithString() {
+    newTest()
+        .addSource("const x = 1n; const y = 'asdf'; x < y;")
+        .addDiagnostic(
+            lines(
+                "right side of numeric comparison",
+                "found   : string",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntObjectComparisons() {
+    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2n; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {!BigInt} */ var y; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2; x < y").run();
+    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testValidBigIntOrNumberComparisons() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; /** @type {bigint|number} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2; x < y;").run();
+    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2n; x < y;").run();
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; /** @type {!BigInt} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|number} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberComparisonWithString() {
+    newTest()
+        .addSource("/** @type {bigint|number} */ var x; 'asdf' < x;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison", //
+                "found   : string",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testValidBigIntOrOtherComparisons() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|string} */ var y; x < y;")
+        .run();
+    newTest().addSource("/** @type {bigint|string} */ var x; /** @type {?} */ var y; x < y").run();
+  }
+
+  @Test
+  public void testBigIntOrOtherComparisonWithBigint() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 2n; x < y;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison",
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntOrOtherComparisonWithNumber() {
+    newTest()
+        .addSource("/** @type {bigint|string} */ var x; var y = 2; x < y;")
+        .addDiagnostic(
+            lines(
+                "left side of numeric comparison",
+                "found   : (bigint|string)",
+                "required: (bigint|number)"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntObjectIndex() {
+    // As is, TypeCheck allows for objects to be indexed with bigint. An error could be reported as
+    // is done with arrays, but for now we will avoid such restrictions.
+    newTest()
+        .addSource(
+            "var obj = {};",
+            "/** @type {bigint} */ var b;",
+            "/** @type {bigint|number} */ var bn;",
+            "obj[b] = 1;",
+            "obj[bn] = 3;")
+        .run();
+  }
+
+  @Test
+  public void testBigIntArrayIndex() {
+    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
+    // to maintain consistency with TypeScript.
+    newTest()
+        .addSource("var arr = []; /** @type {bigint} */ var b; arr[b];")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : bigint",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntConstructorWithNew() {
+    // BigInt object function type cannot be called with "new" keyword
+    newTest().addSource("new BigInt(1)").addDiagnostic("cannot instantiate non-constructor").run();
+  }
+
+  @Test
+  public void testBigIntOrNumberArrayIndex() {
+    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
+    // to maintain consistency with TypeScript.
+    newTest()
+        .addSource("var arr = []; /** @type {bigint|number} */ var bn; arr[bn];")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : (bigint|number)",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForObjects() {
+    newTest().addSource("/** @type {bigint} */ var x; ({[x]: 'value', 123n() {}});").run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForClasses() {
+    newTest().addSource("/** @unrestricted */ class C { 123n() {} }").run();
+    newTest().addSource("/** @dict */ class C { 123n() {} }").run();
+  }
+
+  @Test
+  public void testBigIntAsComputedPropForStructClasses() {
+    newTest()
+        .addSource("class C { 123n() {} }")
+        .addDiagnostic("Cannot do '[]' access on a struct")
+        .run();
+  }
+
+  @Test
+  public void testBigIntLiteralProperty() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addBigInt().build())
+        .addSource("(1n).toString()")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java b/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java
new file mode 100644
index 0000000..a610b25
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckBugsAndIssuesTest.java
@@ -0,0 +1,1129 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION;
+
+import com.google.javascript.jscomp.testing.TestExternsBuilder;
+import com.google.javascript.rhino.jstype.JSType;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckBugsAndIssuesTest extends TypeCheckTestCase {
+
+  @Test
+  public void testIssue61a() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "var ns = {};"
+                + "(function() {"
+                + "  /** @param {string} b */"
+                + "  ns.a = function(b) {};"
+                + "})();"
+                + "function d() {"
+                + "  ns.a(123);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue61b() {
+    newTest()
+        .addSource(
+            "/** @const */ var ns = {};",
+            "(function() {",
+            "  /** @param {string} b */",
+            "  ns.a = function(b) {};",
+            "})();",
+            "ns.a(123);")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue61c() {
+    newTest()
+        .addSource(
+            "var ns = {};",
+            "(function() {",
+            "  /** @param {string} b */",
+            "  ns.a = function(b) {};",
+            "})();",
+            "ns.a(123);")
+        .addDiagnostic(
+            "actual parameter 1 of ns.a does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue86() {
+    newTest()
+        .addSource(
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.get = function(){};"
+                + "/** @constructor \n * @implements {I} */ function F() {}"
+                + "/** @override */ F.prototype.get = function() { return true; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue124() {
+    newTest()
+        .addSource(
+            "var t = null;"
+                + "function test() {"
+                + "  if (t != null) { t = null; }"
+                + "  t = 1;"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testIssue124b() {
+    newTest()
+        .addSource(
+            "var t = null;"
+                + "function test() {"
+                + "  if (t != null) { t = null; }"
+                + "  t = undefined;"
+                + "}")
+        .addDiagnostic(
+            "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null")
+        .run();
+  }
+
+  @Test
+  public void testIssue259() {
+    newTest()
+        .addSource(
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */"
+                + "var Clock = function() {"
+                + "  /** @constructor */"
+                + "  this.Date = function() {};"
+                + "  f(new this.Date());"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : this.Date\n"
+                + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue301() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addString().addArray().build())
+        .addSource(
+            "Array.indexOf = function() {};",
+            "var s = 'hello';",
+            "alert(s.toLowerCase.indexOf('1'));")
+        .addDiagnostic("Property indexOf never defined on String.prototype.toLowerCase")
+        .run();
+  }
+
+  @Test
+  public void testIssue368() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo(){}"
+                + "/**\n"
+                + " * @param {number} one\n"
+                + " * @param {string} two\n"
+                + " */\n"
+                + "Foo.prototype.add = function(one, two) {};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar(){}"
+                + "/** @override */\n"
+                + "Bar.prototype.add = function(ignored) {};"
+                + "(new Bar()).add(1, 2);")
+        .addDiagnostic(
+            "actual parameter 2 of Bar.prototype.add does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue380() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().addObject().build())
+        .addSource(
+            "/** @type { function(string): {innerHTML: string} } */",
+            "document.getElementById;",
+            "var list = /** @type {!Array<string>} */ ['hello', 'you'];",
+            "list.push('?');",
+            "document.getElementById('node').innerHTML = list.toString();")
+        .run();
+  }
+
+  @Test
+  public void testIssue483() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/** @constructor */ function C() {",
+            "  /** @type {?Array} */ this.a = [];",
+            "}",
+            "C.prototype.f = function() {",
+            "  if (this.a.length > 0) {",
+            "    g(this.a);",
+            "  }",
+            "};",
+            "/** @param {number} a */ function g(a) {}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : Array",
+                "required: number"))
+        .run();
+  }
+
+  @Test
+  public void testIssue537a() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {method: function() {}};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz()) this.method(1);"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic(
+            "Function Foo.prototype.method: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537b() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {method: function() {}};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz(1)) this.method();"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic(
+            "Function Bar.prototype.baz: called with 1 argument(s). "
+                + "Function requires at least 0 argument(s) "
+                + "and no more than 0 argument(s).")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537c() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  Foo.call(this);"
+                + "  if (this.baz2()) alert(1);"
+                + "}"
+                + "Bar.prototype = {"
+                + "  baz: function() {"
+                + "    return true;"
+                + "  }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .addDiagnostic("Property baz2 never defined on Bar")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue537d() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype = {"
+                + "  /** @return {Bar} */ x: function() { new Bar(); },"
+                + "  /** @return {Foo} */ y: function() { new Bar(); }"
+                + "};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "function Bar() {"
+                + "  this.xy = 3;"
+                + "}"
+                + "/** @return {Bar} */ function f() { return new Bar(); }"
+                + "/** @return {Foo} */ function g() { return new Bar(); }"
+                + "Bar.prototype = {"
+                + "  /** @override @return {Bar} */ x: function() { new Bar(); },"
+                + "  /** @override @return {Foo} */ y: function() { new Bar(); }"
+                + "};"
+                + "Bar.prototype.__proto__ = Foo.prototype;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue586() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var MyClass = function() {};"
+                + "/** @param {boolean} success */"
+                + "MyClass.prototype.fn = function(success) {};"
+                + "MyClass.prototype.test = function() {"
+                + "  this.fn();"
+                + "  this.fn = function() {};"
+                + "};")
+        .addDiagnostic(
+            "Function MyClass.prototype.fn: called with 0 argument(s). "
+                + "Function requires at least 1 argument(s) "
+                + "and no more than 1 argument(s).")
+        .run();
+  }
+
+  @Test
+  public void testIssue635() {
+    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "function F() {}"
+                + "F.prototype.bar = function() { this.baz(); };"
+                + "F.prototype.baz = function() {};"
+                + "/** @constructor */"
+                + "function G() {}"
+                + "G.prototype.bar = F.prototype.bar;")
+        .run();
+  }
+
+  @Test
+  public void testIssue635b() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "function F() {}",
+            "/** @constructor */",
+            "function G() {}",
+            "/** @type {function(new:G)} */ var x = F;")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : (typeof F)",
+                "required: function(new:G): ?"))
+        .run();
+  }
+
+  @Test
+  public void testIssue669() {
+    newTest()
+        .addSource(
+            "/** @return {{prop1: (Object|undefined)}} */"
+                + "function f(a) {"
+                + "  var results;"
+                + "  if (a) {"
+                + "    results = {};"
+                + "    results.prop1 = {a: 3};"
+                + "  } else {"
+                + "    results = {prop2: 3};"
+                + "  }"
+                + "  return results;"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testIssue688() {
+    newTest()
+        .addSource(
+            "/** @const */ var SOME_DEFAULT =\n"
+                + "    /** @type {TwoNumbers} */ ({first: 1, second: 2});\n"
+                + "/**\n"
+                + "* Class defining an interface with two numbers.\n"
+                + "* @interface\n"
+                + "*/\n"
+                + "function TwoNumbers() {}\n"
+                + "/** @type {number} */\n"
+                + "TwoNumbers.prototype.first;\n"
+                + "/** @type {number} */\n"
+                + "TwoNumbers.prototype.second;\n"
+                + "/** @return {number} */ function f() { return SOME_DEFAULT; }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (TwoNumbers|null)\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue700() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {{text: string}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp1(opt_data) {\n"
+                + "  return opt_data.text;\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp2(opt_data) {\n"
+                + "  /** @suppress {checkTypes} */\n"
+                + "  function __inner() {\n"
+                + "    return temp1(opt_data.activity);\n"
+                + "  }\n"
+                + "  return __inner();\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {{n: number, text: string, b: boolean}} opt_data\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function temp3(opt_data) {\n"
+                + "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n"
+                + "}\n"
+                + "\n"
+                + "function callee() {\n"
+                + "  var output = temp3({\n"
+                + "    n: 0,\n"
+                + "    text: 'a string',\n"
+                + "    b: true\n"
+                + "  })\n"
+                + "  alert(output);\n"
+                + "}\n"
+                + "\n"
+                + "callee();")
+        .run();
+  }
+
+  @Test
+  public void testIssue725() {
+    newTest()
+        .addSource(
+            "/** @typedef {{name: string}} */ var RecordType1;"
+                + "/** @typedef {{name2222: string}} */ var RecordType2;"
+                + "/** @param {RecordType1} rec */ function f(rec) {"
+                + "  alert(rec.name2222);"
+                + "}")
+        .addDiagnostic("Property name2222 never defined on rec")
+        .run();
+  }
+
+  @Test
+  public void testIssue726() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
+                + "/** @return {!Function} */ "
+                + "Foo.prototype.getDeferredBar = function() { "
+                + "  var self = this;"
+                + "  return function() {"
+                + "    self.bar(true);"
+                + "  };"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue765() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var AnotherType = function(parent) {"
+                + "    /** @param {string} stringParameter Description... */"
+                + "    this.doSomething = function(stringParameter) {};"
+                + "};"
+                + "/** @constructor */"
+                + "var YetAnotherType = function() {"
+                + "    this.field = new AnotherType(self);"
+                + "    this.testfun=function(stringdata) {"
+                + "        this.field.doSomething(null);"
+                + "    };"
+                + "};")
+        .addDiagnostic(
+            "actual parameter 1 of AnotherType.doSomething "
+                + "does not match formal parameter\n"
+                + "found   : null\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue783() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "var Type = function() {"
+                + "  /** @type {Type} */"
+                + "  this.me_ = this;"
+                + "};"
+                + "Type.prototype.doIt = function() {"
+                + "  var me = this.me_;"
+                + "  for (var i = 0; i < me.unknownProp; i++) {}"
+                + "};")
+        .addDiagnostic("Property unknownProp never defined on Type")
+        .run();
+  }
+
+  @Test
+  public void testIssue791() {
+    newTest()
+        .addSource(
+            "/** @param {{func: function()}} obj */"
+                + "function test1(obj) {}"
+                + "var fnStruc1 = {};"
+                + "fnStruc1.func = function() {};"
+                + "test1(fnStruc1);")
+        .run();
+  }
+
+  @Test
+  public void testIssue810() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "var Type = function() {",
+            "  this.prop = x;",
+            "};",
+            "Type.prototype.doIt = function(obj) {",
+            "  this.prop = obj.unknownProp;",
+            "};")
+        .addDiagnostic(
+            "Property unknownProp never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .run();
+  }
+
+  @Test
+  public void testIssue1002() {
+    newTest()
+        .addSource(
+            "/** @interface */"
+                + "var I = function() {};"
+                + "/** @constructor @implements {I} */"
+                + "var A = function() {};"
+                + "/** @constructor @implements {I} */"
+                + "var B = function() {};"
+                + "var f = function() {"
+                + "  if (A === B) {"
+                + "    new B();"
+                + "  }"
+                + "};")
+        .run();
+  }
+
+  @Test
+  public void testIssue1023() {
+    newTest()
+        .addSource(
+            "/** @constructor */"
+                + "function F() {}"
+                + "(function() {"
+                + "  F.prototype = {"
+                + "    /** @param {string} x */"
+                + "    bar: function(x) {  }"
+                + "  };"
+                + "})();"
+                + "(new F()).bar(true)")
+        .addDiagnostic(
+            "actual parameter 1 of F.prototype.bar does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue1047() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C2() {}\n"
+                + "\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C3(c2) {\n"
+                + "  /**\n"
+                + "   * @type {C2} \n"
+                + "   * @private\n"
+                + "   */\n"
+                + "  this.c2_;\n"
+                + "\n"
+                + "  var x = this.c2_.prop;\n"
+                + "}")
+        .addDiagnostic("Property prop never defined on C2")
+        .run();
+  }
+
+  @Test
+  public void testIssue1056() {
+    newTest()
+        .addSource("/** @type {Array} */ var x = null;" + "x.push('hi');")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+        .run();
+  }
+
+  @Test
+  public void testIssue1072() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {string} x\n"
+                + " * @return {number}\n"
+                + " */\n"
+                + "var f1 = function(x) {\n"
+                + "  return 3;\n"
+                + "};\n"
+                + "\n"
+                + "/** Function */\n"
+                + "var f2 = function(x) {\n"
+                + "  if (!x) throw new Error()\n"
+                + "  return /** @type {number} */ (f1('x'))\n"
+                + "}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {string} x\n"
+                + " */\n"
+                + "var f3 = function(x) {};\n"
+                + "\n"
+                + "f1(f3);")
+        .addDiagnostic(
+            "actual parameter 1 of f1 does not match formal parameter\n"
+                + "found   : function(string): undefined\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testIssue1123() {
+    newTest()
+        .addSource("/** @param {function(number)} g */ function f(g) {}" + "f(function(a, b) {})")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : function(?, ?): undefined\n"
+                + "required: function(number): ?")
+        .run();
+  }
+
+  @Test
+  public void testIssue1201() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "/** @constructor */ function F() {}"
+                + "/** desc */ F.prototype.bar = function() {};"
+                + "g(new F().bar);")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : function(this:F): undefined\n"
+                + "required: function(this:undefined): ?")
+        .run();
+  }
+
+  @Test
+  public void testIssue1201b() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "/** @constructor */ function F() {}"
+                + "/** desc */ F.prototype.bar = function() {};"
+                + "var f = new F();"
+                + "g(f.bar.bind(f));")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIssue1201c() {
+    newTest()
+        .addSource(
+            "/** @param {function(this:void)} f */ function g(f) {}"
+                + "g(function() { this.alert() })")
+        .addDiagnostic(
+            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+        .run();
+  }
+
+  @Test
+  public void testIssue926a() {
+    newTest()
+        .addSource(
+            "/** x */ function error() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @param {string} error\n"
+                + " */\n"
+                + "function C(error) {\n"
+                + " /** @const */ this.e = error;\n"
+                + "}"
+                + "/** @type {number} */ var x = (new C('x')).e;")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testIssue926b() {
+    newTest()
+        .addSource(
+            "/** @constructor */\n"
+                + "function A() {\n"
+                + " /** @constructor */\n"
+                + " function B() {}\n"
+                + " /** @type {!B} */ this.foo = new B();"
+                + " /** @type {!B} */ var C = new B();"
+                + "}"
+                + "/** @type {number} */ var x = (new A()).foo;")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: number")
+        .run();
+  }
+
+  /**
+   * Tests that the || operator is type checked correctly, that is of the type of the first argument
+   * or of the second argument. See bugid 592170 for more details.
+   */
+  @Test
+  public void testBug592170() {
+    newTest()
+        .addSource(
+            "/** @param {Function} opt_f ... */"
+                + "function foo(opt_f) {"
+                + "  /** @type {Function} */"
+                + "  return opt_f || function() {};"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testNullishCoalesceTypeIsFirstOrSecondArgument() {
+    newTest()
+        .addSource(
+            "/** @param {Function} opt_f ... */",
+            "function foo(opt_f) {",
+            "  /** @type {Function} */",
+            "  return opt_f ?? function() {};",
+            "}")
+        .run();
+  }
+
+  /**
+   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
+   * of the side on which the undefined value is.
+   */
+  @Test
+  public void testBug901455a() {
+    newTest()
+        .addSource(
+            "/** @return {(number|undefined)} */ function a() { return 3; }"
+                + "var b = undefined === a()")
+        .run();
+  }
+
+  /**
+   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
+   * of the side on which the undefined value is.
+   */
+  @Test
+  public void testBug901455b() {
+    newTest()
+        .addSource(
+            "/** @return {(number|undefined)} */ function a() { return 3; }"
+                + "var b = a() === undefined")
+        .run();
+  }
+
+  /** Tests that the match method of strings returns nullable arrays. */
+  @Test
+  public void testBug908701() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
+        .addSource(
+            "/** @type {String} */ var s = new String('foo');", //
+            "var b = s.match(/a/) != null;")
+        .run();
+  }
+
+  /** Tests that named types play nicely with subtyping. */
+  @Test
+  public void testBug908625() {
+    newTest()
+        .addSource(
+            "/** @constructor */function A(){}"
+                + "/** @constructor\n * @extends A */function B(){}"
+                + "/** @param {B} b"
+                + "\n @return {(A|undefined)} */function foo(b){return b}")
+        .run();
+  }
+
+  /**
+   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
+   * this variable is legal.
+   */
+  @Test
+  public void testBug911118a() {
+    // verifying the type assigned to function expressions assigned variables
+    TypedScope s = parseAndTypeCheckWithScope("var a = function(){};").scope;
+    JSType type = s.getVar("a").getType();
+    assertThat(type.toString()).isEqualTo("function(): undefined");
+  }
+
+  /**
+   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
+   * this variable is legal.
+   */
+  @Test
+  public void testBug911118b() {
+    // verifying the bug example
+    newTest()
+        .addSource(
+            "function nullFunction() {};"
+                + "var foo = nullFunction;"
+                + "foo = function() {};"
+                + "foo();")
+        .run();
+  }
+
+  @Test
+  public void testBug909000() {
+    newTest()
+        .addSource(
+            "/** @constructor */function A(){}\n"
+                + "/** @param {!A} a\n"
+                + "@return {boolean}*/\n"
+                + "function y(a) { return a }")
+        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: boolean")
+        .run();
+  }
+
+  @Test
+  public void testBug930117() {
+    newTest()
+        .addSource("/** @param {boolean} x */function f(x){}" + "f(null);")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : null\n"
+                + "required: boolean")
+        .run();
+  }
+
+  @Test
+  public void testBug1484445() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {number?} */ Foo.prototype.bar = null;"
+                + "/** @type {number?} */ Foo.prototype.baz = null;"
+                + "/** @param {Foo} foo */"
+                + "function f(foo) {"
+                + "  while (true) {"
+                + "    if (foo.bar == null && foo.baz == null) {"
+                + "      foo.bar;"
+                + "    }"
+                + "  }"
+                + "}")
+        .run();
+  }
+
+  @Test
+  public void testBug1859535() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {Function} childCtor Child class.\n"
+                + " * @param {Function} parentCtor Parent class.\n"
+                + " */"
+                + "var inherits = function(childCtor, parentCtor) {"
+                + "  /** @constructor */"
+                + "  function tempCtor() {};"
+                + "  tempCtor.prototype = parentCtor.prototype;"
+                + "  childCtor.superClass_ = parentCtor.prototype;"
+                + "  childCtor.prototype = new tempCtor();"
+                + "  /** @override */ childCtor.prototype.constructor = childCtor;"
+                + "};"
+                + "/**"
+                + " * @param {Function} constructor\n"
+                + " * @param {Object} var_args\n"
+                + " * @return {Object}\n"
+                + " */"
+                + "var factory = function(constructor, var_args) {"
+                + "  /** @constructor */"
+                + "  var tempCtor = function() {};"
+                + "  tempCtor.prototype = constructor.prototype;"
+                + "  var obj = new tempCtor();"
+                + "  constructor.apply(obj, arguments);"
+                + "  return obj;"
+                + "};")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testBug1940591() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @type {Object} */"
+                + "var a = {};\n"
+                + "/** @type {number} */\n"
+                + "a.name = 0;\n"
+                + "/**\n"
+                + " * @param {Function} x anything.\n"
+                + " */\n"
+                + "a.g = function(x) { x.name = 'a'; }")
+        .run();
+  }
+
+  @Test
+  public void testBug1942972() {
+    newTest()
+        .addSource(
+            "var google = {\n"
+                + "  gears: {\n"
+                + "    factory: {},\n"
+                + "    workerPool: {}\n"
+                + "  }\n"
+                + "};\n"
+                + "\n"
+                + "google.gears = {factory: {}};\n")
+        .run();
+  }
+
+  @Test
+  public void testBug1943776() {
+    newTest()
+        .addSource(
+            "/** @return  {{foo: Array}} */" + "function bar() {" + "  return {foo: []};" + "}")
+        .run();
+  }
+
+  @Test
+  public void testBug1987544() {
+    newTest()
+        .addSource(
+            "/** @param {string} x */ function foo(x) {}"
+                + "var duration;"
+                + "if (true && !(duration = 3)) {"
+                + " foo(duration);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug1940769() {
+    newTest()
+        .addSource(
+            "/** @return {!Object} */ "
+                + "function proto(obj) { return obj.prototype; }"
+                + "/** @constructor */ function Map() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Map}\n"
+                + " */"
+                + "function Map2() { Map.call(this); };"
+                + "Map2.prototype = proto(Map);")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testBug2335992() {
+    disableStrictMissingPropertyChecks();
+
+    newTest()
+        .addSource(
+            "/** @return {*} */ function f() { return 3; }"
+                + "var x = f();"
+                + "/** @type {string} */"
+                + "x.y = 3;")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug2341812() {
+    disableStrictMissingPropertyChecks();
+
+    newTest()
+        .addSource(
+            "/** @interface */"
+                + "function EventTarget() {}"
+                + "/** @constructor \n * @implements {EventTarget} */"
+                + "function Node() {}"
+                + "/** @type {number} */ Node.prototype.index;"
+                + "/** @param {EventTarget} x \n * @return {string} */"
+                + "function foo(x) { return x.index; }")
+        .run();
+  }
+
+  @Test
+  public void testBug7701884() {
+    newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/**",
+            " * @param {Array<T>} x",
+            " * @param {function(T)} y",
+            " * @template T",
+            " */",
+            "var forEach = function(x, y) {",
+            "  for (var i = 0; i < x.length; i++) y(x[i]);",
+            "};",
+            "/** @param {number} x */",
+            "function f(x) {}",
+            "/** @param {?} x */",
+            "function h(x) {",
+            "  var top = null;",
+            "  forEach(x, function(z) { top = z; });",
+            "  if (top) f(top);",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testBug8017789() {
+    newTest()
+        .addSource(
+            "/** @param {(map|function())} isResult */"
+                + "var f = function(isResult) {"
+                + "    while (true)"
+                + "        isResult['t'];"
+                + "};"
+                + "/** @typedef {Object<string, number>} */"
+                + "var map;")
+        .run();
+  }
+
+  @Test
+  public void testBug12441160() {
+    newTest()
+        .addSource(
+            "/** @param {string} a */ \n"
+                + "function use(a) {};\n"
+                + "/**\n"
+                + " * @param {function(this:THIS)} fn\n"
+                + " * @param {THIS} context \n"
+                + " * @constructor\n"
+                + " * @template THIS\n"
+                + " */\n"
+                + "var P = function(fn, context) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function C() { /** @type {number} */ this.a = 1; }\n"
+                + "\n"
+                + "/** @return {P} */ \n"
+                + "C.prototype.method = function() {\n"
+                + "   return new P(function() { use(this.a); }, this);\n"
+                + "};\n"
+                + "\n")
+        .addDiagnostic(
+            "actual parameter 1 of use does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testBug13641083a() {
+    newTest()
+        .addSource("/** @constructor @struct */ function C() {};" + "new C().bar;")
+        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testBug13641083b() {
+    newTest()
+        .addSource("/** @type {?} */ var C;" + "C.bar + 1;")
+        .addDiagnostic(TypeCheck.POSSIBLE_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testBug12722936() {
+    // Verify we don't use a weaker type when a
+    // stronger type is known for a slot.
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function X() {}\n"
+                + "/** @constructor */ function C() {\n"
+                + "  /** @type {!X<boolean>}*/\n"
+                + "  this.a = new X();\n"
+                + "  /** @type {null} */ var x = this.a;\n"
+                + "};\n"
+                + "\n")
+        .addDiagnostic("initializing variable\n" + "found   : X<boolean>\n" + "required: null")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java b/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java
new file mode 100644
index 0000000..1167933
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckCovarianceTest.java
@@ -0,0 +1,1104 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.javascript.jscomp.TypeCheck.STRICT_INEXISTENT_PROPERTY;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckCovarianceTest extends TypeCheckTestCase {
+
+  @Test
+  public void testIterableCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterable<(number|string)>*/ x){};",
+            "function g(/** !Iterable<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testLocalShadowOfIterableNotCovariant() {
+    newTest()
+        .addSource(
+            "/** @template T */",
+            "class Iterable {}",
+            "function f(/** !Iterable<(number|string)>*/ x) {};",
+            "function g(/** !Iterable<number> */ arr) {",
+            "    f(arr);",
+            "}",
+            "export {};")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Iterable<number>",
+                "required: Iterable<(number|string)>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableNotContravariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterable<number>*/ x){};",
+            "function g(/** !Iterable<(number|string)> */ arr) {",
+            "    f(arr);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Iterable<(number|string)>",
+                "required: Iterable<number>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableCovariantWhenComparingToSubtype() {
+    newTest()
+        .addExterns(
+            "/** @constructor",
+            " * @implements {Iterable<T>}",
+            " * @template T",
+            " */",
+            "function Set() {}")
+        .addSource(
+            "function f(/** !Iterable<(number|string)>*/ x){};",
+            "function g(/** !Set<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIteratorCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Iterator<(string|number)>*/ x){};",
+            "function g(/** !Iterator<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testGeneratorCovariant() {
+    newTest()
+        .addSource(
+            "function f(/** !Generator<(string|number)>*/ x){};",
+            "function g(/** !Generator<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIterableImplementorInvariant() {
+    newTest()
+        .addExterns(
+            "/** @constructor",
+            " * @implements {Iterable<T>}",
+            " * @template T",
+            " */",
+            "function Set() {}")
+        .addSource(
+            "function f(/** !Set<(string|number)>*/ x){};",
+            "function g(/** !Set<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Set<number>",
+                "required: Set<(number|string)>"))
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeCovariant1() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<(string|number)>*/ x){};",
+            "function g(/** !IArrayLike<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeCovariant2() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<(string|number)>*/ x){};",
+            "function g(/** !Array<number> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testIArrayLikeBivaraint() {
+    newTest()
+        .addSource(
+            "function f(/** !IArrayLike<number>*/ x){};",
+            "function g(/** !IArrayLike<(string|number)> */ arr) {",
+            "    f(arr);",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType1() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor ",
+            "  * @extends {C} ",
+            "  */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType2() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor ",
+            "  * @extends {C} ",
+            "  */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C, prop2: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType3() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType4() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C, prop2: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C2|null)}",
+                "required: {\n  prop: (C|null),\n  prop2: (C|null)\n}",
+                "missing : [prop2]",
+                "mismatch: []"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType5() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function C() {}",
+            "/** @constructor */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C}} */",
+            "var r1;",
+            "/** @type {{prop: C2}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C2|null)}",
+                "required: {prop: (C|null)}",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType6() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C2}} */",
+            "var r1;",
+            "/** @type {{prop: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop: (C|null)}",
+                "required: {prop: (C2|null)}",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType7() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop: C2, prop2: C2}} */",
+            "var r1;",
+            "/** @type {{prop: C2, prop2: C}} */",
+            "var r2;",
+            "r1 = r2;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {\n  prop: (C2|null),\n  prop2: (C|null)\n}",
+                "required: {\n  prop: (C2|null),\n  prop2: (C2|null)\n}",
+                "missing : []",
+                "mismatch: [prop2]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType8() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo(){}",
+            "/** @type {number} */",
+            "Foo.prototype.x = 5",
+            "/** @type {string} */",
+            "Foo.prototype.y = 'str'")
+        .addSource(
+            "/** @type {{x: number, y: string}} */",
+            "var r1 = {x: 1, y: 'value'};",
+            "",
+            "/** @type {!Foo} */",
+            "var f = new Foo();",
+            "r1 = f;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType9() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo(){}",
+            "/** @type {number} */",
+            "Foo.prototype.x1 = 5",
+            "/** @type {string} */",
+            "Foo.prototype.y = 'str'")
+        .addSource(
+            "/** @type {{x: number, y: string}} */",
+            "var r1 = {x: 1, y: 'value'};",
+            "",
+            "/** @type {!Foo} */",
+            "var f = new Foo();",
+            "f = r1;")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : {\n  x: number,\n  y: string\n}",
+                "required: Foo"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType10() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {{x: !Foo}} */",
+            "Foo.prototype.x = {x: new Foo()};")
+        .addSource(
+            "/** @type {!Foo} */",
+            "var o = new Foo();",
+            "",
+            "/** @type {{x: !Foo}} */",
+            "var r = {x : new Foo()};",
+            "r = o;")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : Foo",
+                "required: {x: Foo}",
+                "missing : []",
+                "mismatch: [x]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType11() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "/** @return {number} */",
+            "Bar1.prototype.y = function(){return 1;};",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {string} */",
+            "Bar.prototype.y = function(){return 'test';};")
+        .addSource(
+            "function fun(/** Foo */f) {", //
+            "  f.y();",
+            "}",
+            "fun(new Bar1())",
+            "fun(new Bar());")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType12() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {undefined} */",
+            "Bar.prototype.y = function(){};")
+        .addSource(
+            "/** @type{Foo} */", //
+            "var f = new Bar1();",
+            "f.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run(); // Only if strict warnings are enabled.
+  }
+
+  @Test
+  public void testCovarianceForRecordType13() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor @implements {I} */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{{x: {obj: I}}} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run(); // Only if strict warnings are enabled.
+  }
+
+  @Test
+  public void testCovarianceForRecordType14a() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType14b() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @interface */",
+            "function I() {}",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .addDiagnostic("Property y not defined on all member types of (I|C)")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType15() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {undefined} */",
+            "C.prototype.y1 = function(){};",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @return {undefined} */",
+            "C1.prototype.y = function(){};")
+        .addSource(
+            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */",
+            "var ri;",
+            "ri.x.obj.y1();",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType16() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "/** @return {number} */",
+            "C.prototype.y = function(){return 1;};",
+            "/** @constructor */",
+            "function C1() {}",
+            "/** @return {string} */",
+            "C1.prototype.y = function(){return 'test';};")
+        .addSource(
+            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */", //
+            "var ri;",
+            "ri.x.obj.y();")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType17() {
+    newTest()
+        .addExterns(
+            "/** @interface */",
+            "function Foo() {}",
+            "/** @constructor @implements {Foo} */",
+            "function Bar1() {}",
+            "Bar1.prototype.y = function(){return {};};",
+            "/** @constructor @implements {Foo} */",
+            "function Bar() {}",
+            "/** @return {number} */",
+            "Bar.prototype.y = function(){return 1;};")
+        .addSource(
+            "/** @type {Foo} */ var f;", //
+            "f.y();")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType18() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor*/",
+            "function Bar1() {}",
+            "/** @type {{x: number}} */",
+            "Bar1.prototype.prop;",
+            "/** @constructor */",
+            "function Bar() {}",
+            "/** @type {{x: number, y: number}} */",
+            "Bar.prototype.prop;")
+        .addSource(
+            "/** @type {{x: number}} */ var f;", //
+            "f.z;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType19a() {
+    // Verify loose property check behavior
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @constructor */",
+            "function Bar2() {}",
+            "/** @type {number} */",
+            "Bar2.prototype.prop;")
+        .addSource(
+            "/** @type {(Bar1|Bar2)} */ var b;", //
+            "var x = b.prop1")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType19b() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @constructor */",
+            "function Bar2() {}",
+            "/** @type {number} */",
+            "Bar2.prototype.prop;")
+        .addSource(
+            "/** @type {(Bar1|Bar2)} */ var b;", //
+            "var x = b.prop1")
+        .addDiagnostic("Property prop1 not defined on all member types of (Bar1|Bar2)")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType20() {
+    newTest()
+        .includeDefaultExterns()
+        .addExterns(
+            "/** @constructor */",
+            "function Bar1() {}",
+            "/** @type {number} */",
+            "Bar1.prototype.prop;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop1;",
+            "/** @type {number} */",
+            "Bar1.prototype.prop2;")
+        .addSource(
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {(Bar1|{prop:number, prop2: number})} */ var b;",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = b.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType20_2() {
+    newTest()
+        .includeDefaultExterns()
+        .addSource(
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {({prop:number, prop1: number, prop2: number}|",
+            "{prop:number, prop2: number})} */ var b;",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = b.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType21() {
+    newTest()
+        .addExterns("")
+        .addSource(
+            "/** @constructor */",
+            "function Bar1() {};",
+            "/** @type {number} */",
+            "Bar1.prototype.propName;",
+            "/** @type {number} */",
+            "Bar1.prototype.propName1;",
+            "/** @type {{prop2:number}} */ var c;",
+            "/** @type {(Bar1|{propName:number, propName1: number})} */ var b;",
+            "var x = b.prop2;")
+        .addDiagnostic("Property prop2 never defined on b")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType23() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function A() {}",
+            "/** @constructor @extends{A} */",
+            "function B() {}",
+            "",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @type {B} */",
+            "C.prototype.prop2;",
+            "/** @type {number} */",
+            "C.prototype.prop3;",
+            "",
+            "/** @constructor */",
+            "function D() {}",
+            "/** @type {number} */",
+            "D.prototype.prop;",
+            "/** @type {number} */",
+            "D.prototype.prop1;",
+            "/** @type {B} */",
+            "D.prototype.prop2;")
+        .addSource(
+            "/** @type {{prop2: A}} */ var record;",
+            "var xhr = new C();",
+            "if (true) { xhr = new D(); }",
+            // there should be no warning saying that
+            // prop2 is not defined on b;
+            "var x = xhr.prop2")
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType24() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** @type {!Function} */",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function, count: number}} */",
+            "  var x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{abort: Function})} */",
+            "  var y;",
+            "  y.abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType25() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** @type {!Function} */",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{!Function} */ var f;",
+            "  var x = {abort: f, count: 1}",
+            "  return x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{test2: number})} */",
+            "  var y;",
+            "  y.abort();",
+            "}")
+        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType26() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function}} */",
+            "  var x;",
+            "}",
+            "",
+            "function f2() {",
+            "  /** @type{(C|{test2: number})} */",
+            "  var y;",
+            "  /** @type {C} */ (y).abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType26AndAHalf() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "C.prototype.abort = function() {};",
+            "",
+            "/** @type{number} */",
+            "C.prototype.test2 = 1;",
+            "var g = function /** !C */(){};")
+        .addSource(
+            "function f() {",
+            "  /** @type{{abort: !Function}} */",
+            "  var x;",
+            "}",
+            "function f2() {",
+            "  var y = g();",
+            "  y.abort();",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType27() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function C(){}",
+            "/** @constructor @extends {C} */",
+            "function C2() {}")
+        .addSource(
+            "/** @type {{prop2:C}} */ var c;",
+            "/** @type {({prop:number, prop1: number, prop2: C}|",
+            "{prop:number, prop1: number, prop2: number})} */ var b;",
+            "var x = b.prop2;")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType28() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function XMLHttpRequest() {}",
+            "/**",
+            " * @return {undefined}",
+            " */",
+            "XMLHttpRequest.prototype.abort = function() {};",
+            "",
+            "/** @constructor */",
+            "function XDomainRequest() {}",
+            "",
+            "XDomainRequest.prototype.abort = function() {};")
+        .addSource(
+            "/**",
+            " * @typedef {{abort: !Function, close: !Function}}",
+            " */",
+            "var WritableStreamSink;",
+            "function sendCrossOrigin() {",
+            "  var xhr = new XMLHttpRequest;",
+            "  xhr = new XDomainRequest;",
+            "  return function() {",
+            "    xhr.abort();",
+            "  };",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType29() {
+    newTest()
+        .addExterns(
+            "/** @constructor */",
+            "function XMLHttpRequest() {}",
+            "/**",
+            " * @type {!Function}",
+            " */",
+            "XMLHttpRequest.prototype.abort = function() {};",
+            "",
+            "/** @constructor */",
+            "function XDomainRequest() {}",
+            "/**",
+            " * @type {!Function}",
+            " */",
+            "XDomainRequest.prototype.abort = function() {};")
+        .addSource(
+            "/**",
+            " * @typedef {{close: !Function, abort: !Function}}",
+            " */",
+            "var WritableStreamSink;",
+            "function sendCrossOrigin() {",
+            "  var xhr = new XMLHttpRequest;",
+            "  xhr = new XDomainRequest;",
+            "  return function() {",
+            "    xhr.abort();",
+            "  };",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType30() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function A() {}")
+        .addSource(
+            "/**",
+            " * @type {{prop1: (A)}}",
+            " */",
+            "var r1;",
+            "/**",
+            " * @type {{prop1: (A|undefined)}}",
+            " */",
+            "var r2;",
+            "r1 = r2")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop1: (A|null|undefined)}",
+                "required: {prop1: (A|null)}",
+                "missing : []",
+                "mismatch: [prop1]"))
+        .run();
+  }
+
+  @Test
+  public void testCovarianceForRecordType31() {
+    newTest()
+        .addExterns(
+            "/** @constructor */", //
+            "function A() {}")
+        .addSource(
+            "/**",
+            " * @type {{prop1: (A|null)}}",
+            " */",
+            "var r1;",
+            "/**",
+            " * @type {{prop1: (A|null|undefined)}}",
+            " */",
+            "var r2;",
+            "r1 = r2")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : {prop1: (A|null|undefined)}",
+                "required: {prop1: (A|null)}",
+                "missing : []",
+                "mismatch: [prop1]"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable1() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string|number>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable2() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !IThenable<string|number> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment",
+                "found   : IThenable<(number|string)>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable3() {
+    newTest()
+        .addSource(
+            "/** @type {!Promise<string|number>} */ var x;",
+            "function fn(/** !Promise<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenable4() {
+    newTest()
+        .addSource(
+            "/** @type {!Promise<string>} */ var x;",
+            "function fn(/** !Promise<string|number> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : Promise<(number|string)>",
+                "required: Promise<string>"))
+        .includeDefaultExterns()
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable1() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : IThenable<string>",
+                "required: Array<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable2() {
+    newTest()
+        .addSource(
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !Array<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : Array<string>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable3() {
+    newTest()
+        .addSource(
+            "/** ",
+            "  @constructor",
+            "  @template T",
+            " */",
+            "function C() {}",
+            "/** @type {!C<string>} */ var x;",
+            "function fn(/** !IThenable<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : IThenable<string>",
+                "required: C<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonThenable4() {
+    newTest()
+        .addSource(
+            "/** ",
+            "  @constructor",
+            "  @template T",
+            " */",
+            "function C() {}",
+            "/** @type {!IThenable<string>} */ var x;",
+            "function fn(/** !C<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : C<string>",
+                "required: IThenable<string>"))
+        .run();
+  }
+
+  @Test
+  public void testCovariantIThenableNonNativeSubclass() {
+    newTest()
+        .addSource(
+            "/**",
+            " * @implements {IThenable<T>}",
+            " * @template T",
+            " */",
+            "class CustomPromise {}",
+            "/** @type {!CustomPromise<(number|string)>} */ var x;",
+            "function fn(/** !CustomPromise<string> */ a ) {",
+            "  x = a;",
+            "}")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
index c61176d..66722b5 100644
--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java
@@ -21,6 +21,7 @@ import static com.google.javascript.jscomp.FunctionTypeBuilder.VAR_ARGS_MUST_BE_
 import static com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT;
 
 import com.google.javascript.rhino.Node;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -33,7 +34,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class TypeCheckFunctionCheckTest extends CompilerTestCase {
 
-  private CodingConvention convention = null;
+  private @Nullable CodingConvention convention = null;
 
   @Override
   protected CompilerPass getProcessor(Compiler compiler) {
diff --git a/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java b/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
index 222361f..d5d4f19 100644
--- a/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckNoTranspileTest.java
@@ -4789,7 +4789,7 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
 
   @Test
   public void testClassFieldsThis() {
-    newTest() // TODO(b/189993301): `this` should produce a type error
+    newTest()
         .addSource(
             "class F {", //
             "  /** @type {number} */",
@@ -4797,22 +4797,53 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "  /** @type {boolean} */",
             "  y = this.x",
             "}")
-        .addDiagnostic("Property x never defined on global this")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of F", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
   public void testClassFieldsSuper() {
-    newTest() // TODO(b/189993301): `super` should produce a type error
+    newTest()
         .addSource(
             "class G {", //
-            "  /** @type {number} */",
-            "  x = 2;",
+            "  /** @return {number} */",
+            "  getX() { return 2; }",
             "}",
             "class H extends G {",
+            "  /** @return {?} */",
+            "  /** @override*/ getX() {}",
             "  /** @type {string} */",
-            "  y = super.x;",
+            "  y = super.getX();",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of H", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testComputedFields() {
+    newTest()
+        .addSource(
+            "var /** number */ x = 1;",
+            "function takesNumber(/** number */ x) {}",
+            "/** @unrestricted */",
+            "class Foo {",
+            "  /** @type {boolean} */",
+            "  x = true;",
+            "  [this.x] = takesNumber(this.x);",
             "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of takesNumber does not match formal parameter", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
@@ -4854,7 +4885,7 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
 
   @Test
   public void testStaticClassFieldsThis() {
-    newTest() // TODO(b/189993301): `this` should produce a type error
+    newTest()
         .addSource(
             "class F {", //
             "  /** @type {number} */",
@@ -4862,13 +4893,37 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "  /** @type {boolean} */",
             "  static y = this.x",
             "}")
-        .addDiagnostic("Property x never defined on global this")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of F", //
+                "found   : number",
+                "required: boolean"))
+        .run();
+  }
+
+  @Test
+  public void testStaticComputedFields() {
+    newTest()
+        .addSource(
+            "var /** number */ x = 1;",
+            "function takesNumber(/** number */ x) {}",
+            "/** @unrestricted */",
+            "class Foo {",
+            "  /** @type {boolean} */",
+            "  static x = true;",
+            "  static [this.x] = takesNumber(this.x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of takesNumber does not match formal parameter", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
   public void testStaticClassFieldsSuper() {
-    newTest() // TODO(b/189993301): `super` should produce a type error
+    newTest()
         .addSource(
             "class G {", //
             "  /** @type {number} */",
@@ -4878,6 +4933,11 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "  /** @type {string} */",
             "  static y = super.x;",
             "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property y of H", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
@@ -4984,7 +5044,6 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
 
   @Test
   public void testClassStaticBlockWithWrongTypeSuper() {
-    // TODO(b/235871861): should be reporting a type error
     newTest()
         .addSource(
             "class Foo {",
@@ -4996,6 +5055,11 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "    super.str = 5;",
             "  }",
             "};")
+        .addDiagnostic(
+            lines(
+                "assignment to property str of super", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
@@ -5021,7 +5085,6 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
 
   @Test
   public void testClassStaticBlockWithWrongTypeSuperParameter() {
-    // TODO(b/235871861): should be reporting a type error
     newTest()
         .addSource(
             "class Foo {",
@@ -5032,6 +5095,11 @@ public final class TypeCheckNoTranspileTest extends TypeCheckTestCase {
             "    super.foo('str');",
             "  }",
             "};")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of super.foo does not match formal parameter",
+                "found   : string",
+                "required: number"))
         .run();
   }
 
diff --git a/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java b/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java
new file mode 100644
index 0000000..982214a
--- /dev/null
+++ b/test/com/google/javascript/jscomp/TypeCheckTemplatizedTest.java
@@ -0,0 +1,573 @@
+/*
+ * Copyright 2006 The Closure Compiler Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.javascript.jscomp;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.javascript.rhino.jstype.JSType;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests {@link TypeCheck}. */
+@RunWith(JUnit4.class)
+public final class TypeCheckTemplatizedTest extends TypeCheckTestCase {
+
+  @Test
+  public void testTemplatizedArray1() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray2() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<!Array<number>>} a\n"
+                + "* @return {number}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : Array<number>\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray3() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<number>} a\n"
+                + "* @return {number}\n"
+                + "*/ var f = function(a) { a[1] = 0; return a[0]; };")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray4() {
+    newTest()
+        .addSource("/** @param {!Array<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray5() {
+    newTest()
+        .addSource("/** @param {!Array<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray6() {
+    newTest()
+        .addSource(
+            "/** @param {!Array<*>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : *\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedArray7() {
+    newTest()
+        .addSource(
+            "/** @param {?Array<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject1() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a[0]; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObjectOnWindow() {
+    newTest()
+        .addExterns("/** @constructor */ window.Object = Object;")
+        .addSource(
+            "/** @param {!window.Object<number>} a",
+            " *  @return {string}",
+            " */ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObjectOnWindow2() {
+    newTest()
+        .addExterns("/** @const */ window.Object = Object;")
+        .addSource(
+            "/** @param {!window.Object<number>} a",
+            " *  @return {string}",
+            " */ var f = function(a) { return a[0]; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject2() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<string,number>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject3() {
+    newTest()
+        .addSource(
+            "/** @param {!Object<number,string>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject4() {
+    newTest()
+        .addSource(
+            "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n"
+                + "/** @param {!Object<E,string>} a\n"
+                + "* @return {string}\n"
+                + "*/ var f = function(a) { return a['x']; };")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: E<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedObject5() {
+    newTest()
+        .addSource(
+            "/** @constructor */ function F() {"
+                + "  /** @type {Object<number, string>} */ this.numbers = {};"
+                + "}"
+                + "(new F()).numbers['ten'] = '10';")
+        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized1() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */"
+                + "var arr1 = [];\n"
+                + "/** @type {!Array<number>} */"
+                + "var arr2 = [];\n"
+                + "arr1 = arr2;")
+        .addDiagnostic("assignment\n" + "found   : Array<number>\n" + "required: Array<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized2() {
+    newTest()
+        .addSource(
+            "/** @type {!Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : Array<number>\n" + "required: Array<string>")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized3() {
+    newTest()
+        .addSource(
+            "/** @type {Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : Array<number>\n"
+                + "required: (Array<string>|null)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized4() {
+    newTest()
+        .addSource(
+            "/** @type {Array<string>} */"
+                + "var arr1 = [];\n"
+                + "/** @type {Array<number>} */"
+                + "var arr2 = arr1;\n")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : (Array<string>|null)\n"
+                + "required: (Array<number>|null)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized5() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @param {Object<T>} obj\n"
+                + " * @return {boolean|undefined}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var some = function(obj) {"
+                + "  for (var key in obj) if (obj[key]) return true;"
+                + "};"
+                + "/** @return {!Array} */ function f() { return []; }"
+                + "/** @return {!Array<string>} */ function g() { return []; }"
+                + "some(f());\n"
+                + "some(g());\n")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized6() {
+    newTest()
+        .addSource(
+            "/** @interface */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {I}\n"
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + ""
+                + "/** @type {null} */ var some = new C().method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized7() {
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " * @implements {I<number>}\n"
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {null} */ var some = new C().method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  @Ignore
+  public void testTemplatized8() {
+    // TODO(johnlenz): this should generate a warning but does not.
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " *  @implements {I<R>}\n"
+                + " *  @template R\n "
+                + " */ function C(){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {C<number>} var x = new C();"
+                + "/** @type {null} */ var some = x.method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized9() {
+    newTest()
+        .addSource(
+            "/** @interface\n"
+                + " *  @template Q\n "
+                + " */ function I(){}\n"
+                + "/** @param {T} a\n"
+                + " * @return {T|Q}\n"
+                + " * @template T\n"
+                + "*/\n"
+                + "I.prototype.method;\n"
+                + "/** @constructor \n"
+                + " *  @param {R} a\n"
+                + " *  @implements {I<R>}\n"
+                + " *  @template R\n "
+                + " */ function C(a){}\n"
+                + "/** @override*/ C.prototype.method = function(a) {}\n"
+                + "/** @type {null} */ var some = new C(1).method('str');")
+        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized10() {
+    newTest()
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Parent() {};\n"
+                + "\n"
+                + "/** @param {T} x */\n"
+                + "Parent.prototype.method = function(x) {};\n"
+                + "\n"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Parent<string>}\n"
+                + " */\n"
+                + "function Child() {};\n"
+                + "Child.prototype = new Parent();\n"
+                + "\n"
+                + "(new Child()).method(123); \n")
+        .addDiagnostic(
+            "actual parameter 1 of Parent.prototype.method does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .run();
+  }
+
+  @Test
+  public void testTemplatized11() {
+    newTest()
+        .addSource(
+            "/** \n"
+                + " * @template T\n"
+                + " * @constructor\n"
+                + " */\n"
+                + "function C() {}\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {T|K} a\n"
+                + " * @return {T}\n"
+                + " * @template K\n"
+                + " */\n"
+                + "C.prototype.method = function(a) {};\n"
+                + "\n"
+                +
+                // method returns "?"
+                "/** @type {void} */ var x = new C().method(1);")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedTypeSubtypes2() {
+    JSType arrayOfNumber = createTemplatizedType(getNativeArrayType(), getNativeNumberType());
+    JSType arrayOfString = createTemplatizedType(getNativeArrayType(), getNativeStringType());
+    assertThat(arrayOfString.isSubtypeOf(createUnionType(arrayOfNumber, getNativeNullVoidType())))
+        .isFalse();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch1() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop;",
+            "function f(/** !WithPropT<number> */ x){}",
+            "/** @constructor */ function Foo() {}",
+            "/** @type {number} */ Foo.prototype.prop;",
+            "f(new Foo);")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch2() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {number} */ Foo.prototype.prop",
+            "f(new Foo)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMatch3() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<string> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {U} */ Foo.prototype.prop",
+            "f(new Foo)")
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch1() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor */ function Foo() {}",
+            "/** @type {string} */ Foo.prototype.prop = 'str'",
+            "f(new Foo)")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch2() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/** @constructor @template U */ function Foo() {}",
+            "/** @type {string} */ Foo.prototype.prop = 'str'",
+            "f(new Foo)")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<?>",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch3() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithPropT() {}",
+            "/** @type {T} */ WithPropT.prototype.prop",
+            "function f(/** !WithPropT<number> */ x){};",
+            "/**",
+            " * @constructor",
+            " * @template U",
+            " * @param {U} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {U} */ this.prop = x",
+            "}",
+            "f(new Foo('str'))")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<string>",
+                "required: WithPropT<number>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatch4() {
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithProp() {}",
+            "/** @type {T} */ WithProp.prototype.prop;",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.prop = 4;",
+            "}",
+            "/**",
+            " * @template U",
+            " * @param {!WithProp<U>} x",
+            " * @param {U} y",
+            " */",
+            "function f(x, y){};",
+            "f(new Foo, 'str')")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo",
+                "required: WithProp<string>",
+                "missing : []",
+                "mismatch: [prop]"))
+        .run();
+  }
+
+  @Test
+  public void testTemplatizedStructuralMismatchNotFound() {
+    // TODO(blickly): We would like to find the parameter mismatch here.
+    // Currently they match with type WithProp<?>, which is somewhat unsatisfying.
+    newTest()
+        .addSource(
+            "/** @record @template T */",
+            "function WithProp() {}",
+            "/** @type {T} */ WithProp.prototype.prop;",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.prop = 4;",
+            "}",
+            "/** @constructor */",
+            "function Bar() {",
+            "  /** @type {string} */ this.prop = 'str';",
+            "}",
+            "/**",
+            " * @template U",
+            " * @param {!WithProp<U>} x",
+            " * @param {!WithProp<U>} y",
+            " */",
+            "function f(x, y){};",
+            "f(new Foo, new Bar)")
+        .run();
+  }
+}
diff --git a/test/com/google/javascript/jscomp/TypeCheckTest.java b/test/com/google/javascript/jscomp/TypeCheckTest.java
index c65218c..0967062 100644
--- a/test/com/google/javascript/jscomp/TypeCheckTest.java
+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java
@@ -19,6 +19,7 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.javascript.jscomp.TypeCheck.CONFLICTING_GETTER_SETTER_TYPE;
+import static com.google.javascript.jscomp.TypeCheck.ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE;
 import static com.google.javascript.jscomp.TypeCheck.INSTANTIATE_ABSTRACT_CLASS;
 import static com.google.javascript.jscomp.TypeCheck.POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION;
 import static com.google.javascript.jscomp.TypeCheck.STRICT_INEXISTENT_PROPERTY;
@@ -46,6 +47,7 @@ import com.google.javascript.rhino.jstype.ObjectType;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -419,165 +421,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testTemplatizedArray1() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray2() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<!Array<number>>} a\n"
-                + "* @return {number}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : Array<number>\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray3() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<number>} a\n"
-                + "* @return {number}\n"
-                + "*/ var f = function(a) { a[1] = 0; return a[0]; };")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray4() {
-    newTest()
-        .addSource("/** @param {!Array<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray5() {
-    newTest()
-        .addSource("/** @param {!Array<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray6() {
-    newTest()
-        .addSource(
-            "/** @param {!Array<*>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : *\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedArray7() {
-    newTest()
-        .addSource(
-            "/** @param {?Array<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject1() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a[0]; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObjectOnWindow() {
-    newTest()
-        .addExterns("/** @constructor */ window.Object = Object;")
-        .addSource(
-            "/** @param {!window.Object<number>} a",
-            " *  @return {string}",
-            " */ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObjectOnWindow2() {
-    newTest()
-        .addExterns("/** @const */ window.Object = Object;")
-        .addSource(
-            "/** @param {!window.Object<number>} a",
-            " *  @return {string}",
-            " */ var f = function(a) { return a[0]; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject2() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<string,number>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject3() {
-    newTest()
-        .addSource(
-            "/** @param {!Object<number,string>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject4() {
-    newTest()
-        .addSource(
-            "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n"
-                + "/** @param {!Object<E,string>} a\n"
-                + "* @return {string}\n"
-                + "*/ var f = function(a) { return a['x']; };")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: E<string>")
-        .run();
-  }
-
-  @Test
-  public void testTemplatizedObject5() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function F() {"
-                + "  /** @type {Object<number, string>} */ this.numbers = {};"
-                + "}"
-                + "(new F()).numbers['ten'] = '10';")
-        .addDiagnostic("restricted index type\n" + "found   : string\n" + "required: number")
-        .run();
-  }
-
-  @Test
   public void testUnionOfFunctionAndType() {
     newTest()
         .addSource(
@@ -7666,7 +7509,7 @@ public final class TypeCheckTest extends TypeCheckTestCase {
                 + " */\n"
                 + "function Foo() {}\n"
                 + "(true ? new Foo() : {}).x = 123;")
-        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_MESSAGE)
+        .addDiagnostic(ILLEGAL_PROPERTY_CREATION_ON_UNION_TYPE)
         .run();
   }
 
@@ -11103,12884 +10946,9952 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testIssue61a() {
-    disableStrictMissingPropertyChecks();
+  public void testEnums() {
     newTest()
         .addSource(
-            "var ns = {};"
-                + "(function() {"
-                + "  /** @param {string} b */"
-                + "  ns.a = function(b) {};"
-                + "})();"
-                + "function d() {"
-                + "  ns.a(123);"
+            "var outer = function() {"
+                + "  /** @enum {number} */"
+                + "  var Level = {"
+                + "    NONE: 0,"
+                + "  };"
+                + "  /** @type {!Level} */"
+                + "  var l = Level.NONE;"
                 + "}")
-        .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
         .run();
   }
 
   @Test
-  public void testIssue61b() {
+  public void testStrictInterfaceCheck() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "(function() {",
-            "  /** @param {string} b */",
-            "  ns.a = function(b) {};",
-            "})();",
-            "ns.a(123);")
-        .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @interface */",
+            "function EventTarget() {}",
+            "/** @constructor \n * @implements {EventTarget} */",
+            "function Node() {}",
+            "/** @type {number} */ Node.prototype.index;",
+            "/** @param {EventTarget} x \n * @return {string} */",
+            "function foo(x) { return x.index; }")
+        .addDiagnostic("Property index never defined on EventTarget")
         .run();
   }
 
   @Test
-  public void testIssue61c() {
+  public void testTemplateSubtyping_0() {
+    // TODO(b/145145406): This is testing that things work despite this bug.
     newTest()
         .addSource(
-            "var ns = {};",
-            "(function() {",
-            "  /** @param {string} b */",
-            "  ns.a = function(b) {};",
-            "})();",
-            "ns.a(123);")
-        .addDiagnostic(
-            "actual parameter 1 of ns.a does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            // IFoo is a NamedType here.
+            "/** @implements {IFoo<number>} */",
+            "class Foo { }",
+            "",
+            "/**",
+            " * @template T",
+            " * @interface",
+            " */",
+            "class IFoo { }",
+            "",
+            "const /** !IFoo<number> */ x = new Foo();")
         .run();
   }
 
   @Test
-  public void testIssue86() {
+  public void testTemplateSubtyping_1() {
+    // TOOD(b/139230800): This is testing things work despite this bug.
     newTest()
         .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.get = function(){};"
-                + "/** @constructor \n * @implements {I} */ function F() {}"
-                + "/** @override */ F.prototype.get = function() { return true; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : boolean\n" + "required: number")
+            "/**",
+            " * @template T",
+            " * @interface",
+            " */",
+            "class IFoo { }",
+            "",
+            "/** @implements {IFoo<number>} */",
+            "class FooA { }",
+            "",
+            "/** @implements {IFoo<string>} */",
+            "class FooB extends FooA { }",
+            "",
+            "const /** !IFoo<number> */ x = new FooB();",
+            "const /** !IFoo<string> */ y = new FooB();")
         .run();
   }
 
   @Test
-  public void testIssue124() {
+  public void testTypedefBeforeUse() {
     newTest()
         .addSource(
-            "var t = null;"
-                + "function test() {"
-                + "  if (t != null) { t = null; }"
-                + "  t = 1;"
-                + "}")
+            "/** @typedef {Object<string, number>} */"
+                + "var map;"
+                + "/** @param {(map|function())} isResult */"
+                + "var f = function(isResult) {"
+                + "    while (true)"
+                + "        isResult['t'];"
+                + "};")
         .run();
   }
 
   @Test
-  public void testIssue124b() {
+  public void testScopedConstructors1() {
     newTest()
         .addSource(
-            "var t = null;"
-                + "function test() {"
-                + "  if (t != null) { t = null; }"
-                + "  t = undefined;"
+            "function foo1() { "
+                + "  /** @constructor */ function Bar() { "
+                + "    /** @type {number} */ this.x = 3;"
+                + "  }"
+                + "}"
+                + "function foo2() { "
+                + "  /** @constructor */ function Bar() { "
+                + "    /** @type {string} */ this.x = 'y';"
+                + "  }"
+                + "  /** "
+                + "   * @param {Bar} b\n"
+                + "   * @return {number}\n"
+                + "   */"
+                + "  function baz(b) { return b.x; }"
                 + "}")
-        .addDiagnostic(
-            "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null")
-        .run();
-  }
-
-  @Test
-  public void testIssue259() {
-    newTest()
-        .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */"
-                + "var Clock = function() {"
-                + "  /** @constructor */"
-                + "  this.Date = function() {};"
-                + "  f(new this.Date());"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : this.Date\n"
-                + "required: number")
+        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testIssue301() {
+  public void testScopedConstructors2() {
     newTest()
-        .addExterns(new TestExternsBuilder().addString().addArray().build())
         .addSource(
-            "Array.indexOf = function() {};",
-            "var s = 'hello';",
-            "alert(s.toLowerCase.indexOf('1'));")
-        .addDiagnostic("Property indexOf never defined on String.prototype.toLowerCase")
+            "/** @param {Function} f */"
+                + "function foo1(f) {"
+                + "  /** @param {Function} g */"
+                + "  f.prototype.bar = function(g) {};"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue368() {
+  public void testQualifiedNameInference1() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo(){}"
-                + "/**\n"
-                + " * @param {number} one\n"
-                + " * @param {string} two\n"
-                + " */\n"
-                + "Foo.prototype.add = function(one, two) {};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar(){}"
-                + "/** @override */\n"
-                + "Bar.prototype.add = function(ignored) {};"
-                + "(new Bar()).add(1, 2);")
-        .addDiagnostic(
-            "actual parameter 2 of Bar.prototype.add does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @constructor */ function Foo() {}"
+                + "/** @type {number?} */ Foo.prototype.bar = null;"
+                + "/** @type {number?} */ Foo.prototype.baz = null;"
+                + "/** @param {Foo} foo */"
+                + "function f(foo) {"
+                + "  while (true) {"
+                + "    if (!foo.baz) break; "
+                + "    foo.bar = null;"
+                + "  }"
+                +
+                // Tests a bug where this condition always evaluated to true.
+                "  return foo.bar == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue380() {
+  public void testQualifiedNameInference2() {
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().addObject().build())
         .addSource(
-            "/** @type { function(string): {innerHTML: string} } */",
-            "document.getElementById;",
-            "var list = /** @type {!Array<string>} */ ['hello', 'you'];",
-            "list.push('?');",
-            "document.getElementById('node').innerHTML = list.toString();")
+            "var x = {};"
+                + "x.y = c;"
+                + "function f(a, b) {"
+                + "  if (a) {"
+                + "    if (b) "
+                + "      x.y = 2;"
+                + "    else "
+                + "      x.y = 1;"
+                + "  }"
+                + "  return x.y == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue483() {
+  public void testQualifiedNameInference3() {
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "/** @constructor */ function C() {",
-            "  /** @type {?Array} */ this.a = [];",
-            "}",
-            "C.prototype.f = function() {",
-            "  if (this.a.length > 0) {",
-            "    g(this.a);",
-            "  }",
-            "};",
-            "/** @param {number} a */ function g(a) {}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : Array",
-                "required: number"))
-        .run();
-  }
-
-  @Test
-  public void testIssue537a() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {method: function() {}};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz()) this.method(1);"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
+            "var x = {};"
+                + "x.y = c;"
+                + "function f(a, b) {"
+                + "  if (a) {"
+                + "    if (b) "
+                + "      x.y = 2;"
+                + "    else "
+                + "      x.y = 1;"
                 + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic(
-            "Function Foo.prototype.method: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
-        .includeDefaultExterns()
+                + "  return x.y == null;"
+                + "} function g() { x.y = null; }")
         .run();
   }
 
   @Test
-  public void testIssue537b() {
+  public void testQualifiedNameInference4() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {method: function() {}};"
+            "/** @param {string} x */ function f(x) {}\n"
                 + "/**\n"
+                + " * @param {?string} x \n"
                 + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz(1)) this.method();"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
-                + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic(
-            "Function Bar.prototype.baz: called with 1 argument(s). "
-                + "Function requires at least 0 argument(s) "
-                + "and no more than 0 argument(s).")
-        .includeDefaultExterns()
+                + " */"
+                + "function Foo(x) { this.x_ = x; }\n"
+                + "Foo.prototype.bar = function() {"
+                + "  if (this.x_) { f(this.x_); }"
+                + "};")
         .run();
   }
 
   @Test
-  public void testIssue537c() {
+  public void testQualifiedNameInference5() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  Foo.call(this);"
-                + "  if (this.baz2()) alert(1);"
-                + "}"
-                + "Bar.prototype = {"
-                + "  baz: function() {"
-                + "    return true;"
-                + "  }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .addDiagnostic("Property baz2 never defined on Bar")
-        .includeDefaultExterns()
+            "var ns = {}; "
+                + "(function() { "
+                + "    /** @param {number} x */ ns.foo = function(x) {}; })();"
+                + "(function() { ns.foo(true); })();")
+        .addDiagnostic(
+            "actual parameter 1 of ns.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIssue537d() {
+  public void testQualifiedNameInference6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype = {"
-                + "  /** @return {Bar} */ x: function() { new Bar(); },"
-                + "  /** @return {Foo} */ y: function() { new Bar(); }"
-                + "};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {"
-                + "  this.xy = 3;"
-                + "}"
-                + "/** @return {Bar} */ function f() { return new Bar(); }"
-                + "/** @return {Foo} */ function g() { return new Bar(); }"
-                + "Bar.prototype = {"
-                + "  /** @override @return {Bar} */ x: function() { new Bar(); },"
-                + "  /** @override @return {Foo} */ y: function() { new Bar(); }"
-                + "};"
-                + "Bar.prototype.__proto__ = Foo.prototype;")
-        .includeDefaultExterns()
+            "/** @const */ var ns = {}; "
+                + "/** @param {number} x */ ns.foo = function(x) {};"
+                + "(function() { "
+                + "    ns.foo = function(x) {};"
+                + "    ns.foo(true); "
+                + "})();")
+        .addDiagnostic(
+            "actual parameter 1 of ns.foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIssue586() {
+  public void testQualifiedNameInference7() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @constructor */"
-                + "var MyClass = function() {};"
-                + "/** @param {boolean} success */"
-                + "MyClass.prototype.fn = function(success) {};"
-                + "MyClass.prototype.test = function() {"
-                + "  this.fn();"
-                + "  this.fn = function() {};"
-                + "};")
+            "var ns = {}; "
+                + "(function() { "
+                + "  /** @constructor \n * @param {number} x */ "
+                + "  ns.Foo = function(x) {};"
+                + "  /** @param {ns.Foo} x */ function f(x) {}"
+                + "  f(new ns.Foo(true));"
+                + "})();")
         .addDiagnostic(
-            "Function MyClass.prototype.fn: called with 0 argument(s). "
-                + "Function requires at least 1 argument(s) "
-                + "and no more than 1 argument(s).")
+            "actual parameter 1 of ns.Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIssue635() {
-    // TODO(nicksantos): Make this emit a warning, because of the 'this' type.
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function F() {}"
-                + "F.prototype.bar = function() { this.baz(); };"
-                + "F.prototype.baz = function() {};"
-                + "/** @constructor */"
-                + "function G() {}"
-                + "G.prototype.bar = F.prototype.bar;")
-        .run();
+  public void testQualifiedNameInference8() {
+    disableStrictMissingPropertyChecks();
+    testClosureTypesMultipleWarnings(
+        "var ns = {}; "
+            + "(function() { "
+            + "  /** @constructor \n * @param {number} x */ "
+            + "  ns.Foo = function(x) {};"
+            + "})();"
+            + "/** @param {ns.Foo} x */ function f(x) {}"
+            + "f(new ns.Foo(true));",
+        ImmutableList.of(
+            "actual parameter 1 of ns.Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number"));
   }
 
   @Test
-  public void testIssue635b() {
+  public void testQualifiedNameInference9() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function F() {}",
-            "/** @constructor */",
-            "function G() {}",
-            "/** @type {function(new:G)} */ var x = F;")
+            "var ns = {}; "
+                + "ns.ns2 = {}; "
+                + "(function() { "
+                + "  /** @constructor \n * @param {number} x */ "
+                + "  ns.ns2.Foo = function(x) {};"
+                + "  /** @param {ns.ns2.Foo} x */ function f(x) {}"
+                + "  f(new ns.ns2.Foo(true));"
+                + "})();")
         .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (typeof F)",
-                "required: function(new:G): ?"))
+            "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIssue669() {
+  public void testQualifiedNameInference10() {
     newTest()
         .addSource(
-            "/** @return {{prop1: (Object|undefined)}} */"
-                + "function f(a) {"
-                + "  var results;"
-                + "  if (a) {"
-                + "    results = {};"
-                + "    results.prop1 = {a: 3};"
-                + "  } else {"
-                + "    results = {prop2: 3};"
-                + "  }"
-                + "  return results;"
-                + "}")
+            "var ns = {}; "
+                + "ns.ns2 = {}; "
+                + "(function() { "
+                + "  /** @interface */ "
+                + "  ns.ns2.Foo = function() {};"
+                + "  /** @constructor \n * @implements {ns.ns2.Foo} */ "
+                + "  function F() {}"
+                + "  (new F());"
+                + "})();")
         .run();
   }
 
   @Test
-  public void testIssue688() {
+  public void testQualifiedNameInference11() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @const */ var SOME_DEFAULT =\n"
-                + "    /** @type {TwoNumbers} */ ({first: 1, second: 2});\n"
-                + "/**\n"
-                + "* Class defining an interface with two numbers.\n"
-                + "* @interface\n"
-                + "*/\n"
-                + "function TwoNumbers() {}\n"
-                + "/** @type {number} */\n"
-                + "TwoNumbers.prototype.first;\n"
-                + "/** @type {number} */\n"
-                + "TwoNumbers.prototype.second;\n"
-                + "/** @return {number} */ function f() { return SOME_DEFAULT; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (TwoNumbers|null)\n" + "required: number")
+            "/** @constructor */ function Foo() {}"
+                + "function f() {"
+                + "  var x = new Foo();"
+                + "  x.onload = function() {"
+                + "    x.onload = null;"
+                + "  };"
+                + "}")
         .run();
   }
 
   @Test
-  public void testTypeofBigInt() {
+  public void testQualifiedNameInference12() {
+    disableStrictMissingPropertyChecks();
+    // We should be able to tell that the two 'this' properties
+    // are different.
     newTest()
         .addSource(
-            "/**",
-            " * @param {bigint|number} i",
-            " * @return {boolean}",
-            " */",
-            "function foo(i) {",
-            "  return typeof i === 'bigint';",
+            "/** @param {function(this:Object)} x */ function f(x) {}",
+            "/** @constructor */ function Foo() {",
+            "  /** @type {number} */ this.bar = 3;",
+            "  f(function() { this.bar = true; });",
             "}")
         .run();
   }
 
   @Test
-  public void testIssue700() {
+  public void testQualifiedNameInference13() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {{text: string}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp1(opt_data) {\n"
-                + "  return opt_data.text;\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp2(opt_data) {\n"
-                + "  /** @suppress {checkTypes} */\n"
-                + "  function __inner() {\n"
-                + "    return temp1(opt_data.activity);\n"
-                + "  }\n"
-                + "  return __inner();\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {{n: number, text: string, b: boolean}} opt_data\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function temp3(opt_data) {\n"
-                + "  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n"
-                + "}\n"
-                + "\n"
-                + "function callee() {\n"
-                + "  var output = temp3({\n"
-                + "    n: 0,\n"
-                + "    text: 'a string',\n"
-                + "    b: true\n"
-                + "  })\n"
-                + "  alert(output);\n"
-                + "}\n"
-                + "\n"
-                + "callee();")
+            "/** @constructor */ function Foo() {}"
+                + "function f(z) {"
+                + "  var x = new Foo();"
+                + "  if (z) {"
+                + "    x.onload = function() {};"
+                + "  } else {"
+                + "    x.onload = null;"
+                + "  };"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue725() {
+  public void testQualifiedNameInference14() {
+    // Unconditional blocks don't cause functions to be treated as inferred.
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @typedef {{name: string}} */ var RecordType1;"
-                + "/** @typedef {{name2222: string}} */ var RecordType2;"
-                + "/** @param {RecordType1} rec */ function f(rec) {"
-                + "  alert(rec.name2222);"
-                + "}")
-        .addDiagnostic("Property name2222 never defined on rec")
+            "/** @constructor */ function Foo() {}",
+            "function f(z) {",
+            "  var x = new Foo();",
+            "  {",
+            "    x.onload = function() {};",
+            "  }",
+            "  {",
+            "    x.onload = null;",
+            "  };",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : null",
+                "required: function(): undefined"))
         .run();
   }
 
   @Test
-  public void testIssue726() {
+  public void testScopeQualifiedNamesOnThis() {
+    // Ensure that we don't flow-scope qualified names on 'this' too broadly.
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @param {number} x */ Foo.prototype.bar = function(x) {};"
-                + "/** @return {!Function} */ "
-                + "Foo.prototype.getDeferredBar = function() { "
-                + "  var self = this;"
-                + "  return function() {"
-                + "    self.bar(true);"
-                + "  };"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @constructor */ function Foo() {",
+            "  /** @type {!Bar} */",
+            "  this.baz = new Bar();",
+            "}",
+            "Foo.prototype.foo = function() {",
+            "  this.baz.bar();",
+            "};",
+            "/** @constructor */ function Bar() {",
+            "  /** @type {!Foo} */",
+            "  this.baz = new Foo();",
+            "}",
+            "Bar.prototype.bar = function() {",
+            "  this.baz.foo();",
+            "};")
         .run();
   }
 
   @Test
-  public void testIssue765() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "var AnotherType = function(parent) {"
-                + "    /** @param {string} stringParameter Description... */"
-                + "    this.doSomething = function(stringParameter) {};"
-                + "};"
-                + "/** @constructor */"
-                + "var YetAnotherType = function() {"
-                + "    this.field = new AnotherType(self);"
-                + "    this.testfun=function(stringdata) {"
-                + "        this.field.doSomething(null);"
-                + "    };"
-                + "};")
-        .addDiagnostic(
-            "actual parameter 1 of AnotherType.doSomething "
-                + "does not match formal parameter\n"
-                + "found   : null\n"
-                + "required: string")
-        .run();
+  public void testSheqRefinedScope() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */function A() {}\n"
+                + "/** @constructor \n @extends A */ function B() {}\n"
+                + "/** @return {number} */\n"
+                + "B.prototype.p = function() { return 1; }\n"
+                + "/** @param {A} a\n @param {B} b */\n"
+                + "function f(a, b) {\n"
+                + "  b.p();\n"
+                + "  if (a === b) {\n"
+                + "    b.p();\n"
+                + "  }\n"
+                + "}");
+    Node nodeC =
+        n.getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getLastChild();
+    JSType typeC = nodeC.getJSType();
+    assertThat(typeC.isNumber()).isTrue();
+
+    Node nodeB = nodeC.getFirstFirstChild();
+    JSType typeB = nodeB.getJSType();
+    assertThat(typeB.toString()).isEqualTo("B");
   }
 
   @Test
-  public void testIssue783() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "var Type = function() {"
-                + "  /** @type {Type} */"
-                + "  this.me_ = this;"
-                + "};"
-                + "Type.prototype.doIt = function() {"
-                + "  var me = this.me_;"
-                + "  for (var i = 0; i < me.unknownProp; i++) {}"
-                + "};")
-        .addDiagnostic("Property unknownProp never defined on Type")
-        .run();
+  public void testAssignToUntypedVariable() {
+    Node n = parseAndTypeCheck("var z; z = 1;");
+
+    Node assign = n.getLastChild().getFirstChild();
+    Node node = assign.getFirstChild();
+    assertThat(node.getJSType().isUnknownType()).isFalse();
+    assertThat(node.getJSType().toString()).isEqualTo("number");
   }
 
   @Test
-  public void testIssue791() {
-    newTest()
-        .addSource(
-            "/** @param {{func: function()}} obj */"
-                + "function test1(obj) {}"
-                + "var fnStruc1 = {};"
-                + "fnStruc1.func = function() {};"
-                + "test1(fnStruc1);")
-        .run();
+  public void testAssignToUntypedProperty() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;");
+
+    Node node = n.getLastChild().getFirstChild();
+    assertThat(node.getJSType().isUnknownType()).isFalse();
+    assertThat(node.getJSType().isNumber()).isTrue();
   }
 
   @Test
-  public void testIssue810() {
-    newTest()
-        .addSource(
-            "/** @constructor */",
-            "var Type = function() {",
-            "  this.prop = x;",
-            "};",
-            "Type.prototype.doIt = function(obj) {",
-            "  this.prop = obj.unknownProp;",
-            "};")
-        .addDiagnostic(
-            "Property unknownProp never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
+  public void testNew1() {
+    newTest().addSource("new 4").addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR).run();
   }
 
   @Test
-  public void testIssue1002() {
+  public void testNew2() {
     newTest()
-        .addSource(
-            "/** @interface */"
-                + "var I = function() {};"
-                + "/** @constructor @implements {I} */"
-                + "var A = function() {};"
-                + "/** @constructor @implements {I} */"
-                + "var B = function() {};"
-                + "var f = function() {"
-                + "  if (A === B) {"
-                + "    new B();"
-                + "  }"
-                + "};")
+        .addSource("var Math = {}; new Math()")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue1023() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function F() {}"
-                + "(function() {"
-                + "  F.prototype = {"
-                + "    /** @param {string} x */"
-                + "    bar: function(x) {  }"
-                + "  };"
-                + "})();"
-                + "(new F()).bar(true)")
-        .addDiagnostic(
-            "actual parameter 1 of F.prototype.bar does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: string")
-        .run();
+  public void testNew3() {
+    newTest().addSource("new Date()").run();
   }
 
   @Test
-  public void testIssue1047() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C2() {}\n"
-                + "\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C3(c2) {\n"
-                + "  /**\n"
-                + "   * @type {C2} \n"
-                + "   * @private\n"
-                + "   */\n"
-                + "  this.c2_;\n"
-                + "\n"
-                + "  var x = this.c2_.prop;\n"
-                + "}")
-        .addDiagnostic("Property prop never defined on C2")
-        .run();
+  public void testNew4() {
+    newTest().addSource("/** @constructor */function A(){}; new A();").run();
   }
 
   @Test
-  public void testIssue1056() {
+  public void testNew5() {
     newTest()
-        .addSource("/** @type {Array} */ var x = null;" + "x.push('hi');")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : null\n" + "required: Object")
+        .addSource("function A(){}; new A();")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue1072() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {string} x\n"
-                + " * @return {number}\n"
-                + " */\n"
-                + "var f1 = function(x) {\n"
-                + "  return 3;\n"
-                + "};\n"
-                + "\n"
-                + "/** Function */\n"
-                + "var f2 = function(x) {\n"
-                + "  if (!x) throw new Error()\n"
-                + "  return /** @type {number} */ (f1('x'))\n"
-                + "}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {string} x\n"
-                + " */\n"
-                + "var f3 = function(x) {};\n"
-                + "\n"
-                + "f1(f3);")
-        .addDiagnostic(
-            "actual parameter 1 of f1 does not match formal parameter\n"
-                + "found   : function(string): undefined\n"
-                + "required: string")
-        .run();
+  public void testNew6() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();");
+
+    JSType aType = p.scope.getVar("a").getType();
+    assertThat(aType).isInstanceOf(ObjectType.class);
+    ObjectType aObjectType = (ObjectType) aType;
+    assertThat(aObjectType.getConstructor().getReferenceName()).isEqualTo("A");
   }
 
   @Test
-  public void testIssue1123() {
+  public void testNew7() {
     newTest()
-        .addSource("/** @param {function(number)} g */ function f(g) {}" + "f(function(a, b) {})")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : function(?, ?): undefined\n"
-                + "required: function(number): ?")
+        .addSource(
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "if (opt_constructor) { new opt_constructor; }"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue1201() {
+  public void testNew8() {
     newTest()
         .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "/** @constructor */ function F() {}"
-                + "/** desc */ F.prototype.bar = function() {};"
-                + "g(new F().bar);")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : function(this:F): undefined\n"
-                + "required: function(this:undefined): ?")
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "new opt_constructor;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue1201b() {
+  public void testNew9() {
     newTest()
         .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "/** @constructor */ function F() {}"
-                + "/** desc */ F.prototype.bar = function() {};"
-                + "var f = new F();"
-                + "g(f.bar.bind(f));")
-        .includeDefaultExterns()
+            "/** @param {Function} opt_constructor */"
+                + "function foo(opt_constructor) {"
+                + "new (opt_constructor || Array);"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue1201c() {
+  public void testNew10() {
     newTest()
         .addSource(
-            "/** @param {function(this:void)} f */ function g(f) {}"
-                + "g(function() { this.alert() })")
-        .addDiagnostic(
-            "No properties on this expression\n" + "found   : undefined\n" + "required: Object")
+            "var goog = {};"
+                + "/** @param {Function} opt_constructor */"
+                + "goog.Foo = function(opt_constructor) {"
+                + "new (opt_constructor || Array);"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIssue926a() {
+  public void testNew11() {
     newTest()
         .addSource(
-            "/** x */ function error() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @param {string} error\n"
-                + " */\n"
-                + "function C(error) {\n"
-                + " /** @const */ this.e = error;\n"
-                + "}"
-                + "/** @type {number} */ var x = (new C('x')).e;")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: number")
+            "/** @param {Function} c1 */"
+                + "function f(c1) {"
+                + "  var c2 = function(){};"
+                + "  c1.prototype = new c2;"
+                + "}")
+        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
         .run();
   }
 
   @Test
-  public void testIssue926b() {
-    newTest()
-        .addSource(
-            "/** @constructor */\n"
-                + "function A() {\n"
-                + " /** @constructor */\n"
-                + " function B() {}\n"
-                + " /** @type {!B} */ this.foo = new B();"
-                + " /** @type {!B} */ var C = new B();"
-                + "}"
-                + "/** @type {number} */ var x = (new A()).foo;")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: number")
-        .run();
+  public void testNew12() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertTypeEquals(getNativeArrayType(), a.getType());
   }
 
   @Test
-  public void testEnums() {
-    newTest()
-        .addSource(
-            "var outer = function() {"
-                + "  /** @enum {number} */"
-                + "  var Level = {"
-                + "    NONE: 0,"
-                + "  };"
-                + "  /** @type {!Level} */"
-                + "  var l = Level.NONE;"
-                + "}")
-        .run();
+  public void testNew13() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "/** @constructor */function FooBar(){};" + "var a = new FooBar();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("FooBar");
   }
 
-  /**
-   * Tests that the || operator is type checked correctly, that is of the type of the first argument
-   * or of the second argument. See bugid 592170 for more details.
-   */
   @Test
-  public void testBug592170() {
-    newTest()
-        .addSource(
-            "/** @param {Function} opt_f ... */"
-                + "function foo(opt_f) {"
-                + "  /** @type {Function} */"
-                + "  return opt_f || function() {};"
-                + "}")
-        .run();
+  public void testNew14() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("FooBar");
   }
 
   @Test
-  public void testNullishCoalesceTypeIsFirstOrSecondArgument() {
-    newTest()
-        .addSource(
-            "/** @param {Function} opt_f ... */",
-            "function foo(opt_f) {",
-            "  /** @type {Function} */",
-            "  return opt_f ?? function() {};",
-            "}")
-        .run();
+  public void testNew15() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            "var goog = {};"
+                + "/** @constructor */goog.A = function(){};"
+                + "var a = new goog.A();");
+    TypedVar a = p.scope.getVar("a");
+
+    assertThat(a.getType()).isInstanceOf(ObjectType.class);
+    assertThat(a.getType().toString()).isEqualTo("goog.A");
   }
 
-  /**
-   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
-   * of the side on which the undefined value is.
-   */
   @Test
-  public void testBug901455a() {
+  public void testNew16() {
     newTest()
         .addSource(
-            "/** @return {(number|undefined)} */ function a() { return 3; }"
-                + "var b = undefined === a()")
+            "/** \n"
+                + " * @param {string} x \n"
+                + " * @constructor \n"
+                + " */"
+                + "function Foo(x) {}"
+                + "function g() { new Foo(1); }")
+        .addDiagnostic(
+            "actual parameter 1 of Foo does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
-  /**
-   * Tests that undefined can be compared shallowly to a value of type (number,undefined) regardless
-   * of the side on which the undefined value is.
-   */
   @Test
-  public void testBug901455b() {
+  public void testNew17() {
     newTest()
-        .addSource(
-            "/** @return {(number|undefined)} */ function a() { return 3; }"
-                + "var b = a() === undefined")
+        .addSource("var goog = {}; goog.x = 3; new goog.x")
+        .addDiagnostic("cannot instantiate non-constructor")
         .run();
   }
 
-  /** Tests that the match method of strings returns nullable arrays. */
   @Test
-  public void testBug908701() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
+  public void testNew18() {
+    newTest()
         .addSource(
-            "/** @type {String} */ var s = new String('foo');", //
-            "var b = s.match(/a/) != null;")
+            "var goog = {};"
+                + "/** @constructor */ goog.F = function() {};"
+                + "/** @constructor */ goog.G = goog.F;")
         .run();
   }
 
-  /** Tests that named types play nicely with subtyping. */
   @Test
-  public void testBug908625() {
+  public void testNew19() {
     newTest()
-        .addSource(
-            "/** @constructor */function A(){}"
-                + "/** @constructor\n * @extends A */function B(){}"
-                + "/** @param {B} b"
-                + "\n @return {(A|undefined)} */function foo(b){return b}")
+        .addSource("/** @constructor @abstract */ var Foo = function() {}; var foo = new Foo();")
+        .addDiagnostic(INSTANTIATE_ABSTRACT_CLASS)
         .run();
   }
 
-  /**
-   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
-   * this variable is legal.
-   */
   @Test
-  public void testBug911118a() {
-    // verifying the type assigned to function expressions assigned variables
-    TypedScope s = parseAndTypeCheckWithScope("var a = function(){};").scope;
-    JSType type = s.getVar("a").getType();
-    assertThat(type.toString()).isEqualTo("function(): undefined");
-  }
-
-  /**
-   * Tests that assigning two untyped functions to a variable whose type is inferred and calling
-   * this variable is legal.
-   */
-  @Test
-  public void testBug911118b() {
-    // verifying the bug example
+  public void testNew20() {
     newTest()
         .addSource(
-            "function nullFunction() {};"
-                + "var foo = nullFunction;"
-                + "foo = function() {};"
-                + "foo();")
+            "/** @constructor @abstract */",
+            "function Bar() {};",
+            "/** @return {function(new:Bar)} */",
+            "function foo() {}",
+            "var Foo = foo();",
+            "var f = new Foo;")
         .run();
   }
 
   @Test
-  public void testBug909000() {
-    newTest()
-        .addSource(
-            "/** @constructor */function A(){}\n"
-                + "/** @param {!A} a\n"
-                + "@return {boolean}*/\n"
-                + "function y(a) { return a }")
-        .addDiagnostic("inconsistent return type\n" + "found   : A\n" + "required: boolean")
-        .run();
+  public void testName1() {
+    assertTypeEquals(getNativeVoidType(), testNameNode("undefined"));
   }
 
   @Test
-  public void testBug930117() {
-    newTest()
-        .addSource("/** @param {boolean} x */function f(x){}" + "f(null);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : null\n"
-                + "required: boolean")
-        .run();
+  public void testName2() {
+    assertTypeEquals(getNativeObjectConstructorType(), testNameNode("Object"));
+  }
+
+  @Test
+  public void testName3() {
+    assertTypeEquals(getNativeArrayConstructorType(), testNameNode("Array"));
+  }
+
+  @Test
+  public void testName4() {
+    assertTypeEquals(getNativeDateConstructorType(), testNameNode("Date"));
+  }
+
+  @Test
+  public void testName5() {
+    assertTypeEquals(getNativeRegexpConstructorType(), testNameNode("RegExp"));
+  }
+
+  /** Type checks a NAME node and retrieve its type. */
+  private JSType testNameNode(String name) {
+    Node node = Node.newString(Token.NAME, name);
+    Node parent = new Node(Token.SCRIPT, node);
+    parent.setInputId(new InputId("code"));
+
+    Node externs = new Node(Token.SCRIPT);
+    externs.setInputId(new InputId("externs"));
+
+    Node root = IR.root(IR.root(externs), IR.root(parent));
+
+    makeTypeCheck().processForTesting(root.getFirstChild(), root.getSecondChild());
+    return node.getJSType();
   }
 
   @Test
-  public void testBug1484445() {
+  public void testBitOperation1() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {number?} */ Foo.prototype.bar = null;"
-                + "/** @type {number?} */ Foo.prototype.baz = null;"
-                + "/** @param {Foo} foo */"
-                + "function f(foo) {"
-                + "  while (true) {"
-                + "    if (foo.bar == null && foo.baz == null) {"
-                + "      foo.bar;"
-                + "    }"
-                + "  }"
-                + "}")
+        .addSource("/**@return {void}*/function foo(){ ~foo(); }")
+        .addDiagnostic("operator ~ cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testBug1859535() {
-    disableStrictMissingPropertyChecks();
+  public void testBitOperation2() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {Function} childCtor Child class.\n"
-                + " * @param {Function} parentCtor Parent class.\n"
-                + " */"
-                + "var inherits = function(childCtor, parentCtor) {"
-                + "  /** @constructor */"
-                + "  function tempCtor() {};"
-                + "  tempCtor.prototype = parentCtor.prototype;"
-                + "  childCtor.superClass_ = parentCtor.prototype;"
-                + "  childCtor.prototype = new tempCtor();"
-                + "  /** @override */ childCtor.prototype.constructor = childCtor;"
-                + "};"
-                + "/**"
-                + " * @param {Function} constructor\n"
-                + " * @param {Object} var_args\n"
-                + " * @return {Object}\n"
-                + " */"
-                + "var factory = function(constructor, var_args) {"
-                + "  /** @constructor */"
-                + "  var tempCtor = function() {};"
-                + "  tempCtor.prototype = constructor.prototype;"
-                + "  var obj = new tempCtor();"
-                + "  constructor.apply(obj, arguments);"
-                + "  return obj;"
-                + "};")
-        .includeDefaultExterns()
+        .addSource("/**@return {void}*/function foo(){var a = foo()<<3;}")
+        .addDiagnostic("operator << cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testBug1940591() {
-    disableStrictMissingPropertyChecks();
+  public void testBitOperation3() {
     newTest()
-        .addSource(
-            "/** @type {Object} */"
-                + "var a = {};\n"
-                + "/** @type {number} */\n"
-                + "a.name = 0;\n"
-                + "/**\n"
-                + " * @param {Function} x anything.\n"
-                + " */\n"
-                + "a.g = function(x) { x.name = 'a'; }")
+        .addSource("/**@return {void}*/function foo(){var a = 3<<foo();}")
+        .addDiagnostic("operator << cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testBug1942972() {
+  public void testBitOperation4() {
     newTest()
-        .addSource(
-            "var google = {\n"
-                + "  gears: {\n"
-                + "    factory: {},\n"
-                + "    workerPool: {}\n"
-                + "  }\n"
-                + "};\n"
-                + "\n"
-                + "google.gears = {factory: {}};\n")
+        .addSource("/**@return {void}*/function foo(){var a = foo()>>>3;}")
+        .addDiagnostic("operator >>> cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testBug1943776() {
+  public void testBitOperation5() {
     newTest()
-        .addSource(
-            "/** @return  {{foo: Array}} */" + "function bar() {" + "  return {foo: []};" + "}")
+        .addSource("/**@return {void}*/function foo(){var a = 3>>>foo();}")
+        .addDiagnostic("operator >>> cannot be applied to undefined")
         .run();
   }
 
   @Test
-  public void testBug1987544() {
+  public void testBitOperation6() {
     newTest()
-        .addSource(
-            "/** @param {string} x */ function foo(x) {}"
-                + "var duration;"
-                + "if (true && !(duration = 3)) {"
-                + " foo(duration);"
-                + "}")
+        .addSource("/**@return {!Object}*/function foo(){var a = foo()&3;}")
         .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "bad left operand to bitwise operator\n"
+                + "found   : Object\n"
+                + "required: (boolean|null|number|string|undefined)")
         .run();
   }
 
   @Test
-  public void testBug1940769() {
-    newTest()
-        .addSource(
-            "/** @return {!Object} */ "
-                + "function proto(obj) { return obj.prototype; }"
-                + "/** @constructor */ function Map() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Map}\n"
-                + " */"
-                + "function Map2() { Map.call(this); };"
-                + "Map2.prototype = proto(Map);")
-        .includeDefaultExterns()
-        .run();
+  public void testBitOperation7() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;").run();
   }
 
   @Test
-  public void testBug2335992() {
-    disableStrictMissingPropertyChecks();
+  public void testBitOperation8() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+    newTest().addSource("var x = void 0; x |= new Number(3);").run();
+  }
 
+  @Test
+  public void testBitOperation9() {
+    compiler
+        .getOptions()
+        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
     newTest()
-        .addSource(
-            "/** @return {*} */ function f() { return 3; }"
-                + "var x = f();"
-                + "/** @type {string} */"
-                + "x.y = 3;")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+        .addSource("var x = void 0; x |= {};")
+        .addDiagnostic(
+            "bad right operand to bitwise operator\n"
+                + "found   : {}\n"
+                + "required: (boolean|null|number|string|undefined)")
         .run();
   }
 
   @Test
-  public void testBug2341812() {
-    disableStrictMissingPropertyChecks();
+  public void testCall1() {
+    newTest().addSource("3();").addDiagnostic("number expressions are not callable").run();
+  }
 
+  @Test
+  public void testCall2() {
     newTest()
-        .addSource(
-            "/** @interface */"
-                + "function EventTarget() {}"
-                + "/** @constructor \n * @implements {EventTarget} */"
-                + "function Node() {}"
-                + "/** @type {number} */ Node.prototype.index;"
-                + "/** @param {EventTarget} x \n * @return {string} */"
-                + "function foo(x) { return x.index; }")
+        .addSource("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: Number")
         .run();
   }
 
   @Test
-  public void testStrictInterfaceCheck() {
+  public void testCall3() {
+    // We are checking that an unresolved named type can successfully
+    // meet with a functional type to produce a callable type.
     newTest()
         .addSource(
-            "/** @interface */",
-            "function EventTarget() {}",
-            "/** @constructor \n * @implements {EventTarget} */",
-            "function Node() {}",
-            "/** @type {number} */ Node.prototype.index;",
-            "/** @param {EventTarget} x \n * @return {string} */",
-            "function foo(x) { return x.index; }")
-        .addDiagnostic("Property index never defined on EventTarget")
+            "/** @type {Function|undefined} */var opt_f;"
+                + "/** @type {some.unknown.type} */var f1;"
+                + "var f2 = opt_f || f1;"
+                + "f2();")
+        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
         .run();
   }
 
   @Test
-  public void testBug7701884() {
+  public void testCall3NullishCoalesce() {
+    // We are checking that an unresolved named type can successfully
+    // meet with a functional type to produce a callable type.
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "/**",
-            " * @param {Array<T>} x",
-            " * @param {function(T)} y",
-            " * @template T",
-            " */",
-            "var forEach = function(x, y) {",
-            "  for (var i = 0; i < x.length; i++) y(x[i]);",
-            "};",
-            "/** @param {number} x */",
-            "function f(x) {}",
-            "/** @param {?} x */",
-            "function h(x) {",
-            "  var top = null;",
-            "  forEach(x, function(z) { top = z; });",
-            "  if (top) f(top);",
-            "}")
+            "/** @type {Function|undefined} */var opt_f;",
+            "/** @type {some.unknown.type} */var f1;",
+            "var f2 = opt_f ?? f1;",
+            "f2();")
+        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
         .run();
   }
 
   @Test
-  public void testBug8017789() {
+  public void testCall4() {
     newTest()
-        .addSource(
-            "/** @param {(map|function())} isResult */"
-                + "var f = function(isResult) {"
-                + "    while (true)"
-                + "        isResult['t'];"
-                + "};"
-                + "/** @typedef {Object<string, number>} */"
-                + "var map;")
+        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
   @Test
-  public void testBug12441160() {
+  public void testCall5() {
     newTest()
-        .addSource(
-            "/** @param {string} a */ \n"
-                + "function use(a) {};\n"
-                + "/**\n"
-                + " * @param {function(this:THIS)} fn\n"
-                + " * @param {THIS} context \n"
-                + " * @constructor\n"
-                + " * @template THIS\n"
-                + " */\n"
-                + "var P = function(fn, context) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function C() { /** @type {number} */ this.a = 1; }\n"
-                + "\n"
-                + "/** @return {P} */ \n"
-                + "C.prototype.method = function() {\n"
-                + "   return new P(function() { use(this.a); }, this);\n"
-                + "};\n"
-                + "\n")
+        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }")
         .addDiagnostic(
-            "actual parameter 1 of use does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
   @Test
-  public void testBug13641083a() {
+  public void testCall6() {
     newTest()
-        .addSource("/** @constructor @struct */ function C() {};" + "new C().bar;")
-        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
+        .addSource("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: Number")
         .run();
   }
 
   @Test
-  public void testBug13641083b() {
+  public void testCall7() {
     newTest()
-        .addSource("/** @type {?} */ var C;" + "C.bar + 1;")
-        .addDiagnostic(TypeCheck.POSSIBLE_INEXISTENT_PROPERTY)
+        .addSource("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: RegExp")
         .run();
   }
 
   @Test
-  public void testTemplateSubtyping_0() {
-    // TODO(b/145145406): This is testing that things work despite this bug.
+  public void testCall8() {
     newTest()
-        .addSource(
-            // IFoo is a NamedType here.
-            "/** @implements {IFoo<number>} */",
-            "class Foo { }",
-            "",
-            "/**",
-            " * @template T",
-            " * @interface",
-            " */",
-            "class IFoo { }",
-            "",
-            "const /** !IFoo<number> */ x = new Foo();")
+        .addSource("/** @type {Function|number} */var f;f();")
+        .addDiagnostic("(Function|number) expressions are " + "not callable")
         .run();
   }
 
   @Test
-  public void testTemplateSubtyping_1() {
-    // TOOD(b/139230800): This is testing things work despite this bug.
+  public void testCall9() {
     newTest()
         .addSource(
-            "/**",
-            " * @template T",
-            " * @interface",
-            " */",
-            "class IFoo { }",
-            "",
-            "/** @implements {IFoo<number>} */",
-            "class FooA { }",
-            "",
-            "/** @implements {IFoo<string>} */",
-            "class FooB extends FooA { }",
-            "",
-            "const /** !IFoo<number> */ x = new FooB();",
-            "const /** !IFoo<string> */ y = new FooB();")
+            "var goog = {};"
+                + "/** @constructor */ goog.Foo = function() {};"
+                + "/** @param {!goog.Foo} a */ var bar = function(a){};"
+                + "bar('abc');")
+        .addDiagnostic(
+            "actual parameter 1 of bar does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: goog.Foo")
         .run();
   }
 
   @Test
-  public void testTypedefBeforeUse() {
-    newTest()
-        .addSource(
-            "/** @typedef {Object<string, number>} */"
-                + "var map;"
-                + "/** @param {(map|function())} isResult */"
-                + "var f = function(isResult) {"
-                + "    while (true)"
-                + "        isResult['t'];"
-                + "};")
-        .run();
+  public void testCall10() {
+    newTest().addSource("/** @type {Function} */var f;f();").run();
   }
 
   @Test
-  public void testScopedConstructors1() {
-    newTest()
-        .addSource(
-            "function foo1() { "
-                + "  /** @constructor */ function Bar() { "
-                + "    /** @type {number} */ this.x = 3;"
-                + "  }"
-                + "}"
-                + "function foo2() { "
-                + "  /** @constructor */ function Bar() { "
-                + "    /** @type {string} */ this.x = 'y';"
-                + "  }"
-                + "  /** "
-                + "   * @param {Bar} b\n"
-                + "   * @return {number}\n"
-                + "   */"
-                + "  function baz(b) { return b.x; }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : string\n" + "required: number")
-        .run();
+  public void testCall11() {
+    newTest().addSource("var f = new Function(); f();").run();
   }
 
   @Test
-  public void testScopedConstructors2() {
+  public void testCall12() {
     newTest()
         .addSource(
-            "/** @param {Function} f */"
-                + "function foo1(f) {"
-                + "  /** @param {Function} g */"
-                + "  f.prototype.bar = function(g) {};"
-                + "}")
+            "/**",
+            " * @param {*} x",
+            " * @return {number}",
+            " */",
+            "function f(x, y) {",
+            "  return x && x.foo();",
+            "}")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", // preserve new line
+                "found   : *",
+                "required: number"))
+        .addDiagnostic("Property foo never defined on *" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference1() {
+  public void testCall13() {
+    // Test a case where we use inferred types across scopes.
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @type {number?} */ Foo.prototype.bar = null;"
-                + "/** @type {number?} */ Foo.prototype.baz = null;"
-                + "/** @param {Foo} foo */"
-                + "function f(foo) {"
-                + "  while (true) {"
-                + "    if (!foo.baz) break; "
-                + "    foo.bar = null;"
-                + "  }"
-                +
-                // Tests a bug where this condition always evaluated to true.
-                "  return foo.bar == null;"
-                + "}")
+            "var x;",
+            "function useX() { var /** string */ str = x(); }",
+            "function setX() { x = /** @return {number} */ () => 3; }")
+        .addDiagnostic(
+            lines(
+                "initializing variable", // preserve new line
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference2() {
+  public void testFunctionCall1() {
     newTest()
-        .addSource(
-            "var x = {};"
-                + "x.y = c;"
-                + "function f(a, b) {"
-                + "  if (a) {"
-                + "    if (b) "
-                + "      x.y = 2;"
-                + "    else "
-                + "      x.y = 1;"
-                + "  }"
-                + "  return x.y == null;"
-                + "}")
+        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference3() {
+  public void testFunctionCall2() {
     newTest()
-        .addSource(
-            "var x = {};"
-                + "x.y = c;"
-                + "function f(a, b) {"
-                + "  if (a) {"
-                + "    if (b) "
-                + "      x.y = 2;"
-                + "    else "
-                + "      x.y = 1;"
-                + "  }"
-                + "  return x.y == null;"
-                + "} function g() { x.y = null; }")
+        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');")
+        .addDiagnostic(
+            "actual parameter 2 of foo.call does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference4() {
+  public void testFunctionCall3() {
     newTest()
         .addSource(
-            "/** @param {string} x */ function f(x) {}\n"
-                + "/**\n"
-                + " * @param {?string} x \n"
-                + " * @constructor\n"
-                + " */"
-                + "function Foo(x) { this.x_ = x; }\n"
-                + "Foo.prototype.bar = function() {"
-                + "  if (this.x_) { f(this.x_); }"
-                + "};")
+            "/** @param {number} x \n * @constructor */ "
+                + "var Foo = function(x) { this.bar.call(null, x); };"
+                + "/** @type {function(number)} */ Foo.prototype.bar;")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference5() {
-    disableStrictMissingPropertyChecks();
+  public void testFunctionCall4() {
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "(function() { "
-                + "    /** @param {number} x */ ns.foo = function(x) {}; })();"
-                + "(function() { ns.foo(true); })();")
+            "/** @param {string} x \n * @constructor */ "
+                + "var Foo = function(x) { this.bar.call(null, x); };"
+                + "/** @type {function(number)} */ Foo.prototype.bar;")
         .addDiagnostic(
-            "actual parameter 1 of ns.foo does not match formal parameter\n"
-                + "found   : boolean\n"
+            "actual parameter 2 of this.bar.call "
+                + "does not match formal parameter\n"
+                + "found   : string\n"
                 + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference6() {
+  public void testFunctionCall5() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {}; "
-                + "/** @param {number} x */ ns.foo = function(x) {};"
-                + "(function() { "
-                + "    ns.foo = function(x) {};"
-                + "    ns.foo(true); "
-                + "})();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @param {Function} handler \n * @constructor */ "
+                + "var Foo = function(handler) { handler.call(this, x); };")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference7() {
-    disableStrictMissingPropertyChecks();
+  public void testFunctionCall6() {
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "(function() { "
-                + "  /** @constructor \n * @param {number} x */ "
-                + "  ns.Foo = function(x) {};"
-                + "  /** @param {ns.Foo} x */ function f(x) {}"
-                + "  f(new ns.Foo(true));"
-                + "})();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @param {Function} handler \n * @constructor */ "
+                + "var Foo = function(handler) { handler.apply(this, x); };")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference8() {
-    disableStrictMissingPropertyChecks();
-    testClosureTypesMultipleWarnings(
-        "var ns = {}; "
-            + "(function() { "
-            + "  /** @constructor \n * @param {number} x */ "
-            + "  ns.Foo = function(x) {};"
-            + "})();"
-            + "/** @param {ns.Foo} x */ function f(x) {}"
-            + "f(new ns.Foo(true));",
-        ImmutableList.of(
-            "actual parameter 1 of ns.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number"));
+  public void testFunctionCall7() {
+    newTest()
+        .addSource(
+            "/** @param {Function} handler \n * @param {Object} opt_context */ "
+                + "var Foo = function(handler, opt_context) { "
+                + "  handler.call(opt_context, x);"
+                + "};")
+        .includeDefaultExterns()
+        .run();
   }
 
   @Test
-  public void testQualifiedNameInference9() {
+  public void testFunctionCall8() {
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "ns.ns2 = {}; "
-                + "(function() { "
-                + "  /** @constructor \n * @param {number} x */ "
-                + "  ns.ns2.Foo = function(x) {};"
-                + "  /** @param {ns.ns2.Foo} x */ function f(x) {}"
-                + "  f(new ns.ns2.Foo(true));"
-                + "})();")
-        .addDiagnostic(
-            "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
+            "/** @param {Function} handler \n * @param {Object} opt_context */ "
+                + "var Foo = function(handler, opt_context) { "
+                + "  handler.apply(opt_context, x);"
+                + "};")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference10() {
+  public void testFunctionCall9() {
     newTest()
         .addSource(
-            "var ns = {}; "
-                + "ns.ns2 = {}; "
-                + "(function() { "
-                + "  /** @interface */ "
-                + "  ns.ns2.Foo = function() {};"
-                + "  /** @constructor \n * @implements {ns.ns2.Foo} */ "
-                + "  function F() {}"
-                + "  (new F());"
-                + "})();")
+            "/** @constructor\n * @template T\n **/ function Foo() {}\n"
+                + "/** @param {T} x */ Foo.prototype.bar = function(x) {}\n"
+                + "var foo = /** @type {Foo<string>} */ (new Foo());\n"
+                + "foo.bar(3);")
+        .addDiagnostic(
+            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference11() {
-    disableStrictMissingPropertyChecks();
+  public void testFunctionBind1() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "function f() {"
-                + "  var x = new Foo();"
-                + "  x.onload = function() {"
-                + "    x.onload = null;"
-                + "  };"
-                + "}")
+            "/** @type {function(string, number): boolean} */"
+                + "function f(x, y) { return true; }"
+                + "f.bind(null, 3);")
+        .addDiagnostic(
+            "actual parameter 2 of f.bind does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference12() {
-    disableStrictMissingPropertyChecks();
-    // We should be able to tell that the two 'this' properties
-    // are different.
+  public void testFunctionBind2() {
     newTest()
         .addSource(
-            "/** @param {function(this:Object)} x */ function f(x) {}",
-            "/** @constructor */ function Foo() {",
-            "  /** @type {number} */ this.bar = 3;",
-            "  f(function() { this.bar = true; });",
-            "}")
+            "/** @type {function(number): boolean} */"
+                + "function f(x) { return true; }"
+                + "f(f.bind(null, 3)());")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: number")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference13() {
-    disableStrictMissingPropertyChecks();
+  public void testFunctionBind3() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "function f(z) {"
-                + "  var x = new Foo();"
-                + "  if (z) {"
-                + "    x.onload = function() {};"
-                + "  } else {"
-                + "    x.onload = null;"
-                + "  };"
-                + "}")
+            "/** @type {function(number, string): boolean} */"
+                + "function f(x, y) { return true; }"
+                + "f.bind(null, 3)(true);")
+        .addDiagnostic(
+            "actual parameter 1 of function does not match formal parameter\n"
+                + "found   : boolean\n"
+                + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testQualifiedNameInference14() {
-    // Unconditional blocks don't cause functions to be treated as inferred.
-    disableStrictMissingPropertyChecks();
-    newTest()
+  public void testFunctionBind4() {
+    this.newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "function f(z) {",
-            "  var x = new Foo();",
-            "  {",
-            "    x.onload = function() {};",
-            "  }",
-            "  {",
-            "    x.onload = null;",
-            "  };",
-            "}")
+            "/** @param {...number} x */", //
+            "function f(x) {}",
+            "f.bind(null, 3, 3, 3)(true);")
         .addDiagnostic(
             lines(
-                "assignment", //
-                "found   : null",
-                "required: function(): undefined"))
+                "actual parameter 1 of function does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testScopeQualifiedNamesOnThis() {
-    // Ensure that we don't flow-scope qualified names on 'this' too broadly.
-    newTest()
+  public void testFunctionBind5() {
+    this.newTest()
         .addSource(
-            "/** @constructor */ function Foo() {",
-            "  /** @type {!Bar} */",
-            "  this.baz = new Bar();",
-            "}",
-            "Foo.prototype.foo = function() {",
-            "  this.baz.bar();",
-            "};",
-            "/** @constructor */ function Bar() {",
-            "  /** @type {!Foo} */",
-            "  this.baz = new Foo();",
-            "}",
-            "Bar.prototype.bar = function() {",
-            "  this.baz.foo();",
-            "};")
+            "/** @param {...number} x */", //
+            "function f(x) {}",
+            "f.bind(null, true)(3, 3, 3);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 2 of f.bind does not match formal parameter",
+                "found   : boolean",
+                "required: number"))
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testSheqRefinedScope() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */function A() {}\n"
-                + "/** @constructor \n @extends A */ function B() {}\n"
-                + "/** @return {number} */\n"
-                + "B.prototype.p = function() { return 1; }\n"
-                + "/** @param {A} a\n @param {B} b */\n"
-                + "function f(a, b) {\n"
-                + "  b.p();\n"
-                + "  if (a === b) {\n"
-                + "    b.p();\n"
-                + "  }\n"
-                + "}");
-    Node nodeC =
-        n.getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getLastChild();
-    JSType typeC = nodeC.getJSType();
-    assertThat(typeC.isNumber()).isTrue();
-
-    Node nodeB = nodeC.getFirstFirstChild();
-    JSType typeB = nodeB.getJSType();
-    assertThat(typeB.toString()).isEqualTo("B");
-  }
-
-  @Test
-  public void testAssignToUntypedVariable() {
-    Node n = parseAndTypeCheck("var z; z = 1;");
-
-    Node assign = n.getLastChild().getFirstChild();
-    Node node = assign.getFirstChild();
-    assertThat(node.getJSType().isUnknownType()).isFalse();
-    assertThat(node.getJSType().toString()).isEqualTo("number");
+  public void testFunctionBind6() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "function MyType() {",
+            "  /** @type {number} */",
+            "  this.x = 0;",
+            "  var f = function() {",
+            "    this.x = 'str';",
+            "  }.bind(this);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment to property x of MyType", //
+                "found   : string",
+                "required: number"))
+        .includeDefaultExterns()
+        .run();
   }
 
   @Test
-  public void testAssignToUntypedProperty() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;");
-
-    Node node = n.getLastChild().getFirstChild();
-    assertThat(node.getJSType().isUnknownType()).isFalse();
-    assertThat(node.getJSType().isNumber()).isTrue();
+  public void testFunctionBind7() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "function MyType() {",
+            "  /** @type {number} */",
+            "  this.x = 0;",
+            "}",
+            "var m = new MyType;",
+            "(function f() {this.x = 'str';}).bind(m);")
+        .addDiagnostic(
+            lines(
+                "assignment to property x of MyType", //
+                "found   : string",
+                "required: number"))
+        .includeDefaultExterns()
+        .run();
   }
 
   @Test
-  public void testNew1() {
-    newTest().addSource("new 4").addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR).run();
+  public void testFunctionBind8() {
+    newTest()
+        .addSource(
+            "/** @constructor */",
+            "function MyType() {}",
+            "",
+            "/** @constructor */",
+            "function AnotherType() {}",
+            "AnotherType.prototype.foo = function() {};",
+            "",
+            "/** @type {?} */",
+            "var m = new MyType;",
+            "(function f() {this.foo();}).bind(m);")
+        .includeDefaultExterns()
+        .run();
   }
 
   @Test
-  public void testNew2() {
+  public void testFunctionBind9() {
     newTest()
-        .addSource("var Math = {}; new Math()")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
+        .addSource(
+            "/** @constructor */",
+            "function MyType() {}",
+            "",
+            "/** @constructor */",
+            "function AnotherType() {}",
+            "AnotherType.prototype.foo = function() {};",
+            "",
+            "var m = new MyType;",
+            "(function f() {this.foo();}).bind(m);")
+        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
         .run();
   }
 
   @Test
-  public void testNew3() {
-    newTest().addSource("new Date()").run();
+  public void testGoogBind1() {
+    testClosureTypes(
+        "goog.bind = function(var_args) {};"
+            + "/** @type {function(number): boolean} */"
+            + "function f(x, y) { return true; }"
+            + "f(goog.bind(f, null, 'x')());",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : boolean\n"
+            + "required: number");
   }
 
   @Test
-  public void testNew4() {
-    newTest().addSource("/** @constructor */function A(){}; new A();").run();
+  public void testGoogBind2() {
+    // TODO(nicksantos): We do not currently type-check the arguments
+    // of the goog.bind.
+    testClosureTypes(
+        "goog.bind = function(var_args) {};"
+            + "/** @type {function(boolean): boolean} */"
+            + "function f(x, y) { return true; }"
+            + "f(goog.bind(f, null, 'x')());",
+        null);
   }
 
   @Test
-  public void testNew5() {
+  public void testCast2() {
+    // can upcast to a base type.
     newTest()
-        .addSource("function A(){}; new A();")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
+        .addSource(
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n @extends {base} */function derived() {}\n"
+                + "/** @type {base} */ var baz = new derived();\n")
         .run();
   }
 
   @Test
-  public void testNew6() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();");
-
-    JSType aType = p.scope.getVar("a").getType();
-    assertThat(aType).isInstanceOf(ObjectType.class);
-    ObjectType aObjectType = (ObjectType) aType;
-    assertThat(aObjectType.getConstructor().getReferenceName()).isEqualTo("A");
-  }
-
-  @Test
-  public void testNew7() {
+  public void testCast3() {
+    // cannot downcast
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "if (opt_constructor) { new opt_constructor; }"
-                + "}")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = new base();\n")
+        .addDiagnostic("initializing variable\n" + "found   : base\n" + "required: derived")
         .run();
   }
 
   @Test
-  public void testNew8() {
+  public void testCast3a() {
+    // cannot downcast
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "new opt_constructor;"
-                + "}")
+            "/** @constructor */function Base() {}\n"
+                + "/** @constructor @extends {Base} */function Derived() {}\n"
+                + "var baseInstance = new Base();"
+                + "/** @type {!Derived} */ var baz = baseInstance;\n")
+        .addDiagnostic("initializing variable\n" + "found   : Base\n" + "required: Derived")
         .run();
   }
 
   @Test
-  public void testNew9() {
+  public void testCast4() {
+    // downcast must be explicit
     newTest()
         .addSource(
-            "/** @param {Function} opt_constructor */"
-                + "function foo(opt_constructor) {"
-                + "new (opt_constructor || Array);"
-                + "}")
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = "
+                + "/** @type {!derived} */(new base());\n")
         .run();
   }
 
   @Test
-  public void testNew10() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @param {Function} opt_constructor */"
-                + "goog.Foo = function(opt_constructor) {"
-                + "new (opt_constructor || Array);"
-                + "}")
-        .run();
+  public void testCast4Types() {
+    // downcast must be explicit
+    Node root =
+        parseAndTypeCheck(
+            "/** @constructor */function base() {}\n"
+                + "/** @constructor\n * @extends {base} */function derived() {}\n"
+                + "/** @type {!derived} */ var baz = "
+                + "/** @type {!derived} */(new base());\n");
+    Node castedExprNode = root.getLastChild().getFirstFirstChild().getFirstChild();
+    assertThat(castedExprNode.getJSType().toString()).isEqualTo("derived");
+    assertThat(castedExprNode.getJSTypeBeforeCast().toString()).isEqualTo("base");
   }
 
   @Test
-  public void testNew11() {
+  public void testCast5() {
+    // cannot explicitly cast to an unrelated type
     newTest()
         .addSource(
-            "/** @param {Function} c1 */"
-                + "function f(c1) {"
-                + "  var c2 = function(){};"
-                + "  c1.prototype = new c2;"
-                + "}")
-        .addDiagnostic(TypeCheck.NOT_A_CONSTRUCTOR)
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor */function bar() {}\n"
+                + "var baz = /** @type {!foo} */(new bar);\n")
+        .addDiagnostic(
+            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
         .run();
   }
 
   @Test
-  public void testNew12() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertTypeEquals(getNativeArrayType(), a.getType());
-  }
-
-  @Test
-  public void testNew13() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "/** @constructor */function FooBar(){};" + "var a = new FooBar();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("FooBar");
-  }
-
-  @Test
-  public void testNew14() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("FooBar");
-  }
-
-  @Test
-  public void testNew15() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            "var goog = {};"
-                + "/** @constructor */goog.A = function(){};"
-                + "var a = new goog.A();");
-    TypedVar a = p.scope.getVar("a");
-
-    assertThat(a.getType()).isInstanceOf(ObjectType.class);
-    assertThat(a.getType().toString()).isEqualTo("goog.A");
+  public void testCast5a() {
+    // cannot explicitly cast to an unrelated type
+    newTest()
+        .addSource(
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor */function bar() {}\n"
+                + "var barInstance = new bar;\n"
+                + "var baz = /** @type {!foo} */(barInstance);\n")
+        .addDiagnostic(
+            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
+        .run();
   }
 
   @Test
-  public void testNew16() {
+  public void testCast6() {
+    // can explicitly cast to a subtype or supertype
     newTest()
         .addSource(
-            "/** \n"
-                + " * @param {string} x \n"
-                + " * @constructor \n"
-                + " */"
-                + "function Foo(x) {}"
-                + "function g() { new Foo(1); }")
-        .addDiagnostic(
-            "actual parameter 1 of Foo does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @constructor */function foo() {}\n"
+                + "/** @constructor \n @extends foo */function bar() {}\n"
+                + "var baz = /** @type {!bar} */(new bar);\n"
+                + "var baz = /** @type {!foo} */(new foo);\n"
+                + "var baz = /** @type {bar} */(new bar);\n"
+                + "var baz = /** @type {foo} */(new foo);\n"
+                + "var baz = /** @type {!foo} */(new bar);\n"
+                + "var baz = /** @type {!bar} */(new foo);\n"
+                + "var baz = /** @type {foo} */(new bar);\n"
+                + "var baz = /** @type {bar} */(new foo);\n")
         .run();
   }
 
   @Test
-  public void testNew17() {
+  public void testCast7() {
     newTest()
-        .addSource("var goog = {}; goog.x = 3; new goog.x")
-        .addDiagnostic("cannot instantiate non-constructor")
+        .addSource("var x = /** @type {foo} */ (new Object());")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testNew18() {
+  public void testCast8() {
     newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.F = function() {};"
-                + "/** @constructor */ goog.G = goog.F;")
+        .addSource("function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testNew19() {
+  public void testCast9() {
     newTest()
-        .addSource("/** @constructor @abstract */ var Foo = function() {}; var foo = new Foo();")
-        .addDiagnostic(INSTANTIATE_ABSTRACT_CLASS)
+        .addSource("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testNew20() {
+  public void testCast10() {
     newTest()
         .addSource(
-            "/** @constructor @abstract */",
-            "function Bar() {};",
-            "/** @return {function(new:Bar)} */",
-            "function foo() {}",
-            "var Foo = foo();",
-            "var f = new Foo;")
+            "var foo = function() {};"
+                + "function f() { return /** @type {foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type foo")
         .run();
   }
 
   @Test
-  public void testName1() {
-    assertTypeEquals(getNativeVoidType(), testNameNode("undefined"));
+  public void testCast11() {
+    newTest()
+        .addSource(
+            "var goog = {}; goog.foo = {};"
+                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+        .run();
   }
 
   @Test
-  public void testName2() {
-    assertTypeEquals(getNativeObjectConstructorType(), testNameNode("Object"));
+  public void testCast12() {
+    newTest()
+        .addSource(
+            "var goog = {}; goog.foo = function() {};"
+                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
+        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+        .run();
   }
 
   @Test
-  public void testName3() {
-    assertTypeEquals(getNativeArrayConstructorType(), testNameNode("Array"));
+  public void testCast13() {
+    // In a typespace world, types and values may collide on the same symbol.
+    testClosureTypes(
+        "goog.forwardDeclare('goog.foo');"
+            + "goog.foo = function() {};"
+            + "function f() { return /** @type {goog.foo} */ (new Object()); }",
+        null);
   }
 
   @Test
-  public void testName4() {
-    assertTypeEquals(getNativeDateConstructorType(), testNameNode("Date"));
+  public void testCast14() {
+    // Test to make sure that the forward-declaration still prevents
+    // some warnings.
+    testClosureTypes(
+        "goog.forwardDeclare('goog.bar');"
+            + "function f() { return /** @type {goog.bar} */ (new Object()); }",
+        null);
   }
 
   @Test
-  public void testName5() {
-    assertTypeEquals(getNativeRegexpConstructorType(), testNameNode("RegExp"));
-  }
-
-  /** Type checks a NAME node and retrieve its type. */
-  private JSType testNameNode(String name) {
-    Node node = Node.newString(Token.NAME, name);
-    Node parent = new Node(Token.SCRIPT, node);
-    parent.setInputId(new InputId("code"));
-
-    Node externs = new Node(Token.SCRIPT);
-    externs.setInputId(new InputId("externs"));
+  public void testCast15() {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a run-time cast exception if the node was visited
+    // more than once.
 
-    Node root = IR.root(IR.root(externs), IR.root(parent));
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
 
-    makeTypeCheck().processForTesting(root.getFirstChild(), root.getSecondChild());
-    return node.getJSType();
-  }
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testBitOperation1() {
     newTest()
-        .addSource("/**@return {void}*/function foo(){ ~foo(); }")
-        .addDiagnostic("operator ~ cannot be applied to undefined")
+        .addSource(
+            "for (var i = 0; i < 10; i++) {",
+            "var x = /** @type {Object|number} */ ({foo: 3});",
+            "/** @param {number} x */ function f(x) {}",
+            "f(x.foo);",
+            "f([].foo);",
+            "}")
+        .addDiagnostic("Property foo never defined on Array<?>")
         .run();
   }
 
   @Test
-  public void testBitOperation2() {
-    newTest()
-        .addSource("/**@return {void}*/function foo(){var a = foo()<<3;}")
-        .addDiagnostic("operator << cannot be applied to undefined")
-        .run();
-  }
+  public void testCast15b() {
+    // This fixes a bug where a type cast on an object literal
+    // would cause a run-time cast exception if the node was visited
+    // more than once.
 
-  @Test
-  public void testBitOperation3() {
-    newTest()
-        .addSource("/**@return {void}*/function foo(){var a = 3<<foo();}")
-        .addDiagnostic("operator << cannot be applied to undefined")
+    // Some code assumes that an object literal must have a object type,
+    // while because of the cast, it could have any type (including
+    // a union).
+    newTest()
+        .addSource(
+            "for (var i = 0; i < 10; i++) {",
+            "var x = /** @type {{foo:number}}|number} */ ({foo: 3});",
+            "/** @param {number} x */ function f(x) {}",
+            "f(x.foo);",
+            "f([].foo);",
+            "}")
+        .addDiagnostic("Property foo never defined on Array<?>")
         .run();
   }
 
   @Test
-  public void testBitOperation4() {
+  public void testCast16() {
+    // A type cast should not invalidate the checks on the members
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = foo()>>>3;}")
-        .addDiagnostic("operator >>> cannot be applied to undefined")
+        .addSource(
+            "for (var i = 0; i < 10; i++) {"
+                + "var x = /** @type {Object|number} */ ("
+                + "  {/** @type {string} */ foo: 3});"
+                + "}")
+        .addDiagnostic(
+            "assignment to property foo of {foo: string}\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testBitOperation5() {
+  public void testCast17a() {
+    // Mostly verifying that rhino actually understands these JsDocs.
     newTest()
-        .addSource("/**@return {void}*/function foo(){var a = 3>>>foo();}")
-        .addDiagnostic("operator >>> cannot be applied to undefined")
+        .addSource(
+            "/** @constructor */ function Foo() {} \n"
+                + "/** @type {Foo} */ var x = /** @type {Foo} */ (y)")
         .run();
   }
 
   @Test
-  public void testBitOperation6() {
+  public void testCast17b() {
+    // Mostly verifying that rhino actually understands these JsDocs.
     newTest()
-        .addSource("/**@return {!Object}*/function foo(){var a = foo()&3;}")
+        .addSource(
+            "/** @constructor */ function Foo() {} \n"
+                + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})")
+        .run();
+  }
+
+  @Test
+  public void testCast19() {
+    newTest()
+        .addSource(
+            "var x = 'string';\n" + "/** @type {number} */\n" + "var y = /** @type {number} */(x);")
         .addDiagnostic(
-            "bad left operand to bitwise operator\n"
-                + "found   : Object\n"
-                + "required: (boolean|null|number|string|undefined)")
+            "invalid cast - must be a subtype or supertype\n" + "from: string\n" + "to  : number")
         .run();
   }
 
   @Test
-  public void testBitOperation7() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;").run();
+  public void testCast20() {
+    newTest()
+        .addSource(
+            "/** @enum {boolean|null} */\n"
+                + "var X = {"
+                + "  AA: true,"
+                + "  BB: false,"
+                + "  CC: null"
+                + "};\n"
+                + "var y = /** @type {X} */(true);")
+        .run();
   }
 
   @Test
-  public void testBitOperation8() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
-    newTest().addSource("var x = void 0; x |= new Number(3);").run();
+  public void testCast21() {
+    newTest()
+        .addSource(
+            "/** @enum {boolean|null} */\n"
+                + "var X = {"
+                + "  AA: true,"
+                + "  BB: false,"
+                + "  CC: null"
+                + "};\n"
+                + "var value = true;\n"
+                + "var y = /** @type {X} */(value);")
+        .run();
   }
 
   @Test
-  public void testBitOperation9() {
-    compiler
-        .getOptions()
-        .setWarningLevel(DiagnosticGroups.STRICT_PRIMITIVE_OPERATORS, CheckLevel.OFF);
+  public void testCast22() {
     newTest()
-        .addSource("var x = void 0; x |= {};")
+        .addSource("var x = null;\n" + "var y = /** @type {number} */(x);")
         .addDiagnostic(
-            "bad right operand to bitwise operator\n"
-                + "found   : {}\n"
-                + "required: (boolean|null|number|string|undefined)")
+            "invalid cast - must be a subtype or supertype\n" + "from: null\n" + "to  : number")
         .run();
   }
 
   @Test
-  public void testCall1() {
-    newTest().addSource("3();").addDiagnostic("number expressions are not callable").run();
+  public void testCast23() {
+    newTest().addSource("var x = null;\n" + "var y = /** @type {Number} */(x);").run();
   }
 
   @Test
-  public void testCall2() {
+  public void testCast24() {
     newTest()
-        .addSource("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }")
+        .addSource("var x = undefined;\n" + "var y = /** @type {number} */(x);")
         .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: Number")
+            "invalid cast - must be a subtype or supertype\n"
+                + "from: undefined\n"
+                + "to  : number")
         .run();
   }
 
   @Test
-  public void testCall3() {
-    // We are checking that an unresolved named type can successfully
-    // meet with a functional type to produce a callable type.
+  public void testCast25() {
     newTest()
-        .addSource(
-            "/** @type {Function|undefined} */var opt_f;"
-                + "/** @type {some.unknown.type} */var f1;"
-                + "var f2 = opt_f || f1;"
-                + "f2();")
-        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
+        .addSource("var x = undefined;\n" + "var y = /** @type {number|undefined} */(x);")
         .run();
   }
 
   @Test
-  public void testCall3NullishCoalesce() {
-    // We are checking that an unresolved named type can successfully
-    // meet with a functional type to produce a callable type.
+  public void testCast26() {
     newTest()
         .addSource(
-            "/** @type {Function|undefined} */var opt_f;",
-            "/** @type {some.unknown.type} */var f1;",
-            "var f2 = opt_f ?? f1;",
-            "f2();")
-        .addDiagnostic("Bad type annotation. Unknown type some.unknown.type")
+            "function fn(dir) {\n"
+                + "  var node = dir ? 1 : 2;\n"
+                + "  fn(/** @type {number} */ (node));\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testCall4() {
+  public void testCast27() {
+    // C doesn't implement I but a subtype might.
     newTest()
-        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: RegExp")
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "var x = new C();\n"
+                + "var y = /** @type {I} */(x);")
         .run();
   }
 
   @Test
-  public void testCall5() {
+  public void testCast27a() {
+    // C doesn't implement I but a subtype might.
     newTest()
-        .addSource("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }")
-        .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: RegExp")
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {C} */ var x ;\n"
+                + "var y = /** @type {I} */(x);")
         .run();
   }
 
   @Test
-  public void testCall6() {
+  public void testCast28() {
+    // C doesn't implement I but a subtype might.
     newTest()
-        .addSource("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: Number")
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {!I} */ var x;\n"
+                + "var y = /** @type {C} */(x);")
         .run();
   }
 
   @Test
-  public void testCall7() {
+  public void testCast28a() {
+    // C doesn't implement I but a subtype might.
     newTest()
-        .addSource("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');")
-        .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: RegExp")
+        .addSource(
+            "/** @interface */ function I() {}\n"
+                + "/** @constructor */ function C() {}\n"
+                + "/** @type {I} */ var x;\n"
+                + "var y = /** @type {C} */(x);")
         .run();
   }
 
   @Test
-  public void testCall8() {
+  public void testCast29a() {
+    // C doesn't implement the record type but a subtype might.
     newTest()
-        .addSource("/** @type {Function|number} */var f;f();")
-        .addDiagnostic("(Function|number) expressions are " + "not callable")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "var x = new C();\n"
+                + "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);")
         .run();
   }
 
   @Test
-  public void testCall9() {
+  public void testCast29b() {
+    // C doesn't implement the record type but a subtype might.
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @constructor */ goog.Foo = function() {};"
-                + "/** @param {!goog.Foo} a */ var bar = function(a){};"
-                + "bar('abc');")
-        .addDiagnostic(
-            "actual parameter 1 of bar does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: goog.Foo")
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {C} */ var x;\n"
+                + "var y = /** @type {{prop1: Array, prop2: string}} */(x);")
         .run();
   }
 
   @Test
-  public void testCall10() {
-    newTest().addSource("/** @type {Function} */var f;f();").run();
+  public void testCast29c() {
+    // C doesn't implement the record type but a subtype might.
+    newTest()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n"
+                + "var y = /** @type {C} */(x);")
+        .run();
   }
 
   @Test
-  public void testCall11() {
-    newTest().addSource("var f = new Function(); f();").run();
+  public void testCast30() {
+    // Should be able to cast to a looser return type
+    newTest()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {function():string} */ var x ;\n"
+                + "var y = /** @type {function():?} */(x);")
+        .run();
   }
 
   @Test
-  public void testCall12() {
+  public void testCast31() {
+    // Should be able to cast to a tighter parameter type
     newTest()
         .addSource(
-            "/**",
-            " * @param {*} x",
-            " * @return {number}",
-            " */",
-            "function f(x, y) {",
-            "  return x && x.foo();",
-            "}")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", // preserve new line
-                "found   : *",
-                "required: number"))
-        .addDiagnostic("Property foo never defined on *" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {function(*)} */ var x ;\n"
+                + "var y = /** @type {function(string)} */(x);")
         .run();
   }
 
   @Test
-  public void testCall13() {
-    // Test a case where we use inferred types across scopes.
+  public void testCast32() {
     newTest()
         .addSource(
-            "var x;",
-            "function useX() { var /** string */ str = x(); }",
-            "function setX() { x = /** @return {number} */ () => 3; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", // preserve new line
-                "found   : number",
-                "required: string"))
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Object} */ var x ;\n"
+                + "var y = /** @type {null|{length:number}} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall1() {
+  public void testCast33a() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
-        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string?|undefined} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall2() {
+  public void testCast33b() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
-        .addSource("/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');")
-        .addDiagnostic(
-            "actual parameter 2 of foo.call does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string|undefined} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall3() {
+  public void testCast33c() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
         .addSource(
-            "/** @param {number} x \n * @constructor */ "
-                + "var Foo = function(x) { this.bar.call(null, x); };"
-                + "/** @type {function(number)} */ Foo.prototype.bar;")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {string?} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall4() {
+  public void testCast33d() {
+    // null and void should be assignable to any type that accepts one or the
+    // other or both.
     newTest()
         .addSource(
-            "/** @param {string} x \n * @constructor */ "
-                + "var Foo = function(x) { this.bar.call(null, x); };"
-                + "/** @type {function(number)} */ Foo.prototype.bar;")
-        .addDiagnostic(
-            "actual parameter 2 of this.bar.call "
-                + "does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {null|undefined} */ var x ;\n"
+                + "var y = /** @type {null} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall5() {
+  public void testCast34a() {
     newTest()
         .addSource(
-            "/** @param {Function} handler \n * @constructor */ "
-                + "var Foo = function(handler) { handler.call(this, x); };")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Object} */ var x ;\n"
+                + "var y = /** @type {Function} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall6() {
+  public void testCast34b() {
     newTest()
         .addSource(
-            "/** @param {Function} handler \n * @constructor */ "
-                + "var Foo = function(handler) { handler.apply(this, x); };")
-        .includeDefaultExterns()
+            "/** @constructor */ function C() {}\n"
+                + "/** @type {Function} */ var x ;\n"
+                + "var y = /** @type {Object} */(x);")
         .run();
   }
 
   @Test
-  public void testFunctionCall7() {
+  public void testCastToNameRequiringPropertyResolution() {
+    // regression test for correctly typing properties off of types in CASTs.
+    // The type JSDoc in a cast is currently evaluated during TypeInference. In the past any
+    // 'unresolved' types in cast JSDoc were not resolved until after type inference completed. This
+    // caused type inference to infer properties off of those unresolved types as unknown.
     newTest()
+        .addExterns("var unknownVar;")
         .addSource(
-            "/** @param {Function} handler \n * @param {Object} opt_context */ "
-                + "var Foo = function(handler, opt_context) { "
-                + "  handler.call(opt_context, x);"
-                + "};")
-        .includeDefaultExterns()
+            "const foo = {bar: {}};",
+            "const bar = foo.bar;",
+            "bar.Class = class {",
+            "  /** @return {number} */",
+            "  id() { return 0; }",
+            "};",
+            // Because `foo.bar.Class = ...` was never directly assigned, the type 'foo.bar.Class'
+            // is not in the JSTypeRegistry. It's resolved through NamedType#resolveViaProperty.
+            // The same thing would have occurred if we assigned 'foo.bar.Class = ...' then
+            // referred to '!bar.Class' in the JSDoc.
+            // Verify that type inference correctly infers the id property's type.
+
+            "const /** null */ n = /** @type {!foo.bar.Class} */ (unknownVar).id;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : function(this:bar.Class): number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testFunctionCall8() {
+  public void testNestedCasts() {
     newTest()
         .addSource(
-            "/** @param {Function} handler \n * @param {Object} opt_context */ "
-                + "var Foo = function(handler, opt_context) { "
-                + "  handler.apply(opt_context, x);"
-                + "};")
-        .includeDefaultExterns()
+            "/** @constructor */var T = function() {};\n"
+                + "/** @constructor */var V = function() {};\n"
+                + "/**\n"
+                + "* @param {boolean} b\n"
+                + "* @return {T|V}\n"
+                + "*/\n"
+                + "function f(b) { return b ? new T() : new V(); }\n"
+                + "/**\n"
+                + "* @param {boolean} b\n"
+                + "* @return {boolean|undefined}\n"
+                + "*/\n"
+                + "function g(b) { return b ? true : undefined; }\n"
+                + "/** @return {T} */\n"
+                + "function h() {\n"
+                + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testFunctionCall9() {
+  public void testNativeCast1() {
     newTest()
-        .addSource(
-            "/** @constructor\n * @template T\n **/ function Foo() {}\n"
-                + "/** @param {T} x */ Foo.prototype.bar = function(x) {}\n"
-                + "var foo = /** @type {Foo<string>} */ (new Foo());\n"
-                + "foo.bar(3);")
+        .addSource("/** @param {number} x */ function f(x) {}" + "f(String(true));")
         .addDiagnostic(
-            "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .includeDefaultExterns()
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testFunctionBind1() {
+  public void testNativeCast2() {
     newTest()
-        .addSource(
-            "/** @type {function(string, number): boolean} */"
-                + "function f(x, y) { return true; }"
-                + "f.bind(null, 3);")
+        .addSource("/** @param {string} x */ function f(x) {}" + "f(Number(true));")
         .addDiagnostic(
-            "actual parameter 2 of f.bind does not match formal parameter\n"
+            "actual parameter 1 of f does not match formal parameter\n"
                 + "found   : number\n"
                 + "required: string")
-        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testFunctionBind2() {
+  public void testNativeCast3() {
     newTest()
-        .addSource(
-            "/** @type {function(number): boolean} */"
-                + "function f(x) { return true; }"
-                + "f(f.bind(null, 3)());")
+        .addSource("/** @param {number} x */ function f(x) {}" + "f(Boolean(''));")
         .addDiagnostic(
             "actual parameter 1 of f does not match formal parameter\n"
                 + "found   : boolean\n"
                 + "required: number")
-        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testFunctionBind3() {
+  public void testNativeCast4() {
     newTest()
         .addSource(
-            "/** @type {function(number, string): boolean} */"
-                + "function f(x, y) { return true; }"
-                + "f.bind(null, 3)(true);")
+            "/** @param {number} x */ function f(x) {}", //
+            "f(Array(1));")
         .addDiagnostic(
-            "actual parameter 1 of function does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: string")
-        .includeDefaultExterns()
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Array",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testFunctionBind4() {
-    this.newTest()
+  public void testBadConstructorCall() {
+    newTest()
         .addSource(
-            "/** @param {...number} x */", //
-            "function f(x) {}",
-            "f.bind(null, 3, 3, 3)(true);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of function does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
-        .includeDefaultExterns()
+            "/** @constructor */ function Foo() {}", //
+            "Foo();")
+        .addDiagnostic("Constructor (typeof Foo) should be called with the \"new\" keyword")
         .run();
   }
 
   @Test
-  public void testFunctionBind5() {
-    this.newTest()
-        .addSource(
-            "/** @param {...number} x */", //
-            "function f(x) {}",
-            "f.bind(null, true)(3, 3, 3);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 2 of f.bind does not match formal parameter",
-                "found   : boolean",
-                "required: number"))
-        .includeDefaultExterns()
-        .run();
+  public void testTypeof() {
+    newTest().addSource("/**@return {void}*/function foo(){ var a = typeof foo(); }").run();
   }
 
   @Test
-  public void testFunctionBind6() {
+  public void testTypeof2() {
     newTest()
-        .addSource(
-            "/** @constructor */",
-            "function MyType() {",
-            "  /** @type {number} */",
-            "  this.x = 0;",
-            "  var f = function() {",
-            "    this.x = 'str';",
-            "  }.bind(this);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment to property x of MyType", //
-                "found   : string",
-                "required: number"))
-        .includeDefaultExterns()
+        .addSource("function f(){ if (typeof 123 == 'numbr') return 321; }")
+        .addDiagnostic("unknown type: numbr")
         .run();
   }
 
   @Test
-  public void testFunctionBind7() {
+  public void testTypeof3() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function MyType() {",
-            "  /** @type {number} */",
-            "  this.x = 0;",
-            "}",
-            "var m = new MyType;",
-            "(function f() {this.x = 'str';}).bind(m);")
-        .addDiagnostic(
-            lines(
-                "assignment to property x of MyType", //
-                "found   : string",
-                "required: number"))
-        .includeDefaultExterns()
+            "function f() {",
+            "  return (",
+            "      typeof 123 == 'number' ||",
+            "      typeof 123 == 'string' ||",
+            "      typeof 123 == 'boolean' ||",
+            "      typeof 123 == 'undefined' ||",
+            "      typeof 123 == 'function' ||",
+            "      typeof 123 == 'object' ||",
+            "      typeof 123 == 'symbol' ||",
+            "      typeof 123 == 'unknown'); }")
         .run();
   }
 
   @Test
-  public void testFunctionBind8() {
+  public void testConstDecl1() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function MyType() {}",
-            "",
-            "/** @constructor */",
-            "function AnotherType() {}",
-            "AnotherType.prototype.foo = function() {};",
-            "",
-            "/** @type {?} */",
-            "var m = new MyType;",
-            "(function f() {this.foo();}).bind(m);")
-        .includeDefaultExterns()
+            "/** @param {?number} x \n @return {boolean} */"
+                + "function f(x) { "
+                + "  if (x) { /** @const */ var y = x; return y } return true; "
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testFunctionBind9() {
+  public void testConstDecl2() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function MyType() {}",
-            "",
-            "/** @constructor */",
-            "function AnotherType() {}",
-            "AnotherType.prototype.foo = function() {};",
-            "",
-            "var m = new MyType;",
-            "(function f() {this.foo();}).bind(m);")
-        .addDiagnostic(TypeCheck.INEXISTENT_PROPERTY)
+            "/** @param {?number} x */"
+                + "function f(x) { "
+                + "  if (x) {"
+                + "    /** @const */ var y = x; "
+                + "    /** @return {boolean} */ function g() { return y; } "
+                + "  }"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testGoogBind1() {
-    testClosureTypes(
-        "goog.bind = function(var_args) {};"
-            + "/** @type {function(number): boolean} */"
-            + "function f(x, y) { return true; }"
-            + "f(goog.bind(f, null, 'x')());",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : boolean\n"
-            + "required: number");
-  }
-
-  @Test
-  public void testGoogBind2() {
-    // TODO(nicksantos): We do not currently type-check the arguments
-    // of the goog.bind.
-    testClosureTypes(
-        "goog.bind = function(var_args) {};"
-            + "/** @type {function(boolean): boolean} */"
-            + "function f(x, y) { return true; }"
-            + "f(goog.bind(f, null, 'x')());",
-        null);
+  public void testConstructorType1() {
+    newTest()
+        .addSource("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();")
+        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: Foo")
+        .run();
   }
 
   @Test
-  public void testCast2() {
-    // can upcast to a base type.
+  public void testConstructorType2() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n @extends {base} */function derived() {}\n"
-                + "/** @type {base} */ var baz = new derived();\n")
+            "/**@constructor*/function Foo(){\n"
+                + "/**@type{Number}*/this.bar = new Number(5);\n"
+                + "}\n"
+                + "/**@type{Foo}*/var f = new Foo();\n"
+                + "/**@type{Number}*/var n = f.bar;")
         .run();
   }
 
   @Test
-  public void testCast3() {
-    // cannot downcast
+  public void testConstructorType3() {
+    // Reverse the declaration order so that we know that Foo is getting set
+    // even on an out-of-order declaration sequence.
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = new base();\n")
-        .addDiagnostic("initializing variable\n" + "found   : base\n" + "required: derived")
+            "/**@type{Foo}*/var f = new Foo();\n"
+                + "/**@type{Number}*/var n = f.bar;"
+                + "/**@constructor*/function Foo(){\n"
+                + "/**@type{Number}*/this.bar = new Number(5);\n"
+                + "}\n")
         .run();
   }
 
   @Test
-  public void testCast3a() {
-    // cannot downcast
+  public void testConstructorType4() {
     newTest()
         .addSource(
-            "/** @constructor */function Base() {}\n"
-                + "/** @constructor @extends {Base} */function Derived() {}\n"
-                + "var baseInstance = new Base();"
-                + "/** @type {!Derived} */ var baz = baseInstance;\n")
-        .addDiagnostic("initializing variable\n" + "found   : Base\n" + "required: Derived")
+            "/**@constructor*/function Foo(){\n"
+                + "/**@type{!Number}*/this.bar = new Number(5);\n"
+                + "}\n"
+                + "/**@type{!Foo}*/var f = new Foo();\n"
+                + "/**@type{!String}*/var n = f.bar;")
+        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: String")
         .run();
   }
 
   @Test
-  public void testCast4() {
-    // downcast must be explicit
+  public void testConstructorType5() {
+    newTest().addSource("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n").run();
+  }
+
+  @Test
+  public void testConstructorType6() {
     newTest()
         .addSource(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = "
-                + "/** @type {!derived} */(new base());\n")
+            "/** @constructor */\n"
+                + "function bar() {}\n"
+                + "function _foo() {\n"
+                + " /** @param {bar} x */\n"
+                + "  function f(x) {}\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testCast4Types() {
-    // downcast must be explicit
-    Node root =
-        parseAndTypeCheck(
-            "/** @constructor */function base() {}\n"
-                + "/** @constructor\n * @extends {base} */function derived() {}\n"
-                + "/** @type {!derived} */ var baz = "
-                + "/** @type {!derived} */(new base());\n");
-    Node castedExprNode = root.getLastChild().getFirstFirstChild().getFirstChild();
-    assertThat(castedExprNode.getJSType().toString()).isEqualTo("derived");
-    assertThat(castedExprNode.getJSTypeBeforeCast().toString()).isEqualTo("base");
+  public void testConstructorType7() {
+    TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};");
+
+    JSType type = p.scope.getVar("A").getType();
+    assertThat(type).isInstanceOf(FunctionType.class);
+    FunctionType fType = (FunctionType) type;
+    assertThat(fType.getReferenceName()).isEqualTo("A");
   }
 
   @Test
-  public void testCast5() {
-    // cannot explicitly cast to an unrelated type
+  public void testConstructorType8() {
     newTest()
         .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor */function bar() {}\n"
-                + "var baz = /** @type {!foo} */(new bar);\n")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
+            "var ns = {};"
+                + "ns.create = function() { return function() {}; };"
+                + "/** @constructor */ ns.Foo = ns.create();"
+                + "ns.Foo.prototype = {x: 0, y: 0};"
+                + "/**\n"
+                + " * @param {ns.Foo} foo\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function f(foo) {"
+                + "  return foo.x;"
+                + "}")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testCast5a() {
-    // cannot explicitly cast to an unrelated type
+  public void testConstructorType9() {
     newTest()
         .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor */function bar() {}\n"
-                + "var barInstance = new bar;\n"
-                + "var baz = /** @type {!foo} */(barInstance);\n")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to  : foo")
+            "var ns = {};"
+                + "ns.create = function() { return function() {}; };"
+                + "ns.extend = function(x) { return x; };"
+                + "/** @constructor */ ns.Foo = ns.create();"
+                + "ns.Foo.prototype = ns.extend({x: 0, y: 0});"
+                + "/**\n"
+                + " * @param {ns.Foo} foo\n"
+                + " * @return {string}\n"
+                + " */\n"
+                + "function f(foo) {"
+                + "  return foo.x;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testCast6() {
-    // can explicitly cast to a subtype or supertype
+  public void testConstructorType10() {
     newTest()
         .addSource(
-            "/** @constructor */function foo() {}\n"
-                + "/** @constructor \n @extends foo */function bar() {}\n"
-                + "var baz = /** @type {!bar} */(new bar);\n"
-                + "var baz = /** @type {!foo} */(new foo);\n"
-                + "var baz = /** @type {bar} */(new bar);\n"
-                + "var baz = /** @type {foo} */(new foo);\n"
-                + "var baz = /** @type {!foo} */(new bar);\n"
-                + "var baz = /** @type {!bar} */(new foo);\n"
-                + "var baz = /** @type {foo} */(new bar);\n"
-                + "var baz = /** @type {bar} */(new foo);\n")
+            "/** @constructor */"
+                + "function NonStr() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " * @extends{NonStr}\n"
+                + " */"
+                + "function NonStrKid() {}")
         .run();
   }
 
   @Test
-  public void testCast7() {
+  public void testConstructorType11() {
     newTest()
-        .addSource("var x = /** @type {foo} */ (new Object());")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
+        .addSource(
+            "/** @constructor */"
+                + "function NonDict() {}"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @dict\n"
+                + " * @extends{NonDict}\n"
+                + " */"
+                + "function NonDictKid() {}")
         .run();
   }
 
   @Test
-  public void testCast8() {
+  public void testConstructorType12() {
     newTest()
-        .addSource("function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
+        .addSource(
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "Bar.prototype = {};\n")
         .run();
   }
 
   @Test
-  public void testCast9() {
+  public void testBadStruct() {
     newTest()
-        .addSource("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
+        .addSource("/** @struct */function Struct1() {}")
+        .addDiagnostic("@struct used without @constructor for Struct1")
         .run();
   }
 
   @Test
-  public void testCast10() {
+  public void testBadDict() {
     newTest()
-        .addSource(
-            "var foo = function() {};"
-                + "function f() { return /** @type {foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type foo")
+        .addSource("/** @dict */function Dict1() {}")
+        .addDiagnostic("@dict used without @constructor for Dict1")
         .run();
   }
 
   @Test
-  public void testCast11() {
+  public void testAnonymousPrototype1() {
     newTest()
         .addSource(
-            "var goog = {}; goog.foo = {};"
-                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
+            "var ns = {};"
+                + "/** @constructor */ ns.Foo = function() {"
+                + "  this.bar(3, 5);"
+                + "};"
+                + "ns.Foo.prototype = {"
+                + "  bar: function(x) {}"
+                + "};")
+        .addDiagnostic(
+            "Function ns.Foo.prototype.bar: called with 2 argument(s). "
+                + "Function requires at least 1 argument(s) and no more "
+                + "than 1 argument(s).")
         .run();
   }
 
   @Test
-  public void testCast12() {
+  public void testAnonymousPrototype2() {
     newTest()
         .addSource(
-            "var goog = {}; goog.foo = function() {};"
-                + "function f() { return /** @type {goog.foo} */ (new Object()); }")
-        .addDiagnostic("Bad type annotation. Unknown type goog.foo")
-        .run();
-  }
-
-  @Test
-  public void testCast13() {
-    // In a typespace world, types and values may collide on the same symbol.
-    testClosureTypes(
-        "goog.forwardDeclare('goog.foo');"
-            + "goog.foo = function() {};"
-            + "function f() { return /** @type {goog.foo} */ (new Object()); }",
-        null);
-  }
-
-  @Test
-  public void testCast14() {
-    // Test to make sure that the forward-declaration still prevents
-    // some warnings.
-    testClosureTypes(
-        "goog.forwardDeclare('goog.bar');"
-            + "function f() { return /** @type {goog.bar} */ (new Object()); }",
-        null);
+            "/** @interface */ var Foo = function() {};"
+                + "Foo.prototype = {"
+                + "  foo: function(x) {}"
+                + "};"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @implements {Foo}\n"
+                + " */ var Bar = function() {};")
+        .addDiagnostic("property foo on interface Foo is not implemented by type Bar")
+        .run();
   }
 
   @Test
-  public void testCast15() {
-    // This fixes a bug where a type cast on an object literal
-    // would cause a run-time cast exception if the node was visited
-    // more than once.
-
-    // Some code assumes that an object literal must have a object type,
-    // while because of the cast, it could have any type (including
-    // a union).
-
-    // This test is specifically checking loose property check behavior.
-    disableStrictMissingPropertyChecks();
-
+  public void testAnonymousType1() {
     newTest()
         .addSource(
-            "for (var i = 0; i < 10; i++) {",
-            "var x = /** @type {Object|number} */ ({foo: 3});",
-            "/** @param {number} x */ function f(x) {}",
-            "f(x.foo);",
-            "f([].foo);",
-            "}")
-        .addDiagnostic("Property foo never defined on Array<?>")
+            "function f() { return {}; }", //
+            "/** @constructor */",
+            "f().bar = function() {};")
         .run();
   }
 
   @Test
-  public void testCast15b() {
-    // This fixes a bug where a type cast on an object literal
-    // would cause a run-time cast exception if the node was visited
-    // more than once.
-
-    // Some code assumes that an object literal must have a object type,
-    // while because of the cast, it could have any type (including
-    // a union).
+  public void testAnonymousType2() {
     newTest()
         .addSource(
-            "for (var i = 0; i < 10; i++) {",
-            "var x = /** @type {{foo:number}}|number} */ ({foo: 3});",
-            "/** @param {number} x */ function f(x) {}",
-            "f(x.foo);",
-            "f([].foo);",
-            "}")
-        .addDiagnostic("Property foo never defined on Array<?>")
+            "function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};")
         .run();
   }
 
   @Test
-  public void testCast16() {
-    // A type cast should not invalidate the checks on the members
+  public void testAnonymousType3() {
     newTest()
-        .addSource(
-            "for (var i = 0; i < 10; i++) {"
-                + "var x = /** @type {Object|number} */ ("
-                + "  {/** @type {string} */ foo: 3});"
-                + "}")
-        .addDiagnostic(
-            "assignment to property foo of {foo: string}\n"
-                + "found   : number\n"
-                + "required: string")
+        .addSource("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};")
         .run();
   }
 
   @Test
-  public void testCast17a() {
-    // Mostly verifying that rhino actually understands these JsDocs.
+  public void testBang1() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {} \n"
-                + "/** @type {Foo} */ var x = /** @type {Foo} */ (y)")
+        .addSource("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (Object|null)\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testCast17b() {
-    // Mostly verifying that rhino actually understands these JsDocs.
+  public void testBang2() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {} \n"
-                + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})")
+            "/** @param {Object} x\n@return {!Object} */\n"
+                + "function f(x) { return x ? x : new Object(); }")
         .run();
   }
 
   @Test
-  public void testCast19() {
+  public void testBang3() {
     newTest()
         .addSource(
-            "var x = 'string';\n" + "/** @type {number} */\n" + "var y = /** @type {number} */(x);")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: string\n" + "to  : number")
+            "/** @param {Object} x\n@return {!Object} */\n"
+                + "function f(x) { return /** @type {!Object} */ (x); }")
         .run();
   }
 
   @Test
-  public void testCast20() {
+  public void testBang4() {
     newTest()
         .addSource(
-            "/** @enum {boolean|null} */\n"
-                + "var X = {"
-                + "  AA: true,"
-                + "  BB: false,"
-                + "  CC: null"
-                + "};\n"
-                + "var y = /** @type {X} */(true);")
+            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
+                + "function f(x, y) {\n"
+                + "if (typeof x != 'undefined') { return x == y; }\n"
+                + "else { return x != y; }\n}")
         .run();
   }
 
   @Test
-  public void testCast21() {
+  public void testBang5() {
     newTest()
         .addSource(
-            "/** @enum {boolean|null} */\n"
-                + "var X = {"
-                + "  AA: true,"
-                + "  BB: false,"
-                + "  CC: null"
-                + "};\n"
-                + "var value = true;\n"
-                + "var y = /** @type {X} */(value);")
+            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
+                + "function f(x, y) { return !!x && x == y; }")
         .run();
   }
 
   @Test
-  public void testCast22() {
+  public void testBang6() {
     newTest()
-        .addSource("var x = null;\n" + "var y = /** @type {number} */(x);")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n" + "from: null\n" + "to  : number")
+        .addSource("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }")
         .run();
   }
 
   @Test
-  public void testCast23() {
-    newTest().addSource("var x = null;\n" + "var y = /** @type {Number} */(x);").run();
-  }
-
-  @Test
-  public void testCast24() {
+  public void testBang7() {
     newTest()
-        .addSource("var x = undefined;\n" + "var y = /** @type {number} */(x);")
-        .addDiagnostic(
-            "invalid cast - must be a subtype or supertype\n"
-                + "from: undefined\n"
-                + "to  : number")
+        .addSource(
+            "/**@param {(Object|string|null)} x\n"
+                + "@return {(Object|string)}*/function f(x) { return x; }")
         .run();
   }
 
   @Test
-  public void testCast25() {
+  public void testDefinePropertyOnNullableObject1() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource("var x = undefined;\n" + "var y = /** @type {number|undefined} */(x);")
+        .addSource(
+            "/** @type {Object} */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */ function f() { return n.x; }")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testCast26() {
+  public void testDefinePropertyOnNullableObject1a() {
     newTest()
         .addSource(
-            "function fn(dir) {\n"
-                + "  var node = dir ? 1 : 2;\n"
-                + "  fn(/** @type {number} */ (node));\n"
-                + "}")
+            "/** @const */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */function f() { return n.x; }")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testCast27() {
-    // C doesn't implement I but a subtype might.
+  public void testDefinePropertyOnObject() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "var x = new C();\n"
-                + "var y = /** @type {I} */(x);")
+            "/** @type {!Object} */ var n = {};",
+            "/** @type {number} */ n.x = 1;",
+            "/** @return {boolean} */function f() { return n.x; }")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testCast27a() {
-    // C doesn't implement I but a subtype might.
+  public void testDefinePropertyOnNullableObject2() {
+    // checking loose property behavior
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {C} */ var x ;\n"
-                + "var y = /** @type {I} */(x);")
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @param {T} t\n@return {boolean} */function f(t) {\n"
+                + "t.x = 1; return t.x; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testCast28() {
-    // C doesn't implement I but a subtype might.
+  public void testDefinePropertyOnNullableObject2b() {
     newTest()
         .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {!I} */ var x;\n"
-                + "var y = /** @type {C} */(x);")
+            "/** @constructor */ var T = function() {};",
+            "/** @param {T} t */function f(t) { t.x = 1; }")
+        .addDiagnostic("Property x never defined on T")
         .run();
   }
 
   @Test
-  public void testCast28a() {
-    // C doesn't implement I but a subtype might.
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {}\n"
-                + "/** @constructor */ function C() {}\n"
-                + "/** @type {I} */ var x;\n"
-                + "var y = /** @type {C} */(x);")
-        .run();
+  public void testUnknownConstructorInstanceType1() {
+    newTest().addSource("/** @return {Array} */ function g(f) { return new f(); }").run();
   }
 
   @Test
-  public void testCast29a() {
-    // C doesn't implement the record type but a subtype might.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "var x = new C();\n"
-                + "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);")
-        .run();
+  public void testUnknownConstructorInstanceType2() {
+    newTest().addSource("function g(f) { return /** @type {Array} */(new f()); }").run();
   }
 
   @Test
-  public void testCast29b() {
-    // C doesn't implement the record type but a subtype might.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {C} */ var x;\n"
-                + "var y = /** @type {{prop1: Array, prop2: string}} */(x);")
-        .run();
+  public void testUnknownConstructorInstanceType3() {
+    newTest().addSource("function g(f) { var x = new f(); x.a = 1; return x; }").run();
   }
 
   @Test
-  public void testCast29c() {
-    // C doesn't implement the record type but a subtype might.
+  public void testUnknownPrototypeChain1() {
     newTest()
         .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n"
-                + "var y = /** @type {C} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast30() {
-    // Should be able to cast to a looser return type
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {function():string} */ var x ;\n"
-                + "var y = /** @type {function():?} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast31() {
-    // Should be able to cast to a tighter parameter type
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {function(*)} */ var x ;\n"
-                + "var y = /** @type {function(string)} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast32() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Object} */ var x ;\n"
-                + "var y = /** @type {null|{length:number}} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast33a() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string?|undefined} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast33b() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string|undefined} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast33c() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {string?} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast33d() {
-    // null and void should be assignable to any type that accepts one or the
-    // other or both.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {null|undefined} */ var x ;\n"
-                + "var y = /** @type {null} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast34a() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Object} */ var x ;\n"
-                + "var y = /** @type {Function} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCast34b() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "/** @type {Function} */ var x ;\n"
-                + "var y = /** @type {Object} */(x);")
-        .run();
-  }
-
-  @Test
-  public void testCastToNameRequiringPropertyResolution() {
-    // regression test for correctly typing properties off of types in CASTs.
-    // The type JSDoc in a cast is currently evaluated during TypeInference. In the past any
-    // 'unresolved' types in cast JSDoc were not resolved until after type inference completed. This
-    // caused type inference to infer properties off of those unresolved types as unknown.
-    newTest()
-        .addExterns("var unknownVar;")
-        .addSource(
-            "const foo = {bar: {}};",
-            "const bar = foo.bar;",
-            "bar.Class = class {",
-            "  /** @return {number} */",
-            "  id() { return 0; }",
-            "};",
-            // Because `foo.bar.Class = ...` was never directly assigned, the type 'foo.bar.Class'
-            // is not in the JSTypeRegistry. It's resolved through NamedType#resolveViaProperty.
-            // The same thing would have occurred if we assigned 'foo.bar.Class = ...' then
-            // referred to '!bar.Class' in the JSDoc.
-            // Verify that type inference correctly infers the id property's type.
-
-            "const /** null */ n = /** @type {!foo.bar.Class} */ (unknownVar).id;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : function(this:bar.Class): number",
-                "required: null"))
-        .run();
-  }
-
-  @Test
-  public void testNestedCasts() {
-    newTest()
-        .addSource(
-            "/** @constructor */var T = function() {};\n"
-                + "/** @constructor */var V = function() {};\n"
-                + "/**\n"
-                + "* @param {boolean} b\n"
-                + "* @return {T|V}\n"
-                + "*/\n"
-                + "function f(b) { return b ? new T() : new V(); }\n"
-                + "/**\n"
-                + "* @param {boolean} b\n"
-                + "* @return {boolean|undefined}\n"
-                + "*/\n"
-                + "function g(b) { return b ? true : undefined; }\n"
-                + "/** @return {T} */\n"
-                + "function h() {\n"
-                + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testNativeCast1() {
-    newTest()
-        .addSource("/** @param {number} x */ function f(x) {}" + "f(String(true));")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testNativeCast2() {
-    newTest()
-        .addSource("/** @param {string} x */ function f(x) {}" + "f(Number(true));")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testNativeCast3() {
-    newTest()
-        .addSource("/** @param {number} x */ function f(x) {}" + "f(Boolean(''));")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : boolean\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testNativeCast4() {
-    newTest()
-        .addSource(
-            "/** @param {number} x */ function f(x) {}", //
-            "f(Array(1));")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Array",
-                "required: number"))
-        .run();
-  }
-
-  @Test
-  public void testBadConstructorCall() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "Foo();")
-        .addDiagnostic("Constructor (typeof Foo) should be called with the \"new\" keyword")
-        .run();
-  }
-
-  @Test
-  public void testTypeof() {
-    newTest().addSource("/**@return {void}*/function foo(){ var a = typeof foo(); }").run();
-  }
-
-  @Test
-  public void testTypeof2() {
-    newTest()
-        .addSource("function f(){ if (typeof 123 == 'numbr') return 321; }")
-        .addDiagnostic("unknown type: numbr")
-        .run();
-  }
-
-  @Test
-  public void testTypeof3() {
-    newTest()
-        .addSource(
-            "function f() {",
-            "  return (",
-            "      typeof 123 == 'number' ||",
-            "      typeof 123 == 'string' ||",
-            "      typeof 123 == 'boolean' ||",
-            "      typeof 123 == 'undefined' ||",
-            "      typeof 123 == 'function' ||",
-            "      typeof 123 == 'object' ||",
-            "      typeof 123 == 'symbol' ||",
-            "      typeof 123 == 'unknown'); }")
-        .run();
-  }
-
-  @Test
-  public void testConstDecl1() {
-    newTest()
-        .addSource(
-            "/** @param {?number} x \n @return {boolean} */"
-                + "function f(x) { "
-                + "  if (x) { /** @const */ var y = x; return y } return true; "
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
-        .run();
-  }
-
-  @Test
-  public void testConstDecl2() {
-    newTest()
-        .addSource(
-            "/** @param {?number} x */"
-                + "function f(x) { "
-                + "  if (x) {"
-                + "    /** @const */ var y = x; "
-                + "    /** @return {boolean} */ function g() { return y; } "
-                + "  }"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType1() {
-    newTest()
-        .addSource("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();")
-        .addDiagnostic("initializing variable\n" + "found   : Date\n" + "required: Foo")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType2() {
-    newTest()
-        .addSource(
-            "/**@constructor*/function Foo(){\n"
-                + "/**@type{Number}*/this.bar = new Number(5);\n"
-                + "}\n"
-                + "/**@type{Foo}*/var f = new Foo();\n"
-                + "/**@type{Number}*/var n = f.bar;")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType3() {
-    // Reverse the declaration order so that we know that Foo is getting set
-    // even on an out-of-order declaration sequence.
-    newTest()
-        .addSource(
-            "/**@type{Foo}*/var f = new Foo();\n"
-                + "/**@type{Number}*/var n = f.bar;"
-                + "/**@constructor*/function Foo(){\n"
-                + "/**@type{Number}*/this.bar = new Number(5);\n"
-                + "}\n")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType4() {
-    newTest()
-        .addSource(
-            "/**@constructor*/function Foo(){\n"
-                + "/**@type{!Number}*/this.bar = new Number(5);\n"
-                + "}\n"
-                + "/**@type{!Foo}*/var f = new Foo();\n"
-                + "/**@type{!String}*/var n = f.bar;")
-        .addDiagnostic("initializing variable\n" + "found   : Number\n" + "required: String")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType5() {
-    newTest().addSource("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n").run();
-  }
-
-  @Test
-  public void testConstructorType6() {
-    newTest()
-        .addSource(
-            "/** @constructor */\n"
-                + "function bar() {}\n"
-                + "function _foo() {\n"
-                + " /** @param {bar} x */\n"
-                + "  function f(x) {}\n"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType7() {
-    TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};");
-
-    JSType type = p.scope.getVar("A").getType();
-    assertThat(type).isInstanceOf(FunctionType.class);
-    FunctionType fType = (FunctionType) type;
-    assertThat(fType.getReferenceName()).isEqualTo("A");
-  }
-
-  @Test
-  public void testConstructorType8() {
-    newTest()
-        .addSource(
-            "var ns = {};"
-                + "ns.create = function() { return function() {}; };"
-                + "/** @constructor */ ns.Foo = ns.create();"
-                + "ns.Foo.prototype = {x: 0, y: 0};"
-                + "/**\n"
-                + " * @param {ns.Foo} foo\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function f(foo) {"
-                + "  return foo.x;"
-                + "}")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType9() {
-    newTest()
-        .addSource(
-            "var ns = {};"
-                + "ns.create = function() { return function() {}; };"
-                + "ns.extend = function(x) { return x; };"
-                + "/** @constructor */ ns.Foo = ns.create();"
-                + "ns.Foo.prototype = ns.extend({x: 0, y: 0});"
-                + "/**\n"
-                + " * @param {ns.Foo} foo\n"
-                + " * @return {string}\n"
-                + " */\n"
-                + "function f(foo) {"
-                + "  return foo.x;"
-                + "}")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType10() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function NonStr() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @extends{NonStr}\n"
-                + " */"
-                + "function NonStrKid() {}")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType11() {
-    newTest()
-        .addSource(
-            "/** @constructor */"
-                + "function NonDict() {}"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @dict\n"
-                + " * @extends{NonDict}\n"
-                + " */"
-                + "function NonDictKid() {}")
-        .run();
-  }
-
-  @Test
-  public void testConstructorType12() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "Bar.prototype = {};\n")
-        .run();
-  }
-
-  @Test
-  public void testBadStruct() {
-    newTest()
-        .addSource("/** @struct */function Struct1() {}")
-        .addDiagnostic("@struct used without @constructor for Struct1")
-        .run();
-  }
-
-  @Test
-  public void testBadDict() {
-    newTest()
-        .addSource("/** @dict */function Dict1() {}")
-        .addDiagnostic("@dict used without @constructor for Dict1")
-        .run();
-  }
-
-  @Test
-  public void testAnonymousPrototype1() {
-    newTest()
-        .addSource(
-            "var ns = {};"
-                + "/** @constructor */ ns.Foo = function() {"
-                + "  this.bar(3, 5);"
-                + "};"
-                + "ns.Foo.prototype = {"
-                + "  bar: function(x) {}"
-                + "};")
-        .addDiagnostic(
-            "Function ns.Foo.prototype.bar: called with 2 argument(s). "
-                + "Function requires at least 1 argument(s) and no more "
-                + "than 1 argument(s).")
-        .run();
-  }
-
-  @Test
-  public void testAnonymousPrototype2() {
-    newTest()
-        .addSource(
-            "/** @interface */ var Foo = function() {};"
-                + "Foo.prototype = {"
-                + "  foo: function(x) {}"
-                + "};"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @implements {Foo}\n"
-                + " */ var Bar = function() {};")
-        .addDiagnostic("property foo on interface Foo is not implemented by type Bar")
-        .run();
-  }
-
-  @Test
-  public void testAnonymousType1() {
-    newTest()
-        .addSource(
-            "function f() { return {}; }", //
-            "/** @constructor */",
-            "f().bar = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testAnonymousType2() {
-    newTest()
-        .addSource(
-            "function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testAnonymousType3() {
-    newTest()
-        .addSource("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};")
-        .run();
-  }
-
-  @Test
-  public void testBang1() {
-    newTest()
-        .addSource("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (Object|null)\n" + "required: Object")
-        .run();
-  }
-
-  @Test
-  public void testBang2() {
-    newTest()
-        .addSource(
-            "/** @param {Object} x\n@return {!Object} */\n"
-                + "function f(x) { return x ? x : new Object(); }")
-        .run();
-  }
-
-  @Test
-  public void testBang3() {
-    newTest()
-        .addSource(
-            "/** @param {Object} x\n@return {!Object} */\n"
-                + "function f(x) { return /** @type {!Object} */ (x); }")
-        .run();
-  }
-
-  @Test
-  public void testBang4() {
-    newTest()
-        .addSource(
-            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
-                + "function f(x, y) {\n"
-                + "if (typeof x != 'undefined') { return x == y; }\n"
-                + "else { return x != y; }\n}")
-        .run();
-  }
-
-  @Test
-  public void testBang5() {
-    newTest()
-        .addSource(
-            "/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n"
-                + "function f(x, y) { return !!x && x == y; }")
-        .run();
-  }
-
-  @Test
-  public void testBang6() {
-    newTest()
-        .addSource("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }")
-        .run();
-  }
-
-  @Test
-  public void testBang7() {
-    newTest()
-        .addSource(
-            "/**@param {(Object|string|null)} x\n"
-                + "@return {(Object|string)}*/function f(x) { return x; }")
-        .run();
-  }
-
-  @Test
-  public void testDefinePropertyOnNullableObject1() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @type {Object} */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */ function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
-        .run();
-  }
-
-  @Test
-  public void testDefinePropertyOnNullableObject1a() {
-    newTest()
-        .addSource(
-            "/** @const */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
-        .run();
-  }
-
-  @Test
-  public void testDefinePropertyOnObject() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @type {!Object} */ var n = {};",
-            "/** @type {number} */ n.x = 1;",
-            "/** @return {boolean} */function f() { return n.x; }")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: boolean"))
-        .run();
-  }
-
-  @Test
-  public void testDefinePropertyOnNullableObject2() {
-    // checking loose property behavior
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @param {T} t\n@return {boolean} */function f(t) {\n"
-                + "t.x = 1; return t.x; }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: boolean")
-        .run();
-  }
-
-  @Test
-  public void testDefinePropertyOnNullableObject2b() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};",
-            "/** @param {T} t */function f(t) { t.x = 1; }")
-        .addDiagnostic("Property x never defined on T")
-        .run();
-  }
-
-  @Test
-  public void testUnknownConstructorInstanceType1() {
-    newTest().addSource("/** @return {Array} */ function g(f) { return new f(); }").run();
-  }
-
-  @Test
-  public void testUnknownConstructorInstanceType2() {
-    newTest().addSource("function g(f) { return /** @type {Array} */(new f()); }").run();
-  }
-
-  @Test
-  public void testUnknownConstructorInstanceType3() {
-    newTest().addSource("function g(f) { var x = new f(); x.a = 1; return x; }").run();
-  }
-
-  @Test
-  public void testUnknownPrototypeChain1() {
-    newTest()
-        .addSource(
-            "/**",
-            "* @param {Object} co",
-            " * @return {Object}",
-            " */",
-            "function inst(co) {",
-            " /** @constructor */",
-            " var c = function() {};",
-            " c.prototype = co.prototype;",
-            " return new c;",
-            "}")
-        .addDiagnostic("Property prototype never defined on Object")
-        .run();
-  }
-
-  @Test
-  public void testUnknownPrototypeChain2() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @param {Function} co",
-            " * @return {Object}",
-            " */",
-            "function inst(co) {",
-            " /** @constructor */",
-            " var c = function() {};",
-            " c.prototype = co.prototype;",
-            " return new c;",
-            "}")
-        .run();
-  }
-
-  @Test
-  public void testNamespacedConstructor() {
-    Node root =
-        parseAndTypeCheck(
-            "var goog = {};"
-                + "/** @constructor */ goog.MyClass = function() {};"
-                + "/** @return {!goog.MyClass} */ "
-                + "function foo() { return new goog.MyClass(); }");
-
-    JSType typeOfFoo = root.getLastChild().getJSType();
-    assertType(typeOfFoo).isInstanceOf(FunctionType.class);
-
-    JSType retType = ((FunctionType) typeOfFoo).getReturnType();
-    assertType(retType).isInstanceOf(ObjectType.class);
-    assertThat(((ObjectType) retType).getReferenceName()).isEqualTo("goog.MyClass");
-  }
-
-  @Test
-  public void testComplexNamespace() {
-    String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;";
-
-    TypeCheckResult p = parseAndTypeCheckWithScope(js);
-
-    // goog type in the scope
-    JSType googScopeType = p.scope.getVar("goog").getType();
-    assertThat(googScopeType).isInstanceOf(ObjectType.class);
-    assertWithMessage("foo property not present on goog type")
-        .that(googScopeType.hasProperty("foo"))
-        .isTrue();
-    assertWithMessage("bar property present on goog type")
-        .that(googScopeType.hasProperty("bar"))
-        .isFalse();
-
-    // goog type on the VAR node
-    Node varNode = p.root.getFirstChild();
-    assertNode(varNode).hasToken(Token.VAR);
-    JSType googNodeType = varNode.getFirstChild().getJSType();
-    assertThat(googNodeType).isInstanceOf(ObjectType.class);
-
-    // goog scope type and goog type on VAR node must be the same
-    assertThat(googScopeType).isSameInstanceAs(googNodeType);
-
-    // goog type on the left of the GETPROP node (under fist ASSIGN)
-    Node getpropFoo1 = varNode.getNext().getFirstFirstChild();
-    assertNode(getpropFoo1).hasToken(Token.GETPROP);
-    assertThat(getpropFoo1.getFirstChild().getString()).isEqualTo("goog");
-    JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType();
-    assertThat(googGetpropFoo1Type).isInstanceOf(ObjectType.class);
-
-    // still the same type as the one on the variable
-    assertThat(googGetpropFoo1Type).isSameInstanceAs(googScopeType);
-
-    // the foo property should be defined on goog
-    JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo");
-    assertThat(googFooType).isInstanceOf(ObjectType.class);
-
-    // goog type on the left of the GETPROP lower level node
-    // (under second ASSIGN)
-    Node getpropFoo2 = varNode.getNext().getNext().getFirstFirstChild().getFirstChild();
-    assertNode(getpropFoo2).hasToken(Token.GETPROP);
-    assertThat(getpropFoo2.getFirstChild().getString()).isEqualTo("goog");
-    JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType();
-    assertThat(googGetpropFoo2Type).isInstanceOf(ObjectType.class);
-
-    // still the same type as the one on the variable
-    assertThat(googGetpropFoo2Type).isSameInstanceAs(googScopeType);
-
-    // goog.foo type on the left of the top-level GETPROP node
-    // (under second ASSIGN)
-    JSType googFooGetprop2Type = getpropFoo2.getJSType();
-    assertWithMessage("goog.foo incorrectly annotated in goog.foo.bar selection")
-        .that(googFooGetprop2Type)
-        .isInstanceOf(ObjectType.class);
-    ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type;
-    assertWithMessage("foo property present on goog.foo type")
-        .that(googFooGetprop2ObjectType.hasProperty("foo"))
-        .isFalse();
-    assertWithMessage("bar property not present on goog.foo type")
-        .that(googFooGetprop2ObjectType.hasProperty("bar"))
-        .isTrue();
-    assertTypeEquals(
-        "bar property on goog.foo type incorrectly inferred",
-        getNativeNumberType(),
-        googFooGetprop2ObjectType.getPropertyType("bar"));
-  }
-
-  @Test
-  public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() {
-    disableStrictMissingPropertyChecks();
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS, "/** @constructor */function A() {}" + "A.prototype.m1 = 5");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 1);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
-  }
-
-  @Test
-  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            "var goog = {};"
-                + "goog.A = /** @constructor */function() {};"
-                + "/** @type {number} */goog.A.prototype.m1 = 5");
-
-    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
-  }
-
-  @Test
-  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            "var goog = {};"
-                + "/** @constructor */goog.A = function() {};"
-                + "/** @type {number} */goog.A.prototype.m1 = 5");
-
-    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
-  }
-
-  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(TypeCheckResult p) {
-    ObjectType goog = (ObjectType) p.scope.getVar("goog").getType();
-    assertHasXMorePropertiesThanNativeObject(goog, 1);
-    JSType googA = goog.getPropertyType("A");
-    assertThat(googA).isNotNull();
-    assertThat(googA).isInstanceOf(FunctionType.class);
-    FunctionType googAFunction = (FunctionType) googA;
-    ObjectType classA = googAFunction.getInstanceType();
-    assertHasXMorePropertiesThanNativeObject(classA, 1);
-    checkObjectType(classA, "m1", getNativeNumberType());
-  }
-
-  @Test
-  public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 2);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
-    checkObjectType(instanceType, "m2", getNativeBooleanType());
-  }
-
-  @Test
-  public void testDontAddMethodsIfNoConstructor() {
-    Node js1Node = parseAndTypeCheck("function A() {}" + "A.prototype = {m1: 5, m2: true}");
-
-    JSType functionAType = js1Node.getFirstChild().getJSType();
-    assertThat(functionAType.toString()).isEqualTo("function(): undefined");
-    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m1"));
-    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m2"));
-  }
-
-  @Test
-  public void testFunctionAssignement() {
-    newTest()
-        .addSource(
-            "/**"
-                + "* @param {string} ph0"
-                + "* @param {string} ph1"
-                + "* @return {string}"
-                + "*/"
-                + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}"
-                + "/** @type {Function} */"
-                + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;")
-        .run();
-  }
-
-  @Test
-  public void testAddMethodsPrototypeTwoWays() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {}"
-                + "A.prototype = {m1: 5, m2: true};"
-                + "A.prototype.m3 = 'third property!';");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertThat(instanceType.toString()).isEqualTo("A");
-    assertHasXMorePropertiesThanNativeObject(instanceType, 3);
-    checkObjectType(instanceType, "m1", getNativeNumberType());
-    checkObjectType(instanceType, "m2", getNativeBooleanType());
-    checkObjectType(instanceType, "m3", getNativeStringType());
-  }
-
-  @Test
-  public void testPrototypePropertyTypes() {
-    Node js1Node =
-        parseAndTypeCheck(
-            DEFAULT_EXTERNS,
-            "/** @constructor */function A() {\n"
-                + "  /** @type {string} */ this.m1;\n"
-                + "  /** @type {Object?} */ this.m2 = {};\n"
-                + "  /** @type {boolean} */ this.m3;\n"
-                + "}\n"
-                + "/** @type {string} */ A.prototype.m4;\n"
-                + "/** @type {number} */ A.prototype.m5 = 0;\n"
-                + "/** @type {boolean} */ A.prototype.m6;\n");
-
-    ObjectType instanceType = getInstanceType(js1Node);
-    assertHasXMorePropertiesThanNativeObject(instanceType, 6);
-    checkObjectType(instanceType, "m1", getNativeStringType());
-    checkObjectType(
-        instanceType, "m2", createUnionType(getNativeObjectType(), getNativeNullType()));
-    checkObjectType(instanceType, "m3", getNativeBooleanType());
-    checkObjectType(instanceType, "m4", getNativeStringType());
-    checkObjectType(instanceType, "m5", getNativeNumberType());
-    checkObjectType(instanceType, "m6", getNativeBooleanType());
-  }
-
-  @Test
-  public void testValueTypeBuiltInPrototypePropertyType() {
-    Node node = parseAndTypeCheck(new TestExternsBuilder().addString().build(), "\"x\".charAt(0)");
-    assertTypeEquals(getNativeStringType(), node.getFirstFirstChild().getJSType());
-  }
-
-  @Test
-  public void testDeclareBuiltInConstructor() {
-    // Built-in prototype properties should be accessible
-    // even if the built-in constructor is declared.
-    Node node =
-        parseAndTypeCheck(
-            new TestExternsBuilder().addString().build(),
-            lines(
-                "/** @constructor */ var String = function(opt_str) {};",
-                "(new String(\"x\")).charAt(0)"));
-    assertTypeEquals(getNativeStringType(), node.getLastChild().getFirstChild().getJSType());
-  }
-
-  @Test
-  public void testExtendBuiltInType1() {
-    String externs =
-        "/** @constructor */ var String = function(opt_str) {};\n"
-            + "/**\n"
-            + "* @param {number} start\n"
-            + "* @param {number} opt_length\n"
-            + "* @return {string}\n"
-            + "*/\n"
-            + "String.prototype.substr = function(start, opt_length) {};\n";
-    Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);");
-    assertTypeEquals(getNativeStringType(), n1.getLastChild().getFirstChild().getJSType());
-  }
-
-  @Test
-  public void testExtendBuiltInType2() {
-    String externs =
-        "/** @constructor */ var String = function(opt_str) {};\n"
-            + "/**\n"
-            + "* @param {number} start\n"
-            + "* @param {number} opt_length\n"
-            + "* @return {string}\n"
-            + "*/\n"
-            + "String.prototype.substr = function(start, opt_length) {};\n";
-    Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);");
-    assertTypeEquals(getNativeStringType(), n2.getLastChild().getFirstChild().getJSType());
-  }
-
-  @Test
-  public void testExtendFunction1() {
-    Node n =
-        parseAndTypeCheck(
-            "/**@return {number}*/Function.prototype.f = "
-                + "function() { return 1; };\n"
-                + "(new Function()).f();");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertTypeEquals(getNativeNumberType(), type);
-  }
-
-  @Test
-  public void testExtendFunction2() {
-    Node n =
-        parseAndTypeCheck(
-            "/**@return {number}*/Function.prototype.f = "
-                + "function() { return 1; };\n"
-                + "(function() {}).f();");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertTypeEquals(getNativeNumberType(), type);
-  }
-
-  @Test
-  public void testClassExtendPrimitive() {
-    newTest()
-        .addSource("/** @extends {number} */ class C extends number {}")
-        .addDiagnostic("C @extends non-object type number")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck1() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck2() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("property foo not defined on any superclass of Sub")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck3() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .addDiagnostic(
-            "property foo already defined on superclass Super; " + "use @override to override it")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck4() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck5() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .addDiagnostic(
-            "property foo already defined on superclass Root; " + "use @override to override it")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck6() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck7() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "goog.Sub.prototype.foo = 5;")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck8() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override */goog.Sub.prototype.foo = 5;")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck9_1() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "Super.prototype.foo = function() { return 3; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1; };")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck9_2() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @return {number} */"
-                + "Super.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo =\n"
-                + "function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck9_3() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @return {number} */"
-                + "Super.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
-                + "function() { return \"some string\" };")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Super\n"
-                + "original: function(this:Super): number\n"
-                + "override: function(this:Sub): string")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck10_1() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "Root.prototype.foo = function() { return 3; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1; };")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck10_2() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "/** @return {number} */"
-                + "Root.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo =\n"
-                + "function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck10_3() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Root() {};"
-                + "/** @return {number} */"
-                + "Root.prototype.foo = function() { return 1; };"
-                + "/** @constructor\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
-                + "function() { return \"some string\" };")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Root\n"
-                + "original: function(this:Root): number\n"
-                + "override: function(this:Sub): string")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck11() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass Super\n"
-                + "original: function(this:Super, number): undefined\n"
-                + "override: function(this:Sub, string): undefined")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck12() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override */goog.Sub.prototype.foo = \"some string\";")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck13() {
-    newTest()
-        .addSource(
-            "var goog = {};\n"
-                + "/** @constructor\n @extends {goog.Missing} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("Bad type annotation. Unknown type goog.Missing")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck14() {
-    testClosureTypes(
-        lines(
-            "/** @constructor\n @extends {goog.Missing} */",
-            "goog.Super = function() {};",
-            "/** @constructor\n @extends {goog.Super} */function Sub() {};",
-            "/** @override */ Sub.prototype.foo = function() {};"),
-        "Bad type annotation. Unknown type goog.Missing");
-  }
-
-  @Test
-  public void testInheritanceCheck15() {
-    newTest()
-        .addSource(
-            "/** @constructor */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo;"
-                + "/** @constructor\n @extends {Super} */function Sub() {};"
-                + "/** @override\n  @param {number} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck16() {
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "/** @type {number} */ goog.Super.prototype.foo = 3;"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @type {number} */ goog.Sub.prototype.foo = 5;")
-        .addDiagnostic(
-            "property foo already defined on superclass goog.Super; "
-                + "use @override to override it")
-        .run();
-  }
-
-  @Test
-  public void testInheritanceCheck17() {
-    // Make sure this warning still works, even when there's no
-    // @override tag.
-    newTest()
-        .addSource(
-            "var goog = {};"
-                + "/** @constructor */goog.Super = function() {};"
-                + "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};"
-                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
-                + "/** @override @param {string} x */ goog.Sub.prototype.foo = function(x) {};")
-        .addDiagnostic(
-            "mismatch of the foo property type and the type of the property it "
-                + "overrides from superclass goog.Super\n"
-                + "original: function(this:goog.Super, number): undefined\n"
-                + "override: function(this:goog.Sub, string): undefined")
-        .run();
-  }
-
-  @Test
-  public void testInterfacePropertyOverride1() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInterfacePropertyOverride2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Root() {};"
-                + "Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @interface\n @extends {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInterfacePropertyBadOverrideFails() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};",
-            "/** @type {number} */",
-            "Super.prototype.foo;",
-            "/** @interface @extends {Super} */function Sub() {};",
-            "/** @type {string} */",
-            "Sub.prototype.foo;")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Sub and the type of the property it "
-                    + "overrides from interface Super",
-                "original: number",
-                "override: string"))
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck1() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "Sub.prototype.foo = function() {};")
-        .addDiagnostic(
-            "property foo already defined on interface Super; use @override to " + "override it")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};"
-                + "Super.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck3() {
-    newTest()
-        .addSource(
-            "/** @interface */function Root() {};"
-                + "/** @return {number} */Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @return {number} */Sub.prototype.foo = function() { return 1;};")
-        .addDiagnostic(
-            "property foo already defined on interface Root; use @override to " + "override it")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck4() {
-    newTest()
-        .addSource(
-            "/** @interface */function Root() {};"
-                + "/** @return {number} */Root.prototype.foo = function() {};"
-                + "/** @interface\n @extends {Root} */function Super() {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override\n * @return {number} */Sub.prototype.foo =\n"
-                + "function() { return 1;};")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck5() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};/** @return {string} */Super.prototype.foo ="
-                + " function() {};/** @constructor\n"
-                + " @implements {Super} */function Sub() {};/** @override\n"
-                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
-        .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Super\n"
-                + "original: function(this:Super): string\n"
-                + "override: function(this:Sub): number")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck6() {
-    newTest()
-        .addSource(
-            "/** @interface */function Root() {};/** @return {string} */Root.prototype.foo ="
-                + " function() {};/** @interface\n"
-                + " @extends {Root} */function Super() {};/** @constructor\n"
-                + " @implements {Super} */function Sub() {};/** @override\n"
-                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
-        .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Root\n"
-                + "original: function(this:Root): string\n"
-                + "override: function(this:Sub): number")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck7() {
-    newTest()
-        .addSource(
-            "/** @interface */function Super() {};"
-                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
-                + "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
-                + "function(bar) {};")
-        .addDiagnostic(
-            "mismatch of the foo property on type Sub and the type of the property it "
-                + "overrides from interface Super\n"
-                + "original: function(this:Super, number): undefined\n"
-                + "override: function(this:Sub, string): undefined")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck8() {
-    newTest()
-        .addSource(
-            "/** @constructor\n @implements {Super} */function Sub() {};"
-                + "/** @override */Sub.prototype.foo = function() {};")
-        .addDiagnostic("Bad type annotation. Unknown type Super")
-        .addDiagnostic("property foo not defined on any superclass of Sub")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck9() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.bar = function() {};"
-                + "/** @constructor */ function F() {}"
-                + "/** @return {number} */ F.prototype.bar = function() {return 3; };"
-                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
-                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
-                + "function G() {}"
-                + "/** @return {string} */ function f() { return new G().bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck10() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {}"
-                + "/** @return {number} */ I.prototype.bar = function() {};"
-                + "/** @constructor */ function F() {}"
-                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
-                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
-                + "function G() {}"
-                + "/** @return {number} \n * @override */ "
-                + "G.prototype.bar = G.prototype.foo;"
-                + "/** @return {string} */ function f() { return new G().bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck12() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I() {};\n"
-                + "/** @type {string} */ I.prototype.foobar;\n"
-                + "/** \n * @constructor \n * @implements {I} */\n"
-                + "function C() {\n"
-                + "/** \n * @type {number} */ this.foobar = 2;};\n"
-                + "/** @type {I} */ \n var test = new C(); alert(test.foobar);")
-        .addDiagnostic(
-            "mismatch of the foobar property on type C and the type of the property"
-                + " it overrides from interface I\n"
-                + "original: string\n"
-                + "override: number")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInheritanceCheck13() {
-    newTest()
-        .addSource(
-            "function abstractMethod() {};\n"
-                + "/** @interface */var base = function() {};\n"
-                + "/** @extends {base} \n @interface */ var Int = function() {}\n"
-                + "/** @type {{bar : !Function}} */ var x; \n"
-                + "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n"
-                + "/** @type {Int} */ var foo;\n"
-                + "foo.bar();")
-        .run();
-  }
-
-  /** Verify that templatized interfaces can extend one another and share template values. */
-  @Test
-  public void testInterfaceInheritanceCheck14() {
-    newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
-                + "/** @return {U} */B.prototype.bar = function() {};"
-                + "/** @constructor\n @implements {B<string>} */function C() {};"
-                + "/** @return {string}\n @override */C.prototype.foo = function() {};"
-                + "/** @return {string}\n @override */C.prototype.bar = function() {};")
-        .run();
-  }
-
-  /** Verify that templatized instances can correctly implement templatized interfaces. */
-  @Test
-  public void testInterfaceInheritanceCheck15() {
-    newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
-                + "/** @return {U} */B.prototype.bar = function() {};"
-                + "/** @constructor\n @template V\n @implements {B<V>}\n */function C() {};"
-                + "/** @return {V}\n @override */C.prototype.foo = function() {};"
-                + "/** @return {V}\n @override */C.prototype.bar = function() {};")
-        .run();
-  }
-
-  /**
-   * Verify that using @override to declare the signature for an implementing class works correctly
-   * when the interface is generic.
-   */
-  @Test
-  public void testInterfaceInheritanceCheck16() {
-    newTest()
-        .addSource(
-            "/** @interface\n @template T */function A() {};"
-                + "/** @return {T} */A.prototype.foo = function() {};"
-                + "/** @return {T} */A.prototype.bar = function() {};"
-                + "/** @constructor\n @implements {A<string>} */function B() {};"
-                + "/** @override */B.prototype.foo = function() { return 'string'};"
-                + "/** @override */B.prototype.bar = function() { return 3 };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testInterfacePropertyNotImplemented() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int() {};"
-                + "Int.prototype.foo = function() {};"
-                + "/** @constructor\n @implements {Int} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
-        .run();
-  }
-
-  @Test
-  public void testInterfacePropertyNotImplemented2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int() {};"
-                + "Int.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int} */function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
-        .run();
-  }
-
-  /** Verify that templatized interfaces enforce their template type values. */
-  @Test
-  public void testInterfacePropertyNotImplemented3() {
-    newTest()
-        .addSource(
-            "/** @interface  @template T */ function Int() {};",
-            "/** @return {T} */ Int.prototype.foo = function() {};",
-            "",
-            "/** @constructor @implements {Int<string>} */ function Foo() {};",
-            "/** @return {number}  @override */ Foo.prototype.foo = function() {};")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Foo and the type of the property it "
-                    + "overrides from interface Int",
-                "original: function(this:Int): string",
-                "override: function(this:Foo): number"))
-        .run();
-  }
-
-  @Test
-  public void testStubConstructorImplementingInterface() {
-    // This does not throw a warning for unimplemented property because Foo is
-    // just a stub.
-    newTest()
-        .addExterns(
-            "/** @interface */ function Int() {}\n"
-                + "Int.prototype.foo = function() {};"
-                + "/** @constructor \n @implements {Int} */ var Foo;\n")
-        .addSource("")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteral() {
-    Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}");
-
-    Node nameNode = n.getFirstFirstChild();
-    Node objectNode = nameNode.getFirstChild();
-
-    // node extraction
-    assertNode(nameNode).hasToken(Token.NAME);
-    assertNode(objectNode).hasToken(Token.OBJECTLIT);
-
-    // value's type
-    ObjectType objectType = (ObjectType) objectNode.getJSType();
-    assertTypeEquals(getNativeNumberType(), objectType.getPropertyType("m1"));
-    assertTypeEquals(getNativeStringType(), objectType.getPropertyType("m2"));
-
-    // variable's type
-    assertTypeEquals(objectType, nameNode.getJSType());
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration1() {
-    newTest()
-        .addSource(
-            "var x = {"
-                + "/** @type {boolean} */ abc: true,"
-                + "/** @type {number} */ 'def': 0,"
-                + "/** @type {string} */ 3: 'fgh'"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration2() {
-    newTest()
-        .addSource("var x = {" + "  /** @type {boolean} */ abc: true" + "};" + "x.abc = 0;")
-        .addDiagnostic(
-            "assignment to property abc of x\n" + "found   : number\n" + "required: boolean")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration3() {
-    newTest()
-        .addSource(
-            "/** @param {{foo: !Function}} x */ function f(x) {}" + "f({foo: function() {}});")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration4() {
-    testClosureTypes(
-        "var x = {"
-            + "  /** @param {boolean} x */ abc: function(x) {}"
-            + "};"
-            + "/**\n"
-            + " * @param {string} x\n"
-            + " * @suppress {duplicate}\n"
-            + " */ x.abc = function(x) {};",
-        "assignment to property abc of x\n"
-            + "found   : function(string): undefined\n"
-            + "required: function(boolean): undefined");
-    // TODO(user): suppress {duplicate} currently also silence the
-    // redefining type error in the TypeValidator. Maybe it needs
-    // a new suppress name instead?
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration5() {
-    newTest()
-        .addSource(
-            "var x = {"
-                + "  /** @param {boolean} x */ abc: function(x) {}"
-                + "};"
-                + "/**\n"
-                + " * @param {boolean} x\n"
-                + " * @suppress {duplicate}\n"
-                + " */ x.abc = function(x) {};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration6() {
-    newTest()
-        .addSource(
-            "var x = {};"
-                + "/**\n"
-                + " * @param {boolean} x\n"
-                + " * @suppress {duplicate}\n"
-                + " */ x.abc = function(x) {};"
-                + "x = {"
-                + "  /**\n"
-                + "   * @param {boolean} x\n"
-                + "   * @suppress {duplicate}\n"
-                + "   */"
-                + "  abc: function(x) {}"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testObjectLiteralDeclaration7() {
-    newTest()
-        .addSource(
-            "var x = {};"
-                + "/**\n"
-                + " * @type {function(boolean): undefined}\n"
-                + " */ x.abc = function(x) {};"
-                + "x = {"
-                + "  /**\n"
-                + "   * @param {boolean} x\n"
-                + "   * @suppress {duplicate}\n"
-                + "   */"
-                + "  abc: function(x) {}"
-                + "};")
-        .run();
-  }
-
-  @Test
-  public void testCallDateConstructorAsFunction() {
-    // ECMA-262 15.9.2: When Date is called as a function rather than as a
-    // constructor, it returns a string.
-    Node n = parseAndTypeCheck("Date()");
-    assertTypeEquals(getNativeStringType(), n.getFirstFirstChild().getJSType());
-  }
-
-  // According to ECMA-262, Error & Array function calls are equivalent to
-  // constructor calls.
-
-  @Test
-  public void testCallErrorConstructorAsFunction() {
-    String externs =
-        lines(
-            "/** @constructor",
-            "    @param {string} message",
-            "    @return {!Error} */",
-            "function Error(message) {}");
-    Node n = parseAndTypeCheck(externs, "Error('x')");
-    Node call = n.getFirstFirstChild();
-    assertThat(call.isCall()).isTrue();
-    assertTypeEquals(
-        call.getFirstChild().getJSType().toMaybeFunctionType().getInstanceType(), call.getJSType());
-  }
-
-  @Test
-  public void testCallArrayConstructorAsFunction() {
-    Node n = parseAndTypeCheck("Array()");
-    assertTypeEquals(getNativeArrayType(), n.getFirstFirstChild().getJSType());
-  }
-
-  @Test
-  public void testPropertyTypeOfUnionType() {
-    newTest()
-        .addSource(
-            "var a = {};"
-                + "/** @constructor */ a.N = function() {};\n"
-                + "a.N.prototype.p = 1;\n"
-                + "/** @constructor */ a.S = function() {};\n"
-                + "a.S.prototype.p = 'a';\n"
-                + "/** @param {!a.N|!a.S} x\n@return {string} */\n"
-                + "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testGetPropertyTypeOfUnionType_withMatchingTemplates() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<number>} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testGetPropertyTypeOfUnionType_withDifferingTemplates() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<string>} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : (number|string)",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testGetPropertyTypeOfUnionType_withMembersThatExtendATemplatizedType() {
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "",
-            "/** @interface @extends {Foo<number>} */ function Bar() {};",
-            "/** @interface @extends {Foo<number>} */ function Baz() {}",
-            "",
-            "/**",
-            " * @param {!Bar|!Baz} x",
-            " * @return {string} ",
-            " */",
-            "var f = function(x) { return x.p; };")
-        .addDiagnostic(
-            lines(
-                "inconsistent return type", //
-                "found   : number",
-                "required: string"))
-        .run();
-  }
-
-  @Test
-  public void testInvalidAssignToPropertyTypeOfUnionType_withMatchingTemplates_doesntWarn() {
-    // We don't warn for this assignment because we treat the type of `x.p` as inferred...
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function Foo() {};",
-            "/** @type {T} */",
-            "Foo.prototype.p;",
-            "/** @interface @template U */ function Bar() {};",
-            "/** @type {U} */",
-            "Bar.prototype.p;",
-            "",
-            "/**",
-            " * @param {!Foo<number>|!Bar<number>} x",
-            " */",
-            "var f = function(x) { x.p = 'not a number'; };")
-        .run();
-  }
-
-  // TODO(user): We should flag these as invalid. This will probably happen
-  // when we make sure the interface is never referenced outside of its
-  // definition. We might want more specific and helpful error messages.
-  @Test
-  @Ignore
-  public void testWarningOnInterfacePrototype() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype = function() { };")
-        .addDiagnostic("e of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.f = function() { return 1;};")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.f = function() { return 1;};")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface3() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {}; u.T.x")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testBadPropertyOnInterface4() {
-    newTest()
-        .addSource("/** @interface */ function T() {}; T.x;")
-        .addDiagnostic("cannot reference an interface outside of its definition")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface1() {
-    // For interfaces we must allow function definitions that don't have a
-    // return statement, even though they declare a returned type.
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype.f = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @return {number} */ u.T.prototype.f = function() { };")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.prototype.f = function() { };")
-        .run();
-  }
-
-  @Test
-  public void testAnnotatedPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            CLOSURE_DEFS
-                + "/** @interface */ function T() {};\n"
-                + "/** @return {number} */ T.prototype.f = goog.abstractMethod;")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we have to warn about
-  // missing annotations.
-  @Test
-  @Ignore
-  public void testWarnUnannotatedPropertyOnInterface1() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {}; u.T.prototype.x;")
-        .addDiagnostic("interface property x is not annotated")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testWarnUnannotatedPropertyOnInterface2() {
-    newTest()
-        .addSource("/** @interface */ function T() {}; T.prototype.x;")
-        .addDiagnostic("interface property x is not annotated")
-        .run();
-  }
-
-  @Test
-  public void testWarnUnannotatedPropertyOnInterface5() {
-    newTest()
-        .addSource("/** @interface */ u.T = function() {};\n" + "u.T.prototype.x = function() {};")
-        .run();
-  }
-
-  @Test
-  public void testWarnUnannotatedPropertyOnInterface6() {
-    newTest()
-        .addSource("/** @interface */ function T() {};\n" + "T.prototype.x = function() {};")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we have to warn about
-  // the invalid type of the interface member.
-  @Test
-  @Ignore
-  public void testWarnDataPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n" + "/** @type {number} */u.T.prototype.x;")
-        .addDiagnostic("interface members can only be plain functions")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface1() {
-    newTest()
-        .addSource("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() {}\n"
-                + "/** @override */\n"
-                + "C.prototype.x = 'foo';")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() {}\n"
-                + "/** @override */\n"
-                + "C.prototype.x = 'foo';")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testDataPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x;\n"
-                + "/** @constructor \n"
-                + " *  @implements {T} \n"
-                + " */\n"
-                + "function C() { /** @type {string} */ \n this.x = 'foo'; }\n")
-        .addDiagnostic(
-            "mismatch of the x property on type C and the type of the property it "
-                + "overrides from interface T\n"
-                + "original: number\n"
-                + "override: string")
-        .run();
-  }
-
-  @Test
-  public void testWarnDataPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @type {number} */u.T.prototype.x = 1;")
-        .addDiagnostic(
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod")
-        .run();
-  }
-
-  @Test
-  public void testWarnDataPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;")
-        .addDiagnostic(
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod")
-        .run();
-  }
-
-  // TODO(user): If we want to support this syntax we should warn about the
-  // mismatching types in the two tests below.
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface1() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "/** @param {String} foo */function(foo) {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @return {number} */T.prototype.x =\n"
-                + "/** @return {string} */function() {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  // TODO(user): We should warn about this (bar is missing an annotation). We
-  // probably don't want to warn about all missing parameter annotations, but
-  // we should be as strict as possible regarding interfaces.
-  @Test
-  @Ignore
-  public void testErrorMismatchingPropertyOnInterface3() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "function(foo, bar) {};")
-        .addDiagnostic("found   : \n" + "required: ")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface4() {
-    newTest()
-        .addSource(
-            "/** @interface */ u.T = function() {};\n"
-                + "/** @param {Number} foo */u.T.prototype.x =\n"
-                + "function() {};")
-        .addDiagnostic("parameter foo does not appear in u.T.prototype.x's parameter list")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface5() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n"
-                + "/** @type {number} */T.prototype.x = function() { };")
-        .addDiagnostic(
-            "assignment to property x of T.prototype\n"
-                + "found   : function(): undefined\n"
-                + "required: number")
-        .run();
-  }
-
-  @Test
-  public void testErrorMismatchingPropertyOnInterface6() {
-    testClosureTypesMultipleWarnings(
-        "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1",
-        ImmutableList.of(
-            "assignment to property x of T.prototype\n"
-                + "found   : number\n"
-                + "required: function(this:T): number",
-            "interface members can only be empty property declarations, "
-                + "empty functions, or goog.abstractMethod"));
-  }
-
-  @Test
-  public void testInterfaceNonEmptyFunction() {
-    newTest()
-        .addSource(
-            "/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }")
-        .addDiagnostic("interface member functions must have an empty body")
-        .run();
-  }
-
-  @Test
-  public void testDoubleNestedInterface() {
-    newTest()
-        .addSource(
-            "/** @interface */ var I1 = function() {};\n"
-                + "/** @interface */ I1.I2 = function() {};\n"
-                + "/** @interface */ I1.I2.I3 = function() {};\n")
-        .run();
-  }
-
-  @Test
-  public void testStaticDataPropertyOnNestedInterface() {
-    newTest()
-        .addSource(
-            "/** @interface */ var I1 = function() {};\n"
-                + "/** @interface */ I1.I2 = function() {};\n"
-                + "/** @type {number} */ I1.I2.x = 1;\n")
-        .run();
-  }
-
-  @Test
-  public void testInterfaceInstantiation() {
-    newTest()
-        .addSource("/** @interface */var f = function(){}; new f")
-        .addDiagnostic("cannot instantiate non-constructor")
-        .run();
-  }
-
-  @Test
-  public void testPrototypeLoop() {
-    disableStrictMissingPropertyChecks();
-
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @constructor \n * @extends {T} */var T = function() {};"
-            + "alert((new T).foo);",
-        ImmutableList.of(
-            "Cycle detected in inheritance chain of type T",
-            "Could not resolve type in @extends tag of T"));
-  }
-
-  @Test
-  public void testImplementsLoop() {
-    testClosureTypesMultipleWarnings(
-        lines(
-            "/** @constructor \n * @implements {T} */var T = function() {};",
-            suppressMissingPropertyFor("T", "foo"),
-            "alert((new T).foo);"),
-        ImmutableList.of("Cycle detected in inheritance chain of type T"));
-  }
-
-  @Test
-  public void testImplementsExtendsLoop() {
-    disableStrictMissingPropertyChecks();
-
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @constructor \n * @implements {F} */var G = function() {};"
-            + "/** @constructor \n * @extends {G} */var F = function() {};"
-            + "alert((new F).foo);",
-        ImmutableList.of("Cycle detected in inheritance chain of type F"));
-  }
-
-  // TODO(johnlenz): This test causes an infinite loop,
-  @Test
-  @Ignore
-  public void testInterfaceExtendsLoop() {
-    testClosureTypesMultipleWarnings(
-        lines(
-            "/** @interface \n * @extends {F} */var G = function() {};",
-            "/** @interface \n * @extends {G} */var F = function() {};",
-            "/** @constructor \n * @implements {F} */var H = function() {};",
-            suppressMissingPropertyFor("H", "foo"),
-            "alert((new H).foo);"),
-        ImmutableList.of(
-            "extends loop involving F, " + "loop: F -> G -> F",
-            "extends loop involving G, " + "loop: G -> F -> G"));
-  }
-
-  @Test
-  public void testInterfaceExtendsLoop2() {
-    testClosureTypes(
-        lines(
-            "/** @record \n * @extends {F} */var G = function() {};",
-            "/** @record \n * @extends {G} */var F = function() {};",
-            "/** @constructor \n * @implements {F} */var H = function() {};",
-            suppressMissingPropertyFor("H", "foo"),
-            "alert((new H).foo);"),
-        "Cycle detected in inheritance chain of type F");
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces1() {
-    // Low#prop gets the type of whichever property is declared last,
-    // even if that type is not the most specific.
-    newTest()
-        .addSource(
-            "/** @interface */",
-            "function High1() {}",
-            "/** @type {number|string} */",
-            "High1.prototype.prop;",
-            "/** @interface */",
-            "function High2() {}",
-            "/** @type {number} */",
-            "High2.prototype.prop;",
-            "/**",
-            " * @interface",
-            " * @extends {High1}",
-            " * @extends {High2}",
-            " */",
-            "function Low() {}",
-            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : (number|string)",
-                "required: null"))
-        .run();
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces2() {
-    // Low#prop gets the type of whichever property is declared last,
-    // even if that type is not the most specific.
-    newTest()
-        .addSource(
-            "/** @interface */",
-            "function High1() {}",
-            "/** @type {number} */",
-            "High1.prototype.prop;",
-            "/** @interface */",
-            "function High2() {}",
-            "/** @type {number|string} */",
-            "High2.prototype.prop;",
-            "/**",
-            " * @interface",
-            " * @extends {High1}",
-            " * @extends {High2}",
-            " */",
-            "function Low() {}",
-            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
-        .run();
-  }
-
-  @Test
-  public void testInheritPropFromMultipleInterfaces3() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @interface",
-            " * @template T1",
-            " */",
-            "function MyCollection() {}",
-            "/**",
-            " * @interface",
-            " * @template T2",
-            " * @extends {MyCollection<T2>}",
-            " */",
-            "function MySet() {}",
-            "/**",
-            " * @interface",
-            " * @template T3,T4",
-            " */",
-            "function MyMapEntry() {}",
-            "/**",
-            " * @interface",
-            " * @template T5,T6",
-            " */",
-            "function MyMultimap() {}",
-            "/** @return {MyCollection<MyMapEntry<T5, T6>>} */",
-            "MyMultimap.prototype.entries = function() {};",
             "/**",
-            " * @interface",
-            " * @template T7,T8",
-            " * @extends {MyMultimap<T7, T8>}",
-            " */",
-            "function MySetMultimap() {}",
-            "/** @return {MySet<MyMapEntry<T7, T8>>} */",
-            "MySetMultimap.prototype.entries = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T9,T10",
-            " * @extends {MyMultimap<T9, T10>}",
-            " */",
-            "function MyFilteredMultimap() {}",
-            "/**",
-            " * @interface",
-            " * @template T11,T12",
-            " * @extends {MyFilteredMultimap<T11, T12>}",
-            " * @extends {MySetMultimap<T11, T12>}",
+            "* @param {Object} co",
+            " * @return {Object}",
             " */",
-            "function MyFilteredSetMultimap() {}")
+            "function inst(co) {",
+            " /** @constructor */",
+            " var c = function() {};",
+            " c.prototype = co.prototype;",
+            " return new c;",
+            "}")
+        .addDiagnostic("Property prototype never defined on Object")
         .run();
   }
 
   @Test
-  public void testInheritSameGenericInterfaceFromDifferentPaths() {
+  public void testUnknownPrototypeChain2() {
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/**",
-            " * @constructor",
-            " * @template T1",
-            " */",
-            "ns.Foo = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T2",
-            " */",
-            "ns.High = function() {};",
-            "/** @type {!ns.Foo<T2>} */",
-            "ns.High.prototype.myprop;",
-            "/**",
-            " * @interface",
-            " * @template T3",
-            " * @extends {ns.High<T3>}",
-            " */",
-            "ns.Med1 = function() {};",
-            "/**",
-            " * @interface",
-            " * @template T4",
-            " * @extends {ns.High<T4>}",
-            " */",
-            "ns.Med2 = function() {};",
             "/**",
-            " * @interface",
-            " * @template T5",
-            " * @extends {ns.Med1<T5>}",
-            " * @extends {ns.Med2<T5>}",
+            " * @param {Function} co",
+            " * @return {Object}",
             " */",
-            "ns.Low = function() {};")
+            "function inst(co) {",
+            " /** @constructor */",
+            " var c = function() {};",
+            " c.prototype = co.prototype;",
+            " return new c;",
+            "}")
         .run();
   }
 
   @Test
-  public void testConversionFromInterfaceToRecursiveConstructor() {
-    testClosureTypesMultipleWarnings(
-        suppressMissingProperty("foo")
-            + "/** @interface */ var OtherType = function() {}\n"
-            + "/** @implements {MyType} \n * @constructor */\n"
-            + "var MyType = function() {}\n"
-            + "/** @type {MyType} */\n"
-            + "var x = /** @type {!OtherType} */ (new Object());",
-        ImmutableList.of(
-            "Cycle detected in inheritance chain of type MyType",
-            "initializing variable\n" + "found   : OtherType\n" + "required: (MyType|null)"));
+  public void testNamespacedConstructor() {
+    Node root =
+        parseAndTypeCheck(
+            "var goog = {};"
+                + "/** @constructor */ goog.MyClass = function() {};"
+                + "/** @return {!goog.MyClass} */ "
+                + "function foo() { return new goog.MyClass(); }");
+
+    JSType typeOfFoo = root.getLastChild().getJSType();
+    assertType(typeOfFoo).isInstanceOf(FunctionType.class);
+
+    JSType retType = ((FunctionType) typeOfFoo).getReturnType();
+    assertType(retType).isInstanceOf(ObjectType.class);
+    assertThat(((ObjectType) retType).getReferenceName()).isEqualTo("goog.MyClass");
   }
 
   @Test
-  public void testDirectPrototypeAssign() {
-    // For now, we just ignore @type annotations on the prototype.
-    newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @type {Array} */ Bar.prototype = new Foo()")
-        .run();
-  }
+  public void testComplexNamespace() {
+    String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;";
 
-  // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
-  // be resolved via the registry and not via properties.
+    TypeCheckResult p = parseAndTypeCheckWithScope(js);
 
-  @Test
-  public void testResolutionViaRegistry1() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {};\n"
-                + "/** @type {(number|string)} */ u.T.prototype.a;\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
+    // goog type in the scope
+    JSType googScopeType = p.scope.getVar("goog").getType();
+    assertThat(googScopeType).isInstanceOf(ObjectType.class);
+    assertWithMessage("foo property not present on goog type")
+        .that(googScopeType.hasProperty("foo"))
+        .isTrue();
+    assertWithMessage("bar property present on goog type")
+        .that(googScopeType.hasProperty("bar"))
+        .isFalse();
 
-  @Test
-  public void testResolutionViaRegistry2() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {"
-                + "  this.a = 0; };\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
+    // goog type on the VAR node
+    Node varNode = p.root.getFirstChild();
+    assertNode(varNode).hasToken(Token.VAR);
+    JSType googNodeType = varNode.getFirstChild().getJSType();
+    assertThat(googNodeType).isInstanceOf(ObjectType.class);
 
-  @Test
-  public void testResolutionViaRegistry3() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.T = function() {};\n"
-                + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n"
-                + "/**\n"
-                + "* @param {u.T} t\n"
-                + "* @return {string}\n"
-                + "*/\n"
-                + "var f = function(t) { return t.a; };")
-        .addDiagnostic(
-            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
-        .run();
-  }
+    // goog scope type and goog type on VAR node must be the same
+    assertThat(googScopeType).isSameInstanceAs(googNodeType);
 
-  @Test
-  public void testResolutionViaRegistry4() {
-    newTest()
-        .addSource(
-            "/** @constructor */ u.A = function() {};\n"
-                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;"
-                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n"
-                + "var ab = new u.A.B();\n"
-                + "/** @type {!u.A} */ var a = ab;\n"
-                + "/** @type {!u.A.A} */ var aa = ab;\n")
-        .addDiagnostic("initializing variable\n" + "found   : u.A.B\n" + "required: u.A.A")
-        .run();
-  }
+    // goog type on the left of the GETPROP node (under fist ASSIGN)
+    Node getpropFoo1 = varNode.getNext().getFirstFirstChild();
+    assertNode(getpropFoo1).hasToken(Token.GETPROP);
+    assertThat(getpropFoo1.getFirstChild().getString()).isEqualTo("goog");
+    JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType();
+    assertThat(googGetpropFoo1Type).isInstanceOf(ObjectType.class);
 
-  @Test
-  public void testResolutionViaRegistry5() {
-    Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertThat(type).isInstanceOf(FunctionType.class);
-    assertThat(((FunctionType) type).getInstanceType().getReferenceName()).isEqualTo("u.T");
-  }
+    // still the same type as the one on the variable
+    assertThat(googGetpropFoo1Type).isSameInstanceAs(googScopeType);
 
-  @Test
-  public void testGatherProperyWithoutAnnotation1() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;");
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertThat(type).isInstanceOf(ObjectType.class);
-    ObjectType objectType = (ObjectType) type;
-    assertThat(objectType.hasProperty("x")).isFalse();
-  }
+    // the foo property should be defined on goog
+    JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo");
+    assertThat(googFooType).isInstanceOf(ObjectType.class);
 
-  @Test
-  public void testGatherProperyWithoutAnnotation2() {
-    TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;");
-    Node n = ns.root;
-    JSType type = n.getLastChild().getLastChild().getJSType();
-    assertThat(type.isUnknownType()).isFalse();
-    assertTypeEquals(type, getNativeObjectType());
-    assertThat(type).isInstanceOf(ObjectType.class);
-    ObjectType objectType = (ObjectType) type;
-    assertThat(objectType.hasProperty("x")).isFalse();
+    // goog type on the left of the GETPROP lower level node
+    // (under second ASSIGN)
+    Node getpropFoo2 = varNode.getNext().getNext().getFirstFirstChild().getFirstChild();
+    assertNode(getpropFoo2).hasToken(Token.GETPROP);
+    assertThat(getpropFoo2.getFirstChild().getString()).isEqualTo("goog");
+    JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType();
+    assertThat(googGetpropFoo2Type).isInstanceOf(ObjectType.class);
+
+    // still the same type as the one on the variable
+    assertThat(googGetpropFoo2Type).isSameInstanceAs(googScopeType);
+
+    // goog.foo type on the left of the top-level GETPROP node
+    // (under second ASSIGN)
+    JSType googFooGetprop2Type = getpropFoo2.getJSType();
+    assertWithMessage("goog.foo incorrectly annotated in goog.foo.bar selection")
+        .that(googFooGetprop2Type)
+        .isInstanceOf(ObjectType.class);
+    ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type;
+    assertWithMessage("foo property present on goog.foo type")
+        .that(googFooGetprop2ObjectType.hasProperty("foo"))
+        .isFalse();
+    assertWithMessage("bar property not present on goog.foo type")
+        .that(googFooGetprop2ObjectType.hasProperty("bar"))
+        .isTrue();
+    assertTypeEquals(
+        "bar property on goog.foo type incorrectly inferred",
+        getNativeNumberType(),
+        googFooGetprop2ObjectType.getPropertyType("bar"));
   }
 
   @Test
-  public void testFunctionMasksVariableBug() {
-    newTest()
-        .addSource("var x = 4; var f = function x(b) { return b ? 1 : x(true); };")
-        .addDiagnostic("function x masks variable (IE bug)")
-        .run();
-  }
+  public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() {
+    disableStrictMissingPropertyChecks();
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS, "/** @constructor */function A() {}" + "A.prototype.m1 = 5");
 
-  @Test
-  public void testDfa1() {
-    newTest().addSource("var x = null;\n x = 1;\n /** @type {number} */ var y = x;").run();
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 1);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
   }
 
   @Test
-  public void testDfa2() {
-    newTest()
-        .addSource(
-            "function u() {}\n"
-                + "/** @return {number} */ function f() {\nvar x = 'todo';\n"
-                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
-        .run();
+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            "var goog = {};"
+                + "goog.A = /** @constructor */function() {};"
+                + "/** @type {number} */goog.A.prototype.m1 = 5");
+
+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
   }
 
   @Test
-  public void testDfa3() {
-    newTest()
-        .addSource(
-            "function u() {}\n"
-                + "/** @return {number} */ function f() {\n"
-                + "/** @type {number|string} */ var x = 'todo';\n"
-                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
-        .run();
+  public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            "var goog = {};"
+                + "/** @constructor */goog.A = function() {};"
+                + "/** @type {number} */goog.A.prototype.m1 = 5");
+
+    testAddingMethodsUsingPrototypeIdiomComplexNamespace(p);
   }
 
-  @Test
-  public void testDfa4() {
-    newTest()
-        .addSource(
-            "/** @param {Date?} d */ function f(d) {\n"
-                + "if (!d) { return; }\n"
-                + "/** @type {!Date} */ var e = d;\n}")
-        .run();
+  private void testAddingMethodsUsingPrototypeIdiomComplexNamespace(TypeCheckResult p) {
+    ObjectType goog = (ObjectType) p.scope.getVar("goog").getType();
+    assertHasXMorePropertiesThanNativeObject(goog, 1);
+    JSType googA = goog.getPropertyType("A");
+    assertThat(googA).isNotNull();
+    assertThat(googA).isInstanceOf(FunctionType.class);
+    FunctionType googAFunction = (FunctionType) googA;
+    ObjectType classA = googAFunction.getInstanceType();
+    assertHasXMorePropertiesThanNativeObject(classA, 1);
+    checkObjectType(classA, "m1", getNativeNumberType());
   }
 
   @Test
-  public void testDfa5() {
-    newTest()
-        .addSource(
-            "/** @return {string?} */ function u() {return 'a';}\n"
-                + "/** @param {string?} x\n@return {string} */ function f(x) {\n"
-                + "while (!x) { x = u(); }\nreturn x;\n}")
-        .run();
+  public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() {
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 2);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
+    checkObjectType(instanceType, "m2", getNativeBooleanType());
   }
 
   @Test
-  public void testDfa6() {
-    newTest()
-        .addSource(
-            "/** @return {Object?} */ function u() {return {};}\n"
-                + "/** @param {Object?} x */ function f(x) {\n"
-                + "while (x) { x = u(); if (!x) { x = u(); } }\n}")
-        .run();
+  public void testDontAddMethodsIfNoConstructor() {
+    Node js1Node = parseAndTypeCheck("function A() {}" + "A.prototype = {m1: 5, m2: true}");
+
+    JSType functionAType = js1Node.getFirstChild().getJSType();
+    assertThat(functionAType.toString()).isEqualTo("function(): undefined");
+    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m1"));
+    assertTypeEquals(getNativeUnknownType(), getNativeFunctionType().getPropertyType("m2"));
   }
 
   @Test
-  public void testDfa7() {
+  public void testFunctionAssignement() {
     newTest()
         .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @type {Date?} */ T.prototype.x = null;\n"
-                + "/** @param {!T} t */ function f(t) {\n"
-                + "if (!t.x) { return; }\n"
-                + "/** @type {!Date} */ var e = t.x;\n}")
+            "/**"
+                + "* @param {string} ph0"
+                + "* @param {string} ph1"
+                + "* @return {string}"
+                + "*/"
+                + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}"
+                + "/** @type {Function} */"
+                + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;")
         .run();
   }
 
   @Test
-  public void testDfa8() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var T = function() {};\n"
-                + "/** @type {number|string} */ T.prototype.x = '';\n"
-                + "function u() {}\n"
-                + "/** @param {!T} t\n@return {number} */ function f(t) {\n"
-                + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}")
-        .run();
+  public void testAddMethodsPrototypeTwoWays() {
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {}"
+                + "A.prototype = {m1: 5, m2: true};"
+                + "A.prototype.m3 = 'third property!';");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertThat(instanceType.toString()).isEqualTo("A");
+    assertHasXMorePropertiesThanNativeObject(instanceType, 3);
+    checkObjectType(instanceType, "m1", getNativeNumberType());
+    checkObjectType(instanceType, "m2", getNativeBooleanType());
+    checkObjectType(instanceType, "m3", getNativeStringType());
   }
 
   @Test
-  public void testDfa9() {
-    newTest()
-        .addSource(
-            "function f() {\n/** @type {string?} */var x;\nx = null;\n"
-                + "if (x == null) { return 0; } else { return 1; } }")
-        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
-        .run();
+  public void testPrototypePropertyTypes() {
+    Node js1Node =
+        parseAndTypeCheck(
+            DEFAULT_EXTERNS,
+            "/** @constructor */function A() {\n"
+                + "  /** @type {string} */ this.m1;\n"
+                + "  /** @type {Object?} */ this.m2 = {};\n"
+                + "  /** @type {boolean} */ this.m3;\n"
+                + "}\n"
+                + "/** @type {string} */ A.prototype.m4;\n"
+                + "/** @type {number} */ A.prototype.m5 = 0;\n"
+                + "/** @type {boolean} */ A.prototype.m6;\n");
+
+    ObjectType instanceType = getInstanceType(js1Node);
+    assertHasXMorePropertiesThanNativeObject(instanceType, 6);
+    checkObjectType(instanceType, "m1", getNativeStringType());
+    checkObjectType(
+        instanceType, "m2", createUnionType(getNativeObjectType(), getNativeNullType()));
+    checkObjectType(instanceType, "m3", getNativeBooleanType());
+    checkObjectType(instanceType, "m4", getNativeStringType());
+    checkObjectType(instanceType, "m5", getNativeNumberType());
+    checkObjectType(instanceType, "m6", getNativeBooleanType());
   }
 
   @Test
-  public void testDfa10() {
-    newTest()
-        .addSource(
-            "/** @param {null} x */ function g(x) {}"
-                + "/** @param {string?} x */function f(x) {\n"
-                + "if (!x) { x = ''; }\n"
-                + "if (g(x)) { return 0; } else { return 1; } }")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: null")
-        .run();
+  public void testValueTypeBuiltInPrototypePropertyType() {
+    Node node = parseAndTypeCheck(new TestExternsBuilder().addString().build(), "\"x\".charAt(0)");
+    assertTypeEquals(getNativeStringType(), node.getFirstFirstChild().getJSType());
   }
 
   @Test
-  public void testDfa11() {
-    newTest()
-        .addSource(
-            "/** @param {string} opt_x\n@return {string} */\n"
-                + "function f(opt_x) { if (!opt_x) { "
-                + "throw new Error('x cannot be empty'); } return opt_x; }")
-        .run();
+  public void testDeclareBuiltInConstructor() {
+    // Built-in prototype properties should be accessible
+    // even if the built-in constructor is declared.
+    Node node =
+        parseAndTypeCheck(
+            new TestExternsBuilder().addString().build(),
+            lines(
+                "/** @constructor */ var String = function(opt_str) {};",
+                "(new String(\"x\")).charAt(0)"));
+    assertTypeEquals(getNativeStringType(), node.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testDfa12() {
-    newTest()
-        .addSource(
-            "/** @param {string} x \n * @constructor \n */"
-                + "var Bar = function(x) {};"
-                + "/** @param {string} x */ function g(x) { return true; }"
-                + "/** @param {string|number} opt_x */ "
-                + "function f(opt_x) { "
-                + "  if (opt_x) { new Bar(g(opt_x) && 'x'); }"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : (number|string)\n"
-                + "required: string")
-        .run();
+  public void testExtendBuiltInType1() {
+    String externs =
+        "/** @constructor */ var String = function(opt_str) {};\n"
+            + "/**\n"
+            + "* @param {number} start\n"
+            + "* @param {number} opt_length\n"
+            + "* @return {string}\n"
+            + "*/\n"
+            + "String.prototype.substr = function(start, opt_length) {};\n";
+    Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);");
+    assertTypeEquals(getNativeStringType(), n1.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testDfa13() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {string} x \n"
-                + " * @param {number} y \n"
-                + " * @param {number} z \n"
-                + " */"
-                + "function g(x, y, z) {}"
-                + "function f() { "
-                + "  var x = 'a'; g(x, x = 3, x);"
-                + "}")
-        .run();
+  public void testExtendBuiltInType2() {
+    String externs =
+        "/** @constructor */ var String = function(opt_str) {};\n"
+            + "/**\n"
+            + "* @param {number} start\n"
+            + "* @param {number} opt_length\n"
+            + "* @return {string}\n"
+            + "*/\n"
+            + "String.prototype.substr = function(start, opt_length) {};\n";
+    Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);");
+    assertTypeEquals(getNativeStringType(), n2.getLastChild().getFirstChild().getJSType());
   }
 
   @Test
-  public void testTypeInferenceWithCast1() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
-                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
-                + "/**@return {number?}*/function g(x) {"
-                + "var y = /**@type {number?}*/(u(x)); return f(y);}")
-        .run();
+  public void testExtendFunction1() {
+    Node n =
+        parseAndTypeCheck(
+            "/**@return {number}*/Function.prototype.f = "
+                + "function() { return 1; };\n"
+                + "(new Function()).f();");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertTypeEquals(getNativeNumberType(), type);
   }
 
   @Test
-  public void testTypeInferenceWithCast2() {
-    newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
-                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
-                + "/**@return {number?}*/function g(x) {"
-                + "var y; y = /**@type {number?}*/(u(x)); return f(y);}")
-        .run();
+  public void testExtendFunction2() {
+    Node n =
+        parseAndTypeCheck(
+            "/**@return {number}*/Function.prototype.f = "
+                + "function() { return 1; };\n"
+                + "(function() {}).f();");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertTypeEquals(getNativeNumberType(), type);
   }
 
   @Test
-  public void testTypeInferenceWithCast3() {
+  public void testClassExtendPrimitive() {
     newTest()
-        .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
-                + "/**@return {number}*/function g(x) {"
-                + "return /**@type {number}*/(u(x));}")
+        .addSource("/** @extends {number} */ class C extends number {}")
+        .addDiagnostic("C @extends non-object type number")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithCast4() {
+  public void testInheritanceCheck1() {
     newTest()
         .addSource(
-            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
-                + "/**@return {number}*/function g(x) {"
-                + "return /**@type {number}*/(u(x)) && 1;}")
+            "/** @constructor */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithCast5() {
+  public void testInheritanceCheck2() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function foo(x) {}"
-                + "/** @param {{length:*}} y */ function bar(y) {"
-                + "  /** @type {string} */ y.length;"
-                + "  foo(y.length);"
-                + "}")
-        .addDiagnostic(
-            "actual parameter 1 of foo does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            "/** @constructor */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("property foo not defined on any superclass of Sub")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithClosure1() {
+  public void testInheritanceCheck3() {
     newTest()
         .addSource(
-            "/** @return {boolean} */"
-                + "function f() {"
-                + "  /** @type {?string} */ var x = null;"
-                + "  function g() { x = 'y'; } g(); "
-                + "  return x == null;"
-                + "}")
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .addDiagnostic(
+            "property foo already defined on superclass Super; " + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithClosure2() {
+  public void testInheritanceCheck4() {
     newTest()
         .addSource(
-            "/** @return {boolean} */"
-                + "function f() {"
-                + "  /** @type {?string} */ var x = null;"
-                + "  function g() { x = 'y'; } g(); "
-                + "  return x === 3;"
-                + "}")
-        .addDiagnostic(
-            "condition always evaluates to false\n" + "left : (null|string)\n" + "right: number")
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithNoEntry1() {
+  public void testInheritanceCheck5() {
     newTest()
         .addSource(
-            "/** @param {number} x */ function f(x) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.init = function() {"
-                + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
-                + "};"
-                + "/**\n"
-                + " * @extends {Foo}\n"
-                + " * @constructor\n"
-                + " */"
-                + "function SubFoo() {}"
-                + "/** Method */"
-                + "SubFoo.prototype.method = function() {"
-                + "  for (var i = 0; i < 10; i++) {"
-                + "    f(this.bar);"
-                + "    f(this.bar.baz);"
-                + "  }"
-                + "};")
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : (null|{baz: number})\n"
-                + "required: number")
+            "property foo already defined on superclass Root; " + "use @override to override it")
         .run();
   }
 
   @Test
-  public void testTypeInferenceWithNoEntry2() {
-    testClosureTypes(
-        "/** @param {number} x */ function f(x) {}"
-            + "/** @param {!Object} x */ function g(x) {}"
-            + "/** @constructor */ function Foo() {}"
-            + "Foo.prototype.init = function() {"
-            + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
-            + "};"
-            + "/**\n"
-            + " * @extends {Foo}\n"
-            + " * @constructor\n"
-            + " */"
-            + "function SubFoo() {}"
-            + "/** Method */"
-            + "SubFoo.prototype.method = function() {"
-            + "  for (var i = 0; i < 10; i++) {"
-            + "    f(this.bar);"
-            + "    goog.asserts.assert(this.bar);"
-            + "    g(this.bar);"
-            + "  }"
-            + "};",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : (null|{baz: number})\n"
-            + "required: number");
-  }
-
-  @Test
-  public void testForwardPropertyReference() {
+  public void testInheritanceCheck6() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() { this.init(); };"
-                + "/** @return {string} */"
-                + "Foo.prototype.getString = function() {"
-                + "  return this.number_;"
-                + "};"
-                + "Foo.prototype.init = function() {"
-                + "  /** @type {number} */"
-                + "  this.number_ = 3;"
-                + "};")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
-        .run();
-  }
-
-  @Test
-  public void testNoForwardTypeDeclaration() {
-    newTest()
-        .addSource("/** @param {MyType} x */ function f(x) {}")
-        .addDiagnostic("Bad type annotation. Unknown type MyType")
-        .run();
-  }
-
-  @Test
-  public void testNoForwardTypeDeclarationAndNoBraces() {
-    newTest()
-        .addSource("/** @return The result. */ function f() {}")
-        .addDiagnostic(RhinoErrorReporter.JSDOC_MISSING_TYPE_WARNING)
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
         .run();
   }
 
   @Test
-  public void testForwardTypeDeclaration2() {
-    String f = "goog.forwardDeclare('MyType');" + "/** @param {MyType} x */ function f(x) { }";
-    testClosureTypes(f, null);
-    testClosureTypes(
-        f + "f(3);",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: (MyType|null)");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration3() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */ function f(x) { return x; }"
-            + "/** @constructor */ var MyType = function() {};"
-            + "f(3);",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: (MyType|null)");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration4() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */ function f(x) { return x; }"
-            + "/** @constructor */ var MyType = function() {};"
-            + "f(new MyType());",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration5() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @constructor\n"
-            + " * @extends {MyType}\n"
-            + " */ var YourType = function() {};"
-            + "/** @override */ YourType.prototype.method = function() {};",
-        "Could not resolve type in @extends tag of YourType");
-  }
-
-  @Test
-  public void testForwardTypeDeclaration6() {
-    testClosureTypesMultipleWarnings(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @constructor\n"
-            + " * @implements {MyType}\n"
-            + " */ var YourType = function() {};"
-            + "/** @override */ YourType.prototype.method = function() {};",
-        ImmutableList.of(
-            "Could not resolve type in @implements tag of YourType",
-            "property method not defined on any superclass of YourType"));
-  }
-
-  @Test
-  public void testForwardTypeDeclaration7() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType=} x */"
-            + "function f(x) { return x == undefined; }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration8() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */"
-            + "function f(x) { return x.name == undefined; }",
-        null);
-  }
-
-  @Test
-  public void testForwardTypeDeclaration9() {
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/** @param {MyType} x */"
-            + "function f(x) { x.name = 'Bob'; }",
-        null);
+  public void testInheritanceCheck7() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "goog.Sub.prototype.foo = 5;")
+        .run();
   }
 
   @Test
-  public void testForwardTypeDeclaration10() {
-    String f =
-        "goog.forwardDeclare('MyType');" + "/** @param {MyType|number} x */ function f(x) { }";
-    testClosureTypes(f, null);
-    testClosureTypes(f + "f(3);", null);
-    testClosureTypes(
-        f + "f('3');",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : string\n"
-            + "required: (MyType|null|number)");
+  public void testInheritanceCheck8() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override */goog.Sub.prototype.foo = 5;")
+        .run();
   }
 
   @Test
-  public void testForwardTypeDeclaration12() {
-    // We assume that {Function} types can produce anything, and don't
-    // want to type-check them.
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @param {!Function} ctor\n"
-            + " * @return {MyType}\n"
-            + " */\n"
-            + "function f(ctor) { return new ctor(); }",
-        null);
+  public void testInheritanceCheck9_1() {
+    newTest()
+        .addSource(
+            "/** @constructor */function Super() {};"
+                + "Super.prototype.foo = function() { return 3; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1; };")
+        .run();
   }
 
   @Test
-  public void testForwardTypeDeclaration13() {
-    // Some projects use {Function} registries to register constructors
-    // that aren't in their binaries. We want to make sure we can pass these
-    // around, but still do other checks on them.
-    testClosureTypes(
-        "goog.forwardDeclare('MyType');"
-            + "/**\n"
-            + " * @param {!Function} ctor\n"
-            + " * @return {MyType}\n"
-            + " */\n"
-            + "function f(ctor) { return (new ctor()).impossibleProp; }",
-        "Property impossibleProp never defined on ?" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION);
+  public void testInheritanceCheck9_2() {
+    newTest()
+        .addSource(
+            "/** @constructor */function Super() {};"
+                + "/** @return {number} */"
+                + "Super.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo =\n"
+                + "function() {};")
+        .run();
   }
 
   @Test
-  public void testDuplicateTypeDef() {
+  public void testInheritanceCheck9_3() {
     newTest()
         .addSource(
-            "var goog = {};",
-            "/** @constructor */ goog.Bar = function() {};",
-            "/** @typedef {number} */ goog.Bar;")
+            "/** @constructor */function Super() {};"
+                + "/** @return {number} */"
+                + "Super.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
+                + "function() { return \"some string\" };")
         .addDiagnostic(
-            "variable goog.Bar redefined with type None, "
-                + "original definition at [testcode]:2 "
-                + "with type (typeof goog.Bar)")
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Super\n"
+                + "original: function(this:Super): number\n"
+                + "override: function(this:Sub): string")
         .run();
   }
 
   @Test
-  public void testTypeDef1() {
+  public void testInheritanceCheck10_1() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f(3);")
+            "/** @constructor */function Root() {};"
+                + "Root.prototype.foo = function() { return 3; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1; };")
         .run();
   }
 
   @Test
-  public void testTypeDef2() {
+  public void testInheritanceCheck10_2() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f('3');")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            "/** @constructor */function Root() {};"
+                + "/** @return {number} */"
+                + "Root.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo =\n"
+                + "function() {};")
         .run();
   }
 
   @Test
-  public void testTypeDef3() {
+  public void testInheritanceCheck10_3() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @typedef {number} */ var Bar;"
-                + "/** @param {Bar} x */ function f(x) {}"
-                + "f('3');")
+            "/** @constructor */function Root() {};"
+                + "/** @return {number} */"
+                + "Root.prototype.foo = function() { return 1; };"
+                + "/** @constructor\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n @return {string} */Sub.prototype.foo =\n"
+                + "function() { return \"some string\" };")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : string\n"
-                + "required: number")
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Root\n"
+                + "original: function(this:Root): number\n"
+                + "override: function(this:Sub): string")
         .run();
   }
 
   @Test
-  public void testTypeDef4() {
+  public void testInterfaceInheritanceCheck11() {
     newTest()
         .addSource(
-            "/** @constructor */ function A() {}"
-                + "/** @constructor */ function B() {}"
-                + "/** @typedef {(A|B)} */ var AB;"
-                + "/** @param {AB} x */ function f(x) {}"
-                + "f(new A()); f(new B()); f(1);")
+            "/** @constructor */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
         .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: (A|B|null)")
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass Super\n"
+                + "original: function(this:Super, number): undefined\n"
+                + "override: function(this:Sub, string): undefined")
         .run();
   }
 
   @Test
-  public void testTypeDef5() {
-    // Notice that the error message is slightly different than
-    // the one for testTypeDef4, even though they should be the same.
-    // This is an implementation detail necessary for NamedTypes work out
-    // OK, and it should change if NamedTypes ever go away.
+  public void testInheritanceCheck12() {
     newTest()
         .addSource(
-            "/** @param {AB} x */ function f(x) {}"
-                + "/** @constructor */ function A() {}"
-                + "/** @constructor */ function B() {}"
-                + "/** @typedef {(A|B)} */ var AB;"
-                + "f(new A()); f(new B()); f(1);")
-        .addDiagnostic(
-            "actual parameter 1 of f does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: (A|B|null)")
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override */goog.Sub.prototype.foo = \"some string\";")
         .run();
   }
 
   @Test
-  public void testCircularTypeDef() {
+  public void testInheritanceCheck13() {
     newTest()
         .addSource(
-            "var goog = {};"
-                + "/** @typedef {number|Array<goog.Bar>} */ goog.Bar;"
-                + "/** @param {goog.Bar} x */ function f(x) {}"
-                + "f(3); f([3]); f([[3]]);")
+            "var goog = {};\n"
+                + "/** @constructor\n @extends {goog.Missing} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("Bad type annotation. Unknown type goog.Missing")
         .run();
   }
 
   @Test
-  public void testGetTypedPercent1() {
-    String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(50.0);
+  public void testInheritanceCheck14() {
+    testClosureTypes(
+        lines(
+            "/** @constructor\n @extends {goog.Missing} */",
+            "goog.Super = function() {};",
+            "/** @constructor\n @extends {goog.Super} */function Sub() {};",
+            "/** @override */ Sub.prototype.foo = function() {};"),
+        "Bad type annotation. Unknown type goog.Missing");
   }
 
   @Test
-  public void testGetTypedPercent2() {
-    String js = "var x = {}; x.y = 1;";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  public void testInheritanceCheck15() {
+    newTest()
+        .addSource(
+            "/** @constructor */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo;"
+                + "/** @constructor\n @extends {Super} */function Sub() {};"
+                + "/** @override\n  @param {number} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
+        .run();
   }
 
   @Test
-  public void testGetTypedPercent3() {
-    String js = "var f = function(x) { x.a = x.b; }";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(25.0);
+  public void testInheritanceCheck16() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "/** @type {number} */ goog.Super.prototype.foo = 3;"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @type {number} */ goog.Sub.prototype.foo = 5;")
+        .addDiagnostic(
+            "property foo already defined on superclass goog.Super; "
+                + "use @override to override it")
+        .run();
   }
 
   @Test
-  public void testGetTypedPercent4() {
-    String js =
-        "var n = {};\n /** @constructor */ n.T = function() {};\n"
-            + "/** @type {n.T} */ var x = new n.T();";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  public void testInheritanceCheck17() {
+    // Make sure this warning still works, even when there's no
+    // @override tag.
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @constructor */goog.Super = function() {};"
+                + "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};"
+                + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};"
+                + "/** @override @param {string} x */ goog.Sub.prototype.foo = function(x) {};")
+        .addDiagnostic(
+            "mismatch of the foo property type and the type of the property it "
+                + "overrides from superclass goog.Super\n"
+                + "original: function(this:goog.Super, number): undefined\n"
+                + "override: function(this:goog.Sub, string): undefined")
+        .run();
+  }
+
+  @Test
+  public void testInterfacePropertyOverride1() {
+    newTest()
+        .addSource(
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .run();
   }
 
   @Test
-  public void testGetTypedPercent5() {
-    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  public void testInterfacePropertyOverride2() {
+    newTest()
+        .addSource(
+            "/** @interface */function Root() {};"
+                + "Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @interface\n @extends {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .run();
   }
 
   @Test
-  public void testGetTypedPercent6() {
-    String js = "a = {TRUE: 1, FALSE: 0};";
-    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  public void testInterfacePropertyBadOverrideFails() {
+    newTest()
+        .addSource(
+            "/** @interface */function Super() {};",
+            "/** @type {number} */",
+            "Super.prototype.foo;",
+            "/** @interface @extends {Super} */function Sub() {};",
+            "/** @type {string} */",
+            "Sub.prototype.foo;")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Sub and the type of the property it "
+                    + "overrides from interface Super",
+                "original: number",
+                "override: string"))
+        .run();
   }
 
   @Test
-  public void testPrototypePropertyReference() {
-    TypeCheckResult p =
-        parseAndTypeCheckWithScope(
-            DEFAULT_EXTERNS,
-            ""
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "/** @param {number} a */\n"
-                + "Foo.prototype.bar = function(a){};\n"
-                + "/** @param {Foo} f */\n"
-                + "function baz(f) {\n"
-                + "  Foo.prototype.bar.call(f, 3);\n"
-                + "}");
-    assertThat(compiler.getErrorCount()).isEqualTo(0);
-    assertThat(compiler.getWarningCount()).isEqualTo(0);
-
-    assertThat(p.scope.getVar("Foo").getType()).isInstanceOf(FunctionType.class);
-    FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType();
-    assertThat(fooType.getPrototype().getPropertyType("bar").toString())
-        .isEqualTo("function(this:Foo, number): undefined");
+  public void testInterfaceInheritanceCheck1() {
+    newTest()
+        .addSource(
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "Sub.prototype.foo = function() {};")
+        .addDiagnostic(
+            "property foo already defined on interface Super; use @override to " + "override it")
+        .run();
   }
 
   @Test
-  public void testResolvingNamedTypes() {
-    String externs = new TestExternsBuilder().addObject().build();
-    String js =
-        lines(
-            "/** @constructor */",
-            "var Foo = function() {}",
-            "/** @param {number} a */",
-            "Foo.prototype.foo = function(a) {",
-            "  return this.baz().toString();",
-            "};",
-            "/** @return {Baz} */",
-            "Foo.prototype.baz = function() { return new Baz(); };",
-            "/** @constructor",
-            "  * @extends Foo */",
-            "var Bar = function() {};",
-            "/** @constructor */",
-            "var Baz = function() {};");
-    assertThat(getTypedPercentWithExterns(externs, js)).isWithin(0.1).of(100.0);
+  public void testInterfaceInheritanceCheck2() {
+    newTest()
+        .addSource(
+            "/** @interface */function Super() {};"
+                + "Super.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .run();
   }
 
   @Test
-  public void testMissingProperty1a() {
+  public void testInterfaceInheritanceCheck3() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "Foo.prototype.baz = function() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
-        .addDiagnostic("Property a never defined on Foo")
+            "/** @interface */function Root() {};"
+                + "/** @return {number} */Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @return {number} */Sub.prototype.foo = function() { return 1;};")
+        .addDiagnostic(
+            "property foo already defined on interface Root; use @override to " + "override it")
         .run();
   }
 
   @Test
-  public void testMissingProperty1b() {
-    disableStrictMissingPropertyChecks();
-
+  public void testInterfaceInheritanceCheck4() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.a = 3; };")
+            "/** @interface */function Root() {};"
+                + "/** @return {number} */Root.prototype.foo = function() {};"
+                + "/** @interface\n @extends {Root} */function Super() {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override\n * @return {number} */Sub.prototype.foo =\n"
+                + "function() { return 1;};")
         .run();
   }
 
   @Test
-  public void testMissingProperty2a() {
-    disableStrictMissingPropertyChecks();
+  public void testInterfaceInheritanceCheck5() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.b = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
+            "/** @interface */function Super() {};/** @return {string} */Super.prototype.foo ="
+                + " function() {};/** @constructor\n"
+                + " @implements {Super} */function Sub() {};/** @override\n"
+                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Super\n"
+                + "original: function(this:Super): string\n"
+                + "override: function(this:Sub): number")
         .run();
   }
 
   @Test
-  public void testMissingProperty2b() {
+  public void testInterfaceInheritanceCheck6() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.baz = function() { this.b = 3; };")
-        .addDiagnostic("Property b never defined on Foo")
+            "/** @interface */function Root() {};/** @return {string} */Root.prototype.foo ="
+                + " function() {};/** @interface\n"
+                + " @extends {Root} */function Super() {};/** @constructor\n"
+                + " @implements {Super} */function Sub() {};/** @override\n"
+                + " @return {number} */Sub.prototype.foo = function() { return 1; };")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Root\n"
+                + "original: function(this:Root): string\n"
+                + "override: function(this:Sub): number")
         .run();
   }
 
   @Test
-  public void testMissingProperty3a() {
+  public void testInterfaceInheritanceCheck7() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "(new Foo).a = 3;")
-        .addDiagnostic("Property a never defined on Foo") // method
-        .addDiagnostic("Property a never defined on Foo")
-        .run(); // global assignment
+            "/** @interface */function Super() {};"
+                + "/** @param {number} bar */Super.prototype.foo = function(bar) {};"
+                + "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override\n  @param {string} bar */Sub.prototype.foo =\n"
+                + "function(bar) {};")
+        .addDiagnostic(
+            "mismatch of the foo property on type Sub and the type of the property it "
+                + "overrides from interface Super\n"
+                + "original: function(this:Super, number): undefined\n"
+                + "override: function(this:Sub, string): undefined")
+        .run();
   }
 
   @Test
-  public void testMissingProperty3b() {
-    disableStrictMissingPropertyChecks();
-
+  public void testInterfaceInheritanceCheck8() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "(new Foo).a = 3;")
+            "/** @constructor\n @implements {Super} */function Sub() {};"
+                + "/** @override */Sub.prototype.foo = function() {};")
+        .addDiagnostic("Bad type annotation. Unknown type Super")
+        .addDiagnostic("property foo not defined on any superclass of Sub")
         .run();
   }
 
   @Test
-  public void testMissingProperty4a() {
-    disableStrictMissingPropertyChecks();
+  public void testInterfaceInheritanceCheck9() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "(new Foo).b = 3;")
-        .addDiagnostic("Property a never defined on Foo")
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.bar = function() {};"
+                + "/** @constructor */ function F() {}"
+                + "/** @return {number} */ F.prototype.bar = function() {return 3; };"
+                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
+                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
+                + "function G() {}"
+                + "/** @return {string} */ function f() { return new G().bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testMissingProperty4b() {
+  public void testInterfaceInheritanceCheck10() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}", //
-            "(new Foo).b = 3;")
-        .addDiagnostic("Property b never defined on Foo")
+            "/** @interface */ function I() {}"
+                + "/** @return {number} */ I.prototype.bar = function() {};"
+                + "/** @constructor */ function F() {}"
+                + "/** @return {number} */ F.prototype.foo = function() {return 3; };"
+                + "/** @constructor \n * @extends {F} \n * @implements {I} */ "
+                + "function G() {}"
+                + "/** @return {number} \n * @override */ "
+                + "G.prototype.bar = G.prototype.foo;"
+                + "/** @return {string} */ function f() { return new G().bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testMissingProperty5() {
+  public void testInterfaceInheritanceCheck12() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "/** @constructor */ function Bar() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
+            "/** @interface */ function I() {};\n"
+                + "/** @type {string} */ I.prototype.foobar;\n"
+                + "/** \n * @constructor \n * @implements {I} */\n"
+                + "function C() {\n"
+                + "/** \n * @type {number} */ this.foobar = 2;};\n"
+                + "/** @type {I} */ \n var test = new C(); alert(test.foobar);")
+        .addDiagnostic(
+            "mismatch of the foobar property on type C and the type of the property"
+                + " it overrides from interface I\n"
+                + "original: string\n"
+                + "override: number")
         .run();
   }
 
   @Test
-  public void testMissingProperty6a() {
+  public void testInterfaceInheritanceCheck13() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.bar = function() { return this.a; };",
-            "/** @constructor \n * @extends {Foo} */ ",
-            "function Bar() { this.a = 3; };")
-        .addDiagnostic("Property a never defined on Foo")
+            "function abstractMethod() {};\n"
+                + "/** @interface */var base = function() {};\n"
+                + "/** @extends {base} \n @interface */ var Int = function() {}\n"
+                + "/** @type {{bar : !Function}} */ var x; \n"
+                + "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n"
+                + "/** @type {Int} */ var foo;\n"
+                + "foo.bar();")
         .run();
   }
 
+  /** Verify that templatized interfaces can extend one another and share template values. */
   @Test
-  public void testMissingProperty6b() {
-    disableStrictMissingPropertyChecks();
-
+  public void testInterfaceInheritanceCheck14() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "/** @constructor \n * @extends {Foo} */ "
-                + "function Bar() { this.a = 3; };")
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
+                + "/** @return {U} */B.prototype.bar = function() {};"
+                + "/** @constructor\n @implements {B<string>} */function C() {};"
+                + "/** @return {string}\n @override */C.prototype.foo = function() {};"
+                + "/** @return {string}\n @override */C.prototype.bar = function() {};")
         .run();
   }
 
+  /** Verify that templatized instances can correctly implement templatized interfaces. */
   @Test
-  public void testMissingProperty7() {
+  public void testInterfaceInheritanceCheck15() {
     newTest()
-        .addSource("/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }")
-        .addDiagnostic(
-            "Property impossible never defined on Object"
-                + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .addSource(
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @interface\n @template U\n @extends {A<U>} */function B() {};"
+                + "/** @return {U} */B.prototype.bar = function() {};"
+                + "/** @constructor\n @template V\n @implements {B<V>}\n */function C() {};"
+                + "/** @return {V}\n @override */C.prototype.foo = function() {};"
+                + "/** @return {V}\n @override */C.prototype.bar = function() {};")
         .run();
   }
 
+  /**
+   * Verify that using @override to declare the signature for an implementing class works correctly
+   * when the interface is generic.
+   */
   @Test
-  public void testMissingProperty8() {
+  public void testInterfaceInheritanceCheck16() {
     newTest()
         .addSource(
-            "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }")
+            "/** @interface\n @template T */function A() {};"
+                + "/** @return {T} */A.prototype.foo = function() {};"
+                + "/** @return {T} */A.prototype.bar = function() {};"
+                + "/** @constructor\n @implements {A<string>} */function B() {};"
+                + "/** @override */B.prototype.foo = function() { return 'string'};"
+                + "/** @override */B.prototype.bar = function() { return 3 };")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testMissingProperty9() {
-    disableStrictMissingPropertyChecks();
-
+  public void testInterfacePropertyNotImplemented() {
     newTest()
         .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { if (obj.impossible) { return true; } }")
+            "/** @interface */function Int() {};"
+                + "Int.prototype.foo = function() {};"
+                + "/** @constructor\n @implements {Int} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
         .run();
   }
 
   @Test
-  public void testMissingProperty10() {
-    disableStrictMissingPropertyChecks();
+  public void testInterfacePropertyNotImplemented2() {
     newTest()
         .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { while (obj.impossible) { return true; } }")
+            "/** @interface */function Int() {};"
+                + "Int.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int} */function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int is not implemented by type Foo")
         .run();
   }
 
+  /** Verify that templatized interfaces enforce their template type values. */
   @Test
-  public void testMissingProperty11() {
-    disableStrictMissingPropertyChecks();
+  public void testInterfacePropertyNotImplemented3() {
     newTest()
         .addSource(
-            "/** @param {Object} obj */"
-                + "function foo(obj) { for (;obj.impossible;) { return true; } }")
+            "/** @interface  @template T */ function Int() {};",
+            "/** @return {T} */ Int.prototype.foo = function() {};",
+            "",
+            "/** @constructor @implements {Int<string>} */ function Foo() {};",
+            "/** @return {number}  @override */ Foo.prototype.foo = function() {};")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Foo and the type of the property it "
+                    + "overrides from interface Int",
+                "original: function(this:Int): string",
+                "override: function(this:Foo): number"))
         .run();
   }
 
   @Test
-  public void testMissingProperty12() {
-    disableStrictMissingPropertyChecks();
+  public void testStubConstructorImplementingInterface() {
+    // This does not throw a warning for unimplemented property because Foo is
+    // just a stub.
     newTest()
-        .addSource(
-            "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }")
+        .addExterns(
+            "/** @interface */ function Int() {}\n"
+                + "Int.prototype.foo = function() {};"
+                + "/** @constructor \n @implements {Int} */ var Foo;\n")
+        .addSource("")
         .run();
   }
 
-  // Note: testMissingProperty{13,14} pertained to a deleted coding convention.
+  @Test
+  public void testObjectLiteral() {
+    Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}");
+
+    Node nameNode = n.getFirstFirstChild();
+    Node objectNode = nameNode.getFirstChild();
+
+    // node extraction
+    assertNode(nameNode).hasToken(Token.NAME);
+    assertNode(objectNode).hasToken(Token.OBJECTLIT);
+
+    // value's type
+    ObjectType objectType = (ObjectType) objectNode.getJSType();
+    assertTypeEquals(getNativeNumberType(), objectType.getPropertyType("m1"));
+    assertTypeEquals(getNativeStringType(), objectType.getPropertyType("m2"));
+
+    // variable's type
+    assertTypeEquals(objectType, nameNode.getJSType());
+  }
 
   @Test
-  public void testMissingProperty15() {
-    disableStrictMissingPropertyChecks();
+  public void testObjectLiteralDeclaration1() {
     newTest()
-        .addSource("/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }")
+        .addSource(
+            "var x = {"
+                + "/** @type {boolean} */ abc: true,"
+                + "/** @type {number} */ 'def': 0,"
+                + "/** @type {string} */ 3: 'fgh'"
+                + "};")
         .run();
   }
 
   @Test
-  public void testMissingProperty16() {
-    disableStrictMissingPropertyChecks();
+  public void testObjectLiteralDeclaration2() {
     newTest()
-        .addSource("/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }")
+        .addSource("var x = {" + "  /** @type {boolean} */ abc: true" + "};" + "x.abc = 0;")
         .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "assignment to property abc of x\n" + "found   : number\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testMissingProperty17() {
+  public void testObjectLiteralDeclaration3() {
     newTest()
         .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }")
+            "/** @param {{foo: !Function}} x */ function f(x) {}" + "f({foo: function() {}});")
         .run();
   }
 
   @Test
-  public void testMissingProperty18() {
-    disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }")
-        .run();
+  public void testObjectLiteralDeclaration4() {
+    testClosureTypes(
+        "var x = {"
+            + "  /** @param {boolean} x */ abc: function(x) {}"
+            + "};"
+            + "/**\n"
+            + " * @param {string} x\n"
+            + " * @suppress {duplicate}\n"
+            + " */ x.abc = function(x) {};",
+        "assignment to property abc of x\n"
+            + "found   : function(string): undefined\n"
+            + "required: function(boolean): undefined");
+    // TODO(user): suppress {duplicate} currently also silence the
+    // redefining type error in the TypeValidator. Maybe it needs
+    // a new suppress name instead?
   }
 
   @Test
-  public void testMissingProperty19() {
-    disableStrictMissingPropertyChecks();
+  public void testObjectLiteralDeclaration5() {
     newTest()
         .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }")
-        .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "var x = {"
+                + "  /** @param {boolean} x */ abc: function(x) {}"
+                + "};"
+                + "/**\n"
+                + " * @param {boolean} x\n"
+                + " * @suppress {duplicate}\n"
+                + " */ x.abc = function(x) {};")
         .run();
   }
 
   @Test
-  public void testMissingProperty20() {
-    disableStrictMissingPropertyChecks();
+  public void testObjectLiteralDeclaration6() {
     newTest()
         .addSource(
-            "/** @param {Object} x */" + "function f(x) { if (x.foo) { } else { x.foo(); } }")
-        .addDiagnostic(
-            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "var x = {};"
+                + "/**\n"
+                + " * @param {boolean} x\n"
+                + " * @suppress {duplicate}\n"
+                + " */ x.abc = function(x) {};"
+                + "x = {"
+                + "  /**\n"
+                + "   * @param {boolean} x\n"
+                + "   * @suppress {duplicate}\n"
+                + "   */"
+                + "  abc: function(x) {}"
+                + "};")
         .run();
   }
 
   @Test
-  public void testMissingProperty21() {
-    disableStrictMissingPropertyChecks();
-    newTest().addSource("/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }").run();
-  }
-
-  @Test
-  public void testMissingProperty22() {
-    disableStrictMissingPropertyChecks();
+  public void testObjectLiteralDeclaration7() {
     newTest()
         .addSource(
-            "/** @param {Object} x \n * @return {boolean} */"
-                + "function f(x) { return x.foo ? x.foo() : true; }")
+            "var x = {};"
+                + "/**\n"
+                + " * @type {function(boolean): undefined}\n"
+                + " */ x.abc = function(x) {};"
+                + "x = {"
+                + "  /**\n"
+                + "   * @param {boolean} x\n"
+                + "   * @suppress {duplicate}\n"
+                + "   */"
+                + "  abc: function(x) {}"
+                + "};")
         .run();
   }
 
   @Test
-  public void testMissingProperty23() {
-    newTest()
-        .addSource("function f(x) { x.impossible(); }")
-        .addDiagnostic(
-            "Property impossible never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
+  public void testCallDateConstructorAsFunction() {
+    // ECMA-262 15.9.2: When Date is called as a function rather than as a
+    // constructor, it returns a string.
+    Node n = parseAndTypeCheck("Date()");
+    assertTypeEquals(getNativeStringType(), n.getFirstFirstChild().getJSType());
   }
 
+  // According to ECMA-262, Error & Array function calls are equivalent to
+  // constructor calls.
+
   @Test
-  public void testMissingProperty24() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {MissingType} x */"
-            + "function f(x) { x.impossible(); }",
-        null);
+  public void testCallErrorConstructorAsFunction() {
+    String externs =
+        lines(
+            "/** @constructor",
+            "    @param {string} message",
+            "    @return {!Error} */",
+            "function Error(message) {}");
+    Node n = parseAndTypeCheck(externs, "Error('x')");
+    Node call = n.getFirstFirstChild();
+    assertThat(call.isCall()).isTrue();
+    assertTypeEquals(
+        call.getFirstChild().getJSType().toMaybeFunctionType().getInstanceType(), call.getJSType());
   }
 
   @Test
-  public void testMissingProperty25() {
-    newTest()
-        .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "Foo.prototype.bar = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "(new FooAlias()).bar();")
-        .run();
+  public void testCallArrayConstructorAsFunction() {
+    Node n = parseAndTypeCheck("Array()");
+    assertTypeEquals(getNativeArrayType(), n.getFirstFirstChild().getJSType());
   }
 
   @Test
-  public void testMissingProperty26() {
+  public void testPropertyTypeOfUnionType() {
     newTest()
         .addSource(
-            "/** @constructor */ var Foo = function() {};"
-                + "/** @constructor */ var FooAlias = Foo;"
-                + "FooAlias.prototype.bar = function() {};"
-                + "(new Foo()).bar();")
+            "var a = {};"
+                + "/** @constructor */ a.N = function() {};\n"
+                + "a.N.prototype.p = 1;\n"
+                + "/** @constructor */ a.S = function() {};\n"
+                + "a.S.prototype.p = 'a';\n"
+                + "/** @param {!a.N|!a.S} x\n@return {string} */\n"
+                + "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testMissingProperty27() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {?MissingType} x */"
-            + "function f(x) {"
-            + "  for (var parent = x; parent; parent = parent.getParent()) {}"
-            + "}",
-        null);
-  }
-
-  @Test
-  public void testMissingProperty28a() {
+  public void testGetPropertyTypeOfUnionType_withMatchingTemplates() {
     newTest()
-        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foo;" + "}")
+        .addSource(
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<number>} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testMissingProperty28b() {
+  public void testGetPropertyTypeOfUnionType_withDifferingTemplates() {
     newTest()
-        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foox;" + "}")
+        .addSource(
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<string>} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
         .addDiagnostic(
-            "Property foox never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            lines(
+                "inconsistent return type", //
+                "found   : (number|string)",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testMissingProperty29() {
-    // This used to emit a warning.
+  public void testGetPropertyTypeOfUnionType_withMembersThatExtendATemplatizedType() {
     newTest()
-        .addExterns(
-            "/** @constructor */ var Foo;"
-                + "Foo.prototype.opera;"
-                + "Foo.prototype.opera.postError;")
-        .addSource("")
+        .addSource(
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "",
+            "/** @interface @extends {Foo<number>} */ function Bar() {};",
+            "/** @interface @extends {Foo<number>} */ function Baz() {}",
+            "",
+            "/**",
+            " * @param {!Bar|!Baz} x",
+            " * @return {string} ",
+            " */",
+            "var f = function(x) { return x.p; };")
+        .addDiagnostic(
+            lines(
+                "inconsistent return type", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testMissingProperty30a() {
+  public void testInvalidAssignToPropertyTypeOfUnionType_withMatchingTemplates_doesntWarn() {
+    // We don't warn for this assignment because we treat the type of `x.p` as inferred...
     newTest()
         .addSource(
-            "/** @return {*} */",
-            "function f() {",
-            " return {};",
-            "}",
-            "f().a = 3;",
-            "/** @param {Object} y */ function g(y) { return y.a; }")
-        .addDiagnostic("Property a never defined on *")
-        .addDiagnostic("Property a never defined on Object")
+            "/** @interface @template T */ function Foo() {};",
+            "/** @type {T} */",
+            "Foo.prototype.p;",
+            "/** @interface @template U */ function Bar() {};",
+            "/** @type {U} */",
+            "Bar.prototype.p;",
+            "",
+            "/**",
+            " * @param {!Foo<number>|!Bar<number>} x",
+            " */",
+            "var f = function(x) { x.p = 'not a number'; };")
         .run();
   }
 
+  // TODO(user): We should flag these as invalid. This will probably happen
+  // when we make sure the interface is never referenced outside of its
+  // definition. We might want more specific and helpful error messages.
   @Test
-  public void testMissingProperty30b() {
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testWarningOnInterfacePrototype() {
     newTest()
         .addSource(
-            "/** @return {*} */"
-                + "function f() {"
-                + " return {};"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Object} y */ function g(y) { return y.a; }")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype = function() { };")
+        .addDiagnostic("e of its definition")
         .run();
   }
 
   @Test
-  public void testMissingProperty31a() {
+  @Ignore
+  public void testBadPropertyOnInterface1() {
     newTest()
         .addSource(
-            "/** @return {Array|number} */", //
-            "function f() {",
-            " return [];",
-            "}",
-            "f().a = 3;")
-        .addDiagnostic("Property a never defined on (Array|Number)")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.f = function() { return 1;};")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testMissingProperty31b() {
-    disableStrictMissingPropertyChecks();
-
+  @Ignore
+  public void testBadPropertyOnInterface2() {
     newTest()
         .addSource(
-            "/** @return {Array|number} */"
-                + "function f() {"
-                + " return [];"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Array} y */ function g(y) { return y.a; }")
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.f = function() { return 1;};")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testMissingProperty32() {
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testBadPropertyOnInterface3() {
     newTest()
-        .addSource(
-            "/** @return {Array|number} */"
-                + "function f() {"
-                + " return [];"
-                + "}"
-                + "f().a = 3;"
-                + "/** @param {Date} y */ function g(y) { return y.a; }")
-        .addDiagnostic("Property a never defined on Date")
+        .addSource("/** @interface */ u.T = function() {}; u.T.x")
+        .addDiagnostic("cannot reference an interface outside of its definition")
         .run();
   }
 
   @Test
-  public void testMissingProperty33() {
-    disableStrictMissingPropertyChecks();
-    newTest().addSource("/** @param {Object} x */" + "function f(x) { !x.foo || x.foo(); }").run();
+  @Ignore
+  public void testBadPropertyOnInterface4() {
+    newTest()
+        .addSource("/** @interface */ function T() {}; T.x;")
+        .addDiagnostic("cannot reference an interface outside of its definition")
+        .run();
   }
 
   @Test
-  public void testMissingProperty34() {
+  public void testAnnotatedPropertyOnInterface1() {
+    // For interfaces we must allow function definitions that don't have a
+    // return statement, even though they declare a returned type.
     newTest()
         .addSource(
-            "/** @fileoverview \n * @suppress {missingProperties} */"
-                + "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.bar = function() { return this.a; };"
-                + "Foo.prototype.baz = function() { this.b = 3; };")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype.f = function() {};")
         .run();
   }
 
   @Test
-  public void testMissingProperty35a() {
-    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
+  public void testAnnotatedPropertyOnInterface2() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "/** @constructor */ function Bar() {}",
-            "/** @constructor */ function Baz() {}",
-            "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }",
-            "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
-        .addDiagnostic("Property specialProp never defined on (Foo|Bar)")
-        .addDiagnostic("Property specialProp never defined on (Bar|Baz)")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @return {number} */ u.T.prototype.f = function() { };")
         .run();
   }
 
   @Test
-  public void testMissingProperty35b() {
-    disableStrictMissingPropertyChecks();
-
-    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
+  public void testAnnotatedPropertyOnInterface3() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @constructor */ function Baz() {}"
-                + "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }"
-                + "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.prototype.f = function() { };")
         .run();
   }
 
   @Test
-  public void testMissingProperty36a() {
-    // Foo has baz defined, and SubFoo has bar defined, so some objects with
-    // bar may have baz.
+  public void testAnnotatedPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/** @constructor */ function Foo() {}",
-            "Foo.prototype.baz = 0;",
-            "/** @constructor \n * @extends {Foo} */ function SubFoo() {}",
-            "SubFoo.prototype.bar = 0;",
-            "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
-        .addDiagnostic("Property baz never defined on x")
+            CLOSURE_DEFS
+                + "/** @interface */ function T() {};\n"
+                + "/** @return {number} */ T.prototype.f = goog.abstractMethod;")
         .run();
   }
 
+  // TODO(user): If we want to support this syntax we have to warn about
+  // missing annotations.
   @Test
-  public void testMissingProperty36b() {
-    disableStrictMissingPropertyChecks();
-
-    // Foo has baz defined, and SubFoo has bar defined, so some objects with
-    // bar may have baz.
+  @Ignore
+  public void testWarnUnannotatedPropertyOnInterface1() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "Foo.prototype.baz = 0;"
-                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
-                + "SubFoo.prototype.bar = 0;"
-                + "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
+        .addSource("/** @interface */ u.T = function() {}; u.T.prototype.x;")
+        .addDiagnostic("interface property x is not annotated")
         .run();
   }
 
   @Test
-  public void testMissingProperty37a() {
-    // This used to emit a missing property warning because we couldn't
-    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
+  @Ignore
+  public void testWarnUnannotatedPropertyOnInterface2() {
     newTest()
-        .addSource(
-            "/** @param {{isVisible: boolean}} x */",
-            "function f(x){",
-            "  x.isVisible = false;",
-            "}",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/**",
-            " * @constructor",
-            " * @extends {Foo}",
-            " */",
-            "function SubFoo() {}",
-            "/** @type {boolean} */",
-            "SubFoo.prototype.isVisible = true;",
-            "/**",
-            " * @param {Foo} x",
-            " * @return {boolean}",
-            " */",
-            "function g(x) { return x.isVisible; }")
-        .addDiagnostic("Property isVisible never defined on Foo")
+        .addSource("/** @interface */ function T() {}; T.prototype.x;")
+        .addDiagnostic("interface property x is not annotated")
         .run();
   }
 
   @Test
-  public void testMissingProperty37b() {
-    disableStrictMissingPropertyChecks();
-
-    // This used to emit a missing property warning because we couldn't
-    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
+  public void testWarnUnannotatedPropertyOnInterface5() {
     newTest()
-        .addSource(
-            "/** @param {{isVisible: boolean}} x */ function f(x){"
-                + "  x.isVisible = false;"
-                + "}"
-                + "/** @constructor */ function Foo() {}"
-                + "/**\n"
-                + " * @constructor \n"
-                + " * @extends {Foo}\n"
-                + " */ function SubFoo() {}"
-                + "/** @type {boolean} */ SubFoo.prototype.isVisible = true;"
-                + "/**\n"
-                + " * @param {Foo} x\n"
-                + " * @return {boolean}\n"
-                + " */\n"
-                + "function g(x) { return x.isVisible; }")
+        .addSource("/** @interface */ u.T = function() {};\n" + "u.T.prototype.x = function() {};")
         .run();
   }
 
   @Test
-  public void testMissingProperty38() {
+  public void testWarnUnannotatedPropertyOnInterface6() {
     newTest()
-        .addSource(
-            "/** @constructor */ function Foo() {}"
-                + "/** @constructor */ function Bar() {}"
-                + "/** @return {Foo|Bar} */ function f() { return new Foo(); }"
-                + "f().missing;")
-        .addDiagnostic("Property missing never defined on (Foo|Bar)")
+        .addSource("/** @interface */ function T() {};\n" + "T.prototype.x = function() {};")
         .run();
   }
 
+  // TODO(user): If we want to support this syntax we have to warn about
+  // the invalid type of the interface member.
   @Test
-  public void testMissingProperty39a() {
-    disableStrictMissingPropertyChecks();
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
+  @Ignore
+  public void testWarnDataPropertyOnInterface1() {
+    newTest()
         .addSource(
-            "/** @return {string|number} */ function f() { return 3; }", //
-            "f().length;")
+            "/** @interface */ u.T = function() {};\n" + "/** @type {number} */u.T.prototype.x;")
+        .addDiagnostic("interface members can only be plain functions")
         .run();
   }
 
   @Test
-  public void testMissingProperty39b() {
+  public void testDataPropertyOnInterface1() {
     newTest()
-        .addExterns(new TestExternsBuilder().addString().build())
-        .addSource(
-            "/** @return {string|number} */ function f() { return 3; }", //
-            "f().length;")
-        // TODO(johnlenz): enable this.
-        // "Property length not defined on all member types of (String|Number)"
+        .addSource("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;")
         .run();
   }
 
   @Test
-  public void testMissingProperty40a() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {MissingType} x */"
-            + "function f(x) { x.impossible(); }",
-        null);
+  public void testDataPropertyOnInterface2() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() {}\n"
+                + "/** @override */\n"
+                + "C.prototype.x = 'foo';")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
+        .run();
   }
 
   @Test
-  public void testMissingProperty40b() {
-    testClosureTypes(
-        "goog.forwardDeclare('MissingType');"
-            + "/** @param {(Array|MissingType)} x */"
-            + "function f(x) { x.impossible(); }",
-        // TODO(johnlenz): enable this.
-        // "Property impossible not defined on all member types of x"
-        null);
+  public void testDataPropertyOnInterface3() {
+    newTest()
+        .addSource(
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() {}\n"
+                + "/** @override */\n"
+                + "C.prototype.x = 'foo';")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
+        .run();
   }
 
   @Test
-  public void testMissingProperty41a() {
+  public void testDataPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/** @param {(Array|Date)} x */", //
-            "function f(x) { if (x.impossible) x.impossible(); }")
-        .addDiagnostic("Property impossible never defined on (Array|Date)")
-        .addDiagnostic("Property impossible never defined on (Array|Date)")
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x;\n"
+                + "/** @constructor \n"
+                + " *  @implements {T} \n"
+                + " */\n"
+                + "function C() { /** @type {string} */ \n this.x = 'foo'; }\n")
+        .addDiagnostic(
+            "mismatch of the x property on type C and the type of the property it "
+                + "overrides from interface T\n"
+                + "original: number\n"
+                + "override: string")
         .run();
   }
 
   @Test
-  public void testMissingProperty41b() {
-    disableStrictMissingPropertyChecks();
+  public void testWarnDataPropertyOnInterface3() {
     newTest()
         .addSource(
-            "/** @param {(Array|Date)} x */", //
-            "function f(x) { if (x.impossible) x.impossible(); }")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @type {number} */u.T.prototype.x = 1;")
+        .addDiagnostic(
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod")
         .run();
   }
 
   @Test
-  public void testMissingProperty42() {
+  public void testWarnDataPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/** @param {Object} x */"
-                + "function f(x) { "
-                + "  if (typeof x.impossible == 'undefined') throw Error();"
-                + "  return x.impossible;"
-                + "}")
+            "/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;")
+        .addDiagnostic(
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod")
         .run();
   }
 
+  // TODO(user): If we want to support this syntax we should warn about the
+  // mismatching types in the two tests below.
   @Test
-  public void testMissingProperty43() {
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface1() {
     newTest()
-        .addSource("function f(x) { " + " return /** @type {number} */ (x.impossible) && 1;" + "}")
+        .addSource(
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "/** @param {String} foo */function(foo) {};")
+        .addDiagnostic("found   : \n" + "required: ")
         .run();
   }
 
   @Test
-  public void testMissingProperty_notReportedInPropertyAbsenceCheck() {
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface2() {
     newTest()
         .addSource(
-            "function f(/** !Object */ x) {", //
-            "  if (x.y == null) throw new Error();",
-            "}")
+            "/** @interface */ function T() {};\n"
+                + "/** @return {number} */T.prototype.x =\n"
+                + "/** @return {string} */function() {};")
+        .addDiagnostic("found   : \n" + "required: ")
         .run();
   }
 
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
+  // TODO(user): We should warn about this (bar is missing an annotation). We
+  // probably don't want to warn about all missing parameter annotations, but
+  // we should be as strict as possible regarding interfaces.
   @Test
-  public void optChainGetPropAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  @Ignore
+  public void testErrorMismatchingPropertyOnInterface3() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.z;",
-            "}")
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "function(foo, bar) {};")
+        .addDiagnostic("found   : \n" + "required: ")
         .run();
   }
 
-  // this is the same test as above except that it does not use optional chaining so it should
-  // emit a warning about missing properties
   @Test
-  public void normalGetPropNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testErrorMismatchingPropertyOnInterface4() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y.z;",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "/** @interface */ u.T = function() {};\n"
+                + "/** @param {Number} foo */u.T.prototype.x =\n"
+                + "function() {};")
+        .addDiagnostic("parameter foo does not appear in u.T.prototype.x's parameter list")
         .run();
   }
 
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
   @Test
-  public void optChainGetElemAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testErrorMismatchingPropertyOnInterface5() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.[z];",
-            "}")
+            "/** @interface */ function T() {};\n"
+                + "/** @type {number} */T.prototype.x = function() { };")
+        .addDiagnostic(
+            "assignment to property x of T.prototype\n"
+                + "found   : function(): undefined\n"
+                + "required: number")
         .run();
   }
 
-  // this is the same test as above except that it does not use optional chaining so it should emit
-  // a warning about missing properties
   @Test
-  public void normalGetElemNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testErrorMismatchingPropertyOnInterface6() {
+    testClosureTypesMultipleWarnings(
+        "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1",
+        ImmutableList.of(
+            "assignment to property x of T.prototype\n"
+                + "found   : number\n"
+                + "required: function(this:T): number",
+            "interface members can only be empty property declarations, "
+                + "empty functions, or goog.abstractMethod"));
+  }
+
+  @Test
+  public void testInterfaceNonEmptyFunction() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y[z];",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }")
+        .addDiagnostic("interface member functions must have an empty body")
         .run();
   }
 
-  // since optional chaining is a property test (tests for the existence of x.y), no warnings
-  // about missing properties are emitted
   @Test
-  public void optChainCallAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testDoubleNestedInterface() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y?.();",
-            "}")
+            "/** @interface */ var I1 = function() {};\n"
+                + "/** @interface */ I1.I2 = function() {};\n"
+                + "/** @interface */ I1.I2.I3 = function() {};\n")
         .run();
   }
 
-  // this is the same test as above except that it does not use optional chaining so it should emit
-  // a warning about missing properties
   @Test
-  public void normalCallNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testStaticDataPropertyOnNestedInterface() {
     newTest()
         .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x.y();",
-            "}")
-        .addDiagnostic(
-            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+            "/** @interface */ var I1 = function() {};\n"
+                + "/** @interface */ I1.I2 = function() {};\n"
+                + "/** @type {number} */ I1.I2.x = 1;\n")
         .run();
   }
 
-  // prop.access?.() is property test and should allow loose property access
-  // but x?.(prop.access) is not
   @Test
-  public void getNotFirstChildOfOptChainCallNotAllowLoosePropertyAccess() {
-    disableStrictMissingPropertyChecks();
+  public void testInterfaceInstantiation() {
     newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  return false;",
-            "}",
-            "f?.(x.y)")
-        .addDiagnostic("Property y never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .addSource("/** @interface */var f = function(){}; new f")
+        .addDiagnostic("cannot instantiate non-constructor")
         .run();
   }
 
-  // prop.access?.[x] is property test and should allow loose property access
-  // but x?.[prop.access] is not
   @Test
-  public void getNotFirstChildOfOptionalGetElemNotAllowLoosePropertyAccess() {
+  public void testPrototypeLoop() {
     disableStrictMissingPropertyChecks();
-    newTest()
-        .addSource(
-            "/** @param {?Object} x */", //
-            "function f(x) {",
-            "  x?.[y.z];",
-            "}")
-        .addDiagnostic("Property z never defined on y" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .run();
+
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @constructor \n * @extends {T} */var T = function() {};"
+            + "alert((new T).foo);",
+        ImmutableList.of(
+            "Cycle detected in inheritance chain of type T",
+            "Could not resolve type in @extends tag of T"));
   }
 
   @Test
-  public void testOptChainGetPropProvidesThisForMethodCall() {
-    newTest()
-        .addSource(
-            "class A {",
-            "  foo() {}",
-            "}",
-            "/** @param {?A} a */",
-            "function f(a) {",
-            // TypeCheck should not complain that foo() is getting called without a correctly typed
-            // `this` value.
-            "  a?.foo();",
-            "}",
-            "",
-            "")
-        .run();
+  public void testImplementsLoop() {
+    testClosureTypesMultipleWarnings(
+        lines(
+            "/** @constructor \n * @implements {T} */var T = function() {};",
+            suppressMissingPropertyFor("T", "foo"),
+            "alert((new T).foo);"),
+        ImmutableList.of("Cycle detected in inheritance chain of type T"));
   }
 
   @Test
-  public void testReflectObject1() {
-    testClosureTypes(
-        "goog.reflect = {}; "
-            + "goog.reflect.object = function(x, y){};"
-            + "/** @constructor */ function A() {}"
-            + "goog.reflect.object(A, {x: 3});",
-        null);
+  public void testImplementsExtendsLoop() {
+    disableStrictMissingPropertyChecks();
+
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @constructor \n * @implements {F} */var G = function() {};"
+            + "/** @constructor \n * @extends {G} */var F = function() {};"
+            + "alert((new F).foo);",
+        ImmutableList.of("Cycle detected in inheritance chain of type F"));
   }
 
+  // TODO(johnlenz): This test causes an infinite loop,
   @Test
-  public void testReflectObject2() {
-    testClosureTypes(
-        "goog.reflect = {}; "
-            + "goog.reflect.object = function(x, y){};"
-            + "/** @param {string} x */ function f(x) {}"
-            + "/** @constructor */ function A() {}"
-            + "goog.reflect.object(A, {x: f(1 + 1)});",
-        "actual parameter 1 of f does not match formal parameter\n"
-            + "found   : number\n"
-            + "required: string");
+  @Ignore
+  public void testInterfaceExtendsLoop() {
+    testClosureTypesMultipleWarnings(
+        lines(
+            "/** @interface \n * @extends {F} */var G = function() {};",
+            "/** @interface \n * @extends {G} */var F = function() {};",
+            "/** @constructor \n * @implements {F} */var H = function() {};",
+            suppressMissingPropertyFor("H", "foo"),
+            "alert((new H).foo);"),
+        ImmutableList.of(
+            "extends loop involving F, " + "loop: F -> G -> F",
+            "extends loop involving G, " + "loop: G -> F -> G"));
   }
 
   @Test
-  public void testLends1() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends */ ({bar: 1}));")
-        .addDiagnostic(
-            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK)
-        .run();
+  public void testInterfaceExtendsLoop2() {
+    testClosureTypes(
+        lines(
+            "/** @record \n * @extends {F} */var G = function() {};",
+            "/** @record \n * @extends {G} */var F = function() {};",
+            "/** @constructor \n * @implements {F} */var H = function() {};",
+            suppressMissingPropertyFor("H", "foo"),
+            "alert((new H).foo);"),
+        "Cycle detected in inheritance chain of type F");
   }
 
   @Test
-  public void testLends2() {
+  public void testInheritPropFromMultipleInterfaces1() {
+    // Low#prop gets the type of whichever property is declared last,
+    // even if that type is not the most specific.
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foob} */ ({bar: 1}));")
-        .addDiagnostic("Variable Foob not declared before @lends annotation.")
+            "/** @interface */",
+            "function High1() {}",
+            "/** @type {number|string} */",
+            "High1.prototype.prop;",
+            "/** @interface */",
+            "function High2() {}",
+            "/** @type {number} */",
+            "High2.prototype.prop;",
+            "/**",
+            " * @interface",
+            " * @extends {High1}",
+            " * @extends {High2}",
+            " */",
+            "function Low() {}",
+            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : (number|string)",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testLends3() {
+  public void testInheritPropFromMultipleInterfaces2() {
+    // Low#prop gets the type of whichever property is declared last,
+    // even if that type is not the most specific.
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, {bar: 1});"
-                + "alert(Foo.bar);")
-        .addDiagnostic("Property bar never defined on Foo")
+            "/** @interface */",
+            "function High1() {}",
+            "/** @type {number} */",
+            "High1.prototype.prop;",
+            "/** @interface */",
+            "function High2() {}",
+            "/** @type {number|string} */",
+            "High2.prototype.prop;",
+            "/**",
+            " * @interface",
+            " * @extends {High1}",
+            " * @extends {High2}",
+            " */",
+            "function Low() {}",
+            "function f(/** !Low */ x) { var /** null */ n = x.prop; }")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testLends4() {
+  public void testInheritPropFromMultipleInterfaces3() {
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));"
-                + "alert(Foo.bar);")
+            "/**",
+            " * @interface",
+            " * @template T1",
+            " */",
+            "function MyCollection() {}",
+            "/**",
+            " * @interface",
+            " * @template T2",
+            " * @extends {MyCollection<T2>}",
+            " */",
+            "function MySet() {}",
+            "/**",
+            " * @interface",
+            " * @template T3,T4",
+            " */",
+            "function MyMapEntry() {}",
+            "/**",
+            " * @interface",
+            " * @template T5,T6",
+            " */",
+            "function MyMultimap() {}",
+            "/** @return {MyCollection<MyMapEntry<T5, T6>>} */",
+            "MyMultimap.prototype.entries = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T7,T8",
+            " * @extends {MyMultimap<T7, T8>}",
+            " */",
+            "function MySetMultimap() {}",
+            "/** @return {MySet<MyMapEntry<T7, T8>>} */",
+            "MySetMultimap.prototype.entries = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T9,T10",
+            " * @extends {MyMultimap<T9, T10>}",
+            " */",
+            "function MyFilteredMultimap() {}",
+            "/**",
+            " * @interface",
+            " * @template T11,T12",
+            " * @extends {MyFilteredMultimap<T11, T12>}",
+            " * @extends {MySetMultimap<T11, T12>}",
+            " */",
+            "function MyFilteredSetMultimap() {}")
         .run();
   }
 
   @Test
-  public void testLends5() {
+  public void testInheritSameGenericInterfaceFromDifferentPaths() {
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, {bar: 1});"
-                + "alert((new Foo()).bar);")
-        .addDiagnostic("Property bar never defined on Foo")
+            "/** @const */ var ns = {};",
+            "/**",
+            " * @constructor",
+            " * @template T1",
+            " */",
+            "ns.Foo = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T2",
+            " */",
+            "ns.High = function() {};",
+            "/** @type {!ns.Foo<T2>} */",
+            "ns.High.prototype.myprop;",
+            "/**",
+            " * @interface",
+            " * @template T3",
+            " * @extends {ns.High<T3>}",
+            " */",
+            "ns.Med1 = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T4",
+            " * @extends {ns.High<T4>}",
+            " */",
+            "ns.Med2 = function() {};",
+            "/**",
+            " * @interface",
+            " * @template T5",
+            " * @extends {ns.Med1<T5>}",
+            " * @extends {ns.Med2<T5>}",
+            " */",
+            "ns.Low = function() {};")
         .run();
   }
 
   @Test
-  public void testLends6() {
-    newTest()
-        .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));"
-                + "alert((new Foo()).bar);")
-        .run();
+  public void testConversionFromInterfaceToRecursiveConstructor() {
+    testClosureTypesMultipleWarnings(
+        suppressMissingProperty("foo")
+            + "/** @interface */ var OtherType = function() {}\n"
+            + "/** @implements {MyType} \n * @constructor */\n"
+            + "var MyType = function() {}\n"
+            + "/** @type {MyType} */\n"
+            + "var x = /** @type {!OtherType} */ (new Object());",
+        ImmutableList.of(
+            "Cycle detected in inheritance chain of type MyType",
+            "initializing variable\n" + "found   : OtherType\n" + "required: (MyType|null)"));
   }
 
   @Test
-  public void testLends7() {
+  public void testDirectPrototypeAssign() {
+    // For now, we just ignore @type annotations on the prototype.
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @constructor */ function Foo() {}"
-                + "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));")
-        .addDiagnostic("Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK)
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @type {Array} */ Bar.prototype = new Foo()")
         .run();
   }
 
+  // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only
+  // be resolved via the registry and not via properties.
+
   @Test
-  public void testLends8() {
+  public void testResolutionViaRegistry1() {
     newTest()
         .addSource(
-            "function extend(x, y) {}"
-                + "/** @type {number} */ var Foo = 3;"
-                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));")
-        .addDiagnostic("May only lend properties to object types. Foo has type number.")
+            "/** @constructor */ u.T = function() {};\n"
+                + "/** @type {(number|string)} */ u.T.prototype.a;\n"
+                + "/**\n"
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testLends9() {
-    testClosureTypesMultipleWarnings(
-        "function extend(x, y) {}"
-            + "/** @constructor */ function Foo() {}"
-            + "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
-        ImmutableList.of(
-            "Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK,
-            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK));
-  }
-
-  @Test
-  public void testLends10() {
+  public void testResolutionViaRegistry2() {
     newTest()
         .addSource(
-            "function defineClass(x) { return function() {}; } "
-                + "/** @constructor */"
-                + "var Foo = defineClass("
-                + "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));"
-                + "/** @return {string} */ function f() { return (new Foo()).bar; }")
+            "/** @constructor */ u.T = function() {"
+                + "  this.a = 0; };\n"
+                + "/**\n"
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
         .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testLends11() {
+  public void testResolutionViaRegistry3() {
     newTest()
         .addSource(
-            "function defineClass(x, y) { return function() {}; } "
-                + "/** @constructor */"
-                + "var Foo = function() {};"
-                + "/** @return {*} */ Foo.prototype.bar = function() { return 3; };"
+            "/** @constructor */ u.T = function() {};\n"
+                + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n"
                 + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "var SubFoo = defineClass(Foo, "
-                + "    /** @lends {SubFoo.prototype} */ ({\n"
-                + "      /** @override @return {number} */ bar: function() { return 3; }}));"
-                + "/** @return {string} */ function f() { return (new SubFoo()).bar(); }")
-        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
+                + "* @param {u.T} t\n"
+                + "* @return {string}\n"
+                + "*/\n"
+                + "var f = function(t) { return t.a; };")
+        .addDiagnostic(
+            "inconsistent return type\n" + "found   : (number|string)\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testDeclaredNativeTypeEquality() {
-    Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType());
+  public void testResolutionViaRegistry4() {
+    newTest()
+        .addSource(
+            "/** @constructor */ u.A = function() {};\n"
+                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;"
+                + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n"
+                + "var ab = new u.A.B();\n"
+                + "/** @type {!u.A} */ var a = ab;\n"
+                + "/** @type {!u.A.A} */ var aa = ab;\n")
+        .addDiagnostic("initializing variable\n" + "found   : u.A.B\n" + "required: u.A.A")
+        .run();
   }
 
   @Test
-  public void testUndefinedVar() {
-    Node n = parseAndTypeCheck("var undefined;");
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstFirstChild().getJSType());
+  public void testResolutionViaRegistry5() {
+    Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertThat(type).isInstanceOf(FunctionType.class);
+    assertThat(((FunctionType) type).getInstanceType().getReferenceName()).isEqualTo("u.T");
   }
 
   @Test
-  public void testFlowScopeBug1() {
+  public void testGatherProperyWithoutAnnotation1() {
     Node n =
         parseAndTypeCheck(
-            "/** @param {number} a \n"
-                + "* @param {number} b */\n"
-                + "function f(a, b) {\n"
-                + "/** @type {number} */"
-                + "var i = 0;"
-                + "for (; (i + a) < b; ++i) {}}");
-
-    // check the type of the add node for i + f
-    assertTypeEquals(
-        registry.getNativeType(JSTypeNative.NUMBER_TYPE),
-        n.getFirstChild()
-            .getLastChild()
-            .getLastChild()
-            .getFirstChild()
-            .getNext()
-            .getFirstChild()
-            .getJSType());
+            "/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;");
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertThat(type).isInstanceOf(ObjectType.class);
+    ObjectType objectType = (ObjectType) type;
+    assertThat(objectType.hasProperty("x")).isFalse();
   }
 
   @Test
-  public void testFlowScopeBug2() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {};\n"
-                + "Foo.prototype.hi = false;"
-                + "function foo(a, b) {\n"
-                + "  /** @type {Array} */"
-                + "  var arr;"
-                + "  /** @type {number} */"
-                + "  var iter;"
-                + "  for (iter = 0; iter < arr.length; ++ iter) {"
-                + "    /** @type {Foo} */"
-                + "    var afoo = arr[iter];"
-                + "    afoo;"
-                + "  }"
-                + "}");
-
-    // check the type of afoo when referenced
-    assertTypeEquals(
-        registry.createNullableType(registry.getGlobalType("Foo")),
-        n.getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getLastChild()
-            .getJSType());
+  public void testGatherProperyWithoutAnnotation2() {
+    TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;");
+    Node n = ns.root;
+    JSType type = n.getLastChild().getLastChild().getJSType();
+    assertThat(type.isUnknownType()).isFalse();
+    assertTypeEquals(type, getNativeObjectType());
+    assertThat(type).isInstanceOf(ObjectType.class);
+    ObjectType objectType = (ObjectType) type;
+    assertThat(objectType.hasProperty("x")).isFalse();
   }
 
   @Test
-  public void testAddSingletonGetter() {
-    Node n =
-        parseAndTypeCheck(
-            "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);");
-    ObjectType o = (ObjectType) n.getFirstChild().getJSType();
-    assertThat(o.getPropertyType("getInstance").toString()).isEqualTo("function(): Foo");
-    assertThat(o.getPropertyType("instance_").toString()).isEqualTo("Foo");
+  public void testFunctionMasksVariableBug() {
+    newTest()
+        .addSource("var x = 4; var f = function x(b) { return b ? 1 : x(true); };")
+        .addDiagnostic("function x masks variable (IE bug)")
+        .run();
   }
 
   @Test
-  public void testTypeCheckStandaloneAST() {
-    Node externs = IR.root();
-    Node firstScript = compiler.parseTestCode("function Foo() { }");
-    typeCheck(firstScript);
-    Node root = IR.root(externs, IR.root(firstScript.detach()));
-    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
-    TypedScope topScope = scopeCreator.createScope(root, null);
-
-    Node secondScript = compiler.parseTestCode("new Foo");
-
-    firstScript.replaceWith(secondScript);
-
-    new TypeCheck(
-            compiler,
-            new SemanticReverseAbstractInterpreter(registry),
-            registry,
-            topScope,
-            scopeCreator)
-        .process(externs, secondScript.getParent());
-
-    assertThat(compiler.getWarningCount()).isEqualTo(1);
-    assertThat(compiler.getWarnings().get(0).getDescription())
-        .isEqualTo("cannot instantiate non-constructor");
+  public void testDfa1() {
+    newTest().addSource("var x = null;\n x = 1;\n /** @type {number} */ var y = x;").run();
   }
 
   @Test
-  public void testUpdateParameterTypeOnClosure() {
+  public void testDfa2() {
     newTest()
-        .addExterns(
-            "/**\n"
-                + "* @constructor\n"
-                + "* @param {*=} opt_value\n"
-                + "* @return {!Object}\n"
-                + "*/\n"
-                + "function Object(opt_value) {}\n"
-                + "/**\n"
-                + "* @constructor\n"
-                + "* @param {...*} var_args\n"
-                + "*/\n"
-                + "function Function(var_args) {}\n"
-                + "/**\n"
-                + "* @type {Function}\n"
-                + "*/\n"
-                +
-                // The line below sets JSDocInfo on Object so that the type of the
-                // argument to function f has JSDoc through its prototype chain.
-                "Object.prototype.constructor = function() {};\n")
         .addSource(
-            "/**\n"
-                + "* @param {function(): boolean} fn\n"
-                + "*/\n"
-                + "function f(fn) {}\n"
-                + "f(function() { });\n")
+            "function u() {}\n"
+                + "/** @return {number} */ function f() {\nvar x = 'todo';\n"
+                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
+        .run();
+  }
+
+  @Test
+  public void testDfa3() {
+    newTest()
+        .addSource(
+            "function u() {}\n"
+                + "/** @return {number} */ function f() {\n"
+                + "/** @type {number|string} */ var x = 'todo';\n"
+                + "if (u()) { x = 1; } else { x = 2; } return x;\n}")
         .run();
   }
 
   @Test
-  public void testTemplatedThisType1() {
+  public void testDfa4() {
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "/**\n"
-                + " * @this {T}\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "Foo.prototype.method = function() {};\n"
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @extends {Foo}\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "var g = new Bar().method();\n"
-                + "/**\n"
-                + " * @param {number} a\n"
-                + " */\n"
-                + "function compute(a) {};\n"
-                + "compute(g);\n")
-        .addDiagnostic(
-            "actual parameter 1 of compute does not match formal parameter\n"
-                + "found   : Bar\n"
-                + "required: number")
+            "/** @param {Date?} d */ function f(d) {\n"
+                + "if (!d) { return; }\n"
+                + "/** @type {!Date} */ var e = d;\n}")
         .run();
   }
 
   @Test
-  public void testTemplatedThisType2() {
+  public void testDfa5() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @this {Array<T>|{length:number}}\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "Array.prototype.method = function() {};\n"
-                + "(function(){\n"
-                + "  Array.prototype.method.call(arguments);"
-                + "})();")
-        .includeDefaultExterns()
+            "/** @return {string?} */ function u() {return 'a';}\n"
+                + "/** @param {string?} x\n@return {string} */ function f(x) {\n"
+                + "while (!x) { x = u(); }\nreturn x;\n}")
         .run();
   }
 
   @Test
-  public void testTemplateType1() {
+  public void testDfa6() {
     newTest()
         .addSource(
-            "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {T} y\n"
-                + "* @param {function(this:T, ...)} z\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y, z) {}\n"
-                + "f(this, this, function() { this });")
+            "/** @return {Object?} */ function u() {return {};}\n"
+                + "/** @param {Object?} x */ function f(x) {\n"
+                + "while (x) { x = u(); if (!x) { x = u(); } }\n}")
         .run();
   }
 
   @Test
-  public void testTemplateType2() {
-    // "this" types need to be coerced for ES3 style function or left
-    // allow for ES5-strict methods.
+  public void testDfa7() {
     newTest()
         .addSource(
-            "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(0, function() {});")
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @type {Date?} */ T.prototype.x = null;\n"
+                + "/** @param {!T} t */ function f(t) {\n"
+                + "if (!t.x) { return; }\n"
+                + "/** @type {!Date} */ var e = t.x;\n}")
         .run();
   }
 
   @Test
-  public void testTemplateType3() {
+  public void testDfa8() {
     newTest()
         .addSource(
-            "/**"
-                + " * @param {T} v\n"
-                + " * @param {function(T)} f\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function call(v, f) { f.call(null, v); }"
-                + "/** @type {string} */ var s;"
-                + "call(3, function(x) {"
-                + " x = true;"
-                + " s = x;"
-                + "});")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: string")
-        .includeDefaultExterns()
+            "/** @constructor */ var T = function() {};\n"
+                + "/** @type {number|string} */ T.prototype.x = '';\n"
+                + "function u() {}\n"
+                + "/** @param {!T} t\n@return {number} */ function f(t) {\n"
+                + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}")
         .run();
   }
 
   @Test
-  public void testTemplateType4() {
+  public void testDfa9() {
     newTest()
         .addSource(
-            "/**"
-                + " * @param {...T} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(3, null);")
-        .addDiagnostic("assignment\n" + "found   : (null|number)\n" + "required: Object")
+            "function f() {\n/** @type {string?} */var x;\nx = null;\n"
+                + "if (x == null) { return 0; } else { return 1; } }")
+        .addDiagnostic("condition always evaluates to true\n" + "left : null\n" + "right: null")
         .run();
   }
 
   @Test
-  public void testTemplateType5() {
+  public void testDfa10() {
     newTest()
         .addSource(
-            "const CGI_PARAM_RETRY_COUNT = 'rc';",
-            "",
-            "/**",
-            " * @param {...T} p",
-            " * @return {T} ",
-            " * @template T",
-            " */",
-            "function fn(p) { return p; }",
-            "/** @type {!Object} */ var x;",
-            "",
-            "/** @return {void} */",
-            "function aScope() {",
-            "  x = fn(CGI_PARAM_RETRY_COUNT, 1);",
-            "}")
+            "/** @param {null} x */ function g(x) {}"
+                + "/** @param {string?} x */function f(x) {\n"
+                + "if (!x) { x = ''; }\n"
+                + "if (g(x)) { return 0; } else { return 1; } }")
         .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : (number|string)",
-                "required: Object"))
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: null")
         .run();
   }
 
   @Test
-  public void testTemplateType6() {
+  public void testDfa11() {
     newTest()
         .addSource(
-            "/**"
-                + " * @param {Array<T>} arr \n"
-                + " * @param {?function(T)} f \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(arr, f) { return arr[0]; }\n"
-                + "/** @param {Array<number>} arr */ function g(arr) {"
-                + "  /** @type {!Object} */ var x = fn.call(null, arr, null);"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
-        .includeDefaultExterns()
+            "/** @param {string} opt_x\n@return {string} */\n"
+                + "function f(opt_x) { if (!opt_x) { "
+                + "throw new Error('x cannot be empty'); } return opt_x; }")
         .run();
   }
 
   @Test
-  public void testTemplateType7() {
-    this.newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
+  public void testDfa12() {
+    newTest()
         .addSource(
-            "/** @type {!Array<string>} */", //
-            "var query = [];",
-            "query.push(1);")
+            "/** @param {string} x \n * @constructor \n */"
+                + "var Bar = function(x) {};"
+                + "/** @param {string} x */ function g(x) { return true; }"
+                + "/** @param {string|number} opt_x */ "
+                + "function f(opt_x) { "
+                + "  if (opt_x) { new Bar(g(opt_x) && 'x'); }"
+                + "}")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of Array.prototype.push does not match formal parameter",
-                "found   : number",
-                "required: string"))
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : (number|string)\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplateType8() {
+  public void testDfa13() {
     newTest()
         .addSource(
-            "/** @constructor \n"
-                + " * @template S,T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "/**"
-                + " * @param {Bar<T>} bar \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(bar) {}\n"
-                + "/** @param {Bar<number>} bar */ function g(bar) {"
-                + "  /** @type {!Object} */ var x = fn(bar);"
+            "/**\n"
+                + " * @param {string} x \n"
+                + " * @param {number} y \n"
+                + " * @param {number} z \n"
+                + " */"
+                + "function g(x, y, z) {}"
+                + "function f() { "
+                + "  var x = 'a'; g(x, x = 3, x);"
                 + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testTemplateType9() {
-    // verify interface type parameters are recognized.
+  public void testTypeInferenceWithCast1() {
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @template S,T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "/**"
-                + " * @param {Bar<T>} bar \n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(bar) {}\n"
-                + "/** @param {Bar<number>} bar */ function g(bar) {"
-                + "  /** @type {!Object} */ var x = fn(bar);"
-                + "}")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
+            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
+                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
+                + "/**@return {number?}*/function g(x) {"
+                + "var y = /**@type {number?}*/(u(x)); return f(y);}")
         .run();
   }
 
   @Test
-  public void testTemplateType10() {
-    // verify a type parameterized with unknown can be assigned to
-    // the same type with any other type parameter.
+  public void testTypeInferenceWithCast2() {
     newTest()
         .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Bar() {}\n"
-                + "\n"
-                + ""
-                + "/** @type {!Bar<?>} */ var x;"
-                + "/** @type {!Bar<number>} */ var y;"
-                + "y = x;")
+            "/**@return {(number|null|undefined)}*/function u(x) {return null;}"
+                + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}"
+                + "/**@return {number?}*/function g(x) {"
+                + "var y; y = /**@type {number?}*/(u(x)); return f(y);}")
+        .run();
+  }
+
+  @Test
+  public void testTypeInferenceWithCast3() {
+    newTest()
+        .addSource(
+            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
+                + "/**@return {number}*/function g(x) {"
+                + "return /**@type {number}*/(u(x));}")
+        .run();
+  }
+
+  @Test
+  public void testTypeInferenceWithCast4() {
+    newTest()
+        .addSource(
+            "/**@return {(number|null|undefined)}*/function u(x) {return 1;}"
+                + "/**@return {number}*/function g(x) {"
+                + "return /**@type {number}*/(u(x)) && 1;}")
         .run();
   }
 
   @Test
-  public void testTemplateType11() {
-    // verify that assignment/subtype relationships work when extending
-    // templatized types.
+  public void testTypeInferenceWithCast5() {
     newTest()
         .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @extends {Foo<string>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @extends {Foo<number>}\n"
-                + " */\n"
-                + "function B() {}\n"
-                + ""
-                + "/** @type {!Foo<string>} */ var a = new A();\n"
-                + "/** @type {!Foo<string>} */ var b = new B();")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
+            "/** @param {number} x */ function foo(x) {}"
+                + "/** @param {{length:*}} y */ function bar(y) {"
+                + "  /** @type {string} */ y.length;"
+                + "  foo(y.length);"
+                + "}")
+        .addDiagnostic(
+            "actual parameter 1 of foo does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testTemplateType12() {
-    // verify that assignment/subtype relationships work when implementing
-    // templatized types.
+  public void testTypeInferenceWithClosure1() {
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {Foo<string>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {Foo<number>}\n"
-                + " */\n"
-                + "function B() {}\n"
-                + ""
-                + "/** @type {!Foo<string>} */ var a = new A();\n"
-                + "/** @type {!Foo<string>} */ var b = new B();")
-        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
+            "/** @return {boolean} */"
+                + "function f() {"
+                + "  /** @type {?string} */ var x = null;"
+                + "  function g() { x = 'y'; } g(); "
+                + "  return x == null;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testTemplateType13() {
-    // verify that assignment/subtype relationships work when extending
-    // templatized types.
+  public void testTypeInferenceWithClosure2() {
     newTest()
         .addSource(
-            "/** @constructor \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @template T\n"
-                + " * @extends {Foo<T>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "var a1 = new A();\n"
-                + "var a2 = /** @type {!A<string>} */ (new A());\n"
-                + "var a3 = /** @type {!A<number>} */ (new A());\n"
-                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
-                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
-                + "/** @type {!Foo<string>} */ var f3 = a3;")
+            "/** @return {boolean} */"
+                + "function f() {"
+                + "  /** @type {?string} */ var x = null;"
+                + "  function g() { x = 'y'; } g(); "
+                + "  return x === 3;"
+                + "}")
         .addDiagnostic(
-            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
+            "condition always evaluates to false\n" + "left : (null|string)\n" + "right: number")
         .run();
   }
 
   @Test
-  public void testTemplateType14() {
-    // verify that assignment/subtype relationships work when implementing
-    // templatized types.
+  public void testTypeInferenceWithNoEntry1() {
     newTest()
         .addSource(
-            "/** @interface \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @template T\n"
-                + " * @implements {Foo<T>}\n"
-                + " */\n"
-                + "function A() {}\n"
-                + ""
-                + "var a1 = new A();\n"
-                + "var a2 = /** @type {!A<string>} */ (new A());\n"
-                + "var a3 = /** @type {!A<number>} */ (new A());\n"
-                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
-                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
-                + "/** @type {!Foo<string>} */ var f3 = a3;")
+            "/** @param {number} x */ function f(x) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.init = function() {"
+                + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
+                + "};"
+                + "/**\n"
+                + " * @extends {Foo}\n"
+                + " * @constructor\n"
+                + " */"
+                + "function SubFoo() {}"
+                + "/** Method */"
+                + "SubFoo.prototype.method = function() {"
+                + "  for (var i = 0; i < 10; i++) {"
+                + "    f(this.bar);"
+                + "    f(this.bar.baz);"
+                + "  }"
+                + "};")
         .addDiagnostic(
-            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : (null|{baz: number})\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testTemplateType15() {
+  public void testTypeInferenceWithNoEntry2() {
+    testClosureTypes(
+        "/** @param {number} x */ function f(x) {}"
+            + "/** @param {!Object} x */ function g(x) {}"
+            + "/** @constructor */ function Foo() {}"
+            + "Foo.prototype.init = function() {"
+            + "  /** @type {?{baz: number}} */ this.bar = {baz: 3};"
+            + "};"
+            + "/**\n"
+            + " * @extends {Foo}\n"
+            + " * @constructor\n"
+            + " */"
+            + "function SubFoo() {}"
+            + "/** Method */"
+            + "SubFoo.prototype.method = function() {"
+            + "  for (var i = 0; i < 10; i++) {"
+            + "    f(this.bar);"
+            + "    goog.asserts.assert(this.bar);"
+            + "    g(this.bar);"
+            + "  }"
+            + "};",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : (null|{baz: number})\n"
+            + "required: number");
+  }
+
+  @Test
+  public void testForwardPropertyReference() {
     newTest()
         .addSource(
-            "/**"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn({foo:3});")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
+            "/** @constructor */ var Foo = function() { this.init(); };"
+                + "/** @return {string} */"
+                + "Foo.prototype.getString = function() {"
+                + "  return this.number_;"
+                + "};"
+                + "Foo.prototype.init = function() {"
+                + "  /** @type {number} */"
+                + "  this.number_ = 3;"
+                + "};")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplateType16() {
+  public void testNoForwardTypeDeclaration() {
     newTest()
-        .addSource(
-            "/** @constructor */ function C() {\n"
-                + "  /** @type {number} */ this.foo = 1\n"
-                + "}\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(new C());")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
+        .addSource("/** @param {MyType} x */ function f(x) {}")
+        .addDiagnostic("Bad type annotation. Unknown type MyType")
+        .run();
+  }
+
+  @Test
+  public void testNoForwardTypeDeclarationAndNoBraces() {
+    newTest()
+        .addSource("/** @return The result. */ function f() {}")
+        .addDiagnostic(RhinoErrorReporter.JSDOC_MISSING_TYPE_WARNING)
         .run();
   }
 
   @Test
-  public void testTemplateType17() {
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "C.prototype.foo = 1;\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn(new C());")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
-        .run();
+  public void testForwardTypeDeclaration2() {
+    String f = "goog.forwardDeclare('MyType');" + "/** @param {MyType} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(
+        f + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: (MyType|null)");
+  }
+
+  @Test
+  public void testForwardTypeDeclaration3() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */ function f(x) { return x; }"
+            + "/** @constructor */ var MyType = function() {};"
+            + "f(3);",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: (MyType|null)");
+  }
+
+  @Test
+  public void testForwardTypeDeclaration4() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */ function f(x) { return x; }"
+            + "/** @constructor */ var MyType = function() {};"
+            + "f(new MyType());",
+        null);
+  }
+
+  @Test
+  public void testForwardTypeDeclaration5() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @constructor\n"
+            + " * @extends {MyType}\n"
+            + " */ var YourType = function() {};"
+            + "/** @override */ YourType.prototype.method = function() {};",
+        "Could not resolve type in @extends tag of YourType");
+  }
+
+  @Test
+  public void testForwardTypeDeclaration6() {
+    testClosureTypesMultipleWarnings(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @constructor\n"
+            + " * @implements {MyType}\n"
+            + " */ var YourType = function() {};"
+            + "/** @override */ YourType.prototype.method = function() {};",
+        ImmutableList.of(
+            "Could not resolve type in @implements tag of YourType",
+            "property method not defined on any superclass of YourType"));
+  }
+
+  @Test
+  public void testForwardTypeDeclaration7() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType=} x */"
+            + "function f(x) { return x == undefined; }",
+        null);
   }
 
   @Test
-  public void testTemplateType18() {
-    // Until template types can be restricted to exclude undefined, they
-    // are always optional.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {}\n"
-                + "C.prototype.foo = 1;\n"
-                + "/**\n"
-                + " * @param {{foo:T}} p\n"
-                + " * @return {T} \n"
-                + " * @template T\n"
-                + " */\n"
-                + "function fn(p) { return p.foo; }\n"
-                + "/** @type {!Object} */ var x;"
-                + "x = fn({});")
-        .run();
+  public void testForwardTypeDeclaration8() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */"
+            + "function f(x) { return x.name == undefined; }",
+        null);
   }
 
   @Test
-  public void testTemplateType19() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {T} t\n"
-                + " * @param {U} u\n"
-                + " * @return {{t:T, u:U}} \n"
-                + " * @template T,U\n"
-                + " */\n"
-                + "function fn(t, u) { return {t:t, u:u}; }\n"
-                + "/** @type {null} */ var x = fn(1, 'str');")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : {\n  t: number,\n  u: string\n}\n"
-                + "required: null")
-        .run();
+  public void testForwardTypeDeclaration9() {
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/** @param {MyType} x */"
+            + "function f(x) { x.name = 'Bob'; }",
+        null);
   }
 
   @Test
-  public void testTemplateType20() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @constructor */ function C() {\n"
-                + "  /** @type {void} */ this.x;\n"
-                + "}\n"
-                + "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(new C, /** @param {number} a */ function(a) {this.x = a;});")
-        .addDiagnostic(
-            "assignment to property x of C\n" + "found   : number\n" + "required: undefined")
-        .run();
+  public void testForwardTypeDeclaration10() {
+    String f =
+        "goog.forwardDeclare('MyType');" + "/** @param {MyType|number} x */ function f(x) { }";
+    testClosureTypes(f, null);
+    testClosureTypes(f + "f(3);", null);
+    testClosureTypes(
+        f + "f('3');",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : string\n"
+            + "required: (MyType|null|number)");
   }
 
   @Test
-  public void testTemplateType21() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor @implements {A<Bar>} */\n"
-                + "function Bar() {}\n"
-                + "/** @type {!Foo} */\n"
-                + "var x = new Bar();\n")
-        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Foo")
-        .run();
+  public void testForwardTypeDeclaration12() {
+    // We assume that {Function} types can produce anything, and don't
+    // want to type-check them.
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @param {!Function} ctor\n"
+            + " * @return {MyType}\n"
+            + " */\n"
+            + "function f(ctor) { return new ctor(); }",
+        null);
   }
 
   @Test
-  public void testTemplateType22() {
-    // "this" types is inferred when the parameters are declared.
-    newTest()
-        .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @interface @template T */ function B() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @constructor @implements {B<Foo>} */\n"
-                + "function Bar() {}\n"
-                + "/** @constructor @implements {B<Foo>} */\n"
-                + "function Qux() {}\n"
-                + "/** @type {!Qux} */\n"
-                + "var x = new Bar();\n")
-        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Qux")
-        .run();
+  public void testForwardTypeDeclaration13() {
+    // Some projects use {Function} registries to register constructors
+    // that aren't in their binaries. We want to make sure we can pass these
+    // around, but still do other checks on them.
+    testClosureTypes(
+        "goog.forwardDeclare('MyType');"
+            + "/**\n"
+            + " * @param {!Function} ctor\n"
+            + " * @return {MyType}\n"
+            + " */\n"
+            + "function f(ctor) { return (new ctor()).impossibleProp; }",
+        "Property impossibleProp never defined on ?" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION);
   }
 
   @Test
-  public void testTemplateType23() {
-    // "this" types is inferred when the parameters are declared.
+  public void testDuplicateTypeDef() {
     newTest()
         .addSource(
-            "/** @interface @template T */ function A() {}\n"
-                + "/** @constructor @implements {A<Foo>} */\n"
-                + "function Foo() {}\n"
-                + "/** @type {!Foo} */\n"
-                + "var x = new Foo();\n")
+            "var goog = {};",
+            "/** @constructor */ goog.Bar = function() {};",
+            "/** @typedef {number} */ goog.Bar;")
+        .addDiagnostic(
+            "variable goog.Bar redefined with type None, "
+                + "original definition at [testcode]:2 "
+                + "with type (typeof goog.Bar)")
         .run();
   }
 
   @Test
-  public void testTemplateType24() {
-    // Recursive templated type definition.
+  public void testTypeDef1() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " * @param {T} x",
-            " */",
-            "function Foo(x) {",
-            "  /** @type {T} */",
-            "  this.p = x;",
-            "}",
-            "/** @return {Foo<Foo<T>>} */",
-            "Foo.prototype.m = function() {",
-            "  return null;",
-            "};",
-            "/** @return {T} */",
-            "Foo.prototype.get = function() {",
-            "  return this.p;",
-            "};",
-            "var /** null */ n = new Foo(new Object).m().get();")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Foo<Object>|null)\n" + "required: null")
+            "var goog = {};"
+                + "/** @typedef {number} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f(3);")
         .run();
   }
 
   @Test
-  public void testTemplateType25() {
-    // Non-nullable recursive templated type definition.
+  public void testTypeDef2() {
     newTest()
         .addSource(
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " * @param {T} x",
-            " */",
-            "function Foo(x) {",
-            "  /** @type {T} */",
-            "  this.p = x;",
-            "}",
-            "/** @return {!Foo<!Foo<T>>} */",
-            "Foo.prototype.m = function() {",
-            "  return new Foo(new Foo(new Object));",
-            "};",
-            "/** @return {T} */",
-            "Foo.prototype.get = function() {",
-            "  return this.p;",
-            "};",
-            "var /** null */ n = new Foo(new Object).m().get();")
-        .addDiagnostic("initializing variable\n" + "found   : Foo<Object>\n" + "required: null")
+            "var goog = {};"
+                + "/** @typedef {number} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f('3');")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testTemplateType26() {
-    // Class hierarchies which use the same template parameter name should not be treated as
-    // infinite recursion.
-    newTest()
-        .addSource(
-            "/**",
-            " * @param {T} bar",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function Bar(bar) {",
-            "  /** @type {T} */",
-            "  this.bar = bar;",
-            "}",
-            "/** @return {T} */",
-            "Bar.prototype.getBar = function() {",
-            "  return this.bar;",
-            "};",
-            "/**",
-            " * @param {T} foo",
-            " * @constructor",
-            " * @template T",
-            " * @extends {Bar<!Array<T>>}",
-            " */",
-            "function Foo(foo) {",
-            "  /** @type {T} */",
-            "  this.foo = foo;",
-            "}",
-            "var /** null */ n = new Foo(new Object).getBar();")
-        .addDiagnostic("initializing variable\n" + "found   : Array<Object>\n" + "required: null")
+  public void testTypeDef3() {
+    newTest()
+        .addSource(
+            "var goog = {};"
+                + "/** @typedef {number} */ var Bar;"
+                + "/** @param {Bar} x */ function f(x) {}"
+                + "f('3');")
+        .addDiagnostic(
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : string\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testTemplateTypeCollidesWithParameter() {
-    // Function templates are in the same scope as parameters, so cannot collide.
+  public void testTypeDef4() {
     newTest()
         .addSource(
-            "/**", //
-            " * @param {T} T",
-            " * @template T",
-            " */",
-            "function f(T) {}")
+            "/** @constructor */ function A() {}"
+                + "/** @constructor */ function B() {}"
+                + "/** @typedef {(A|B)} */ var AB;"
+                + "/** @param {AB} x */ function f(x) {}"
+                + "f(new A()); f(new B()); f(1);")
         .addDiagnostic(
-            "variable T redefined with type undefined, original definition at [testcode]:5 with"
-                + " type T")
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: (A|B|null)")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReference() {
-    // TODO(martinprobst): the test below asserts incorrect behavior for backwards compatibility.
+  public void testTypeDef5() {
+    // Notice that the error message is slightly different than
+    // the one for testTypeDef4, even though they should be the same.
+    // This is an implementation detail necessary for NamedTypes work out
+    // OK, and it should change if NamedTypes ever go away.
     newTest()
         .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
+            "/** @param {AB} x */ function f(x) {}"
+                + "/** @constructor */ function A() {}"
+                + "/** @constructor */ function B() {}"
+                + "/** @typedef {(A|B)} */ var AB;"
+                + "f(new A()); f(new B()); f(1);")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
+            "actual parameter 1 of f does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: (A|B|null)")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReference_declared() {
-    compiler.forwardDeclareType("Foo");
+  public void testCircularTypeDef() {
     newTest()
         .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
+            "var goog = {};"
+                + "/** @typedef {number|Array<goog.Bar>} */ goog.Bar;"
+                + "/** @param {goog.Bar} x */ function f(x) {}"
+                + "f(3); f([3]); f([[3]]);")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReferenceFunctionWithExtra() {
-    // TODO(johnlenz): report an error when forward references contain extraneous
-    // type arguments.
+  public void testGetTypedPercent1() {
+    String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(50.0);
+  }
+
+  @Test
+  public void testGetTypedPercent2() {
+    String js = "var x = {}; x.y = 1;";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testGetTypedPercent3() {
+    String js = "var f = function(x) { x.a = x.b; }";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(25.0);
+  }
+
+  @Test
+  public void testGetTypedPercent4() {
+    String js =
+        "var n = {};\n /** @constructor */ n.T = function() {};\n"
+            + "/** @type {n.T} */ var x = new n.T();";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testGetTypedPercent5() {
+    String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testGetTypedPercent6() {
+    String js = "a = {TRUE: 1, FALSE: 0};";
+    assertThat(getTypedPercent(js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testPrototypePropertyReference() {
+    TypeCheckResult p =
+        parseAndTypeCheckWithScope(
+            DEFAULT_EXTERNS,
+            ""
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "/** @param {number} a */\n"
+                + "Foo.prototype.bar = function(a){};\n"
+                + "/** @param {Foo} f */\n"
+                + "function baz(f) {\n"
+                + "  Foo.prototype.bar.call(f, 3);\n"
+                + "}");
+    assertThat(compiler.getErrorCount()).isEqualTo(0);
+    assertThat(compiler.getWarningCount()).isEqualTo(0);
+
+    assertThat(p.scope.getVar("Foo").getType()).isInstanceOf(FunctionType.class);
+    FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType();
+    assertThat(fooType.getPrototype().getPropertyType("bar").toString())
+        .isEqualTo("function(this:Foo, number): undefined");
+  }
+
+  @Test
+  public void testResolvingNamedTypes() {
+    String externs = new TestExternsBuilder().addObject().build();
+    String js =
+        lines(
+            "/** @constructor */",
+            "var Foo = function() {}",
+            "/** @param {number} a */",
+            "Foo.prototype.foo = function(a) {",
+            "  return this.baz().toString();",
+            "};",
+            "/** @return {Baz} */",
+            "Foo.prototype.baz = function() { return new Baz(); };",
+            "/** @constructor",
+            "  * @extends Foo */",
+            "var Bar = function() {};",
+            "/** @constructor */",
+            "var Baz = function() {};");
+    assertThat(getTypedPercentWithExterns(externs, js)).isWithin(0.1).of(100.0);
+  }
+
+  @Test
+  public void testMissingProperty1a() {
     newTest()
         .addSource(
-            "/** @param {!Foo<string, boolean>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @constructor",
-            " * @template T",
-            " */",
-            "function Foo() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "Foo.prototype.baz = function() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReferenceVar() {
+  public void testMissingProperty1b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @param {!Foo<string>} x */",
-            "function f(x) {}",
-            "",
-            "/**",
-            " * @template T",
-            " * @constructor",
-            " */",
-            "var Foo = function() {}",
-            "",
-            "/** @param {!Foo<number>} x */",
-            "function g(x) {",
-            "  f(x);",
-            "}")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<number>",
-                "required: Foo<string>"))
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.a = 3; };")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReference_declaredMissing() {
-    compiler.forwardDeclareType("Foo");
-    compiler.forwardDeclareType("DoesNotExist");
+  public void testMissingProperty2a() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @param {!Foo<DoesNotExist>} x */", //
-            "function f(x) {}")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.b = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplateTypeForwardReference_extends() {
-    compiler.forwardDeclareType("Bar");
-    compiler.forwardDeclareType("Baz");
+  public void testMissingProperty2b() {
     newTest()
         .addSource(
-            "/** @constructor @extends {Bar<Baz>} */",
-            "function Foo() {}",
-            "/** @constructor */",
-            "function Bar() {}")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.baz = function() { this.b = 3; };")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
   @Test
-  public void testSubtypeNotTemplated1() {
+  public void testMissingProperty3a() {
     newTest()
         .addSource(
-            "/** @interface @template T */ function A() {}",
-            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
-            "function f(/** (!Object|!Foo<string>) */ x) {",
-            "  var /** null */ n = x;",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
-        .run();
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "(new Foo).a = 3;")
+        .addDiagnostic("Property a never defined on Foo") // method
+        .addDiagnostic("Property a never defined on Foo")
+        .run(); // global assignment
   }
 
   @Test
-  public void testSubtypeNotTemplated2() {
+  public void testMissingProperty3b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/** @interface @template T */ function A() {}",
-            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
-            "function f(/** (!Object|!Foo) */ x) {",
-            "  var /** null */ n = x;",
-            "}")
-        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "(new Foo).a = 3;")
         .run();
   }
 
   @Test
-  public void testTemplateTypeWithUnresolvedType() {
-    testClosureTypes(
-        "goog.forwardDeclare('Color');\n"
-            + "/** @interface @template T */ function C() {}\n"
-            + "/** @return {!Color} */ C.prototype.method;\n"
-            + "/** @constructor @implements {C} */ function D() {}\n"
-            + "/** @override */ D.prototype.method = function() {};",
-        null); // no warning expected.
+  public void testMissingProperty4a() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "(new Foo).b = 3;")
+        .addDiagnostic("Property a never defined on Foo")
+        .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef1a() {
+  public void testMissingProperty4b() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + ""
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "/** @type {Generic<!Bar>} */ var y;\n"
-                + ""
-                + "x = y;\n"
-                + // no warning
-                "/** @type {null} */ var z1 = y;\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
+            "/** @constructor */ function Foo() {}", //
+            "(new Foo).b = 3;")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef1b() {
+  public void testMissingProperty5() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + ""
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + ""
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "/** @type {Generic<!Bar>} */ var y;\n"
-                + ""
-                + "y = x;\n"
-                + // no warning.
-                "/** @type {null} */ var z1 = x;\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "/** @constructor */ function Bar() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
         .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef2a() {
+  public void testMissingProperty6a() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Bar> */ x) {}\n"
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.bar = function() { return this.a; };",
+            "/** @constructor \n * @extends {Foo} */ ",
+            "function Bar() { this.a = 3; };")
+        .addDiagnostic("Property a never defined on Foo")
+        .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef2b() {
+  public void testMissingProperty6b() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Bar> */ x) {}\n"
-                + "/** @type {Generic<!Bar>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "/** @constructor \n * @extends {Foo} */ "
+                + "function Bar() { this.a = 3; };")
+        .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef2c() {
+  public void testMissingProperty7() {
     newTest()
-        .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Foo> */ x) {}\n"
-                + "/** @type {Generic<!Foo>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
+        .addSource("/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }")
+        .addDiagnostic(
+            "Property impossible never defined on Object"
+                + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .run();
   }
 
   @Test
-  public void testTemplateTypeWithTypeDef2d() {
+  public void testMissingProperty8() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @template T\n"
-                + " * @param {T} x\n"
-                + " */\n"
-                + "function Generic(x) {}\n"
-                + "\n"
-                + "/** @constructor */\n"
-                + "function Foo() {}\n"
-                + "\n"
-                + "/** @typedef {!Foo} */\n"
-                + "var Bar;\n"
-                + "\n"
-                + "function f(/** Generic<!Foo> */ x) {}\n"
-                + "/** @type {Generic<!Bar>} */ var x;\n"
-                + "f(x);\n")
-        .run(); // no warning expected.
+            "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }")
+        .run();
   }
 
   @Test
-  public void testTemplatedFunctionInUnion1() {
+  public void testMissingProperty9() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
         .addSource(
-            "/**",
-            "* @param {T} x",
-            "* @param {function(this:T, ...)|{fn:Function}} z",
-            "* @template T",
-            "*/",
-            "function f(x, z) {}",
-            "f([], function() { /** @type {string} */ var x = this });")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : Array<?>",
-                "required: string"))
+            "/** @param {Object} obj */"
+                + "function foo(obj) { if (obj.impossible) { return true; } }")
         .run();
   }
 
   @Test
-  public void testTemplateTypeRecursion1() {
+  public void testMissingProperty10() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @typedef {{a: D2}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
+            "/** @param {Object} obj */"
+                + "function foo(obj) { while (obj.impossible) { return true; } }")
         .run();
   }
 
   @Test
-  public void testTemplateTypeRecursion2() {
+  public void testMissingProperty11() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @typedef {{a: D2}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "/** @type {D1} */ var x;"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
+            "/** @param {Object} obj */"
+                + "function foo(obj) { for (;obj.impossible;) { return true; } }")
         .run();
   }
 
   @Test
-  public void testTemplateTypeRecursion3() {
+  public void testMissingProperty12() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource(
-            "/** @typedef {{a: function(D2)}} */\n"
-                + "var D1;\n"
-                + "\n"
-                + "/** @typedef {{b: D1}} */\n"
-                + "var D2;\n"
-                + "\n"
-                + "/** @type {D1} */ var x;"
-                + "fn(x);\n"
-                + "\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {!D1} s\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var fn = function(s) {};")
+        .addSource(
+            "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }")
         .run();
   }
 
+  // Note: testMissingProperty{13,14} pertained to a deleted coding convention.
+
   @Test
-  @Ignore
-  public void testBadTemplateType4() {
-    // TODO(johnlenz): Add a check for useless of template types.
-    // Unless there are at least two references to a Template type in
-    // a definition it isn't useful.
+  public void testMissingProperty15() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource("/**\n" + "* @template T\n" + "*/\n" + "function f() {}\n" + "f();")
-        .addDiagnostic(FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format())
+        .addSource("/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }")
         .run();
   }
 
   @Test
-  @Ignore
-  public void testBadTemplateType5() {
-    // TODO(johnlenz): Add a check for useless of template types.
-    // Unless there are at least two references to a Template type in
-    // a definition it isn't useful.
+  public void testMissingProperty16() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource(
-            "/**\n" + "* @template T\n" + "* @return {T}\n" + "*/\n" + "function f() {}\n" + "f();")
-        .addDiagnostic(FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format())
+        .addSource("/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }")
+        .addDiagnostic(
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  @Ignore
-  public void testFunctionLiteralUndefinedThisArgument() {
-    // TODO(johnlenz): this was a weird error.  We should add a general
-    // restriction on what is accepted for T. Something like:
-    // "@template T of {Object|string}" or some such.
+  public void testMissingProperty17() {
     newTest()
         .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() { this; });")
-        .addDiagnostic("Function literal argument refers to undefined this argument")
+            "/** @param {Object} x */"
+                + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }")
         .run();
   }
 
   @Test
-  public void testFunctionLiteralDefinedThisArgument() {
+  public void testMissingProperty18() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() { this; }, {});")
+            "/** @param {Object} x */"
+                + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }")
         .run();
   }
 
   @Test
-  public void testFunctionLiteralDefinedThisArgument2() {
+  public void testMissingProperty19() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "/** @param {string} x */ function f(x) {}",
-            "/**",
-            " * @param {?function(this:T, ...)} fn",
-            " * @param {T=} opt_obj",
-            " * @template T",
-            " */",
-            "function baz(fn, opt_obj) {}",
-            "function g() { baz(function() { f(this.length); }, []); }")
+            "/** @param {Object} x */"
+                + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : number",
-                "required: string"))
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testFunctionLiteralUnreadNullThisArgument() {
+  public void testMissingProperty20() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            ""
-                + "/**\n"
-                + " * @param {function(this:T, ...)?} fn\n"
-                + " * @param {?T} opt_obj\n"
-                + " * @template T\n"
-                + " */\n"
-                + "function baz(fn, opt_obj) {}\n"
-                + "baz(function() {}, null);")
+            "/** @param {Object} x */" + "function f(x) { if (x.foo) { } else { x.foo(); } }")
+        .addDiagnostic(
+            "Property foo never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testUnionTemplateThisType() {
+  public void testMissingProperty21() {
+    disableStrictMissingPropertyChecks();
+    newTest().addSource("/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }").run();
+  }
+
+  @Test
+  public void testMissingProperty22() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @constructor */ function F() {}"
-                + "/** @return {F|Array} */ function g() { return []; }"
-                + "/** @param {F} x */ function h(x) { }"
-                + "/**\n"
-                + "* @param {T} x\n"
-                + "* @param {function(this:T, ...)} y\n"
-                + "* @template T\n"
-                + "*/\n"
-                + "function f(x, y) {}\n"
-                + "f(g(), function() { h(this); });")
-        .addDiagnostic(
-            "actual parameter 1 of h does not match formal parameter\n"
-                + "found   : (Array|F|null)\n"
-                + "required: (F|null)")
+            "/** @param {Object} x \n * @return {boolean} */"
+                + "function f(x) { return x.foo ? x.foo() : true; }")
         .run();
   }
 
   @Test
-  public void testRecordType1() {
+  public void testMissingProperty23() {
     newTest()
-        .addSource(
-            "/** @param {{prop: number}} x */", //
-            "function f(x) {}",
-            "f({});")
+        .addSource("function f(x) { x.impossible(); }")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|undefined)}",
-                "required: {prop: number}",
-                "missing : []",
-                "mismatch: [prop]"))
+            "Property impossible never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testRecordType2() {
+  public void testMissingProperty24() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {MissingType} x */"
+            + "function f(x) { x.impossible(); }",
+        null);
+  }
+
+  @Test
+  public void testMissingProperty25() {
     newTest()
-        .addSource("/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "f({});")
+        .addSource(
+            "/** @constructor */ var Foo = function() {};"
+                + "Foo.prototype.bar = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "(new FooAlias()).bar();")
         .run();
   }
 
   @Test
-  public void testRecordType3() {
+  public void testMissingProperty26() {
     newTest()
         .addSource(
-            "/** @param {{prop: number}} x */", //
-            "function f(x) {}",
-            "f({prop: 'x'});")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|string)}",
-                "required: {prop: number}",
-                "missing : []",
-                "mismatch: [prop]"))
+            "/** @constructor */ var Foo = function() {};"
+                + "/** @constructor */ var FooAlias = Foo;"
+                + "FooAlias.prototype.bar = function() {};"
+                + "(new Foo()).bar();")
         .run();
   }
 
   @Test
-  public void testRecordType4() {
-    // Notice that we do not do flow-based inference on the object type:
-    // We don't try to prove that x.prop may not be string until x
-    // gets passed to g.
-    testClosureTypesMultipleWarnings(
-        "/** @param {{prop: (number|undefined)}} x */"
-            + "function f(x) {}"
-            + "/** @param {{prop: (string|undefined)}} x */"
-            + "function g(x) {}"
-            + "var x = {}; f(x); g(x);",
-        ImmutableList.of(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : {prop: (number|string|undefined)}",
-                "required: {prop: (number|undefined)}",
-                "missing : []",
-                "mismatch: [prop]"),
-            lines(
-                "actual parameter 1 of g does not match formal parameter",
-                "found   : {prop: (number|string|undefined)}",
-                "required: {prop: (string|undefined)}",
-                "missing : []",
-                "mismatch: [prop]")));
+  public void testMissingProperty27() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {?MissingType} x */"
+            + "function f(x) {"
+            + "  for (var parent = x; parent; parent = parent.getParent()) {}"
+            + "}",
+        null);
   }
 
   @Test
-  public void testRecordType5() {
+  public void testMissingProperty28a() {
     newTest()
-        .addSource(
-            "/** @param {{prop: (number|undefined)}} x */"
-                + "function f(x) {}"
-                + "/** @param {{otherProp: (string|undefined)}} x */"
-                + "function g(x) {}"
-                + "var x = {}; f(x); g(x);")
+        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foo;" + "}")
         .run();
   }
 
   @Test
-  public void testRecordType6() {
+  public void testMissingProperty28b() {
     newTest()
-        .addSource("/** @return {{prop: (number|undefined)}} x */" + "function f() { return {}; }")
+        .addSource("function f(obj) {" + "  /** @type {*} */ obj.foo;" + "  return obj.foox;" + "}")
+        .addDiagnostic(
+            "Property foox never defined on obj" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testRecordType7() {
+  public void testMissingProperty29() {
+    // This used to emit a warning.
+    newTest()
+        .addExterns(
+            "/** @constructor */ var Foo;"
+                + "Foo.prototype.opera;"
+                + "Foo.prototype.opera.postError;")
+        .addSource("")
+        .run();
+  }
+
+  @Test
+  public void testMissingProperty30a() {
     newTest()
         .addSource(
-            "/** @return {{prop: (number|undefined)}} x */"
-                + "function f() { var x = {}; g(x); return x; }"
-                + "/** @param {number} x */"
-                + "function g(x) {}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : {prop: (number|undefined)}\n"
-                + "required: number")
+            "/** @return {*} */",
+            "function f() {",
+            " return {};",
+            "}",
+            "f().a = 3;",
+            "/** @param {Object} y */ function g(y) { return y.a; }")
+        .addDiagnostic("Property a never defined on *")
+        .addDiagnostic("Property a never defined on Object")
         .run();
   }
 
   @Test
-  public void testRecordType8() {
+  public void testMissingProperty30b() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @return {{prop: (number|string)}} x */"
-                + "function f() { var x = {prop: 3}; g(x.prop); return x; }"
-                + "/** @param {string} x */"
-                + "function g(x) {}")
-        .addDiagnostic(
-            "actual parameter 1 of g does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "/** @return {*} */"
+                + "function f() {"
+                + " return {};"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Object} y */ function g(y) { return y.a; }")
+        .run();
+  }
+
+  @Test
+  public void testMissingProperty31a() {
+    newTest()
+        .addSource(
+            "/** @return {Array|number} */", //
+            "function f() {",
+            " return [];",
+            "}",
+            "f().a = 3;")
+        .addDiagnostic("Property a never defined on (Array|Number)")
         .run();
   }
 
   @Test
-  public void testDuplicateRecordFields1() {
-    newTest()
-        .addSource("/**" + "* @param {{x:string, x:number}} a" + "*/" + "function f(a) {};")
-        .addDiagnostic("Bad type annotation. Duplicate record field x." + BAD_TYPE_WIKI_LINK)
-        .run();
-  }
+  public void testMissingProperty31b() {
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testDuplicateRecordFields2() {
     newTest()
         .addSource(
-            "/**" + "* @param {{name:string,number:x,number:y}} a" + " */" + "function f(a) {};")
-        .addDiagnostic("Bad type annotation. Unknown type x")
-        .addDiagnostic("Bad type annotation. Duplicate record field number." + BAD_TYPE_WIKI_LINK)
+            "/** @return {Array|number} */"
+                + "function f() {"
+                + " return [];"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Array} y */ function g(y) { return y.a; }")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterface1() {
+  public void testMissingProperty32() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */ function base1() {}\n"
-                + "/** @interface */ function base2() {}\n"
-                + "/** @interface\n"
-                + "* @extends {base1}\n"
-                + "* @extends {base2}\n"
-                + "*/\n"
-                + "function derived() {}")
+            "/** @return {Array|number} */"
+                + "function f() {"
+                + " return [];"
+                + "}"
+                + "f().a = 3;"
+                + "/** @param {Date} y */ function g(y) { return y.a; }")
+        .addDiagnostic("Property a never defined on Date")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterface2() {
-    newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "Int0.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int0 is not implemented by type Foo")
-        .run();
+  public void testMissingProperty33() {
+    disableStrictMissingPropertyChecks();
+    newTest().addSource("/** @param {Object} x */" + "function f(x) { !x.foo || x.foo(); }").run();
   }
 
   @Test
-  public void testMultipleExtendsInterface3() {
+  public void testMissingProperty34() {
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "Int1.prototype.foo = function() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("property foo on interface Int1 is not implemented by type Foo")
+            "/** @fileoverview \n * @suppress {missingProperties} */"
+                + "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.bar = function() { return this.a; };"
+                + "Foo.prototype.baz = function() { this.b = 3; };")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterface4() {
+  public void testMissingProperty35a() {
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
-                + " @extends {number} */"
-                + "function Int2() {};"
-                + "/** @constructor\n @implements {Int2} */function Foo() {};")
-        .addDiagnostic("Int2 @extends non-object type number")
+            "/** @constructor */ function Foo() {}",
+            "/** @constructor */ function Bar() {}",
+            "/** @constructor */ function Baz() {}",
+            "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }",
+            "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
+        .addDiagnostic("Property specialProp never defined on (Foo|Bar)")
+        .addDiagnostic("Property specialProp never defined on (Bar|Baz)")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterface5() {
+  public void testMissingProperty35b() {
+    disableStrictMissingPropertyChecks();
+
+    // Bar has specialProp defined, so Bar|Baz may have specialProp defined.
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @constructor */function Int1() {};"
-                + "/** @return {string} x */"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};")
-        .addDiagnostic("Int2 cannot extend this type; interfaces can only extend interfaces")
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @constructor */ function Baz() {}"
+                + "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }"
+                + "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterface6() {
+  public void testMissingProperty36a() {
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
     newTest()
         .addSource(
-            "/** @interface */function Super1() {};",
-            "/** @interface */function Super2() {};",
-            "/** @param {number} bar */Super2.prototype.foo = function(bar) {};",
-            "/** @interface @extends {Super1} @extends {Super2} */function Sub() {};",
-            "/** @override @param {string} bar */Sub.prototype.foo =",
-            "function(bar) {};")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Sub and the type of the property it "
-                    + "overrides from interface Super2",
-                "original: function(this:Super2, number): undefined",
-                "override: function(this:Sub, string): undefined"))
+            "/** @constructor */ function Foo() {}",
+            "Foo.prototype.baz = 0;",
+            "/** @constructor \n * @extends {Foo} */ function SubFoo() {}",
+            "SubFoo.prototype.bar = 0;",
+            "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
+        .addDiagnostic("Property baz never defined on x")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterfaceAssignment() {
+  public void testMissingProperty36b() {
+    disableStrictMissingPropertyChecks();
+
+    // Foo has baz defined, and SubFoo has bar defined, so some objects with
+    // bar may have baz.
     newTest()
         .addSource(
-            "/** @interface */var I1 = function() {};\n"
-                + "/** @interface */ var I2 = function() {}\n"
-                + "/** @interface\n@extends {I1}\n@extends {I2}*/"
-                + "var I3 = function() {};\n"
-                + "/** @constructor\n@implements {I3}*/var T = function() {};\n"
-                + "var t = new T();\n"
-                + "/** @type {I1} */var i1 = t;\n"
-                + "/** @type {I2} */var i2 = t;\n"
-                + "/** @type {I3} */var i3 = t;\n"
-                + "i1 = i3;\n"
-                + "i2 = i3;\n")
+            "/** @constructor */ function Foo() {}"
+                + "Foo.prototype.baz = 0;"
+                + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}"
+                + "SubFoo.prototype.bar = 0;"
+                + "/** @param {{bar: number}} x */ function f(x) { return x.baz; }")
         .run();
   }
 
   @Test
-  public void testMultipleExtendsInterfaceParamPass() {
+  public void testMissingProperty37a() {
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
     newTest()
         .addSource(
-            "/** @interface */",
-            "var I1 = function() {};",
-            "/** @interface */",
-            "var I2 = function() {}",
-            "/** @interface @extends {I1} @extends {I2} */",
-            "var I3 = function() {};",
-            "/** @constructor @implements {I3} */",
-            "var T = function() {};",
-            "var t = new T();",
+            "/** @param {{isVisible: boolean}} x */",
+            "function f(x){",
+            "  x.isVisible = false;",
+            "}",
+            "/** @constructor */",
+            "function Foo() {}",
             "/**",
-            " * @param {I1} x",
-            " * @param {I2} y",
-            " * @param {I3} z",
+            " * @constructor",
+            " * @extends {Foo}",
             " */",
-            "function foo(x,y,z){};",
-            "foo(t,t,t)")
+            "function SubFoo() {}",
+            "/** @type {boolean} */",
+            "SubFoo.prototype.isVisible = true;",
+            "/**",
+            " * @param {Foo} x",
+            " * @return {boolean}",
+            " */",
+            "function g(x) { return x.isVisible; }")
+        .addDiagnostic("Property isVisible never defined on Foo")
         .run();
   }
 
   @Test
-  public void testBadMultipleExtendsClass() {
+  public void testMissingProperty37b() {
+    disableStrictMissingPropertyChecks();
+
+    // This used to emit a missing property warning because we couldn't
+    // determine that the inf(Foo, {isVisible:boolean}) == SubFoo.
     newTest()
         .addSource(
-            "/** @constructor */ function base1() {}\n"
-                + "/** @constructor */ function base2() {}\n"
-                + "/** @constructor\n"
-                + "* @extends {base1}\n"
-                + "* @extends {base2}\n"
-                + "*/\n"
-                + "function derived() {}")
-        .addDiagnostic(
-            "Bad type annotation. type annotation incompatible with other annotations."
-                + BAD_TYPE_WIKI_LINK)
+            "/** @param {{isVisible: boolean}} x */ function f(x){"
+                + "  x.isVisible = false;"
+                + "}"
+                + "/** @constructor */ function Foo() {}"
+                + "/**\n"
+                + " * @constructor \n"
+                + " * @extends {Foo}\n"
+                + " */ function SubFoo() {}"
+                + "/** @type {boolean} */ SubFoo.prototype.isVisible = true;"
+                + "/**\n"
+                + " * @param {Foo} x\n"
+                + " * @return {boolean}\n"
+                + " */\n"
+                + "function g(x) { return x.isVisible; }")
         .run();
   }
 
   @Test
-  public void testInterfaceExtendsResolution() {
+  public void testMissingProperty38() {
     newTest()
         .addSource(
-            "/** @interface \n @extends {A} */ function B() {};\n"
-                + "/** @constructor \n @implements {B} */ function C() {};\n"
-                + "/** @interface */ function A() {};")
+            "/** @constructor */ function Foo() {}"
+                + "/** @constructor */ function Bar() {}"
+                + "/** @return {Foo|Bar} */ function f() { return new Foo(); }"
+                + "f().missing;")
+        .addDiagnostic("Property missing never defined on (Foo|Bar)")
         .run();
   }
 
   @Test
-  public void testPropertyCanBeDefinedInObject() {
-    // This test is specifically checking loose property check behavior.
+  public void testMissingProperty39a() {
     disableStrictMissingPropertyChecks();
-    newTest()
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
         .addSource(
-            "/** @interface */ function I() {};",
-            "I.prototype.bar = function() {};",
-            "/** @type {Object} */ var foo;",
-            "foo.bar();")
+            "/** @return {string|number} */ function f() { return 3; }", //
+            "f().length;")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility1() {
+  public void testMissingProperty39b() {
     newTest()
+        .addExterns(new TestExternsBuilder().addString().build())
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
-                + "function Int2() {};")
-        .addDiagnostic(
-            "Interface Int2 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int1")
+            "/** @return {string|number} */ function f() { return 3; }", //
+            "f().length;")
+        .addDiagnostic("Property length not defined on all member types of (String|Number)")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility2() {
+  public void testMissingProperty40a() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {MissingType} x */"
+            + "function f(x) { x.impossible(); }",
+        null);
+  }
+
+  @Test
+  public void testMissingProperty40b() {
+    testClosureTypes(
+        "goog.forwardDeclare('MissingType');"
+            + "/** @param {(Array|MissingType)} x */"
+            + "function f(x) { x.impossible(); }",
+        "Property impossible not defined on all member types of x");
+  }
+
+  @Test
+  public void testMissingProperty41a() {
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @interface */function Int2() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @type {Object} */"
-                + "Int2.prototype.foo;"
-                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
-                + "@extends {Int2}*/"
-                + "function Int3() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in "
-                + "its super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in "
-                + "its super interfaces Int1 and Int2")
+            "/** @param {(Array|Date)} x */", //
+            "function f(x) { if (x.impossible) x.impossible(); }")
+        .addDiagnostic("Property impossible never defined on (Array|Date)")
+        .addDiagnostic("Property impossible never defined on (Array|Date)")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility3() {
+  public void testMissingProperty41b() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int1")
+            "/** @param {(Array|Date)} x */", //
+            "function f(x) { if (x.impossible) x.impossible(); }")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility4() {
+  public void testMissingProperty42() {
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface \n @extends {Int0} */ function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @interface */function Int2() {};"
-                + "/** @interface \n @extends {Int2} */ function Int3() {};"
-                + "/** @type {string} */"
-                + "Int2.prototype.foo;"
-                + "/** @interface \n @extends {Int1} \n @extends {Int3} */"
-                + "function Int4() {};")
-        .addDiagnostic(
-            "Interface Int4 has a property foo with incompatible types in its "
-                + "super interfaces Int0 and Int2")
+            "/** @param {Object} x */"
+                + "function f(x) { "
+                + "  if (typeof x.impossible == 'undefined') throw Error();"
+                + "  return x.impossible;"
+                + "}")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility5() {
+  public void testMissingProperty43() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {number} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int1 and Int4")
+        .addSource("function f(x) { " + " return /** @type {number} */ (x.impossible) && 1;" + "}")
         .run();
   }
 
   @Test
-  public void testExtendedInterfacePropertiesCompatibility6() {
+  public void testMissingProperty_notReportedInPropertyAbsenceCheck() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {string} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
+            "function f(/** !Object */ x) {", //
+            "  if (x.y == null) throw new Error();",
+            "}")
         .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testExtendedInterfacePropertiesCompatibility7() {
+  public void optChainGetPropAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {Object} */"
-                + "Int4.prototype.foo;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int3 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int1")
-        .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int1 and Int4")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.z;",
+            "}")
         .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should
+  // emit a warning about missing properties
   @Test
-  public void testExtendedInterfacePropertiesCompatibility8() {
+  public void normalGetPropNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @type {number} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {string} */"
-                + "Int1.prototype.bar;"
-                + "/** @interface \n @extends {Int1} */ function Int2() {};"
-                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
-                + "function Int3() {};"
-                + "/** @interface */function Int4() {};"
-                + "/** @type {Object} */"
-                + "Int4.prototype.foo;"
-                + "/** @type {Null} */"
-                + "Int4.prototype.bar;"
-                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
-                + "function Int5() {};")
-        .addDiagnostic(
-            "Interface Int5 has a property bar with incompatible types in its"
-                + " super interfaces Int1 and Int4")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y.z;",
+            "}")
         .addDiagnostic(
-            "Interface Int5 has a property foo with incompatible types in its"
-                + " super interfaces Int0 and Int4")
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testExtendedInterfacePropertiesCompatibility9() {
+  public void optChainGetElemAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface\n * @template T */function Int0() {};"
-                + "/** @interface\n * @template T */function Int1() {};"
-                + "/** @type {T} */"
-                + "Int0.prototype.foo;"
-                + "/** @type {T} */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n @extends {Int0<number>} \n @extends {Int1<string>} */"
-                + "function Int2() {};")
-        .addDiagnostic(
-            "Interface Int2 has a property foo with incompatible types in its "
-                + "super interfaces Int0<number> and Int1<string>")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.[z];",
+            "}")
         .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should emit
+  // a warning about missing properties
   @Test
-  public void testExtendedInterfacePropertiesCompatibilityNoError() {
+  public void normalGetElemNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            ""
-                + "/** @interface */function Int0() {};"
-                + "/** @interface */function Int1() {};"
-                + "/** @param {number} x */"
-                + "Int0.prototype.foo;"
-                + "/** @param {number} x */"
-                + "Int1.prototype.foo;"
-                + "/** @interface \n * @extends {Int0} \n * @extends {Int1} */"
-                + "function Int2() {};")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y[z];",
+            "}")
+        .addDiagnostic(
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // since optional chaining is a property test (tests for the existence of x.y), no warnings
+  // about missing properties are emitted
   @Test
-  public void testImplementedInterfacePropertiesShouldFailOnConflict() {
-    // TODO(b/132718172): Provide a better error message.
+  public void optChainCallAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/** @interface */function Int0() {};",
-            "/** @interface */function Int1() {};",
-            "/** @type {number} */",
-            "Int0.prototype.foo;",
-            "/** @type {string} */",
-            "Int1.prototype.foo;",
-            "/** @constructor @implements {Int0} @implements {Int1} */",
-            "function Foo() {};",
-            "Foo.prototype.foo;")
-        .addDiagnostic(
-            lines(
-                "mismatch of the foo property on type Foo and the type of the property it"
-                    + " overrides from interface Int1",
-                "original: string",
-                "override: number"))
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y?.();",
+            "}")
         .run();
   }
 
+  // this is the same test as above except that it does not use optional chaining so it should emit
+  // a warning about missing properties
   @Test
-  public void testGenerics1a() {
-    String fnDecl =
-        "/** \n"
-            + " * @param {T} x \n"
-            + " * @param {function(T):T} y \n"
-            + " * @template T\n"
-            + " */ \n"
-            + "function f(x,y) { return y(x); }\n";
-
-    newTest()
-        .addSource(
-            fnDecl
-                + "/** @type {string} */"
-                + "var out;"
-                + "/** @type {string} */"
-                + "var result = f('hi', function(x){ out = x; return x; });")
+  public void normalCallNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
+    newTest()
+        .addSource(
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x.y();",
+            "}")
+        .addDiagnostic(
+            "Property y never defined on Object" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // prop.access?.() is property test and should allow loose property access
+  // but x?.(prop.access) is not
   @Test
-  public void testGenerics1b() {
-    String fnDecl =
-        "/** \n"
-            + " * @param {T} x \n"
-            + " * @param {function(T):T} y \n"
-            + " * @template T\n"
-            + " */ \n"
-            + "function f(x,y) { return y(x); }\n";
-
+  public void getNotFirstChildOfOptChainCallNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            fnDecl
-                + "/** @type {string} */"
-                + "var out;"
-                + "var result = f(0, function(x){ out = x; return x; });")
-        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  return false;",
+            "}",
+            "f?.(x.y)")
+        .addDiagnostic("Property y never defined on x" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
+  // prop.access?.[x] is property test and should allow loose property access
+  // but x?.[prop.access] is not
   @Test
-  public void testFilter0() {
+  public void getNotFirstChildOfOptionalGetElemNotAllowLoosePropertyAccess() {
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {T} arr\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<string>} */"
-                + "var result = filter(arr);")
+            "/** @param {?Object} x */", //
+            "function f(x) {",
+            "  x?.[y.z];",
+            "}")
+        .addDiagnostic("Property z never defined on y" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
         .run();
   }
 
   @Test
-  public void testFilter1() {
+  public void testOptChainGetPropProvidesThisForMethodCall() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {!Array<T>} arr\n"
-                + " * @return {!Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<string>} */"
-                + "var result = filter(arr);")
+            "class A {",
+            "  foo() {}",
+            "}",
+            "/** @param {?A} a */",
+            "function f(a) {",
+            // TypeCheck should not complain that foo() is getting called without a correctly typed
+            // `this` value.
+            "  a?.foo();",
+            "}",
+            "",
+            "")
         .run();
   }
 
   @Test
-  public void testFilter2() {
+  public void testReflectObject1() {
+    testClosureTypes(
+        "goog.reflect = {}; "
+            + "goog.reflect.object = function(x, y){};"
+            + "/** @constructor */ function A() {}"
+            + "goog.reflect.object(A, {x: 3});",
+        null);
+  }
+
+  @Test
+  public void testReflectObject2() {
+    testClosureTypes(
+        "goog.reflect = {}; "
+            + "goog.reflect.object = function(x, y){};"
+            + "/** @param {string} x */ function f(x) {}"
+            + "/** @constructor */ function A() {}"
+            + "goog.reflect.object(A, {x: f(1 + 1)});",
+        "actual parameter 1 of f does not match formal parameter\n"
+            + "found   : number\n"
+            + "required: string");
+  }
+
+  @Test
+  public void testLends1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {!Array<T>} arr\n"
-                + " * @return {!Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {!Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {!Array<number>} */"
-                + "var result = filter(arr);")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends */ ({bar: 1}));")
         .addDiagnostic(
-            "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>")
+            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testFilter3() {
+  public void testLends2() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @param {Array<T>} arr\n"
-                + " * @return {Array<T>}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var filter = function(arr){};\n"
-                + "/** @type {Array<string>} */"
-                + "var arr;\n"
-                + "/** @type {Array<number>} */"
-                + "var result = filter(arr);")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : (Array<string>|null)\n"
-                + "required: (Array<number>|null)")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foob} */ ({bar: 1}));")
+        .addDiagnostic("Variable Foob not declared before @lends annotation.")
         .run();
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter1() {
-    testClosureTypes(
-        "/** @type {Array<string>} */"
-            + "var arr;\n"
-            + "/** @type {!Array<number>} */"
-            + "var result = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {return false;});",
-        "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>");
+  public void testLends3() {
+    newTest()
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, {bar: 1});"
+                + "alert(Foo.bar);")
+        .addDiagnostic("Property bar never defined on Foo")
+        .run();
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter2() {
-    testClosureTypes(
-        "/** @type {number} */"
-            + "var out;"
-            + "/** @type {Array<string>} */"
-            + "var arr;\n"
-            + "var out4 = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {out = item; return false});",
-        "assignment\n" + "found   : string\n" + "required: number");
+  public void testLends4() {
+    newTest()
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));"
+                + "alert(Foo.bar);")
+        .run();
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter3() {
-    testClosureTypes(
-        "/** @type {string} */"
-            + "var out;"
-            + "/** @type {Array<string>} */ var arr;\n"
-            + "var result = goog.array.filter("
-            + "   arr,"
-            + "   function(item,index,src) {out = index;});",
-        "assignment\n" + "found   : number\n" + "required: string");
+  public void testLends5() {
+    newTest()
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, {bar: 1});"
+                + "alert((new Foo()).bar);")
+        .addDiagnostic("Property bar never defined on Foo")
+        .run();
   }
 
   @Test
-  public void testBackwardsInferenceGoogArrayFilter4() {
-    testClosureTypes(
-        lines(
-            "/** @type {string} */",
-            "var out;",
-            "/** @type {Array<string>} */ var arr;",
-            "var out4 = goog.array.filter(",
-            "   arr,",
-            "   function(item,index,srcArr) {out = srcArr;});"),
-        lines(
-            "assignment", // keep newlines
-            "found   : (Array|null|{length: number})",
-            "required: string"));
+  public void testLends6() {
+    newTest()
+        .addSource(
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));"
+                + "alert((new Foo()).bar);")
+        .run();
   }
 
   @Test
-  public void testCatchExpression1() {
+  public void testLends7() {
     newTest()
         .addSource(
-            "function fn() {"
-                + "  /** @type {number} */"
-                + "  var out = 0;"
-                + "  try {\n"
-                + "    foo();\n"
-                + "  } catch (/** @type {string} */ e) {\n"
-                + "    out = e;"
-                + "  }"
-                + "}\n")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
+            "function extend(x, y) {}"
+                + "/** @constructor */ function Foo() {}"
+                + "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));")
+        .addDiagnostic("Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testCatchExpression2() {
+  public void testLends8() {
     newTest()
         .addSource(
-            "function fn() {"
-                + "  /** @type {number} */"
-                + "  var out = 0;"
-                + "  /** @type {string} */"
-                + "  var e;"
-                + "  try {\n"
-                + "    foo();\n"
-                + "  } catch (e) {\n"
-                + "    out = e;"
-                + "  }"
-                + "}\n")
+            "function extend(x, y) {}"
+                + "/** @type {number} */ var Foo = 3;"
+                + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));")
+        .addDiagnostic("May only lend properties to object types. Foo has type number.")
         .run();
   }
 
   @Test
-  public void testTemplatized1() {
+  public void testLends9() {
+    testClosureTypesMultipleWarnings(
+        "function extend(x, y) {}"
+            + "/** @constructor */ function Foo() {}"
+            + "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));",
+        ImmutableList.of(
+            "Bad type annotation. expected closing }" + BAD_TYPE_WIKI_LINK,
+            "Bad type annotation. missing object name in @lends tag." + BAD_TYPE_WIKI_LINK));
+  }
+
+  @Test
+  public void testLends10() {
     newTest()
         .addSource(
-            "/** @type {!Array<string>} */"
-                + "var arr1 = [];\n"
-                + "/** @type {!Array<number>} */"
-                + "var arr2 = [];\n"
-                + "arr1 = arr2;")
-        .addDiagnostic("assignment\n" + "found   : Array<number>\n" + "required: Array<string>")
+            "function defineClass(x) { return function() {}; } "
+                + "/** @constructor */"
+                + "var Foo = defineClass("
+                + "    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));"
+                + "/** @return {string} */ function f() { return (new Foo()).bar; }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplatized2() {
+  public void testLends11() {
     newTest()
         .addSource(
-            "/** @type {!Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
-        .addDiagnostic(
-            "initializing variable\n" + "found   : Array<number>\n" + "required: Array<string>")
+            "function defineClass(x, y) { return function() {}; } "
+                + "/** @constructor */"
+                + "var Foo = function() {};"
+                + "/** @return {*} */ Foo.prototype.bar = function() { return 3; };"
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @extends {Foo}\n"
+                + " */\n"
+                + "var SubFoo = defineClass(Foo, "
+                + "    /** @lends {SubFoo.prototype} */ ({\n"
+                + "      /** @override @return {number} */ bar: function() { return 3; }}));"
+                + "/** @return {string} */ function f() { return (new SubFoo()).bar(); }")
+        .addDiagnostic("inconsistent return type\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplatized3() {
-    newTest()
-        .addSource(
-            "/** @type {Array<string>} */" + "var arr1 = /** @type {!Array<number>} */([]);\n")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : Array<number>\n"
-                + "required: (Array<string>|null)")
-        .run();
+  public void testDeclaredNativeTypeEquality() {
+    Node n = parseAndTypeCheck("/** @constructor */ function Object() {};");
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType());
   }
 
   @Test
-  public void testTemplatized4() {
-    newTest()
-        .addSource(
-            "/** @type {Array<string>} */"
-                + "var arr1 = [];\n"
-                + "/** @type {Array<number>} */"
-                + "var arr2 = arr1;\n")
-        .addDiagnostic(
-            "initializing variable\n"
-                + "found   : (Array<string>|null)\n"
-                + "required: (Array<number>|null)")
-        .run();
+  public void testUndefinedVar() {
+    Node n = parseAndTypeCheck("var undefined;");
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstFirstChild().getJSType());
   }
 
   @Test
-  public void testTemplatized5() {
-    newTest()
-        .addSource(
-            "/**\n"
-                + " * @param {Object<T>} obj\n"
-                + " * @return {boolean|undefined}\n"
-                + " * @template T\n"
-                + " */\n"
-                + "var some = function(obj) {"
-                + "  for (var key in obj) if (obj[key]) return true;"
-                + "};"
-                + "/** @return {!Array} */ function f() { return []; }"
-                + "/** @return {!Array<string>} */ function g() { return []; }"
-                + "some(f());\n"
-                + "some(g());\n")
-        .run();
+  public void testFlowScopeBug1() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @param {number} a \n"
+                + "* @param {number} b */\n"
+                + "function f(a, b) {\n"
+                + "/** @type {number} */"
+                + "var i = 0;"
+                + "for (; (i + a) < b; ++i) {}}");
+
+    // check the type of the add node for i + f
+    assertTypeEquals(
+        registry.getNativeType(JSTypeNative.NUMBER_TYPE),
+        n.getFirstChild()
+            .getLastChild()
+            .getLastChild()
+            .getFirstChild()
+            .getNext()
+            .getFirstChild()
+            .getJSType());
   }
 
   @Test
-  public void testTemplatized6() {
-    newTest()
-        .addSource(
-            "/** @interface */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + ""
-                + "/** @constructor \n"
-                + " * @implements {I}\n"
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + ""
-                + "/** @type {null} */ var some = new C().method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : string\n" + "required: null")
-        .run();
+  public void testFlowScopeBug2() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {};\n"
+                + "Foo.prototype.hi = false;"
+                + "function foo(a, b) {\n"
+                + "  /** @type {Array} */"
+                + "  var arr;"
+                + "  /** @type {number} */"
+                + "  var iter;"
+                + "  for (iter = 0; iter < arr.length; ++ iter) {"
+                + "    /** @type {Foo} */"
+                + "    var afoo = arr[iter];"
+                + "    afoo;"
+                + "  }"
+                + "}");
+
+    // check the type of afoo when referenced
+    assertTypeEquals(
+        registry.createNullableType(registry.getGlobalType("Foo")),
+        n.getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getLastChild()
+            .getJSType());
   }
 
   @Test
-  public void testTemplatized7() {
-    newTest()
-        .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " * @implements {I<number>}\n"
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {null} */ var some = new C().method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
-        .run();
+  public void testAddSingletonGetter() {
+    Node n =
+        parseAndTypeCheck(
+            "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);");
+    ObjectType o = (ObjectType) n.getFirstChild().getJSType();
+    assertThat(o.getPropertyType("getInstance").toString()).isEqualTo("function(): Foo");
+    assertThat(o.getPropertyType("instance_").toString()).isEqualTo("Foo");
   }
 
   @Test
-  @Ignore
-  public void testTemplatized8() {
-    // TODO(johnlenz): this should generate a warning but does not.
-    newTest()
-        .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
-                + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " *  @implements {I<R>}\n"
-                + " *  @template R\n "
-                + " */ function C(){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {C<number>} var x = new C();"
-                + "/** @type {null} */ var some = x.method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
-        .run();
+  public void testTypeCheckStandaloneAST() {
+    Node externs = IR.root();
+    Node firstScript = compiler.parseTestCode("function Foo() { }");
+    typeCheck(firstScript);
+    Node root = IR.root(externs, IR.root(firstScript.detach()));
+    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);
+    TypedScope topScope = scopeCreator.createScope(root, null);
+
+    Node secondScript = compiler.parseTestCode("new Foo");
+
+    firstScript.replaceWith(secondScript);
+
+    new TypeCheck(
+            compiler,
+            new SemanticReverseAbstractInterpreter(registry),
+            registry,
+            topScope,
+            scopeCreator)
+        .process(externs, secondScript.getParent());
+
+    assertThat(compiler.getWarningCount()).isEqualTo(1);
+    assertThat(compiler.getWarnings().get(0).getDescription())
+        .isEqualTo("cannot instantiate non-constructor");
   }
 
   @Test
-  public void testTemplatized9() {
+  public void testUpdateParameterTypeOnClosure() {
     newTest()
+        .addExterns(
+            "/**\n"
+                + "* @constructor\n"
+                + "* @param {*=} opt_value\n"
+                + "* @return {!Object}\n"
+                + "*/\n"
+                + "function Object(opt_value) {}\n"
+                + "/**\n"
+                + "* @constructor\n"
+                + "* @param {...*} var_args\n"
+                + "*/\n"
+                + "function Function(var_args) {}\n"
+                + "/**\n"
+                + "* @type {Function}\n"
+                + "*/\n"
+                +
+                // The line below sets JSDocInfo on Object so that the type of the
+                // argument to function f has JSDoc through its prototype chain.
+                "Object.prototype.constructor = function() {};\n")
         .addSource(
-            "/** @interface\n"
-                + " *  @template Q\n "
-                + " */ function I(){}\n"
-                + "/** @param {T} a\n"
-                + " * @return {T|Q}\n"
-                + " * @template T\n"
+            "/**\n"
+                + "* @param {function(): boolean} fn\n"
                 + "*/\n"
-                + "I.prototype.method;\n"
-                + "/** @constructor \n"
-                + " *  @param {R} a\n"
-                + " *  @implements {I<R>}\n"
-                + " *  @template R\n "
-                + " */ function C(a){}\n"
-                + "/** @override*/ C.prototype.method = function(a) {}\n"
-                + "/** @type {null} */ var some = new C(1).method('str');")
-        .addDiagnostic("initializing variable\n" + "found   : (number|string)\n" + "required: null")
+                + "function f(fn) {}\n"
+                + "f(function() { });\n")
         .run();
   }
 
   @Test
-  public void testTemplatized10() {
+  public void testTemplatedThisType1() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
+            "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "/**\n"
+                + " * @this {T}\n"
+                + " * @return {T}\n"
                 + " * @template T\n"
                 + " */\n"
-                + "function Parent() {};\n"
-                + "\n"
-                + "/** @param {T} x */\n"
-                + "Parent.prototype.method = function(x) {};\n"
-                + "\n"
+                + "Foo.prototype.method = function() {};\n"
                 + "/**\n"
                 + " * @constructor\n"
-                + " * @extends {Parent<string>}\n"
+                + " * @extends {Foo}\n"
                 + " */\n"
-                + "function Child() {};\n"
-                + "Child.prototype = new Parent();\n"
-                + "\n"
-                + "(new Child()).method(123); \n")
+                + "function Bar() {}\n"
+                + "var g = new Bar().method();\n"
+                + "/**\n"
+                + " * @param {number} a\n"
+                + " */\n"
+                + "function compute(a) {};\n"
+                + "compute(g);\n")
         .addDiagnostic(
-            "actual parameter 1 of Parent.prototype.method does not match formal parameter\n"
-                + "found   : number\n"
-                + "required: string")
+            "actual parameter 1 of compute does not match formal parameter\n"
+                + "found   : Bar\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testTemplatized11() {
+  public void testTemplatedThisType2() {
     newTest()
         .addSource(
-            "/** \n"
-                + " * @template T\n"
-                + " * @constructor\n"
-                + " */\n"
-                + "function C() {}\n"
-                + "\n"
-                + "/**\n"
-                + " * @param {T|K} a\n"
+            "/**\n"
+                + " * @this {Array<T>|{length:number}}\n"
                 + " * @return {T}\n"
-                + " * @template K\n"
+                + " * @template T\n"
                 + " */\n"
-                + "C.prototype.method = function(a) {};\n"
-                + "\n"
-                +
-                // method returns "?"
-                "/** @type {void} */ var x = new C().method(1);")
+                + "Array.prototype.method = function() {};\n"
+                + "(function(){\n"
+                + "  Array.prototype.method.call(arguments);"
+                + "})();")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testIssue1058() {
+  public void testTemplateType1() {
     newTest()
         .addSource(
             "/**\n"
-                + "  * @constructor\n"
-                + "  * @template CLASS\n"
-                + "  */\n"
-                + "var Class = function() {};\n"
-                + "\n"
-                + "/**\n"
-                + "  * @param {function(CLASS):CLASS} a\n"
-                + "  * @template T\n"
-                + "  */\n"
-                + "Class.prototype.foo = function(a) {\n"
-                + "  return 'string';\n"
-                + "};\n"
-                + "\n"
-                + "/** @param {number} a\n"
-                + "  * @return {string} */\n"
-                + "var a = function(a) { return '' };\n"
-                + "\n"
-                + "new Class().foo(a);")
+                + "* @param {T} x\n"
+                + "* @param {T} y\n"
+                + "* @param {function(this:T, ...)} z\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y, z) {}\n"
+                + "f(this, this, function() { this });")
+        .run();
+  }
+
+  @Test
+  public void testTemplateType2() {
+    // "this" types need to be coerced for ES3 style function or left
+    // allow for ES5-strict methods.
+    newTest()
+        .addSource(
+            "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(0, function() {});")
         .run();
   }
 
   @Test
-  public void testDeterminacyIssue() {
+  public void testTemplateType3() {
     newTest()
         .addSource(
-            "(function() {\n"
-                + "    /** @constructor */\n"
-                + "    var ImageProxy = function() {};\n"
-                + "    /** @constructor */\n"
-                + "    var FeedReader = function() {};\n"
-                + "    /** @type {ImageProxy} */\n"
-                + "    FeedReader.x = new ImageProxy();\n"
-                + "})();")
+            "/**"
+                + " * @param {T} v\n"
+                + " * @param {function(T)} f\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function call(v, f) { f.call(null, v); }"
+                + "/** @type {string} */ var s;"
+                + "call(3, function(x) {"
+                + " x = true;"
+                + " s = x;"
+                + "});")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: string")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testUnknownTypeReport() {
-    enableReportUnknownTypes();
+  public void testTemplateType4() {
     newTest()
-        .addSource("function id(x) { return x; }")
-        .addDiagnostic("could not determine the type of this expression")
+        .addSource(
+            "/**"
+                + " * @param {...T} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(3, null);")
+        .addDiagnostic("assignment\n" + "found   : (null|number)\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testUnknownTypeReport_allowsUnknownIfStatement() {
-    enableReportUnknownTypes();
-    newTest().addSource("function id(x) { x; }").run();
-  }
-
-  @Test
-  public void testUnknownForIn() {
-    enableReportUnknownTypes();
-    newTest().addSource("var x = {'a':1}; var y; \n for(\ny\n in x) {}").run();
+  public void testTemplateType5() {
+    newTest()
+        .addSource(
+            "const CGI_PARAM_RETRY_COUNT = 'rc';",
+            "",
+            "/**",
+            " * @param {...T} p",
+            " * @return {T} ",
+            " * @template T",
+            " */",
+            "function fn(p) { return p; }",
+            "/** @type {!Object} */ var x;",
+            "",
+            "/** @return {void} */",
+            "function aScope() {",
+            "  x = fn(CGI_PARAM_RETRY_COUNT, 1);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "assignment", //
+                "found   : (number|string)",
+                "required: Object"))
+        .run();
   }
 
   @Test
-  public void testUnknownTypeDisabledByDefault() {
-    newTest().addSource("function id(x) { return x; }").run();
+  public void testTemplateType6() {
+    newTest()
+        .addSource(
+            "/**"
+                + " * @param {Array<T>} arr \n"
+                + " * @param {?function(T)} f \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(arr, f) { return arr[0]; }\n"
+                + "/** @param {Array<number>} arr */ function g(arr) {"
+                + "  /** @type {!Object} */ var x = fn.call(null, arr, null);"
+                + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
+        .includeDefaultExterns()
+        .run();
   }
 
   @Test
-  public void testTemplatizedTypeSubtypes2() {
-    JSType arrayOfNumber = createTemplatizedType(getNativeArrayType(), getNativeNumberType());
-    JSType arrayOfString = createTemplatizedType(getNativeArrayType(), getNativeStringType());
-    assertThat(arrayOfString.isSubtypeOf(createUnionType(arrayOfNumber, getNativeNullVoidType())))
-        .isFalse();
+  public void testTemplateType7() {
+    this.newTest()
+        .addExterns(new TestExternsBuilder().addArray().build())
+        .addSource(
+            "/** @type {!Array<string>} */", //
+            "var query = [];",
+            "query.push(1);")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of Array.prototype.push does not match formal parameter",
+                "found   : number",
+                "required: string"))
+        .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessOnStruct() {
+  public void testTemplateType8() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
+            "/** @constructor \n"
+                + " * @template S,T\n"
                 + " */\n"
-                + "var A = function() {};\n"
-                + "/** @param {A} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
+                + "function Bar() {}\n"
+                + "/**"
+                + " * @param {Bar<T>} bar \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(bar) {}\n"
+                + "/** @param {Bar<number>} bar */ function g(bar) {"
+                + "  /** @type {!Object} */ var x = fn(bar);"
                 + "}")
-        .addDiagnostic("Property bar never defined on A")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessOnStructOrObject() {
-    disableStrictMissingPropertyChecks();
+  public void testTemplateType9() {
+    // verify interface type parameters are recognized.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
+            "/** @interface \n"
+                + " * @template S,T\n"
                 + " */\n"
-                + "var A = function() {};\n"
-                + "/** @param {A|Object} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
+                + "function Bar() {}\n"
+                + "/**"
+                + " * @param {Bar<T>} bar \n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(bar) {}\n"
+                + "/** @param {Bar<number>} bar */ function g(bar) {"
+                + "  /** @type {!Object} */ var x = fn(bar);"
                 + "}")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessOnExternStruct() {
+  public void testTemplateType10() {
+    // verify a type parameterized with unknown can be assigned to
+    // the same type with any other type parameter.
     newTest()
-        .addExterns(
-            "/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "var A = function() {};")
         .addSource(
-            "/** @param {A} a */\n" + "function foo(a) {\n" + "  if (a.bar) { a.bar(); }\n" + "}")
-        .addDiagnostic("Property bar never defined on A")
+            "/** @constructor \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Bar() {}\n"
+                + "\n"
+                + ""
+                + "/** @type {!Bar<?>} */ var x;"
+                + "/** @type {!Bar<number>} */ var y;"
+                + "y = x;")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructSubtype() {
+  public void testTemplateType11() {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
+            "/** @constructor \n"
+                + " * @template T\n"
                 + " */\n"
-                + "var A = function() {};"
+                + "function Foo() {}\n"
                 + ""
-                + "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
-                + " * @extends {A}\n"
+                + "/** @constructor \n"
+                + " * @extends {Foo<string>}\n"
                 + " */\n"
-                + "var B = function() { this.bar = function(){}; };"
+                + "function A() {}\n"
                 + ""
-                + "/** @param {A} a */\n"
-                + "function foo(a) {\n"
-                + "  if (a.bar) { a.bar(); }\n"
-                + "}")
-        .addDiagnostic("Property bar never defined on A")
-        .run();
-  }
-
-  @Test
-  public void testNonexistentPropertyAccessStructInterfaceSubtype() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @interface",
-            " * @struct",
-            " */",
-            "var A = function() {};",
-            "",
-            "/**",
-            " * @interface",
-            " * @struct",
-            " * @extends {A}",
-            " */",
-            "var B = function() {};",
-            "/** @return {void} */ B.prototype.bar = function(){};",
-            "",
-            "/** @param {A} a */",
-            "function foo(a) {",
-            "  if (a.bar) { a.bar(); }",
-            "}")
-        .addDiagnostic("Property bar never defined on A")
+                + "/** @constructor \n"
+                + " * @extends {Foo<number>}\n"
+                + " */\n"
+                + "function B() {}\n"
+                + ""
+                + "/** @type {!Foo<string>} */ var a = new A();\n"
+                + "/** @type {!Foo<string>} */ var b = new B();")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructRecordSubtype() {
-    disableStrictMissingPropertyChecks();
-
-    newTest()
-        .addSource(
-            "/**",
-            " * @record",
-            " * @struct",
-            " */",
-            "var A = function() {};",
-            "",
-            "/**",
-            " * @record",
-            " * @struct",
-            " * @extends {A}",
-            " */",
-            "var B = function() {};",
-            "/** @return {void} */ B.prototype.bar = function(){};",
-            "",
-            "/** @param {A} a */",
-            "function foo(a) {",
-            "  if (a.bar) {",
-            "    a.bar();",
-            "  }",
-            "}")
-        .addDiagnostic("Property bar never defined on A")
+  public void testTemplateType12() {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
+    newTest()
+        .addSource(
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {Foo<string>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @implements {Foo<number>}\n"
+                + " */\n"
+                + "function B() {}\n"
+                + ""
+                + "/** @type {!Foo<string>} */ var a = new A();\n"
+                + "/** @type {!Foo<string>} */ var b = new B();")
+        .addDiagnostic("initializing variable\n" + "found   : B\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testNonexistentPropertyAccessStructSubtype2() {
+  public void testTemplateType13() {
+    // verify that assignment/subtype relationships work when extending
+    // templatized types.
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
-                + " * @struct\n"
+            "/** @constructor \n"
+                + " * @template T\n"
                 + " */\n"
-                + "function Foo() {\n"
-                + "  this.x = 123;\n"
-                + "}\n"
-                + "var objlit = /** @struct */ { y: 234 };\n"
-                + "Foo.prototype = objlit;\n"
-                + "var n = objlit.x;\n")
-        .addDiagnostic("Property x never defined on Foo.prototype")
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @template T\n"
+                + " * @extends {Foo<T>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "var a1 = new A();\n"
+                + "var a2 = /** @type {!A<string>} */ (new A());\n"
+                + "var a3 = /** @type {!A<number>} */ (new A());\n"
+                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
+                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
+                + "/** @type {!Foo<string>} */ var f3 = a3;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testIssue1024a() {
-    // This test is specifically checking loose property check behavior.
-    disableStrictMissingPropertyChecks();
+  public void testTemplateType14() {
+    // verify that assignment/subtype relationships work when implementing
+    // templatized types.
     newTest()
         .addSource(
-            "/** @param {Object} a */",
-            "function f(a) {",
-            "  a.prototype = '__proto'",
-            "}",
-            "/** @param {Object} b",
-            " *  @return {!Object}",
-            " */",
-            "function g(b) {",
-            "  return b.prototype",
-            "}")
+            "/** @interface \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @constructor \n"
+                + " * @template T\n"
+                + " * @implements {Foo<T>}\n"
+                + " */\n"
+                + "function A() {}\n"
+                + ""
+                + "var a1 = new A();\n"
+                + "var a2 = /** @type {!A<string>} */ (new A());\n"
+                + "var a3 = /** @type {!A<number>} */ (new A());\n"
+                + "/** @type {!Foo<string>} */ var f1 = a1;\n"
+                + "/** @type {!Foo<string>} */ var f2 = a2;\n"
+                + "/** @type {!Foo<string>} */ var f3 = a3;")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : A<number>\n" + "required: Foo<string>")
         .run();
   }
 
   @Test
-  public void testIssue1024b() {
+  public void testTemplateType15() {
     newTest()
         .addSource(
-            "/** @param {Object} a */",
-            "function f(a) {",
-            "  a.prototype = {foo:3};",
-            "}",
-            "/** @param {Object} b",
-            " */",
-            "function g(b) {",
-            "  b.prototype = function(){};",
-            "}")
+            "/**"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn({foo:3});")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testBug12722936() {
-    // Verify we don't use a weaker type when a
-    // stronger type is known for a slot.
+  public void testTemplateType16() {
     newTest()
         .addSource(
-            "/**\n"
-                + " * @constructor\n"
+            "/** @constructor */ function C() {\n"
+                + "  /** @type {number} */ this.foo = 1\n"
+                + "}\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
                 + " * @template T\n"
                 + " */\n"
-                + "function X() {}\n"
-                + "/** @constructor */ function C() {\n"
-                + "  /** @type {!X<boolean>}*/\n"
-                + "  this.a = new X();\n"
-                + "  /** @type {null} */ var x = this.a;\n"
-                + "};\n"
-                + "\n")
-        .addDiagnostic("initializing variable\n" + "found   : X<boolean>\n" + "required: null")
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(new C());")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testModuleReferenceNotAllowed() {
+  public void testTemplateType17() {
     newTest()
-        .addSource("/** @param {./Foo} z */ function f(z) {}")
-        .addDiagnostic("Bad type annotation. Unknown type ./Foo")
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "C.prototype.foo = 1;\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn(new C());")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: Object")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey1() {
+  public void testTemplateType18() {
+    // Until template types can be restricted to exclude undefined, they
+    // are always optional.
     newTest()
-        .addSource("/** @type {!Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ function C() {}\n"
+                + "C.prototype.foo = 1;\n"
+                + "/**\n"
+                + " * @param {{foo:T}} p\n"
+                + " * @return {T} \n"
+                + " * @template T\n"
+                + " */\n"
+                + "function fn(p) { return p.foo; }\n"
+                + "/** @type {!Object} */ var x;"
+                + "x = fn({});")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey2() {
+  public void testTemplateType19() {
     newTest()
-        .addSource("/** @type {!Object<function(), number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/**\n"
+                + " * @param {T} t\n"
+                + " * @param {U} u\n"
+                + " * @return {{t:T, u:U}} \n"
+                + " * @template T,U\n"
+                + " */\n"
+                + "function fn(t, u) { return {t:t, u:u}; }\n"
+                + "/** @type {null} */ var x = fn(1, 'str');")
+        .addDiagnostic(
+            "initializing variable\n"
+                + "found   : {\n  t: number,\n  u: string\n}\n"
+                + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey3() {
+  public void testTemplateType20() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
-        .addSource("/** @type {!Object<!Array<!Object>, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @constructor */ function C() {\n"
+                + "  /** @type {void} */ this.x;\n"
+                + "}\n"
+                + "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(new C, /** @param {number} a */ function(a) {this.x = a;});")
+        .addDiagnostic(
+            "assignment to property x of C\n" + "found   : number\n" + "required: undefined")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey4() {
+  public void testTemplateType21() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
-        .addSource("/** @type {!Object<*, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor @implements {A<Bar>} */\n"
+                + "function Bar() {}\n"
+                + "/** @type {!Foo} */\n"
+                + "var x = new Bar();\n")
+        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Foo")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey5() {
+  public void testTemplateType22() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
-        .addSource("/** @type {(string|Object<Object, number>)} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @interface @template T */ function B() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @constructor @implements {B<Foo>} */\n"
+                + "function Bar() {}\n"
+                + "/** @constructor @implements {B<Foo>} */\n"
+                + "function Qux() {}\n"
+                + "/** @type {!Qux} */\n"
+                + "var x = new Bar();\n")
+        .addDiagnostic("initializing variable\n" + "found   : Bar\n" + "required: Qux")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey6() {
+  public void testTemplateType23() {
+    // "this" types is inferred when the parameters are declared.
     newTest()
-        .addSource("/** @type {!Object<number, !Object<Object, number>>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @interface @template T */ function A() {}\n"
+                + "/** @constructor @implements {A<Foo>} */\n"
+                + "function Foo() {}\n"
+                + "/** @type {!Foo} */\n"
+                + "var x = new Foo();\n")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey7() {
+  public void testTemplateType24() {
+    // Recursive templated type definition.
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "var MyClass = function() {};\n"
-                + "/** @type {!Object<MyClass, number>} */\n"
-                + "var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " * @param {T} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {T} */",
+            "  this.p = x;",
+            "}",
+            "/** @return {Foo<Foo<T>>} */",
+            "Foo.prototype.m = function() {",
+            "  return null;",
+            "};",
+            "/** @return {T} */",
+            "Foo.prototype.get = function() {",
+            "  return this.p;",
+            "};",
+            "var /** null */ n = new Foo(new Object).m().get();")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (Foo<Object>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey8() {
+  public void testTemplateType25() {
+    // Non-nullable recursive templated type definition.
     newTest()
         .addSource(
-            "/** @enum{!Object} */\n"
-                + "var Enum = {};\n"
-                + "/** @type {!Object<Enum, number>} */\n"
-                + "var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " * @param {T} x",
+            " */",
+            "function Foo(x) {",
+            "  /** @type {T} */",
+            "  this.p = x;",
+            "}",
+            "/** @return {!Foo<!Foo<T>>} */",
+            "Foo.prototype.m = function() {",
+            "  return new Foo(new Foo(new Object));",
+            "};",
+            "/** @return {T} */",
+            "Foo.prototype.get = function() {",
+            "  return this.p;",
+            "};",
+            "var /** null */ n = new Foo(new Object).m().get();")
+        .addDiagnostic("initializing variable\n" + "found   : Foo<Object>\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey9() {
+  public void testTemplateType26() {
+    // Class hierarchies which use the same template parameter name should not be treated as
+    // infinite recursion.
     newTest()
-        .addSource("/** @type {function(!Object<!Object, number>)} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/**",
+            " * @param {T} bar",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "function Bar(bar) {",
+            "  /** @type {T} */",
+            "  this.bar = bar;",
+            "}",
+            "/** @return {T} */",
+            "Bar.prototype.getBar = function() {",
+            "  return this.bar;",
+            "};",
+            "/**",
+            " * @param {T} foo",
+            " * @constructor",
+            " * @template T",
+            " * @extends {Bar<!Array<T>>}",
+            " */",
+            "function Foo(foo) {",
+            "  /** @type {T} */",
+            "  this.foo = foo;",
+            "}",
+            "var /** null */ n = new Foo(new Object).getBar();")
+        .addDiagnostic("initializing variable\n" + "found   : Array<Object>\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey10() {
+  public void testTemplateTypeCollidesWithParameter() {
+    // Function templates are in the same scope as parameters, so cannot collide.
     newTest()
-        .addSource("/** @type {function(): !Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/**", //
+            " * @param {T} T",
+            " * @template T",
+            " */",
+            "function f(T) {}")
+        .addDiagnostic(
+            "variable T redefined with type undefined, original definition at [testcode]:5 with"
+                + " type T")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysBadKey11() {
+  public void testTemplateTypeForwardReference() {
+    // TODO(martinprobst): the test below asserts incorrect behavior for backwards compatibility.
     newTest()
         .addSource(
-            "/** @constructor */\n"
-                + "function X() {}\n"
-                + "/** @constructor @extends {X} */\n"
-                + "function X2() {}\n"
-                + "/** @enum {!X} */\n"
-                + "var XE = {A:new X};\n"
-                + "/** @type {Object<(!XE|!X2), string>} */\n"
-                + "var Y = {};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @constructor",
+            " */",
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags1() {
+  public void testTemplateTypeForwardReference_declared() {
+    compiler.forwardDeclareType("Foo");
     newTest()
-        .addSource("/** @type {!Object<!Object, number>} */ var k;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @constructor",
+            " */",
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags2() {
+  public void testTemplateTypeForwardReferenceFunctionWithExtra() {
+    // TODO(johnlenz): report an error when forward references contain extraneous
+    // type arguments.
     newTest()
-        .addSource("/** @param {!Object<!Object, number>} a */ var f = function(a) {};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @param {!Foo<string, boolean>} x */",
+            "function f(x) {}",
+            "",
+            "/**",
+            " * @constructor",
+            " * @template T",
+            " */",
+            "function Foo() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags3() {
+  public void testTemplateTypeForwardReferenceVar() {
     newTest()
-        .addSource("/** @return {!Object<!Object, number>} */ var f = function() {return {}};")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @param {!Foo<string>} x */",
+            "function f(x) {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @constructor",
+            " */",
+            "var Foo = function() {}",
+            "",
+            "/** @param {!Foo<number>} x */",
+            "function g(x) {",
+            "  f(x);",
+            "}")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : Foo<number>",
+                "required: Foo<string>"))
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysVariousTags4() {
+  public void testTemplateTypeForwardReference_declaredMissing() {
+    compiler.forwardDeclareType("Foo");
+    compiler.forwardDeclareType("DoesNotExist");
     newTest()
-        .addSource("/** @typedef {!Object<!Object, number>} */ var MyType;")
-        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
+        .addSource(
+            "/** @param {!Foo<DoesNotExist>} x */", //
+            "function f(x) {}")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey1() {
-    newTest().addSource("/** @type {!Object<number, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey2() {
-    newTest().addSource("/** @type {!Object<string, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey3() {
-    newTest().addSource("/** @type {!Object<boolean, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey4() {
-    newTest().addSource("/** @type {!Object<null, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey5() {
-    newTest().addSource("/** @type {!Object<undefined, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey6() {
-    newTest().addSource("/** @type {!Object<!Date, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey7() {
-    newTest().addSource("/** @type {!Object<!RegExp, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey8() {
-    newTest().addSource("/** @type {!Object<!Array, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey9() {
-    newTest().addSource("/** @type {!Object<!Array<number>, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey10() {
-    newTest().addSource("/** @type {!Object<?, number>} */ var k;").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey11() {
-    newTest().addSource("/** @type {!Object<(string|number), number>} */ var k").run();
-  }
-
-  @Test
-  public void testCheckObjectKeysGoodKey12() {
-    newTest().addSource("/** @type {!Object<Object>} */ var k;").run();
+  public void testTemplateTypeForwardReference_extends() {
+    compiler.forwardDeclareType("Bar");
+    compiler.forwardDeclareType("Baz");
+    newTest()
+        .addSource(
+            "/** @constructor @extends {Bar<Baz>} */",
+            "function Foo() {}",
+            "/** @constructor */",
+            "function Bar() {}")
+        .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey13() {
+  public void testSubtypeNotTemplated1() {
     newTest()
         .addSource(
-            "/** @interface */\n"
-                + "var MyInterface = function() {};\n"
-                + "/** @type {!Object<!MyInterface, number>} */\n"
-                + "var k;")
+            "/** @interface @template T */ function A() {}",
+            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
+            "function f(/** (!Object|!Foo<string>) */ x) {",
+            "  var /** null */ n = x;",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey14() {
+  public void testSubtypeNotTemplated2() {
     newTest()
         .addSource(
-            "/** @typedef {{a: number}} */ var MyRecord;\n"
-                + "/** @type {!Object<MyRecord, number>} */ var k;")
+            "/** @interface @template T */ function A() {}",
+            "/** @constructor @implements {A<U>} @template U */ function Foo() {}",
+            "function f(/** (!Object|!Foo) */ x) {",
+            "  var /** null */ n = x;",
+            "}")
+        .addDiagnostic("initializing variable\n" + "found   : Object\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysGoodKey15() {
-    newTest()
-        .addSource(
-            "/** @enum{number} */\n"
-                + "var Enum = {};\n"
-                + "/** @type {!Object<Enum, number>} */\n"
-                + "var k;")
-        .run();
+  public void testTemplateTypeWithUnresolvedType() {
+    testClosureTypes(
+        "goog.forwardDeclare('Color');\n"
+            + "/** @interface @template T */ function C() {}\n"
+            + "/** @return {!Color} */ C.prototype.method;\n"
+            + "/** @constructor @implements {C} */ function D() {}\n"
+            + "/** @override */ D.prototype.method = function() {};",
+        null); // no warning expected.
   }
 
   @Test
-  public void testCheckObjectKeysClassWithToString() {
+  public void testTemplateTypeWithTypeDef1a() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var MyClass = function() {};",
-            "/** @override*/",
-            "MyClass.prototype.toString = function() { return ''; };",
-            "/** @type {!Object<!MyClass, number>} */",
-            "var k;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + ""
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "/** @type {Generic<!Bar>} */ var y;\n"
+                + ""
+                + "x = y;\n"
+                + // no warning
+                "/** @type {null} */ var z1 = y;\n")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysClassInheritsToString() {
+  public void testTemplateTypeWithTypeDef1b() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var Parent = function() {};",
-            "/** @override */",
-            "Parent.prototype.toString = function() { return ''; };",
-            "/** @constructor @extends {Parent} */",
-            "var Child = function() {};",
-            "/** @type {!Object<!Child, number>} */",
-            "var k;")
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + ""
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + ""
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "/** @type {Generic<!Bar>} */ var y;\n"
+                + ""
+                + "y = x;\n"
+                + // no warning.
+                "/** @type {null} */ var z1 = x;\n")
+        .addDiagnostic(
+            "initializing variable\n" + "found   : (Generic<Foo>|null)\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testCheckObjectKeysForEnumUsingClassWithToString() {
+  public void testTemplateTypeWithTypeDef2a() {
     newTest()
-        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @constructor */",
-            "var MyClass = function() {};",
-            "/** @override*/",
-            "MyClass.prototype.toString = function() { return ''; };",
-            "/** @enum{!MyClass} */",
-            "var Enum = {};",
-            "/** @type {!Object<Enum, number>} */",
-            "var k;")
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Bar> */ x) {}\n"
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testBadSuperclassInheritance1() {
+  public void testTemplateTypeWithTypeDef2b() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
-            "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @type {number} */",
-            "Bar.prototype.myprop = 1;")
-        .addDiagnostic(TypeCheck.HIDDEN_SUPERCLASS_PROPERTY)
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Bar> */ x) {}\n"
+                + "/** @type {Generic<!Bar>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testBadSuperclassInheritance2() {
+  public void testTemplateTypeWithTypeDef2c() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
-            "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @override @type {string} */",
-            "Bar.prototype.myprop = 'qwer';")
-        .addDiagnostic(TypeValidator.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH)
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Foo> */ x) {}\n"
+                + "/** @type {Generic<!Foo>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
-  // If the property has no initializer, the HIDDEN_SUPERCLASS_PROPERTY_MISMATCH warning is missed.
   @Test
-  public void testBadSuperclassInheritance3() {
+  public void testTemplateTypeWithTypeDef2d() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.myprop = 2;",
-            "",
-            "/** @constructor @extends {Foo} */",
-            "function Bar() {}",
-            "/** @override @type {string} */",
-            "Bar.prototype.myprop;")
-        .run();
+            "/**\n"
+                + " * @constructor\n"
+                + " * @template T\n"
+                + " * @param {T} x\n"
+                + " */\n"
+                + "function Generic(x) {}\n"
+                + "\n"
+                + "/** @constructor */\n"
+                + "function Foo() {}\n"
+                + "\n"
+                + "/** @typedef {!Foo} */\n"
+                + "var Bar;\n"
+                + "\n"
+                + "function f(/** Generic<!Foo> */ x) {}\n"
+                + "/** @type {Generic<!Bar>} */ var x;\n"
+                + "f(x);\n")
+        .run(); // no warning expected.
   }
 
   @Test
-  public void testCheckObjectKeysWithNamedType() {
+  public void testTemplatedFunctionInUnion1() {
     newTest()
         .addSource(
-            "/** @type {!Object<!PseudoId, number>} */\n"
-                + "var k;\n"
-                + "/** @typedef {number|string} */\n"
-                + "var PseudoId;")
+            "/**",
+            "* @param {T} x",
+            "* @param {function(this:T, ...)|{fn:Function}} z",
+            "* @template T",
+            "*/",
+            "function f(x, z) {}",
+            "f([], function() { /** @type {string} */ var x = this });")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : Array<?>",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testCheckObjectKeyRecursiveType() {
+  public void testTemplateTypeRecursion1() {
     newTest()
         .addSource(
-            "/** @typedef {!Object<string, !Predicate>} */ var Schema;\n"
-                + "/** @typedef {function(*): boolean|!Schema} */ var Predicate;\n"
-                + "/** @type {!Schema} */ var k;")
+            "/** @typedef {{a: D2}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
   }
 
   @Test
-  public void testDontOverrideNativeScalarTypes() {
+  public void testTemplateTypeRecursion2() {
     newTest()
-        .addSource("string = 123;\n" + "var /** string */ s = 123;")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .addSource(
+            "/** @typedef {{a: D2}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "/** @type {D1} */ var x;"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
+  }
 
+  @Test
+  public void testTemplateTypeRecursion3() {
     newTest()
-        .addSource("var string = goog.require('goog.string');\n" + "var /** string */ s = 123;")
-        .addDiagnostic(
-            "Property require never defined on goog" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
+        .addSource(
+            "/** @typedef {{a: function(D2)}} */\n"
+                + "var D1;\n"
+                + "\n"
+                + "/** @typedef {{b: D1}} */\n"
+                + "var D2;\n"
+                + "\n"
+                + "/** @type {D1} */ var x;"
+                + "fn(x);\n"
+                + "\n"
+                + "\n"
+                + "/**\n"
+                + " * @param {!D1} s\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var fn = function(s) {};")
         .run();
   }
 
   @Test
-  public void testTemplateMap1() {
+  @Ignore
+  public void testFunctionLiteralUndefinedThisArgument() {
+    // TODO(johnlenz): this was a weird error.  We should add a general
+    // restriction on what is accepted for T. Something like:
+    // "@template T of {Object|string}" or some such.
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  /** @type {Int8Array} */\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IArrayLike<string>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n" + "found   : (Int8Array|null)\n" + "required: (IArrayLike<string>|null)")
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() { this; });")
+        .addDiagnostic("Function literal argument refers to undefined this argument")
         .run();
   }
 
   @Test
-  public void testTemplateMap2() {
+  public void testFunctionLiteralDefinedThisArgument() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  /** @type {Int8Array} */\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IObject<number, string>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n"
-                + "found   : (Int8Array|null)\n"
-                + "required: (IObject<number,string>|null)")
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() { this; }, {});")
         .run();
   }
 
   @Test
-  public void testTemplateMap3() {
+  public void testFunctionLiteralDefinedThisArgument2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addExterns(new TestExternsBuilder().addArray().build())
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IArrayLike<string>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
+            "/** @param {string} x */ function f(x) {}",
+            "/**",
+            " * @param {?function(this:T, ...)} fn",
+            " * @param {T=} opt_obj",
+            " * @template T",
+            " */",
+            "function baz(fn, opt_obj) {}",
+            "function g() { baz(function() { f(this.length); }, []); }")
         .addDiagnostic(
-            "assignment\n" + "found   : Int8Array\n" + "required: (IArrayLike<string>|null)")
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testTemplateMap4() {
+  public void testFunctionLiteralUnreadNullThisArgument() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "\n"
-                + "  /** @type {IObject<number, string>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .addDiagnostic(
-            "assignment\n" + "found   : Int8Array\n" + "required: (IObject<number,string>|null)")
+            ""
+                + "/**\n"
+                + " * @param {function(this:T, ...)?} fn\n"
+                + " * @param {?T} opt_obj\n"
+                + " * @template T\n"
+                + " */\n"
+                + "function baz(fn, opt_obj) {}\n"
+                + "baz(function() {}, null);")
         .run();
   }
 
   @Test
-  public void testTemplateMap5() {
+  public void testUnionTemplateThisType() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IArrayLike<number>} */\n"
-                + "  var y;\n"
-                + "  y = x;\n"
-                + "}")
-        .includeDefaultExterns()
+            "/** @constructor */ function F() {}"
+                + "/** @return {F|Array} */ function g() { return []; }"
+                + "/** @param {F} x */ function h(x) { }"
+                + "/**\n"
+                + "* @param {T} x\n"
+                + "* @param {function(this:T, ...)} y\n"
+                + "* @template T\n"
+                + "*/\n"
+                + "function f(x, y) {}\n"
+                + "f(g(), function() { h(this); });")
+        .addDiagnostic(
+            "actual parameter 1 of h does not match formal parameter\n"
+                + "found   : (Array|F|null)\n"
+                + "required: (F|null)")
         .run();
   }
 
   @Test
-  public void testTemplateMap6() {
+  public void testRecordType1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {\n"
-                + "  var x = new Int8Array(10);\n"
-                + "  /** @type {IObject<number, number>} */\n"
-                + "  var z;\n"
-                + "  z = x;\n"
-                + "}")
-        .includeDefaultExterns()
+            "/** @param {{prop: number}} x */", //
+            "function f(x) {}",
+            "f({});")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|undefined)}",
+                "required: {prop: number}",
+                "missing : []",
+                "mismatch: [prop]"))
         .run();
   }
 
-  private static final String EXTERNS_WITH_IARRAYLIKE_DECLS =
-      "/**\n"
-          + " * @constructor @implements IArrayLike<number>\n"
-          + " */\n"
-          + "function Int8Array(length, opt_byteOffset, opt_length) {}\n"
-          + "/** @type {number} */\n"
-          + "Int8Array.prototype.length;\n"
-          + "/**\n"
-          + "* @constructor\n"
-          + "* @extends {Int8Array}\n"
-          + "*/\n"
-          + "function Int8Array2(len) {};\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<number>}\n"
-          + " */\n"
-          + "function IArrayLike2(){}\n"
-          + "\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike2}\n"
-          + " */\n"
-          + "function Int8Array3(len) {};\n"
-          + "/** @type {number} */\n"
-          + "Int8Array3.prototype.length;\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<VALUE3>}\n"
-          + " * @template VALUE3\n"
-          + " */\n"
-          + "function IArrayLike3(){}\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike3<number>}\n"
-          + " */\n"
-          + "function Int8Array4(length) {};\n"
-          + "/** @type {number} */\n"
-          + "Int8Array4.prototype.length;\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike<VALUE2>}\n"
-          + " * @template VALUE2\n"
-          + " */\n"
-          + "function IArrayLike4(){}\n"
-          + "/**\n"
-          + " * @interface\n"
-          + " * @extends {IArrayLike4<boolean>}\n"
-          + " */\n"
-          + "function IArrayLike5(){}\n"
-          + "/**\n"
-          + " * @constructor\n"
-          + " * @implements {IArrayLike5}\n"
-          + " */\n"
-          + "function BooleanArray5(length) {};\n"
-          + "/** @type {number} */\n"
-          + "BooleanArray5.prototype.length;";
-
   @Test
-  public void testArrayImplementsIArrayLike() {
+  public void testRecordType2() {
     newTest()
-        .addSource(
-            "/** @type {!Array<number>} */ var arr = [];\n" + "var /** null */ n = arr[0];\n")
-        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: null")
+        .addSource("/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "f({});")
         .run();
   }
 
   @Test
-  public void testIArrayLike1() {
+  public void testRecordType3() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr = new Int8Array(7);\n" + "// no warning\n" + "arr[0] = 1;\n" + "arr[1] = 2;\n")
-        .includeDefaultExterns()
+            "/** @param {{prop: number}} x */", //
+            "function f(x) {}",
+            "f({prop: 'x'});")
+        .addDiagnostic(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|string)}",
+                "required: {prop: number}",
+                "missing : []",
+                "mismatch: [prop]"))
         .run();
   }
 
   @Test
-  public void testIArrayLike2() {
+  public void testRecordType4() {
+    // Notice that we do not do flow-based inference on the object type:
+    // We don't try to prove that x.prop may not be string until x
+    // gets passed to g.
+    testClosureTypesMultipleWarnings(
+        "/** @param {{prop: (number|undefined)}} x */"
+            + "function f(x) {}"
+            + "/** @param {{prop: (string|undefined)}} x */"
+            + "function g(x) {}"
+            + "var x = {}; f(x); g(x);",
+        ImmutableList.of(
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : {prop: (number|string|undefined)}",
+                "required: {prop: (number|undefined)}",
+                "missing : []",
+                "mismatch: [prop]"),
+            lines(
+                "actual parameter 1 of g does not match formal parameter",
+                "found   : {prop: (number|string|undefined)}",
+                "required: {prop: (string|undefined)}",
+                "missing : []",
+                "mismatch: [prop]")));
+  }
+
+  @Test
+  public void testRecordType5() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array(7);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource(
+            "/** @param {{prop: (number|undefined)}} x */"
+                + "function f(x) {}"
+                + "/** @param {{otherProp: (string|undefined)}} x */"
+                + "function g(x) {}"
+                + "var x = {}; f(x); g(x);")
         .run();
   }
 
   @Test
-  public void testIArrayLike3() {
+  public void testRecordType6() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource("/** @return {{prop: (number|undefined)}} x */" + "function f() { return {}; }")
         .run();
   }
 
   @Test
-  public void testIArrayLike4() {
+  public void testRecordType7() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource(
+            "/** @return {{prop: (number|undefined)}} x */"
+                + "function f() { var x = {}; g(x); return x; }"
+                + "/** @param {number} x */"
+                + "function g(x) {}")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : {prop: (number|undefined)}\n"
+                + "required: number")
         .run();
   }
 
   @Test
-  public void testIArrayLike5() {
+  public void testRecordType8() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array3(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource(
+            "/** @return {{prop: (number|string)}} x */"
+                + "function f() { var x = {prop: 3}; g(x.prop); return x; }"
+                + "/** @param {string} x */"
+                + "function g(x) {}")
+        .addDiagnostic(
+            "actual parameter 1 of g does not match formal parameter\n"
+                + "found   : number\n"
+                + "required: string")
         .run();
   }
 
   @Test
-  public void testIArrayLike6() {
+  public void testDuplicateRecordFields1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr = new Int8Array4(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
-        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .addSource("/**" + "* @param {{x:string, x:number}} a" + "*/" + "function f(a) {};")
+        .addDiagnostic("Bad type annotation. Duplicate record field x." + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testIArrayLike7() {
+  public void testDuplicateRecordFields2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
-        .addSource("var arr5 = new BooleanArray5(10);\n" + "arr5[2] = true;\n" + "arr5[3] = \"\";")
-        .addDiagnostic("assignment\n" + "found   : string\n" + "required: boolean")
+        .addSource(
+            "/**" + "* @param {{name:string,number:x,number:y}} a" + " */" + "function f(a) {};")
+        .addDiagnostic("Bad type annotation. Unknown type x")
+        .addDiagnostic("Bad type annotation. Duplicate record field number." + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testIArrayLike8() {
+  public void testMultipleExtendsInterface1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/** @interface */ function base1() {}\n"
+                + "/** @interface */ function base2() {}\n"
+                + "/** @interface\n"
+                + "* @extends {base1}\n"
+                + "* @extends {base2}\n"
+                + "*/\n"
+                + "function derived() {}")
         .run();
   }
 
   @Test
-  public void testIArrayLike9() {
+  public void testMultipleExtendsInterface2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array2(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "Int0.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int0 is not implemented by type Foo")
         .run();
   }
 
   @Test
-  public void testIArrayLike10() {
+  public void testMultipleExtendsInterface3() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array3(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "Int1.prototype.foo = function() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("property foo on interface Int1 is not implemented by type Foo")
         .run();
   }
 
   @Test
-  public void testIArrayLike11() {
+  public void testMultipleExtendsInterface4() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new Int8Array4(10);", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: number"))
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
+                + " @extends {number} */"
+                + "function Int2() {};"
+                + "/** @constructor\n @implements {Int2} */function Foo() {};")
+        .addDiagnostic("Int2 @extends non-object type number")
         .run();
   }
 
   @Test
-  public void testIArrayLike12() {
+  public void testMultipleExtendsInterface5() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var arr2 = new BooleanArray5(10);", //
-            "arr2['prop'] = true;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : string",
-                "required: number"))
+            "/** @interface */function Int0() {};"
+                + "/** @constructor */function Int1() {};"
+                + "/** @return {string} x */"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};")
+        .addDiagnostic("Int2 cannot extend this type; interfaces can only extend interfaces")
         .run();
   }
 
   @Test
-  public void testIArrayLike13() {
+  public void testMultipleExtendsInterface6() {
     newTest()
-        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "var numOrStr = null ? 0 : 'prop';",
-            "var arr2 = new BooleanArray5(10);",
-            "arr2[numOrStr] = true;")
+            "/** @interface */function Super1() {};",
+            "/** @interface */function Super2() {};",
+            "/** @param {number} bar */Super2.prototype.foo = function(bar) {};",
+            "/** @interface @extends {Super1} @extends {Super2} */function Sub() {};",
+            "/** @override @param {string} bar */Sub.prototype.foo =",
+            "function(bar) {};")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : (number|string)",
-                "required: number"))
+                "mismatch of the foo property on type Sub and the type of the property it "
+                    + "overrides from interface Super2",
+                "original: function(this:Super2, number): undefined",
+                "override: function(this:Sub, string): undefined"))
         .run();
   }
 
   @Test
-  public void testIterableCovariant() {
+  public void testMultipleExtendsInterfaceAssignment() {
     newTest()
         .addSource(
-            "function f(/** !Iterable<(number|string)>*/ x){};",
-            "function g(/** !Iterable<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */var I1 = function() {};\n"
+                + "/** @interface */ var I2 = function() {}\n"
+                + "/** @interface\n@extends {I1}\n@extends {I2}*/"
+                + "var I3 = function() {};\n"
+                + "/** @constructor\n@implements {I3}*/var T = function() {};\n"
+                + "var t = new T();\n"
+                + "/** @type {I1} */var i1 = t;\n"
+                + "/** @type {I2} */var i2 = t;\n"
+                + "/** @type {I3} */var i3 = t;\n"
+                + "i1 = i3;\n"
+                + "i2 = i3;\n")
         .run();
   }
 
   @Test
-  public void testLocalShadowOfIterableNotCovariant() {
+  public void testMultipleExtendsInterfaceParamPass() {
     newTest()
         .addSource(
-            "/** @template T */",
-            "class Iterable {}",
-            "function f(/** !Iterable<(number|string)>*/ x) {};",
-            "function g(/** !Iterable<number> */ arr) {",
-            "    f(arr);",
-            "}",
-            "export {};")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Iterable<number>",
-                "required: Iterable<(number|string)>"))
-        .includeDefaultExterns()
+            "/** @interface */",
+            "var I1 = function() {};",
+            "/** @interface */",
+            "var I2 = function() {}",
+            "/** @interface @extends {I1} @extends {I2} */",
+            "var I3 = function() {};",
+            "/** @constructor @implements {I3} */",
+            "var T = function() {};",
+            "var t = new T();",
+            "/**",
+            " * @param {I1} x",
+            " * @param {I2} y",
+            " * @param {I3} z",
+            " */",
+            "function foo(x,y,z){};",
+            "foo(t,t,t)")
         .run();
   }
 
   @Test
-  public void testIterableNotContravariant() {
+  public void testBadMultipleExtendsClass() {
     newTest()
         .addSource(
-            "function f(/** !Iterable<number>*/ x){};",
-            "function g(/** !Iterable<(number|string)> */ arr) {",
-            "    f(arr);",
-            "}")
+            "/** @constructor */ function base1() {}\n"
+                + "/** @constructor */ function base2() {}\n"
+                + "/** @constructor\n"
+                + "* @extends {base1}\n"
+                + "* @extends {base2}\n"
+                + "*/\n"
+                + "function derived() {}")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Iterable<(number|string)>",
-                "required: Iterable<number>"))
-        .includeDefaultExterns()
+            "Bad type annotation. type annotation incompatible with other annotations."
+                + BAD_TYPE_WIKI_LINK)
         .run();
   }
 
   @Test
-  public void testIterableCovariantWhenComparingToSubtype() {
+  public void testInterfaceExtendsResolution() {
     newTest()
-        .addExterns(
-            "/** @constructor",
-            " * @implements {Iterable<T>}",
-            " * @template T",
-            " */",
-            "function Set() {}")
         .addSource(
-            "function f(/** !Iterable<(number|string)>*/ x){};",
-            "function g(/** !Set<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface \n @extends {A} */ function B() {};\n"
+                + "/** @constructor \n @implements {B} */ function C() {};\n"
+                + "/** @interface */ function A() {};")
         .run();
   }
 
   @Test
-  public void testIteratorCovariant() {
+  public void testPropertyCanBeDefinedInObject() {
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
     newTest()
         .addSource(
-            "function f(/** !Iterator<(string|number)>*/ x){};",
-            "function g(/** !Iterator<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */ function I() {};",
+            "I.prototype.bar = function() {};",
+            "/** @type {Object} */ var foo;",
+            "foo.bar();")
         .run();
   }
 
   @Test
-  public void testGeneratorCovariant() {
+  public void testExtendedInterfacePropertiesCompatibility1() {
     newTest()
         .addSource(
-            "function f(/** !Generator<(string|number)>*/ x){};",
-            "function g(/** !Generator<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} */"
+                + "function Int2() {};")
+        .addDiagnostic(
+            "Interface Int2 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int1")
         .run();
   }
 
   @Test
-  public void testIterableImplementorInvariant() {
+  public void testExtendedInterfacePropertiesCompatibility2() {
     newTest()
-        .addExterns(
-            "/** @constructor",
-            " * @implements {Iterable<T>}",
-            " * @template T",
-            " */",
-            "function Set() {}")
         .addSource(
-            "function f(/** !Set<(string|number)>*/ x){};",
-            "function g(/** !Set<number> */ arr) {",
-            "    f(arr);",
-            "}")
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @interface */function Int2() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @type {Object} */"
+                + "Int2.prototype.foo;"
+                + "/** @interface \n @extends {Int0} \n @extends {Int1} \n"
+                + "@extends {Int2}*/"
+                + "function Int3() {};")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Set<number>",
-                "required: Set<(number|string)>"))
+            "Interface Int3 has a property foo with incompatible types in "
+                + "its super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in "
+                + "its super interfaces Int1 and Int2")
         .run();
   }
 
   @Test
-  public void testIArrayLikeCovariant1() {
+  public void testExtendedInterfacePropertiesCompatibility3() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<(string|number)>*/ x){};",
-            "function g(/** !IArrayLike<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int1")
         .run();
   }
 
   @Test
-  public void testIArrayLikeCovariant2() {
+  public void testExtendedInterfacePropertiesCompatibility4() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<(string|number)>*/ x){};",
-            "function g(/** !Array<number> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface \n @extends {Int0} */ function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @interface */function Int2() {};"
+                + "/** @interface \n @extends {Int2} */ function Int3() {};"
+                + "/** @type {string} */"
+                + "Int2.prototype.foo;"
+                + "/** @interface \n @extends {Int1} \n @extends {Int3} */"
+                + "function Int4() {};")
+        .addDiagnostic(
+            "Interface Int4 has a property foo with incompatible types in its "
+                + "super interfaces Int0 and Int2")
         .run();
   }
 
   @Test
-  public void testIArrayLikeBivaraint() {
+  public void testExtendedInterfacePropertiesCompatibility5() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<number>*/ x){};",
-            "function g(/** !IArrayLike<(string|number)> */ arr) {",
-            "    f(arr);",
-            "}")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {number} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int1 and Int4")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch1() {
+  public void testExtendedInterfacePropertiesCompatibility6() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */ Foo.prototype.length",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {string} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch2() {
+  public void testExtendedInterfacePropertiesCompatibility7() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.length = 5;",
-            "}",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {Object} */"
+                + "Int4.prototype.foo;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int3 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int1")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int1 and Int4")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch3() {
+  public void testExtendedInterfacePropertiesCompatibility8() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};", //
-            "f({length: 5})")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @type {number} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {string} */"
+                + "Int1.prototype.bar;"
+                + "/** @interface \n @extends {Int1} */ function Int2() {};"
+                + "/** @interface \n @extends {Int0} \n @extends {Int2} */"
+                + "function Int3() {};"
+                + "/** @interface */function Int4() {};"
+                + "/** @type {Object} */"
+                + "Int4.prototype.foo;"
+                + "/** @type {Null} */"
+                + "Int4.prototype.bar;"
+                + "/** @interface \n @extends {Int3} \n @extends {Int4} */"
+                + "function Int5() {};")
+        .addDiagnostic(
+            "Interface Int5 has a property bar with incompatible types in its"
+                + " super interfaces Int1 and Int4")
+        .addDiagnostic(
+            "Interface Int5 has a property foo with incompatible types in its"
+                + " super interfaces Int0 and Int4")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch4() {
+  public void testExtendedInterfacePropertiesCompatibility9() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "/** @const */ var ns = {};",
-            "/** @type {number} */ ns.length",
-            "f(ns)")
-        .includeDefaultExterns()
+            "/** @interface\n * @template T */function Int0() {};"
+                + "/** @interface\n * @template T */function Int1() {};"
+                + "/** @type {T} */"
+                + "Int0.prototype.foo;"
+                + "/** @type {T} */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n @extends {Int0<number>} \n @extends {Int1<string>} */"
+                + "function Int2() {};")
+        .addDiagnostic(
+            "Interface Int2 has a property foo with incompatible types in its "
+                + "super interfaces Int0<number> and Int1<string>")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch5() {
+  public void testExtendedInterfacePropertiesCompatibilityNoError() {
     newTest()
         .addSource(
-            "function f(/** !IArrayLike */ x){};",
-            "var ns = function() {};",
-            "/** @type {number} */ ns.length",
-            "f(ns)")
-        .includeDefaultExterns()
+            ""
+                + "/** @interface */function Int0() {};"
+                + "/** @interface */function Int1() {};"
+                + "/** @param {number} x */"
+                + "Int0.prototype.foo;"
+                + "/** @param {number} x */"
+                + "Int1.prototype.foo;"
+                + "/** @interface \n * @extends {Int0} \n * @extends {Int1} */"
+                + "function Int2() {};")
         .run();
   }
 
   @Test
-  public void testIArrayLikeStructuralMatch6() {
-    // Even though Foo's [] element type may not be string, we treat the lack
-    // of explicit type like ? and allow this.
+  public void testImplementedInterfacePropertiesShouldFailOnConflict() {
+    // TODO(b/132718172): Provide a better error message.
     newTest()
         .addSource(
-            "function f(/** !IArrayLike<string> */ x){};",
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {number} */ Foo.prototype.length",
-            "f(new Foo)")
-        .includeDefaultExterns()
+            "/** @interface */function Int0() {};",
+            "/** @interface */function Int1() {};",
+            "/** @type {number} */",
+            "Int0.prototype.foo;",
+            "/** @type {string} */",
+            "Int1.prototype.foo;",
+            "/** @constructor @implements {Int0} @implements {Int1} */",
+            "function Foo() {};",
+            "Foo.prototype.foo;")
+        .addDiagnostic(
+            lines(
+                "mismatch of the foo property on type Foo and the type of the property it"
+                    + " overrides from interface Int1",
+                "original: string",
+                "override: number"))
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch1() {
+  public void testGenerics1a() {
+    String fnDecl =
+        "/** \n"
+            + " * @param {T} x \n"
+            + " * @param {function(T):T} y \n"
+            + " * @template T\n"
+            + " */ \n"
+            + "function f(x,y) { return y(x); }\n";
+
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop;",
-            "function f(/** !WithPropT<number> */ x){}",
-            "/** @constructor */ function Foo() {}",
-            "/** @type {number} */ Foo.prototype.prop;",
-            "f(new Foo);")
+            fnDecl
+                + "/** @type {string} */"
+                + "var out;"
+                + "/** @type {string} */"
+                + "var result = f('hi', function(x){ out = x; return x; });")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch2() {
+  public void testGenerics1b() {
+    String fnDecl =
+        "/** \n"
+            + " * @param {T} x \n"
+            + " * @param {function(T):T} y \n"
+            + " * @template T\n"
+            + " */ \n"
+            + "function f(x,y) { return y(x); }\n";
+
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {number} */ Foo.prototype.prop",
-            "f(new Foo)")
+            fnDecl
+                + "/** @type {string} */"
+                + "var out;"
+                + "var result = f(0, function(x){ out = x; return x; });")
+        .addDiagnostic("assignment\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMatch3() {
+  public void testFilter0() {
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<string> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {U} */ Foo.prototype.prop",
-            "f(new Foo)")
+            "/**\n"
+                + " * @param {T} arr\n"
+                + " * @return {T}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<string>} */"
+                + "var result = filter(arr);")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch1() {
+  public void testFilter1() {
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor */ function Foo() {}",
-            "/** @type {string} */ Foo.prototype.prop = 'str'",
-            "f(new Foo)")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+            "/**\n"
+                + " * @param {!Array<T>} arr\n"
+                + " * @return {!Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<string>} */"
+                + "var result = filter(arr);")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch2() {
+  public void testFilter2() {
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/** @constructor @template U */ function Foo() {}",
-            "/** @type {string} */ Foo.prototype.prop = 'str'",
-            "f(new Foo)")
+            "/**\n"
+                + " * @param {!Array<T>} arr\n"
+                + " * @return {!Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {!Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {!Array<number>} */"
+                + "var result = filter(arr);")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<?>",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+            "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch3() {
+  public void testFilter3() {
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function WithPropT() {}",
-            "/** @type {T} */ WithPropT.prototype.prop",
-            "function f(/** !WithPropT<number> */ x){};",
-            "/**",
-            " * @constructor",
-            " * @template U",
-            " * @param {U} x",
-            " */",
-            "function Foo(x) {",
-            "  /** @type {U} */ this.prop = x",
-            "}",
-            "f(new Foo('str'))")
+            "/**\n"
+                + " * @param {Array<T>} arr\n"
+                + " * @return {Array<T>}\n"
+                + " * @template T\n"
+                + " */\n"
+                + "var filter = function(arr){};\n"
+                + "/** @type {Array<string>} */"
+                + "var arr;\n"
+                + "/** @type {Array<number>} */"
+                + "var result = filter(arr);")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo<string>",
-                "required: WithPropT<number>",
-                "missing : []",
-                "mismatch: [prop]"))
+            "initializing variable\n"
+                + "found   : (Array<string>|null)\n"
+                + "required: (Array<number>|null)")
         .run();
   }
 
   @Test
-  public void testTemplatizedStructuralMismatch4() {
-    newTest()
-        .addSource(
-            "/** @record @template T */",
-            "function WithProp() {}",
-            "/** @type {T} */ WithProp.prototype.prop;",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.prop = 4;",
-            "}",
-            "/**",
-            " * @template U",
-            " * @param {!WithProp<U>} x",
-            " * @param {U} y",
-            " */",
-            "function f(x, y){};",
-            "f(new Foo, 'str')")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : Foo",
-                "required: WithProp<string>",
-                "missing : []",
-                "mismatch: [prop]"))
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter1() {
+    testClosureTypes(
+        "/** @type {Array<string>} */"
+            + "var arr;\n"
+            + "/** @type {!Array<number>} */"
+            + "var result = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {return false;});",
+        "initializing variable\n" + "found   : Array<string>\n" + "required: Array<number>");
   }
 
   @Test
-  public void testTemplatizedStructuralMismatchNotFound() {
-    // TODO(blickly): We would like to find the parameter mismatch here.
-    // Currently they match with type WithProp<?>, which is somewhat unsatisfying.
-    newTest()
-        .addSource(
-            "/** @record @template T */",
-            "function WithProp() {}",
-            "/** @type {T} */ WithProp.prototype.prop;",
-            "/** @constructor */",
-            "function Foo() {",
-            "  /** @type {number} */ this.prop = 4;",
-            "}",
-            "/** @constructor */",
-            "function Bar() {",
-            "  /** @type {string} */ this.prop = 'str';",
-            "}",
-            "/**",
-            " * @template U",
-            " * @param {!WithProp<U>} x",
-            " * @param {!WithProp<U>} y",
-            " */",
-            "function f(x, y){};",
-            "f(new Foo, new Bar)")
-        .run();
+  public void testBackwardsInferenceGoogArrayFilter2() {
+    testClosureTypes(
+        "/** @type {number} */"
+            + "var out;"
+            + "/** @type {Array<string>} */"
+            + "var arr;\n"
+            + "var out4 = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {out = item; return false});",
+        "assignment\n" + "found   : string\n" + "required: number");
   }
 
-  private static final String EXTERNS_WITH_IOBJECT_DECLS =
-      lines(
-          "/**",
-          " * @constructor",
-          " * @implements IObject<(string|number), number>",
-          " */",
-          "function Object2() {}",
-          "/**",
-          " * @constructor @struct",
-          " * @implements IObject<number, number>",
-          " */",
-          "function Object3() {}");
+  @Test
+  public void testBackwardsInferenceGoogArrayFilter3() {
+    testClosureTypes(
+        "/** @type {string} */"
+            + "var out;"
+            + "/** @type {Array<string>} */ var arr;\n"
+            + "var result = goog.array.filter("
+            + "   arr,"
+            + "   function(item,index,src) {out = index;});",
+        "assignment\n" + "found   : number\n" + "required: string");
+  }
 
   @Test
-  public void testIObject1() {
+  public void testBackwardsInferenceGoogArrayFilter4() {
+    testClosureTypes(
+        lines(
+            "/** @type {string} */",
+            "var out;",
+            "/** @type {Array<string>} */ var arr;",
+            "var out4 = goog.array.filter(",
+            "   arr,",
+            "   function(item,index,srcArr) {out = srcArr;});"),
+        lines(
+            "assignment", // keep newlines
+            "found   : (Array|null|{length: number})",
+            "required: string"));
+  }
+
+  @Test
+  public void testCatchExpression1() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[0] = 1;")
-        .includeDefaultExterns()
+            "function fn() {"
+                + "  /** @type {number} */"
+                + "  var out = 0;"
+                + "  try {\n"
+                + "    foo();\n"
+                + "  } catch (/** @type {string} */ e) {\n"
+                + "    out = e;"
+                + "  }"
+                + "}\n")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testIObject2() {
+  public void testCatchExpression2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2['str'] = 1;")
-        .includeDefaultExterns()
+            "function fn() {"
+                + "  /** @type {number} */"
+                + "  var out = 0;"
+                + "  /** @type {string} */"
+                + "  var e;"
+                + "  try {\n"
+                + "    foo();\n"
+                + "  } catch (e) {\n"
+                + "    out = e;"
+                + "  }"
+                + "}\n")
         .run();
   }
 
   @Test
-  public void testIObject3() {
+  public void testIssue1058() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[true] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : boolean",
-                "required: (number|string)"))
+            "/**\n"
+                + "  * @constructor\n"
+                + "  * @template CLASS\n"
+                + "  */\n"
+                + "var Class = function() {};\n"
+                + "\n"
+                + "/**\n"
+                + "  * @param {function(CLASS):CLASS} a\n"
+                + "  * @template T\n"
+                + "  */\n"
+                + "Class.prototype.foo = function(a) {\n"
+                + "  return 'string';\n"
+                + "};\n"
+                + "\n"
+                + "/** @param {number} a\n"
+                + "  * @return {string} */\n"
+                + "var a = function(a) { return '' };\n"
+                + "\n"
+                + "new Class().foo(a);")
         .run();
   }
 
   @Test
-  public void testIObject4() {
+  public void testDeterminacyIssue() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[function(){}] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type",
-                "found   : function(): undefined",
-                "required: (number|string)"))
+            "(function() {\n"
+                + "    /** @constructor */\n"
+                + "    var ImageProxy = function() {};\n"
+                + "    /** @constructor */\n"
+                + "    var FeedReader = function() {};\n"
+                + "    /** @type {ImageProxy} */\n"
+                + "    FeedReader.x = new ImageProxy();\n"
+                + "})();")
         .run();
   }
 
   @Test
-  public void testIObject5() {
+  public void testUnknownTypeReport() {
+    enableReportUnknownTypes();
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[{}] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : {}",
-                "required: (number|string)"))
+        .addSource("function id(x) { return x; }")
+        .addDiagnostic("could not determine the type of this expression")
         .run();
   }
 
   @Test
-  public void testIObject6() {
+  public void testUnknownTypeReport_allowsUnknownIfStatement() {
+    enableReportUnknownTypes();
+    newTest().addSource("function id(x) { x; }").run();
+  }
+
+  @Test
+  public void testUnknownForIn() {
+    enableReportUnknownTypes();
+    newTest().addSource("var x = {'a':1}; var y; \n for(\ny\n in x) {}").run();
+  }
+
+  @Test
+  public void testUnknownTypeDisabledByDefault() {
+    newTest().addSource("function id(x) { return x; }").run();
+  }
+
+  @Test
+  public void testNonexistentPropertyAccessOnStruct() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[undefined] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : undefined",
-                "required: (number|string)"))
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};\n"
+                + "/** @param {A} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testIObject7() {
+  public void testNonexistentPropertyAccessOnStructOrObject() {
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr2 = new Object2();", //
-            "arr2[null] = 1;")
-        .addDiagnostic(
-            lines(
-                "restricted index type", //
-                "found   : null",
-                "required: (number|string)"))
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};\n"
+                + "/** @param {A|Object} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
         .run();
   }
 
   @Test
-  public void testIObject8() {
+  public void testNonexistentPropertyAccessOnExternStruct() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
+        .addExterns(
+            "/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "var A = function() {};")
         .addSource(
-            "var arr = new Object2();", //
-            "/** @type {boolean} */",
-            "var x = arr[3];")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: boolean"))
+            "/** @param {A} a */\n" + "function foo(a) {\n" + "  if (a.bar) { a.bar(); }\n" + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testIObject9() {
+  public void testNonexistentPropertyAccessStructSubtype() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object2();", //
-            "/** @type {(number|string)} */",
-            "var x = arr[3];")
-        .includeDefaultExterns()
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "var A = function() {};"
+                + ""
+                + "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " * @extends {A}\n"
+                + " */\n"
+                + "var B = function() { this.bar = function(){}; };"
+                + ""
+                + "/** @param {A} a */\n"
+                + "function foo(a) {\n"
+                + "  if (a.bar) { a.bar(); }\n"
+                + "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testIObject10() {
+  public void testNonexistentPropertyAccessStructInterfaceSubtype() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {number} */",
-            "var x = arr[3];")
-        .includeDefaultExterns()
+            "/**",
+            " * @interface",
+            " * @struct",
+            " */",
+            "var A = function() {};",
+            "",
+            "/**",
+            " * @interface",
+            " * @struct",
+            " * @extends {A}",
+            " */",
+            "var B = function() {};",
+            "/** @return {void} */ B.prototype.bar = function(){};",
+            "",
+            "/** @param {A} a */",
+            "function foo(a) {",
+            "  if (a.bar) { a.bar(); }",
+            "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testIObject11() {
+  public void testNonexistentPropertyAccessStructRecordSubtype() {
+    disableStrictMissingPropertyChecks();
+
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {boolean} */",
-            "var x = arr[3];")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: boolean"))
+            "/**",
+            " * @record",
+            " * @struct",
+            " */",
+            "var A = function() {};",
+            "",
+            "/**",
+            " * @record",
+            " * @struct",
+            " * @extends {A}",
+            " */",
+            "var B = function() {};",
+            "/** @return {void} */ B.prototype.bar = function(){};",
+            "",
+            "/** @param {A} a */",
+            "function foo(a) {",
+            "  if (a.bar) {",
+            "    a.bar();",
+            "  }",
+            "}")
+        .addDiagnostic("Property bar never defined on A")
         .run();
   }
 
   @Test
-  public void testIObject12() {
+  public void testNonexistentPropertyAccessStructSubtype2() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "/** @type {string} */",
-            "var x = arr[3];")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: string"))
+            "/**\n"
+                + " * @constructor\n"
+                + " * @struct\n"
+                + " */\n"
+                + "function Foo() {\n"
+                + "  this.x = 123;\n"
+                + "}\n"
+                + "var objlit = /** @struct */ { y: 234 };\n"
+                + "Foo.prototype = objlit;\n"
+                + "var n = objlit.x;\n")
+        .addDiagnostic("Property x never defined on Foo.prototype")
         .run();
   }
 
   @Test
-  public void testIObject13() {
+  public void testIssue1024a() {
+    // This test is specifically checking loose property check behavior.
+    disableStrictMissingPropertyChecks();
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "arr[3] = false;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : boolean",
-                "required: number"))
+            "/** @param {Object} a */",
+            "function f(a) {",
+            "  a.prototype = '__proto'",
+            "}",
+            "/** @param {Object} b",
+            " *  @return {!Object}",
+            " */",
+            "function g(b) {",
+            "  return b.prototype",
+            "}")
         .run();
   }
 
   @Test
-  public void testIObject14() {
+  public void testIssue1024b() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var arr = new Object3();", //
-            "arr[3] = 'value';")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : string",
-                "required: number"))
+            "/** @param {Object} a */",
+            "function f(a) {",
+            "  a.prototype = {foo:3};",
+            "}",
+            "/** @param {Object} b",
+            " */",
+            "function g(b) {",
+            "  b.prototype = function(){};",
+            "}")
         .run();
   }
 
   @Test
-  public void testIObject15() {
+  public void testModuleReferenceNotAllowed() {
     newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "function f(/** !Object<string, string> */ x) {}",
-            "var /** !IObject<string, string> */ y;",
-            "f(y);")
-        .includeDefaultExterns()
+        .addSource("/** @param {./Foo} z */ function f(z) {}")
+        .addDiagnostic("Bad type annotation. Unknown type ./Foo")
         .run();
   }
 
   @Test
-  public void testIObject16() {
-    newTest()
-        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
-        .addSource(
-            "function f(/** !Object<string, string> */ x) {}",
-            "var /** !IObject<string, number> */ y;",
-            "f(y);")
-        .addDiagnostic(
-            lines(
-                "actual parameter 1 of f does not match formal parameter",
-                "found   : IObject<string,number>",
-                "required: Object<string,string>"))
+  public void testCheckObjectKeysBadKey1() {
+    newTest()
+        .addSource("/** @type {!Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord1() {
-    // Verify that empty @record subtypes don't cause circular definition warnings.
+  public void testCheckObjectKeysBadKey2() {
     newTest()
-        .addSource(
-            "/** @record */ function I1() {};",
-            "/** @type {number|undefined} */ I1.prototype.prop;",
-            "",
-            "/** @record @extends {I1} */ function I2() {}",
-            "/** @record @extends {I2} */ function I3() {}",
-            "/** @type {string} */ I3.prototype.prop2;",
-            "/** @constructor @implements {I3} */ function C() {",
-            "    /** @type {number} */ this.prop = 1;",
-            "    /** @type {string} */ this.prop2 = 'str';",
-            "}",
-            "",
-            "/** @param {I3} a */ function fn(a) {}")
+        .addSource("/** @type {!Object<function(), number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord2() {
+  public void testCheckObjectKeysBadKey3() {
     newTest()
-        .addSource(
-            "/** @type {!SubInterface} */ var value;",
-            "/** @record */ var SuperInterface = function () {};",
-            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};")
+        .addSource("/** @type {!Object<!Array<!Object>, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testEmptySubtypeRecord3() {
+  public void testCheckObjectKeysBadKey4() {
     newTest()
-        .addSource(
-            "/** @record */ var SuperInterface = function () {};",
-            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};",
-            "/** @type {!SubInterface} */ var value;")
+        .addSource("/** @type {!Object<*, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testEmptySubtypeInterface1() {
+  public void testCheckObjectKeysBadKey5() {
     newTest()
-        .addSource(
-            "/** @type {!SubInterface} */ var value;",
-            "/** @interface */ var SuperInterface = function () {};",
-            "/** @interface @extends {SuperInterface} */ var SubInterface = function() {};")
+        .addSource("/** @type {(string|Object<Object, number>)} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithOptionalProperty() {
+  public void testCheckObjectKeysBadKey6() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, opt_num: (undefined|number)} */ x = new Foo;")
+        .addSource("/** @type {!Object<number, !Object<Object, number>>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithUnknownProperty() {
+  public void testCheckObjectKeysBadKey7() {
     newTest()
         .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, unknown: ?} */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: {\n  str: string,\n  unknown: ?\n}",
-                "missing : [unknown]",
-                "mismatch: []"))
+            "/** @constructor */\n"
+                + "var MyClass = function() {};\n"
+                + "/** @type {!Object<MyClass, number>} */\n"
+                + "var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithOptionalUnknownProperty() {
+  public void testCheckObjectKeysBadKey8() {
     newTest()
         .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, opt_unknown: (?|undefined)} */ x = new Foo;")
+            "/** @enum{!Object} */\n"
+                + "var Enum = {};\n"
+                + "/** @type {!Object<Enum, number>} */\n"
+                + "var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testRecordWithTopProperty() {
+  public void testCheckObjectKeysBadKey9() {
     newTest()
-        .addSource(
-            "/**  @constructor */ function Foo() {};",
-            "Foo.prototype.str = 'foo';",
-            "",
-            "var /** {str: string, top: *} */ x = new Foo;")
-        .addDiagnostic(
-            lines(
-                "initializing variable",
-                "found   : Foo",
-                "required: {\n  str: string,\n  top: *\n}",
-                "missing : [top]",
-                "mismatch: []"))
+        .addSource("/** @type {function(!Object<!Object, number>)} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testOptionalUnknownIsAssignableToUnknown() {
+  public void testCheckObjectKeysBadKey10() {
     newTest()
-        .addSource(
-            "function f(/** (undefined|?) */ opt_unknown) {",
-            "  var /** ? */ unknown = opt_unknown;",
-            "}")
+        .addSource("/** @type {function(): !Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType1() {
+  public void testCheckObjectKeysBadKey11() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor ",
-            "  * @extends {C} ",
-            "  */",
-            "function C2() {}")
         .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+            "/** @constructor */\n"
+                + "function X() {}\n"
+                + "/** @constructor @extends {X} */\n"
+                + "function X2() {}\n"
+                + "/** @enum {!X} */\n"
+                + "var XE = {A:new X};\n"
+                + "/** @type {Object<(!XE|!X2), string>} */\n"
+                + "var Y = {};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType2() {
+  public void testCheckObjectKeysVariousTags1() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor ",
-            "  * @extends {C} ",
-            "  */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C, prop2: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+        .addSource("/** @type {!Object<!Object, number>} */ var k;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType3() {
+  public void testCheckObjectKeysVariousTags2() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .includeDefaultExterns()
+        .addSource("/** @param {!Object<!Object, number>} a */ var f = function(a) {};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType4() {
+  public void testCheckObjectKeysVariousTags3() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C, prop2: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C2|null)}",
-                "required: {\n  prop: (C|null),\n  prop2: (C|null)\n}",
-                "missing : [prop2]",
-                "mismatch: []"))
+        .addSource("/** @return {!Object<!Object, number>} */ var f = function() {return {}};")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType5() {
+  public void testCheckObjectKeysVariousTags4() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function C() {}",
-            "/** @constructor */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop: C}} */",
-            "var r1;",
-            "/** @type {{prop: C2}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C2|null)}",
-                "required: {prop: (C|null)}",
-                "missing : []",
-                "mismatch: [prop]"))
+        .addSource("/** @typedef {!Object<!Object, number>} */ var MyType;")
+        .addDiagnostic(TypeCheck.NON_STRINGIFIABLE_OBJECT_KEY)
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType6() {
+  public void testCheckObjectKeysGoodKey1() {
+    newTest().addSource("/** @type {!Object<number, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey2() {
+    newTest().addSource("/** @type {!Object<string, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey3() {
+    newTest().addSource("/** @type {!Object<boolean, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey4() {
+    newTest().addSource("/** @type {!Object<null, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey5() {
+    newTest().addSource("/** @type {!Object<undefined, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey6() {
+    newTest().addSource("/** @type {!Object<!Date, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey7() {
+    newTest().addSource("/** @type {!Object<!RegExp, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey8() {
+    newTest().addSource("/** @type {!Object<!Array, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey9() {
+    newTest().addSource("/** @type {!Object<!Array<number>, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey10() {
+    newTest().addSource("/** @type {!Object<?, number>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey11() {
+    newTest().addSource("/** @type {!Object<(string|number), number>} */ var k").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey12() {
+    newTest().addSource("/** @type {!Object<Object>} */ var k;").run();
+  }
+
+  @Test
+  public void testCheckObjectKeysGoodKey13() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
         .addSource(
-            "/** @type {{prop: C2}} */",
-            "var r1;",
-            "/** @type {{prop: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop: (C|null)}",
-                "required: {prop: (C2|null)}",
-                "missing : []",
-                "mismatch: [prop]"))
+            "/** @interface */\n"
+                + "var MyInterface = function() {};\n"
+                + "/** @type {!Object<!MyInterface, number>} */\n"
+                + "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType7() {
+  public void testCheckObjectKeysGoodKey14() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
         .addSource(
-            "/** @type {{prop: C2, prop2: C2}} */",
-            "var r1;",
-            "/** @type {{prop: C2, prop2: C}} */",
-            "var r2;",
-            "r1 = r2;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {\n  prop: (C2|null),\n  prop2: (C|null)\n}",
-                "required: {\n  prop: (C2|null),\n  prop2: (C2|null)\n}",
-                "missing : []",
-                "mismatch: [prop2]"))
+            "/** @typedef {{a: number}} */ var MyRecord;\n"
+                + "/** @type {!Object<MyRecord, number>} */ var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType8() {
-    newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Foo(){}",
-            "/** @type {number} */",
-            "Foo.prototype.x = 5",
-            "/** @type {string} */",
-            "Foo.prototype.y = 'str'")
-        .addSource(
-            "/** @type {{x: number, y: string}} */",
-            "var r1 = {x: 1, y: 'value'};",
-            "",
-            "/** @type {!Foo} */",
-            "var f = new Foo();",
-            "r1 = f;")
-        .includeDefaultExterns()
+  public void testCheckObjectKeysGoodKey15() {
+    newTest()
+        .addSource(
+            "/** @enum{number} */\n"
+                + "var Enum = {};\n"
+                + "/** @type {!Object<Enum, number>} */\n"
+                + "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType9() {
+  public void testCheckObjectKeysClassWithToString() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Foo(){}",
-            "/** @type {number} */",
-            "Foo.prototype.x1 = 5",
-            "/** @type {string} */",
-            "Foo.prototype.y = 'str'")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {{x: number, y: string}} */",
-            "var r1 = {x: 1, y: 'value'};",
-            "",
-            "/** @type {!Foo} */",
-            "var f = new Foo();",
-            "f = r1;")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : {\n  x: number,\n  y: string\n}",
-                "required: Foo"))
+            "/** @constructor */",
+            "var MyClass = function() {};",
+            "/** @override*/",
+            "MyClass.prototype.toString = function() { return ''; };",
+            "/** @type {!Object<!MyClass, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType10() {
+  public void testCheckObjectKeysClassInheritsToString() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Foo() {}",
-            "/** @type {{x: !Foo}} */",
-            "Foo.prototype.x = {x: new Foo()};")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "/** @type {!Foo} */",
-            "var o = new Foo();",
-            "",
-            "/** @type {{x: !Foo}} */",
-            "var r = {x : new Foo()};",
-            "r = o;")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : Foo",
-                "required: {x: Foo}",
-                "missing : []",
-                "mismatch: [x]"))
+            "/** @constructor */",
+            "var Parent = function() {};",
+            "/** @override */",
+            "Parent.prototype.toString = function() { return ''; };",
+            "/** @constructor @extends {Parent} */",
+            "var Child = function() {};",
+            "/** @type {!Object<!Child, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType11() {
+  public void testCheckObjectKeysForEnumUsingClassWithToString() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "/** @return {number} */",
-            "Bar1.prototype.y = function(){return 1;};",
-            "/** @constructor @implements {Foo} */",
-            "function Bar() {}",
-            "/** @return {string} */",
-            "Bar.prototype.y = function(){return 'test';};")
+        .addExterns(new TestExternsBuilder().addObject().build())
         .addSource(
-            "function fun(/** Foo */f) {", //
-            "  f.y();",
-            "}",
-            "fun(new Bar1())",
-            "fun(new Bar());")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+            "/** @constructor */",
+            "var MyClass = function() {};",
+            "/** @override*/",
+            "MyClass.prototype.toString = function() { return ''; };",
+            "/** @enum{!MyClass} */",
+            "var Enum = {};",
+            "/** @type {!Object<Enum, number>} */",
+            "var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType12() {
+  public void testBadSuperclassInheritance1() {
     newTest()
-        .addExterns(
-            "/** @interface */",
+        .addSource(
+            "/** @constructor */",
             "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "/** @constructor @implements {Foo} */",
+            "/** @type {number} */",
+            "Foo.prototype.myprop = 2;",
+            "",
+            "/** @constructor @extends {Foo} */",
             "function Bar() {}",
-            "/** @return {undefined} */",
-            "Bar.prototype.y = function(){};")
-        .addSource(
-            "/** @type{Foo} */", //
-            "var f = new Bar1();",
-            "f.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run(); // Only if strict warnings are enabled.
+            "/** @type {number} */",
+            "Bar.prototype.myprop = 1;")
+        .addDiagnostic(TypeCheck.HIDDEN_SUPERCLASS_PROPERTY)
+        .run();
   }
 
   @Test
-  public void testCovarianceForRecordType13() {
+  public void testBadSuperclassInheritance2() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor @implements {I} */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
         .addSource(
-            "/** @type{{x: {obj: I}}} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
-        .run(); // Only if strict warnings are enabled.
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.myprop = 2;",
+            "",
+            "/** @constructor @extends {Foo} */",
+            "function Bar() {}",
+            "/** @override @type {string} */",
+            "Bar.prototype.myprop = 'qwer';")
+        .addDiagnostic(TypeValidator.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH)
+        .run();
   }
 
+  // If the property has no initializer, the HIDDEN_SUPERCLASS_PROPERTY_MISMATCH warning is missed.
   @Test
-  public void testCovarianceForRecordType14a() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testBadSuperclassInheritance3() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
         .addSource(
-            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.myprop = 2;",
+            "",
+            "/** @constructor @extends {Foo} */",
+            "function Bar() {}",
+            "/** @override @type {string} */",
+            "Bar.prototype.myprop;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType14b() {
+  public void testCheckObjectKeysWithNamedType() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @interface */",
-            "function I() {}",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y = function(){};")
         .addSource(
-            "/** @type{({x: {obj: I}}|{x: {obj: C}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
+            "/** @type {!Object<!PseudoId, number>} */\n"
+                + "var k;\n"
+                + "/** @typedef {number|string} */\n"
+                + "var PseudoId;")
         .run();
-    // TODO(johnlenz): enable this.
-    // "Property y not defined on all member types of (I|C)"
   }
 
   @Test
-  public void testCovarianceForRecordType15() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testCheckObjectKeyRecursiveType() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {undefined} */",
-            "C.prototype.y1 = function(){};",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @return {undefined} */",
-            "C1.prototype.y = function(){};")
-        .addSource(
-            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */",
-            "var ri;",
-            "ri.x.obj.y1();",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+        .addSource(
+            "/** @typedef {!Object<string, !Predicate>} */ var Schema;\n"
+                + "/** @typedef {function(*): boolean|!Schema} */ var Predicate;\n"
+                + "/** @type {!Schema} */ var k;")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType16() {
+  public void testDontOverrideNativeScalarTypes() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "/** @return {number} */",
-            "C.prototype.y = function(){return 1;};",
-            "/** @constructor */",
-            "function C1() {}",
-            "/** @return {string} */",
-            "C1.prototype.y = function(){return 'test';};")
-        .addSource(
-            "/** @type{({x: {obj: C}}|{x: {obj: C1}})} */", //
-            "var ri;",
-            "ri.x.obj.y();")
-        .includeDefaultExterns()
+        .addSource("string = 123;\n" + "var /** string */ s = 123;")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
         .run();
-  }
 
-  @Test
-  public void testCovarianceForRecordType17() {
     newTest()
-        .addExterns(
-            "/** @interface */",
-            "function Foo() {}",
-            "/** @constructor @implements {Foo} */",
-            "function Bar1() {}",
-            "Bar1.prototype.y = function(){return {};};",
-            "/** @constructor @implements {Foo} */",
-            "function Bar() {}",
-            "/** @return {number} */",
-            "Bar.prototype.y = function(){return 1;};")
-        .addSource(
-            "/** @type {Foo} */ var f;", //
-            "f.y();")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+        .addSource("var string = goog.require('goog.string');\n" + "var /** string */ s = 123;")
+        .addDiagnostic(
+            "Property require never defined on goog" + POSSIBLE_INEXISTENT_PROPERTY_EXPLANATION)
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: string")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType18() {
-    disableStrictMissingPropertyChecks();
+  public void testTemplateMap1() {
     newTest()
-        .addExterns(
-            "/** @constructor*/",
-            "function Bar1() {}",
-            "/** @type {{x: number}} */",
-            "Bar1.prototype.prop;",
-            "/** @constructor */",
-            "function Bar() {}",
-            "/** @type {{x: number, y: number}} */",
-            "Bar.prototype.prop;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{x: number}} */ var f;", //
-            "f.z;")
-        .includeDefaultExterns()
+            "function f() {\n"
+                + "  /** @type {Int8Array} */\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IArrayLike<string>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : (Int8Array|null)\n" + "required: (IArrayLike<string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType19a() {
-    // Verify loose property check behavior
-    disableStrictMissingPropertyChecks();
+  public void testTemplateMap2() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @constructor */",
-            "function Bar2() {}",
-            "/** @type {number} */",
-            "Bar2.prototype.prop;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {(Bar1|Bar2)} */ var b;", //
-            "var x = b.prop1")
-        .includeDefaultExterns()
+            "function f() {\n"
+                + "  /** @type {Int8Array} */\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IObject<number, string>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n"
+                + "found   : (Int8Array|null)\n"
+                + "required: (IObject<number,string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType19b() {
+  public void testTemplateMap3() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @constructor */",
-            "function Bar2() {}",
-            "/** @type {number} */",
-            "Bar2.prototype.prop;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {(Bar1|Bar2)} */ var b;", //
-            "var x = b.prop1")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IArrayLike<string>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : Int8Array\n" + "required: (IArrayLike<string>|null)")
         .run();
-    // TODO(johnlenz): enable this.
-    // "Property prop1 not defined on all member types of (Bar1|Bar2)"
   }
 
   @Test
-  public void testCovarianceForRecordType20() {
+  public void testTemplateMap4() {
     newTest()
-        .includeDefaultExterns()
-        .addExterns(
-            "/** @constructor */",
-            "function Bar1() {}",
-            "/** @type {number} */",
-            "Bar1.prototype.prop;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop1;",
-            "/** @type {number} */",
-            "Bar1.prototype.prop2;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {(Bar1|{prop:number, prop2: number})} */ var b;",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = b.prop2")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "\n"
+                + "  /** @type {IObject<number, string>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
+        .addDiagnostic(
+            "assignment\n" + "found   : Int8Array\n" + "required: (IObject<number,string>|null)")
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType20_2() {
+  public void testTemplateMap5() {
     newTest()
-        .includeDefaultExterns()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {({prop:number, prop1: number, prop2: number}|",
-            "{prop:number, prop2: number})} */ var b;",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = b.prop2")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IArrayLike<number>} */\n"
+                + "  var y;\n"
+                + "  y = x;\n"
+                + "}")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap1() {
-    // For non object-literal types such as Function, the behavior doesn't change.
-    // The stray property is added as unknown.
+  public void testTemplateMap6() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @return {!Function} */",
-            "function f() {",
-            "  var x = function() {};",
-            "  /** @type {number} */",
-            "  x.prop = 123;",
-            "  return x;",
-            "}",
-            "function g(/** !Function */ x) {",
-            "  var /** null */ n = x.prop;",
-            "}")
-        .addDiagnostic("Property prop never defined on Function")
+            "function f() {\n"
+                + "  var x = new Int8Array(10);\n"
+                + "  /** @type {IObject<number, number>} */\n"
+                + "  var z;\n"
+                + "  z = x;\n"
+                + "}")
+        .includeDefaultExterns()
         .run();
   }
 
-  @Test
-  public void testOptimizePropertyMap1b() {
-    disableStrictMissingPropertyChecks();
+  private static final String EXTERNS_WITH_IARRAYLIKE_DECLS =
+      "/**\n"
+          + " * @constructor @implements IArrayLike<number>\n"
+          + " */\n"
+          + "function Int8Array(length, opt_byteOffset, opt_length) {}\n"
+          + "/** @type {number} */\n"
+          + "Int8Array.prototype.length;\n"
+          + "/**\n"
+          + "* @constructor\n"
+          + "* @extends {Int8Array}\n"
+          + "*/\n"
+          + "function Int8Array2(len) {};\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<number>}\n"
+          + " */\n"
+          + "function IArrayLike2(){}\n"
+          + "\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike2}\n"
+          + " */\n"
+          + "function Int8Array3(len) {};\n"
+          + "/** @type {number} */\n"
+          + "Int8Array3.prototype.length;\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<VALUE3>}\n"
+          + " * @template VALUE3\n"
+          + " */\n"
+          + "function IArrayLike3(){}\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike3<number>}\n"
+          + " */\n"
+          + "function Int8Array4(length) {};\n"
+          + "/** @type {number} */\n"
+          + "Int8Array4.prototype.length;\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike<VALUE2>}\n"
+          + " * @template VALUE2\n"
+          + " */\n"
+          + "function IArrayLike4(){}\n"
+          + "/**\n"
+          + " * @interface\n"
+          + " * @extends {IArrayLike4<boolean>}\n"
+          + " */\n"
+          + "function IArrayLike5(){}\n"
+          + "/**\n"
+          + " * @constructor\n"
+          + " * @implements {IArrayLike5}\n"
+          + " */\n"
+          + "function BooleanArray5(length) {};\n"
+          + "/** @type {number} */\n"
+          + "BooleanArray5.prototype.length;";
 
-    // For non object-literal types such as Function, the behavior doesn't change.
-    // The stray property is added as unknown.
+  @Test
+  public void testArrayImplementsIArrayLike() {
     newTest()
         .addSource(
-            "/** @return {!Function} */",
-            "function f() {",
-            "  var x = function() {};",
-            "  /** @type {number} */",
-            "  x.prop = 123;",
-            "  return x;",
-            "}",
-            "function g(/** !Function */ x) {",
-            "  var /** null */ n = x.prop;",
-            "}")
+            "/** @type {!Array<number>} */ var arr = [];\n" + "var /** null */ n = arr[0];\n")
+        .addDiagnostic("initializing variable\n" + "found   : number\n" + "required: null")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap2() {
-    disableStrictMissingPropertyChecks();
-
-    // Don't add the inferred property to all Foo values.
+  public void testIArrayLike1() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @typedef {{a:number}} */",
-            "var Foo;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+            "var arr = new Int8Array(7);\n" + "// no warning\n" + "arr[0] = 1;\n" + "arr[1] = 2;\n")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap2b() {
-    // Here strict missing properties warns, do we want it to?
+  public void testIArrayLike2() {
     newTest()
-        .addSource(
-            "/** @typedef {{a:number}} */",
-            "var Foo;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}")
-        .addDiagnostic("Property b never defined on y")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array(7);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap3a() {
-    // For @record types, add the stray property to the index as before.
+  public void testIArrayLike3() {
     newTest()
-        .addSource(
-            "/** @record */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.a;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on Foo") // definition
-        .addDiagnostic("Property b never defined on Foo")
-        .run(); // reference
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
+        .run();
   }
 
   @Test
-  public void testOptimizePropertyMap3b() {
-    disableStrictMissingPropertyChecks();
-    // For @record types, add the stray property to the index as before.
+  public void testIArrayLike4() {
     newTest()
-        .addSource(
-            "/** @record */",
-            "function Foo() {}",
-            "/** @type {number} */",
-            "Foo.prototype.a;",
-            "function f(/** !Foo */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array2(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap4() {
+  public void testIArrayLike5() {
     newTest()
-        .addSource(
-            "function f(x) {",
-            "  var y = { a: 1, b: 2 };",
-            "}",
-            "function g(x) {",
-            "  return x.b + 1;",
-            "}")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array3(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap5() {
-    // Tests that we don't declare the properties on Object (so they don't appear on
-    // all object types).
+  public void testIArrayLike6() {
     newTest()
-        .addSource(
-            "function f(x) {",
-            "  var y = { a: 1, b: 2 };",
-            "}",
-            "function g() {",
-            "  var x = { c: 123 };",
-            "  return x.a + 1;",
-            "}")
-        .addDiagnostic("Property a never defined on x")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr = new Int8Array4(10);\n" + "// have warnings\n" + "arr[3] = false;\n")
+        .addDiagnostic("assignment\n" + "found   : boolean\n" + "required: number")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap6() {
-    // Checking loose property behavior
-    disableStrictMissingPropertyChecks();
-
-    // The stray property doesn't appear on other inline record types.
+  public void testIArrayLike7() {
     newTest()
-        .addSource(
-            "function f(/** {a:number} */ x) {",
-            "  var y = x;",
-            "  /** @type {number} */",
-            "  y.b = 123;",
-            "}",
-            "function g(/** {c:number} */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
+        .addSource("var arr5 = new BooleanArray5(10);\n" + "arr5[2] = true;\n" + "arr5[3] = \"\";")
+        .addDiagnostic("assignment\n" + "found   : string\n" + "required: boolean")
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap7() {
+  public void testIArrayLike8() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {",
-            "  var x = {a:1};",
-            "  x.b = 2;",
-            "}",
-            "function g() {",
-            "  var y = {a:1};",
-            "  return y.b + 1;",
-            "}")
-        .addDiagnostic("Property b never defined on y")
+            "var arr2 = new Int8Array(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap8() {
+  public void testIArrayLike9() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f(/** {a:number, b:number} */ x) {}",
-            "function g(/** {c:number} */ x) {",
-            "  var /** null */ n = x.b;",
-            "}")
-        .addDiagnostic("Property b never defined on x")
+            "var arr2 = new Int8Array2(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testOptimizePropertyMap9() {
-    // Checking loose property checks behavior
-    disableStrictMissingPropertyChecks();
-
-    // Don't add the stray property to all types that meet with {a: number, c: string}.
+  public void testIArrayLike10() {
     newTest()
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @constructor */",
-            "function Foo() {",
-            "  this.a = 123;",
-            "}",
-            "function f(/** {a: number, c: string} */ x) {",
-            "  x.b = 234;",
-            "}",
-            "function g(/** !Foo */ x) {",
-            "  return x.b + 5;",
-            "}")
-        .addDiagnostic("Property b never defined on Foo")
+            "var arr2 = new Int8Array3(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType21() {
+  public void testIArrayLike11() {
     newTest()
-        .addExterns("")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @constructor */",
-            "function Bar1() {};",
-            "/** @type {number} */",
-            "Bar1.prototype.propName;",
-            "/** @type {number} */",
-            "Bar1.prototype.propName1;",
-            "/** @type {{prop2:number}} */ var c;",
-            "/** @type {(Bar1|{propName:number, propName1: number})} */ var b;",
-            "var x = b.prop2;")
-        .addDiagnostic("Property prop2 never defined on b")
+            "var arr2 = new Int8Array4(10);", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType23() {
+  public void testIArrayLike12() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function A() {}",
-            "/** @constructor @extends{A} */",
-            "function B() {}",
-            "",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @type {B} */",
-            "C.prototype.prop2;",
-            "/** @type {number} */",
-            "C.prototype.prop3;",
-            "",
-            "/** @constructor */",
-            "function D() {}",
-            "/** @type {number} */",
-            "D.prototype.prop;",
-            "/** @type {number} */",
-            "D.prototype.prop1;",
-            "/** @type {B} */",
-            "D.prototype.prop2;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "/** @type {{prop2: A}} */ var record;",
-            "var xhr = new C();",
-            "if (true) { xhr = new D(); }",
-            // there should be no warning saying that
-            // prop2 is not defined on b;
-            "var x = xhr.prop2")
+            "var arr2 = new BooleanArray5(10);", //
+            "arr2['prop'] = true;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType24() {
+  public void testIArrayLike13() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** @type {!Function} */",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
+        .addExterns(EXTERNS_WITH_IARRAYLIKE_DECLS)
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function, count: number}} */",
-            "  var x;",
-            "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{abort: Function})} */",
-            "  var y;",
-            "  y.abort();",
-            "}")
-        .includeDefaultExterns()
+            "var numOrStr = null ? 0 : 'prop';",
+            "var arr2 = new BooleanArray5(10);",
+            "arr2[numOrStr] = true;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : (number|string)",
+                "required: number"))
         .run();
   }
 
+
   @Test
-  public void testCovarianceForRecordType25() {
+  public void testIArrayLikeStructuralMatch1() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** @type {!Function} */",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
         .addSource(
-            "function f() {",
-            "  /** @type{!Function} */ var f;",
-            "  var x = {abort: f, count: 1}",
-            "  return x;",
-            "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{test2: number})} */",
-            "  var y;",
-            "  y.abort();",
-            "}")
-        .addDiagnostic(STRICT_INEXISTENT_PROPERTY)
+            "function f(/** !IArrayLike */ x){};",
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */ Foo.prototype.length",
+            "f(new Foo)")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType26() {
+  public void testIArrayLikeStructuralMatch2() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;")
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function}} */",
-            "  var x;",
+            "function f(/** !IArrayLike */ x){};",
+            "/** @constructor */",
+            "function Foo() {",
+            "  /** @type {number} */ this.length = 5;",
             "}",
-            "",
-            "function f2() {",
-            "  /** @type{(C|{test2: number})} */",
-            "  var y;",
-            "  /** @type {C} */ (y).abort();",
-            "}")
+            "f(new Foo)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType26AndAHalf() {
+  public void testIArrayLikeStructuralMatch3() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "C.prototype.abort = function() {};",
-            "",
-            "/** @type{number} */",
-            "C.prototype.test2 = 1;",
-            "var g = function /** !C */(){};")
         .addSource(
-            "function f() {",
-            "  /** @type{{abort: !Function}} */",
-            "  var x;",
-            "}",
-            "function f2() {",
-            "  var y = g();",
-            "  y.abort();",
-            "}")
+            "function f(/** !IArrayLike */ x){};", //
+            "f({length: 5})")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType27() {
+  public void testIArrayLikeStructuralMatch4() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function C(){}",
-            "/** @constructor @extends {C} */",
-            "function C2() {}")
-        .addSource(
-            "/** @type {{prop2:C}} */ var c;",
-            "/** @type {({prop:number, prop1: number, prop2: C}|",
-            "{prop:number, prop1: number, prop2: number})} */ var b;",
-            "var x = b.prop2;")
+        .addSource(
+            "function f(/** !IArrayLike */ x){};",
+            "/** @const */ var ns = {};",
+            "/** @type {number} */ ns.length",
+            "f(ns)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType28() {
+  public void testIArrayLikeStructuralMatch5() {
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function XMLHttpRequest() {}",
-            "/**",
-            " * @return {undefined}",
-            " */",
-            "XMLHttpRequest.prototype.abort = function() {};",
-            "",
-            "/** @constructor */",
-            "function XDomainRequest() {}",
-            "",
-            "XDomainRequest.prototype.abort = function() {};")
         .addSource(
-            "/**",
-            " * @typedef {{abort: !Function, close: !Function}}",
-            " */",
-            "var WritableStreamSink;",
-            "function sendCrossOrigin() {",
-            "  var xhr = new XMLHttpRequest;",
-            "  xhr = new XDomainRequest;",
-            "  return function() {",
-            "    xhr.abort();",
-            "  };",
-            "}")
+            "function f(/** !IArrayLike */ x){};",
+            "var ns = function() {};",
+            "/** @type {number} */ ns.length",
+            "f(ns)")
         .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType29() {
+  public void testIArrayLikeStructuralMatch6() {
+    // Even though Foo's [] element type may not be string, we treat the lack
+    // of explicit type like ? and allow this.
     newTest()
-        .addExterns(
-            "/** @constructor */",
-            "function XMLHttpRequest() {}",
-            "/**",
-            " * @type {!Function}",
-            " */",
-            "XMLHttpRequest.prototype.abort = function() {};",
-            "",
-            "/** @constructor */",
-            "function XDomainRequest() {}",
-            "/**",
-            " * @type {!Function}",
-            " */",
-            "XDomainRequest.prototype.abort = function() {};")
         .addSource(
-            "/**",
-            " * @typedef {{close: !Function, abort: !Function}}",
-            " */",
-            "var WritableStreamSink;",
-            "function sendCrossOrigin() {",
-            "  var xhr = new XMLHttpRequest;",
-            "  xhr = new XDomainRequest;",
-            "  return function() {",
-            "    xhr.abort();",
-            "  };",
-            "}")
+            "function f(/** !IArrayLike<string> */ x){};",
+            "/** @constructor */",
+            "function Foo() {}",
+            "/** @type {number} */ Foo.prototype.length",
+            "f(new Foo)")
         .includeDefaultExterns()
         .run();
   }
 
+  private static final String EXTERNS_WITH_IOBJECT_DECLS =
+      lines(
+          "/**",
+          " * @constructor",
+          " * @implements IObject<(string|number), number>",
+          " */",
+          "function Object2() {}",
+          "/**",
+          " * @constructor @struct",
+          " * @implements IObject<number, number>",
+          " */",
+          "function Object3() {}");
+
   @Test
-  public void testCovarianceForRecordType30() {
+  public void testIObject1() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function A() {}")
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/**",
-            " * @type {{prop1: (A)}}",
-            " */",
-            "var r1;",
-            "/**",
-            " * @type {{prop1: (A|undefined)}}",
-            " */",
-            "var r2;",
-            "r1 = r2")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop1: (A|null|undefined)}",
-                "required: {prop1: (A|null)}",
-                "missing : []",
-                "mismatch: [prop1]"))
+            "var arr2 = new Object2();", //
+            "arr2[0] = 1;")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testCovarianceForRecordType31() {
+  public void testIObject2() {
     newTest()
-        .addExterns(
-            "/** @constructor */", //
-            "function A() {}")
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/**",
-            " * @type {{prop1: (A|null)}}",
-            " */",
-            "var r1;",
-            "/**",
-            " * @type {{prop1: (A|null|undefined)}}",
-            " */",
-            "var r2;",
-            "r1 = r2")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : {prop1: (A|null|undefined)}",
-                "required: {prop1: (A|null)}",
-                "missing : []",
-                "mismatch: [prop1]"))
+            "var arr2 = new Object2();", //
+            "arr2['str'] = 1;")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition1() {
+  public void testIObject3() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record */",
-            "function A() {}",
-            "/** @type {number} */",
-            "A.prototype.prop;",
-            "/** @record */",
-            "function B() {}",
-            "/** @type {number} */",
-            "B.prototype.prop;",
-            "/** @constructor */",
-            "function C() {}",
-            "/** @type {number} */",
-            "C.prototype.prop;",
-            "/** @return {(A|B|C)} */",
-            "function fun () {}",
-            "/** @return {(B|A|C)} */",
-            "function fun () {}")
-        .addDiagnostic("variable fun redefined, original definition at [testcode]:14")
+            "var arr2 = new Object2();", //
+            "arr2[true] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type", //
+                "found   : boolean",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3() {
+  public void testIObject4() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};", //
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:number}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[function(){}] = 1;")
+        .addDiagnostic(
+            lines(
+                "restricted index type",
+                "found   : function(): undefined",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3_1() {
+  public void testIObject5() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};", //
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:string}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[{}] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type {x: string}, original definition "
-                + "at [testcode]:2 with type {x: number}")
+            lines(
+                "restricted index type", //
+                "found   : {}",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition3_2() {
+  public void testIObject6() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @type {{x:number}} */ ns.x;",
-            "/** @type {{x:number, y:boolean}} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[undefined] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type {\n  x: number,\n  y: boolean\n}, "
-                + "original definition at [testcode]:2 with type {x: number}")
+            lines(
+                "restricted index type", //
+                "found   : undefined",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition4() {
+  public void testIObject7() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @record */ function rec4(){}",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
+            "var arr2 = new Object2();", //
+            "arr2[null] = 1;")
         .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at [testcode]:4 with type"
-                + " rec3")
+            lines(
+                "restricted index type", //
+                "found   : null",
+                "required: (number|string)"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition5() {
+  public void testIObject8() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @record */ function rec4(){}",
-            "/** @type {number} */ rec4.prototype.prop;",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
+            "var arr = new Object2();", //
+            "/** @type {boolean} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at "
-                + "[testcode]:5 with type rec3")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition6() {
+  public void testIObject9() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {};",
-            "/** @record */ function rec3(){}",
-            "/** @type {number} */ rec3.prototype.prop;",
-            "/** @record */ function rec4(){}",
-            "/** @type {!rec3} */ ns.x;",
-            "/** @type {!rec4} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type rec4, original definition at "
-                + "[testcode]:5 with type rec3")
+            "var arr = new Object2();", //
+            "/** @type {(number|string)} */",
+            "var x = arr[3];")
+        .includeDefaultExterns()
         .run();
   }
 
-  /** check bug fix 22713201 (the first case) */
   @Test
-  public void testDuplicateVariableDefinition7() {
+  public void testIObject10() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @typedef {{prop:TD2}} */",
-            "  var TD1;",
-            "",
-            "  /** @typedef {{prop:TD1}} */",
-            "  var TD2;",
-            "",
-            "  var /** TD1 */ td1;",
-            "  var /** TD2 */ td2;",
-            "",
-            "  td1 = td2;")
+            "var arr = new Object3();", //
+            "/** @type {number} */",
+            "var x = arr[3];")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8() {
+  public void testIObject11() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {number} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:number}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: number}, original definition at [testcode]:5"
-                + " with type rec")
+            "var arr = new Object3();", //
+            "/** @type {boolean} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
-                + " {prop: number}")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: boolean"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_2() {
+  public void testIObject12() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {number} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:string}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: string}, original "
-                + "definition at [testcode]:5 with type rec")
+            "var arr = new Object3();", //
+            "/** @type {string} */",
+            "var x = arr[3];")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
-                + " {prop: number}")
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: string"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_3() {
+  public void testIObject13() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {string} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:string}} */ ns.x;",
-            "",
-            "/** @type {{prop:number}} */ ns.y;",
-            "/** @type {!rec} */ ns.y;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: string}, original definition at [testcode]:5"
-                + " with type rec")
+            "var arr = new Object3();", //
+            "arr[3] = false;")
         .addDiagnostic(
-            "variable ns.y redefined with type rec, original definition at "
-                + "[testcode]:8 with type {prop: number}")
+            lines(
+                "assignment", //
+                "found   : boolean",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_4() {
+  public void testIObject14() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I}} */ ns.x;")
+            "var arr = new Object3();", //
+            "arr[3] = 'value';")
         .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I|null)}, original definition at"
-                + " [testcode]:7 with type rec")
+            lines(
+                "assignment", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_5() {
+  public void testIObject15() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I<number>} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I<number>}} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I<number>|null)}, original definition at"
-                + " [testcode]:7 with type rec")
+            "function f(/** !Object<string, string> */ x) {}",
+            "var /** !IObject<string, string> */ y;",
+            "f(y);")
+        .includeDefaultExterns()
         .run();
   }
 
   @Test
-  public void testDuplicateVariableDefinition8_6() {
+  public void testIObject16() {
     newTest()
+        .addExterns(EXTERNS_WITH_IOBJECT_DECLS)
         .addSource(
-            "/** @record @template T */ function I() {}",
-            "/** @type {T} */ I.prototype.prop;",
-            "var ns = {}",
-            "/** @record */ function rec(){}",
-            "/** @type {I<number>} */ rec.prototype.prop;",
-            "",
-            "/** @type {!rec} */ ns.x;",
-            "/** @type {{prop:I<string>}} */ ns.x;")
+            "function f(/** !Object<string, string> */ x) {}",
+            "var /** !IObject<string, number> */ y;",
+            "f(y);")
         .addDiagnostic(
-            "variable ns.x redefined with type {prop: (I<string>|null)}, "
-                + "original definition at [testcode]:7 with type rec")
+            lines(
+                "actual parameter 1 of f does not match formal parameter",
+                "found   : IObject<string,number>",
+                "required: Object<string,string>"))
         .run();
   }
 
-  // should have no warning, need to handle equivalence checking for
-  // structural types with template types
   @Test
-  public void testDuplicateVariableDefinition8_7() {
+  public void testEmptySubtypeRecord1() {
+    // Verify that empty @record subtypes don't cause circular definition warnings.
     newTest()
         .addSource(
-            "/** @record @template T */",
-            "function rec(){}",
-            "/** @type {T} */ rec.prototype.value;",
+            "/** @record */ function I1() {};",
+            "/** @type {number|undefined} */ I1.prototype.prop;",
             "",
-            "/** @type {rec<string>} */ ns.x;",
-            "/** @type {{value: string}} */ ns.x;")
-        .addDiagnostic(
-            "variable ns.x redefined with type {value: string}, "
-                + "original definition at [testcode]:5 with type (null|rec<string>)")
+            "/** @record @extends {I1} */ function I2() {}",
+            "/** @record @extends {I2} */ function I3() {}",
+            "/** @type {string} */ I3.prototype.prop2;",
+            "/** @constructor @implements {I3} */ function C() {",
+            "    /** @type {number} */ this.prop = 1;",
+            "    /** @type {string} */ this.prop2 = 'str';",
+            "}",
+            "",
+            "/** @param {I3} a */ function fn(a) {}")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules1() {
+  public void testEmptySubtypeRecord2() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "function f(/** function(?Foo, !Foo) */ x) {",
-            "  return /** @type {function(!Foo, ?Foo)} */ (x);",
-            "}")
+            "/** @type {!SubInterface} */ var value;",
+            "/** @record */ var SuperInterface = function () {};",
+            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules2() {
+  public void testEmptySubtypeRecord3() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {}",
-            "function f(/** !Array<!Foo> */ to, /** !Array<?Foo> */ from) {",
-            "  to = from;",
-            "}")
+            "/** @record */ var SuperInterface = function () {};",
+            "/** @record @extends {SuperInterface} */ var SubInterface = function() {};",
+            "/** @type {!SubInterface} */ var value;")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules3() {
+  public void testEmptySubtypeInterface1() {
     newTest()
         .addSource(
-            "function f(/** ?Object */ x) {", //
-            "  return {} instanceof x;",
-            "}")
+            "/** @type {!SubInterface} */ var value;",
+            "/** @interface */ var SuperInterface = function () {};",
+            "/** @interface @extends {SuperInterface} */ var SubInterface = function() {};")
         .run();
   }
 
   @Test
-  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules4() {
+  public void testRecordWithOptionalProperty() {
     newTest()
         .addSource(
-            "function f(/** ?Function */ x) {", //
-            "  return x();",
-            "}")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, opt_num: (undefined|number)} */ x = new Foo;")
         .run();
   }
 
   @Test
-  public void testEs5ClassExtendingEs6Class() {
+  public void testRecordWithUnknownProperty() {
     newTest()
         .addSource(
-            "class Foo {}", //
-            "/** @constructor @extends {Foo} */ var Bar = function() {};")
-        .addDiagnostic("ES5 class Bar cannot extend ES6 class Foo")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, unknown: ?} */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: {\n  str: string,\n  unknown: ?\n}",
+                "missing : [unknown]",
+                "mismatch: []"))
         .run();
   }
 
   @Test
-  public void testEs5ClassExtendingEs6Class_noWarning() {
+  public void testRecordWithOptionalUnknownProperty() {
     newTest()
         .addSource(
-            "class A {}", //
-            "/** @constructor @extends {A} */",
-            "const B = createSubclass(A);")
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
+            "",
+            "var /** {str: string, opt_unknown: (?|undefined)} */ x = new Foo;")
         .run();
   }
 
   @Test
-  public void testNonNullTemplatedThis() {
+  public void testRecordWithTopProperty() {
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function C() {}",
-            "",
-            "/** ",
-            "  @return {THIS} ",
-            "  @this {THIS}",
-            "  @template THIS",
-            "*/",
-            "C.prototype.method = function() {};",
-            "",
-            "/** @return {C|null} */",
-            "function f() {",
-            "  return x;",
-            "};",
+            "/**  @constructor */ function Foo() {};",
+            "Foo.prototype.str = 'foo';",
             "",
-            "/** @type {string} */ var s = f().method();")
-        .addDiagnostic("initializing variable\n" + "found   : C\n" + "required: string")
+            "var /** {str: string, top: *} */ x = new Foo;")
+        .addDiagnostic(
+            lines(
+                "initializing variable",
+                "found   : Foo",
+                "required: {\n  str: string,\n  top: *\n}",
+                "missing : [top]",
+                "mismatch: []"))
         .run();
   }
 
-  // Github issue #2222: https://github.com/google/closure-compiler/issues/2222
   @Test
-  public void testSetPrototypeToNewInstance() {
+  public void testOptionalUnknownIsAssignableToUnknown() {
     newTest()
         .addSource(
-            "/** @constructor */", //
-            "function C() {}",
-            "C.prototype = new C;")
+            "function f(/** (undefined|?) */ opt_unknown) {",
+            "  var /** ? */ unknown = opt_unknown;",
+            "}")
         .run();
   }
 
-  @Test
-  public void testFilterNoResolvedType() {
-    testClosureTypes(
-        lines(
-            "goog.forwardDeclare('Foo');",
-            "/**",
-            " * @param {boolean} pred",
-            " * @param {?Foo} x",
-            " */",
-            "function f(pred, x) {",
-            "  var y;",
-            "  if (pred) {",
-            "    y = null;",
-            "  } else {",
-            "    y = x;",
-            "  }",
-            "  var /** number */ z = y;",
-            "}"),
-        // Tests that the type of y is (NoResolvedType|null) and not (Foo|null)
-        lines(
-            "initializing variable", //
-            "found   : (NoResolvedType|null)",
-            "required: number"));
-  }
-
-  @Test
-  public void testNoResolvedTypeDoesntCauseInfiniteLoop() {
-    testClosureTypes(
-        lines(
-            "goog.forwardDeclare('Foo');",
-            "goog.forwardDeclare('Bar');",
-            "",
-            "/** @interface */",
-            "var Baz = function() {};",
-            "/** @return {!Bar} */",
-            "Baz.prototype.getBar = function() {};",
-            "/** @constructor */",
-            "var Qux = function() {",
-            "  /** @type {?Foo} */",
-            "  this.jobRuntimeTracker_ = null;",
-            "};",
-            "/** @param {!Baz} job */",
-            "Qux.prototype.runRenderJobs_ = function(job) {",
-            "  for (var i = 0; i < 10; i++) {",
-            "    if (this.jobRuntimeTracker_) {",
-            "      goog.asserts.assert(job.getBar, '');",
-            "    }",
-            "  }",
-            "};"),
-        null);
-  }
 
   @Test
-  public void testb38182645() {
+  public void testOptimizePropertyMap1() {
+    // For non object-literal types such as Function, the behavior doesn't change.
+    // The stray property is added as unknown.
     newTest()
         .addSource(
-            "",
-            "/**",
-            " * @interface",
-            " * @template VALUE",
-            " */",
-            "function MyI() {}",
-            "",
-            "",
-            "/**",
-            " * @constructor",
-            " * @implements {MyI<K|V>}",
-            " * @template K, V",
-            " */",
-            "function MyMap() {}",
-            "",
-            "",
-            "/**",
-            " * @param {!MyMap<string, T>} map",
-            " * @return {T}",
-            " * @template T",
-            " */",
-            "function getValueFromNameAndMap(map) {",
-            "  return /** @type {?} */ (123);",
+            "/** @return {!Function} */",
+            "function f() {",
+            "  var x = function() {};",
+            "  /** @type {number} */",
+            "  x.prop = 123;",
+            "  return x;",
             "}",
-            "var m = /** @type {!MyMap<string,number>} */ (new MyMap());",
-            "var /** null */ n = getValueFromNameAndMap(m);")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+            "function g(/** !Function */ x) {",
+            "  var /** null */ n = x.prop;",
+            "}")
+        .addDiagnostic("Property prop never defined on Function")
         .run();
   }
 
   @Test
-  public void testLocalType1() {
+  public void testOptimizePropertyMap1b() {
+    disableStrictMissingPropertyChecks();
+
+    // For non object-literal types such as Function, the behavior doesn't change.
+    // The stray property is added as unknown.
     newTest()
         .addSource(
-            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
+            "/** @return {!Function} */",
             "function f() {",
-            "  // shadow",
-            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "  var x = function() {};",
+            "  /** @type {number} */",
+            "  x.prop = 123;",
+            "  return x;",
+            "}",
+            "function g(/** !Function */ x) {",
+            "  var /** null */ n = x.prop;",
             "}")
         .run();
   }
 
   @Test
-  public void testLocalType2() {
+  public void testOptimizePropertyMap2() {
+    disableStrictMissingPropertyChecks();
+
+    // Don't add the inferred property to all Foo values.
     newTest()
         .addSource(
-            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
-            "function f() {",
-            "  // shadow",
-            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
-            "  /** @type {null} */ var x = new C().a;",
+            "/** @typedef {{a:number}} */",
+            "var Foo;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
             "}")
-        .addDiagnostic(
-            lines(
-                "initializing variable", //
-                "found   : number",
-                "required: null"))
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testForwardDecl1() {
+  public void testOptimizePropertyMap2b() {
+    // Here strict missing properties warns, do we want it to?
     newTest()
         .addSource(
-            "/** @const */ var ns = {};",
-            "/** @constructor */ ns.Outer = function C() {};",
-            "/** @return {!ns.Outer.Inner} */",
-            "ns.Outer.prototype.method = function() {",
-            "  return new ns.Outer.Inner();",
-            "};",
-            "/** @constructor */ ns.Outer.Inner = function () {};")
+            "/** @typedef {{a:number}} */",
+            "var Foo;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}")
+        .addDiagnostic("Property b never defined on y")
         .run();
   }
 
   @Test
-  public void testForwardDecl2() {
+  public void testOptimizePropertyMap3a() {
+    // For @record types, add the stray property to the index as before.
     newTest()
         .addSource(
-            "/** @const */ var ns1 = {};",
-            "/** @const */ ns1.ns2 = {};",
-            "/** @constructor */ ns1.ns2.Outer = function C() {};",
-            "/** @return {!ns1.ns2.Outer.Inner} */",
-            "ns1.ns2.Outer.prototype.method = function() {",
-            "  return new ns1.ns2.Outer.Inner();",
-            "};",
-            "/** @constructor */ ns1.ns2.Outer.Inner = function () {};")
-        .run();
+            "/** @record */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.a;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on Foo") // definition
+        .addDiagnostic("Property b never defined on Foo")
+        .run(); // reference
   }
 
   @Test
-  public void testMissingPropertiesWarningOnObject1() {
+  public void testOptimizePropertyMap3b() {
+    disableStrictMissingPropertyChecks();
+    // For @record types, add the stray property to the index as before.
     newTest()
         .addSource(
-            "/** @constructor */",
-            "function Foo() {",
-            "  this.prop = 123;",
+            "/** @record */",
+            "function Foo() {}",
+            "/** @type {number} */",
+            "Foo.prototype.a;",
+            "function f(/** !Foo */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
             "}",
-            "/** @param {!Object} x */",
-            "function f(x) {",
-            "  return x.prop;",
+            "function g(/** !Foo */ x) {",
+            "  var /** null */ n = x.b;",
             "}")
-        .addDiagnostic("Property prop never defined on Object")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators1() {
+  public void testOptimizePropertyMap4() {
     newTest()
-        .addSource("var x = 'asdf' - 1;")
-        .addDiagnostic(
-            lines(
-                "left operand", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(x) {",
+            "  var y = { a: 1, b: 2 };",
+            "}",
+            "function g(x) {",
+            "  return x.b + 1;",
+            "}")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators2() {
+  public void testOptimizePropertyMap5() {
+    // Tests that we don't declare the properties on Object (so they don't appear on
+    // all object types).
     newTest()
-        .addSource("var x = 1 - 'asdf';")
-        .addDiagnostic(
-            lines(
-                "right operand", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(x) {",
+            "  var y = { a: 1, b: 2 };",
+            "}",
+            "function g() {",
+            "  var x = { c: 123 };",
+            "  return x.a + 1;",
+            "}")
+        .addDiagnostic("Property a never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators3() {
-    newTest()
-        .addSource("var x = 'asdf'; x++;")
-        .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : string",
-                "required: number"))
-        .run();
-  }
+  public void testOptimizePropertyMap6() {
+    // Checking loose property behavior
+    disableStrictMissingPropertyChecks();
 
-  @Test
-  public void testStrictNumericOperators4a() {
+    // The stray property doesn't appear on other inline record types.
     newTest()
-        .addSource("var x = -'asdf';")
-        .addDiagnostic(
-            lines(
-                "sign operator", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(/** {a:number} */ x) {",
+            "  var y = x;",
+            "  /** @type {number} */",
+            "  y.b = 123;",
+            "}",
+            "function g(/** {c:number} */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators4b() {
-    newTest().addSource("var x = +'asdf';").run();
-  }
-
-  @Test
-  public void testStrictNumericOperators5() {
+  public void testOptimizePropertyMap7() {
     newTest()
-        .addSource("var x = 1 < 'asdf';")
-        .addDiagnostic(
-            lines(
-                "right side of numeric comparison",
-                "found   : string",
-                "required: (bigint|number)"))
+        .addSource(
+            "function f() {",
+            "  var x = {a:1};",
+            "  x.b = 2;",
+            "}",
+            "function g() {",
+            "  var y = {a:1};",
+            "  return y.b + 1;",
+            "}")
+        .addDiagnostic("Property b never defined on y")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators6() {
+  public void testOptimizePropertyMap8() {
     newTest()
-        .addSource("var x = 'asdf'; x *= 2;")
-        .addDiagnostic(
-            lines(
-                "left operand", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "function f(/** {a:number, b:number} */ x) {}",
+            "function g(/** {c:number} */ x) {",
+            "  var /** null */ n = x.b;",
+            "}")
+        .addDiagnostic("Property b never defined on x")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators7() {
+  public void testOptimizePropertyMap9() {
+    // Checking loose property checks behavior
+    disableStrictMissingPropertyChecks();
+
+    // Don't add the stray property to all types that meet with {a: number, c: string}.
     newTest()
-        .addSource("var x = ~ 'asdf';")
-        .addDiagnostic(
-            lines(
-                "bitwise NOT", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {",
+            "  this.a = 123;",
+            "}",
+            "function f(/** {a: number, c: string} */ x) {",
+            "  x.b = 234;",
+            "}",
+            "function g(/** !Foo */ x) {",
+            "  return x.b + 5;",
+            "}")
+        .addDiagnostic("Property b never defined on Foo")
         .run();
   }
 
+
   @Test
-  public void testStrictNumericOperators8() {
+  public void testDuplicateVariableDefinition1() {
     newTest()
-        .addSource("var x = 'asdf' | 1;")
-        .addDiagnostic(
-            lines(
-                "bad left operand to bitwise operator", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "/** @record */",
+            "function A() {}",
+            "/** @type {number} */",
+            "A.prototype.prop;",
+            "/** @record */",
+            "function B() {}",
+            "/** @type {number} */",
+            "B.prototype.prop;",
+            "/** @constructor */",
+            "function C() {}",
+            "/** @type {number} */",
+            "C.prototype.prop;",
+            "/** @return {(A|B|C)} */",
+            "function fun () {}",
+            "/** @return {(B|A|C)} */",
+            "function fun () {}")
+        .addDiagnostic("variable fun redefined, original definition at [testcode]:14")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators9() {
+  public void testDuplicateVariableDefinition3() {
     newTest()
-        .addSource("var x = 'asdf' << 1;")
-        .addDiagnostic(
-            lines(
-                "operator <<", //
-                "found   : string",
-                "required: number"))
+        .addSource(
+            "var ns = {};", //
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:number}} */ ns.x;")
         .run();
   }
 
   @Test
-  public void testStrictNumericOperators10() {
+  public void testDuplicateVariableDefinition3_1() {
     newTest()
-        .addSource("var x = 1 >>> 'asdf';")
+        .addSource(
+            "var ns = {};", //
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:string}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "operator >>>", //
-                "found   : string",
-                "required: number"))
+            "variable ns.x redefined with type {x: string}, original definition "
+                + "at [testcode]:2 with type {x: number}")
         .run();
   }
 
   @Test
-  public void testBigIntArgument() {
-    newTest().addSource("BigInt(1)").run();
+  public void testDuplicateVariableDefinition3_2() {
     newTest()
-        .addSource("BigInt({})")
+        .addSource(
+            "var ns = {};",
+            "/** @type {{x:number}} */ ns.x;",
+            "/** @type {{x:number, y:boolean}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "actual parameter 1 of BigInt does not match formal parameter",
-                "found   : {}",
-                "required: (bigint|number|string)"))
+            "variable ns.x redefined with type {\n  x: number,\n  y: boolean\n}, "
+                + "original definition at [testcode]:2 with type {x: number}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_increment() {
-    newTest().addSource("const x = 1n; x++;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; x++;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; x++;").run();
+  public void testDuplicateVariableDefinition4() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; x++;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @record */ function rec4(){}",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at [testcode]:4 with type"
+                + " rec3")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_decrement() {
-    newTest().addSource("const x = 1n; x--;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; x--;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; x--;").run();
+  public void testDuplicateVariableDefinition5() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; x--;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @record */ function rec4(){}",
+            "/** @type {number} */ rec4.prototype.prop;",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "increment/decrement", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at "
+                + "[testcode]:5 with type rec3")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_logicalNot() {
-    newTest().addSource("const x = 1n; !x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; !x;").run();
-    newTest().addSource("/** @type {bigint|string} */var x; !x;").run();
-  }
-
-  @Test
-  public void testBigIntOperators_bitwiseNot() {
-    newTest().addSource("const x = 1n; ~x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; ~x;").run();
-    newTest().addSource("/** @type {?} */var x; ~x;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; ~x;").run();
+  public void testDuplicateVariableDefinition6() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; ~x;")
+        .addSource(
+            "var ns = {};",
+            "/** @record */ function rec3(){}",
+            "/** @type {number} */ rec3.prototype.prop;",
+            "/** @record */ function rec4(){}",
+            "/** @type {!rec3} */ ns.x;",
+            "/** @type {!rec4} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "bitwise NOT", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type rec4, original definition at "
+                + "[testcode]:5 with type rec3")
         .run();
   }
 
+  /** check bug fix 22713201 (the first case) */
   @Test
-  public void testBigIntValueOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition7() {
     newTest()
-        .addSource("var x = 1n; +x;")
-        .addDiagnostic("unary operator + cannot be applied to bigint")
+        .addSource(
+            "/** @typedef {{prop:TD2}} */",
+            "  var TD1;",
+            "",
+            "  /** @typedef {{prop:TD1}} */",
+            "  var TD2;",
+            "",
+            "  var /** TD1 */ td1;",
+            "  var /** TD2 */ td2;",
+            "",
+            "  td1 = td2;")
         .run();
   }
 
   @Test
-  public void testBigIntObjectOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8() {
     newTest()
-        .addSource("/** @type {!BigInt} */ var x; +x;")
-        .addDiagnostic("unary operator + cannot be applied to BigInt")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {number} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:number}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: number}, original definition at [testcode]:5"
+                + " with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
+                + " {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntUnionOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8_2() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; +x;")
-        .addDiagnostic("unary operator + cannot be applied to (bigint|number)")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {number} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:string}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: string}, original "
+                + "definition at [testcode]:5 with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at [testcode]:8 with type"
+                + " {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_unaryPlusIsForbidden() {
+  public void testDuplicateVariableDefinition8_3() {
     newTest()
-        .addSource("/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; +BIGINTS.ONE;")
-        .addDiagnostic("unary operator + cannot be applied to BIGINTS<bigint>")
+        .addSource(
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {string} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:string}} */ ns.x;",
+            "",
+            "/** @type {{prop:number}} */ ns.y;",
+            "/** @type {!rec} */ ns.y;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: string}, original definition at [testcode]:5"
+                + " with type rec")
+        .addDiagnostic(
+            "variable ns.y redefined with type rec, original definition at "
+                + "[testcode]:8 with type {prop: number}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_unaryMinus() {
-    newTest().addSource("const x = 1n; -x;").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; -x;").run();
-    newTest().addSource("/** @type {?} */var x; -x;").run();
-    newTest().addSource("/** @type {bigint|number} */var x; -x;").run();
+  public void testDuplicateVariableDefinition8_4() {
     newTest()
-        .addSource("/** @type {bigint|string} */var x; -x;")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I}} */ ns.x;")
         .addDiagnostic(
-            lines(
-                "unary minus operator", //
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+            "variable ns.x redefined with type {prop: (I|null)}, original definition at"
+                + " [testcode]:7 with type rec")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryOperationWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x * y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_assignOpWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x *= y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_binaryBitwiseOperationWithSelf() {
-    newTest().addSource("const x = 1n; const y = 1n; x | y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_additionWithString() {
-    newTest().addSource("const x = 1n; const y = 'str'; x + y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_assignAddWithString() {
-    newTest().addSource("const x = 1n; const y = 'str'; x += y").run();
-  }
-
-  @Test
-  public void testBigIntOperators_binaryOperationWithString() {
+  public void testDuplicateVariableDefinition8_5() {
     newTest()
-        .addSource("const x = 1n; const y = 'str'; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and string")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I<number>} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I<number>}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: (I<number>|null)}, original definition at"
+                + " [testcode]:7 with type rec")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithString() {
+  public void testDuplicateVariableDefinition8_6() {
     newTest()
-        .addSource("const x = 1n; const y = 'str'; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and string")
+        .addSource(
+            "/** @record @template T */ function I() {}",
+            "/** @type {T} */ I.prototype.prop;",
+            "var ns = {}",
+            "/** @record */ function rec(){}",
+            "/** @type {I<number>} */ rec.prototype.prop;",
+            "",
+            "/** @type {!rec} */ ns.x;",
+            "/** @type {{prop:I<string>}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {prop: (I<string>|null)}, "
+                + "original definition at [testcode]:7 with type rec")
         .run();
   }
 
+  // should have no warning, need to handle equivalence checking for
+  // structural types with template types
   @Test
-  public void testBigIntOperators_binaryOperationWithUnknown() {
+  public void testDuplicateVariableDefinition8_7() {
     newTest()
-        .addSource("var x = 1n; /** @type {?} */var y; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and ?")
+        .addSource(
+            "/** @record @template T */",
+            "function rec(){}",
+            "/** @type {T} */ rec.prototype.value;",
+            "",
+            "/** @type {rec<string>} */ ns.x;",
+            "/** @type {{value: string}} */ ns.x;")
+        .addDiagnostic(
+            "variable ns.x redefined with type {value: string}, "
+                + "original definition at [testcode]:5 with type (null|rec<string>)")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithUnknown() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules1() {
     newTest()
-        .addSource("var x = 1n; /** @type {?} */var y; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and ?")
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {}",
+            "function f(/** function(?Foo, !Foo) */ x) {",
+            "  return /** @type {function(!Foo, ?Foo)} */ (x);",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryOperationWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules2() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x * y")
-        .addDiagnostic("operator * cannot be applied to bigint and number")
+        .addSource(
+            "/** @constructor */",
+            "function Foo() {}",
+            "function f(/** !Array<!Foo> */ to, /** !Array<?Foo> */ from) {",
+            "  to = from;",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignOpWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules3() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x *= y")
-        .addDiagnostic("operator *= cannot be applied to bigint and number")
+        .addSource(
+            "function f(/** ?Object */ x) {", //
+            "  return {} instanceof x;",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_binaryBitwiseOperationWithNumber() {
+  public void testModuloNullUndefThatWorkedWithoutSpecialSubtypingRules4() {
     newTest()
-        .addSource("const x = 1n; const y = 1; x | y")
-        .addDiagnostic("operator | cannot be applied to bigint and number")
+        .addSource(
+            "function f(/** ?Function */ x) {", //
+            "  return x();",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntLeftShift() {
-    newTest().addSource("1n << 2n").run();
-    newTest().addSource("let x = 1n; x <<= 2n").run();
-  }
-
-  @Test
-  public void testBigIntRightShift() {
-    newTest().addSource("2n >> 1n").run();
-    newTest().addSource("let x = 2n; x >>= 1n").run();
-  }
-
-  @Test
-  public void testBigIntOperators_unsignedRightShift() {
+  public void testEs5ClassExtendingEs6Class() {
     newTest()
-        .addSource("const x = 1n; x >>> x;")
-        .addDiagnostic("operator >>> cannot be applied to bigint and bigint")
+        .addSource(
+            "class Foo {}", //
+            "/** @constructor @extends {Foo} */ var Bar = function() {};")
+        .addDiagnostic("ES5 class Bar cannot extend ES6 class Foo")
         .run();
   }
 
   @Test
-  public void testBigIntOperators_assignUnsignedRightShift() {
+  public void testEs5ClassExtendingEs6Class_noWarning() {
     newTest()
-        .addSource("let x = 1n; x >>>= x;")
-        .addDiagnostic("operator >>>= cannot be applied to bigint and bigint")
+        .addSource(
+            "class A {}", //
+            "/** @constructor @extends {A} */",
+            "const B = createSubclass(A);")
         .run();
   }
 
   @Test
-  public void testBigIntOrNumberOperators_binaryOperationWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x * x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_assignOpWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x *= x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithSelf() {
-    newTest().addSource("/** @type {bigint|number} */ var x; x | x;").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberOperators_binaryOperationWithBigInt() {
+  public void testNonNullTemplatedThis() {
     newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x * y;")
-        .addDiagnostic("operator * cannot be applied to bigint and (bigint|number)")
+        .addSource(
+            "/** @constructor */",
+            "function C() {}",
+            "",
+            "/** ",
+            "  @return {THIS} ",
+            "  @this {THIS}",
+            "  @template THIS",
+            "*/",
+            "C.prototype.method = function() {};",
+            "",
+            "/** @return {C|null} */",
+            "function f() {",
+            "  return x;",
+            "};",
+            "",
+            "/** @type {string} */ var s = f().method();")
+        .addDiagnostic("initializing variable\n" + "found   : C\n" + "required: string")
         .run();
   }
 
+  // Github issue #2222: https://github.com/google/closure-compiler/issues/2222
   @Test
-  public void testBigIntOrNumberOperators_assignOpWithBigInt() {
+  public void testSetPrototypeToNewInstance() {
     newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to bigint and (bigint|number)")
+        .addSource(
+            "/** @constructor */", //
+            "function C() {}",
+            "C.prototype = new C;")
         .run();
   }
 
   @Test
-  public void testBigIntOrNumberOperators_binaryBitwiseOperationWithBigInt() {
-    newTest()
-        .addSource("var x = 1n; /** @type {bigint|number} */ var y; x | y;")
-        .addDiagnostic("operator | cannot be applied to bigint and (bigint|number)")
-        .run();
+  public void testFilterNoResolvedType() {
+    testClosureTypes(
+        lines(
+            "goog.forwardDeclare('Foo');",
+            "/**",
+            " * @param {boolean} pred",
+            " * @param {?Foo} x",
+            " */",
+            "function f(pred, x) {",
+            "  var y;",
+            "  if (pred) {",
+            "    y = null;",
+            "  } else {",
+            "    y = x;",
+            "  }",
+            "  var /** number */ z = y;",
+            "}"),
+        // Tests that the type of y is (NoResolvedType|null) and not (Foo|null)
+        lines(
+            "initializing variable", //
+            "found   : (NoResolvedType|null)",
+            "required: number"));
   }
 
   @Test
-  public void testBigIntOrNumberOperators_unsignedRightShift() {
-    newTest()
-        .addSource("/** @type {bigint|number} */ var x = 1n; x >>> x;")
-        .addDiagnostic("operator >>> cannot be applied to (bigint|number) and (bigint|number)")
-        .run();
+  public void testNoResolvedTypeDoesntCauseInfiniteLoop() {
+    testClosureTypes(
+        lines(
+            "goog.forwardDeclare('Foo');",
+            "goog.forwardDeclare('Bar');",
+            "",
+            "/** @interface */",
+            "var Baz = function() {};",
+            "/** @return {!Bar} */",
+            "Baz.prototype.getBar = function() {};",
+            "/** @constructor */",
+            "var Qux = function() {",
+            "  /** @type {?Foo} */",
+            "  this.jobRuntimeTracker_ = null;",
+            "};",
+            "/** @param {!Baz} job */",
+            "Qux.prototype.runRenderJobs_ = function(job) {",
+            "  for (var i = 0; i < 10; i++) {",
+            "    if (this.jobRuntimeTracker_) {",
+            "      goog.asserts.assert(job.getBar, '');",
+            "    }",
+            "  }",
+            "};"),
+        null);
   }
 
   @Test
-  public void testBigIntOrNumberOperators_assignUnsignedRightShift() {
+  public void testb38182645() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x = 1n; x >>>= x;")
-        .addDiagnostic("operator >>>= cannot be applied to (bigint|number) and (bigint|number)")
+        .addSource(
+            "",
+            "/**",
+            " * @interface",
+            " * @template VALUE",
+            " */",
+            "function MyI() {}",
+            "",
+            "",
+            "/**",
+            " * @constructor",
+            " * @implements {MyI<K|V>}",
+            " * @template K, V",
+            " */",
+            "function MyMap() {}",
+            "",
+            "",
+            "/**",
+            " * @param {!MyMap<string, T>} map",
+            " * @return {T}",
+            " * @template T",
+            " */",
+            "function getValueFromNameAndMap(map) {",
+            "  return /** @type {?} */ (123);",
+            "}",
+            "var m = /** @type {!MyMap<string,number>} */ (new MyMap());",
+            "var /** null */ n = getValueFromNameAndMap(m);")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_binaryOperationWithBigInt() {
+  public void testLocalType1() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x * y;")
-        .addDiagnostic("operator * cannot be applied to (bigint|string) and bigint")
+        .addSource(
+            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
+            "function f() {",
+            "  // shadow",
+            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "}")
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_assignOpWithBigInt() {
+  public void testLocalType2() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 1n; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to (bigint|string) and bigint")
+        .addSource(
+            "/** @constructor */ function C(){ /** @const */ this.a = true;}",
+            "function f() {",
+            "  // shadow",
+            "  /** @constructor */ function C(){ /** @const */ this.a = 1;}",
+            "  /** @type {null} */ var x = new C().a;",
+            "}")
+        .addDiagnostic(
+            lines(
+                "initializing variable", //
+                "found   : number",
+                "required: null"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_binaryOperationWithBigIntOrNumber() {
+  public void testForwardDecl1() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x * y;")
-        .addDiagnostic("operator * cannot be applied to (bigint|string) and (bigint|number)")
+        .addSource(
+            "/** @const */ var ns = {};",
+            "/** @constructor */ ns.Outer = function C() {};",
+            "/** @return {!ns.Outer.Inner} */",
+            "ns.Outer.prototype.method = function() {",
+            "  return new ns.Outer.Inner();",
+            "};",
+            "/** @constructor */ ns.Outer.Inner = function () {};")
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherOperators_assignOpWithBigIntOrNumber() {
+  public void testForwardDecl2() {
     newTest()
         .addSource(
-            "/** @type {bigint|string} */ var x; /** @type {bigint|number} */ var y; x *= y;")
-        .addDiagnostic("operator *= cannot be applied to (bigint|string) and (bigint|number)")
+            "/** @const */ var ns1 = {};",
+            "/** @const */ ns1.ns2 = {};",
+            "/** @constructor */ ns1.ns2.Outer = function C() {};",
+            "/** @return {!ns1.ns2.Outer.Inner} */",
+            "ns1.ns2.Outer.prototype.method = function() {",
+            "  return new ns1.ns2.Outer.Inner();",
+            "};",
+            "/** @constructor */ ns1.ns2.Outer.Inner = function () {};")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_binaryOperationWithSelf() {
+  public void testMissingPropertiesWarningOnObject1() {
     newTest()
         .addSource(
-            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE * BIGINTS.TWO;")
+            "/** @constructor */",
+            "function Foo() {",
+            "  this.prop = 123;",
+            "}",
+            "/** @param {!Object} x */",
+            "function f(x) {",
+            "  return x.prop;",
+            "}")
+        .addDiagnostic("Property prop never defined on Object")
         .run();
   }
 
   @Test
-  public void testBigIntEnumOperators_assignOpWithSelf() {
+  public void testStrictNumericOperators1() {
     newTest()
-        .addSource(
-            "/** @enum {bigint} */ const BIGINTS = {ONE: 1n, TWO: 2n}; BIGINTS.ONE *= BIGINTS.TWO;")
+        .addSource("var x = 'asdf' - 1;")
+        .addDiagnostic(
+            lines(
+                "left operand", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntComparisons() {
-    newTest().addSource("var x = 1n; var y = 2n; x < y").run();
-    newTest().addSource("var x = 1n; /** @type {!BigInt} */ var y; x < y").run();
-    newTest().addSource("var x = 1n; var y = 2; x < y").run();
-    newTest().addSource("var x = 1n; /** @type {?} */ var y; x < y").run();
-  }
-
-  @Test
-  public void testBigIntComparisonWithString() {
+  public void testStrictNumericOperators2() {
     newTest()
-        .addSource("const x = 1n; const y = 'asdf'; x < y;")
+        .addSource("var x = 1 - 'asdf';")
         .addDiagnostic(
             lines(
-                "right side of numeric comparison",
+                "right operand", //
                 "found   : string",
-                "required: (bigint|number)"))
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntObjectComparisons() {
-    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2n; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {!BigInt} */ var y; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; var y = 2; x < y").run();
-    newTest().addSource("/** @type {!BigInt} */ var x; /** @type {?} */ var y; x < y").run();
-  }
-
-  @Test
-  public void testValidBigIntOrNumberComparisons() {
-    newTest()
-        .addSource("/** @type {bigint|number} */ var x; /** @type {bigint|number} */ var y; x < y;")
-        .run();
-    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2; x < y;").run();
-    newTest().addSource("/** @type {bigint|number} */ var x; var y = 2n; x < y;").run();
+  public void testStrictNumericOperators3() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; /** @type {!BigInt} */ var y; x < y;")
+        .addSource("var x = 'asdf'; x++;")
+        .addDiagnostic(
+            lines(
+                "increment/decrement", //
+                "found   : string",
+                "required: number"))
         .run();
-    newTest().addSource("/** @type {bigint|number} */ var x; /** @type {?} */ var y; x < y").run();
   }
 
   @Test
-  public void testBigIntOrNumberComparisonWithString() {
+  public void testStrictNumericOperators4a() {
     newTest()
-        .addSource("/** @type {bigint|number} */ var x; 'asdf' < x;")
+        .addSource("var x = -'asdf';")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison", //
+                "sign operator", //
                 "found   : string",
-                "required: (bigint|number)"))
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testValidBigIntOrOtherComparisons() {
-    newTest()
-        .addSource("/** @type {bigint|string} */ var x; /** @type {bigint|string} */ var y; x < y;")
-        .run();
-    newTest().addSource("/** @type {bigint|string} */ var x; /** @type {?} */ var y; x < y").run();
+  public void testStrictNumericOperators4b() {
+    newTest().addSource("var x = +'asdf';").run();
   }
 
   @Test
-  public void testBigIntOrOtherComparisonWithBigint() {
+  public void testStrictNumericOperators5() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 2n; x < y;")
+        .addSource("var x = 1 < 'asdf';")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison",
-                "found   : (bigint|string)",
+                "right side of numeric comparison",
+                "found   : string",
                 "required: (bigint|number)"))
         .run();
   }
 
   @Test
-  public void testBigIntOrOtherComparisonWithNumber() {
+  public void testStrictNumericOperators6() {
     newTest()
-        .addSource("/** @type {bigint|string} */ var x; var y = 2; x < y;")
+        .addSource("var x = 'asdf'; x *= 2;")
         .addDiagnostic(
             lines(
-                "left side of numeric comparison",
-                "found   : (bigint|string)",
-                "required: (bigint|number)"))
+                "left operand", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntObjectIndex() {
-    // As is, TypeCheck allows for objects to be indexed with bigint. An error could be reported as
-    // is done with arrays, but for now we will avoid such restrictions.
+  public void testStrictNumericOperators7() {
     newTest()
-        .addSource(
-            "var obj = {};",
-            "/** @type {bigint} */ var b;",
-            "/** @type {bigint|number} */ var bn;",
-            "obj[b] = 1;",
-            "obj[bn] = 3;")
+        .addSource("var x = ~ 'asdf';")
+        .addDiagnostic(
+            lines(
+                "bitwise NOT", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntArrayIndex() {
-    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
-    // to maintain consistency with TypeScript.
+  public void testStrictNumericOperators8() {
     newTest()
-        .addSource("var arr = []; /** @type {bigint} */ var b; arr[b];")
+        .addSource("var x = 'asdf' | 1;")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : bigint",
+                "bad left operand to bitwise operator", //
+                "found   : string",
                 "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntConstructorWithNew() {
-    // BigInt object function type cannot be called with "new" keyword
-    newTest().addSource("new BigInt(1)").addDiagnostic("cannot instantiate non-constructor").run();
-  }
-
-  @Test
-  public void testBigIntOrNumberArrayIndex() {
-    // Even though the spec doesn't prohibit using bigint as an array index, we will report an error
-    // to maintain consistency with TypeScript.
+  public void testStrictNumericOperators9() {
     newTest()
-        .addSource("var arr = []; /** @type {bigint|number} */ var bn; arr[bn];")
+        .addSource("var x = 'asdf' << 1;")
         .addDiagnostic(
             lines(
-                "restricted index type", //
-                "found   : (bigint|number)",
+                "operator <<", //
+                "found   : string",
                 "required: number"))
         .run();
   }
 
   @Test
-  public void testBigIntAsComputedPropForObjects() {
-    newTest().addSource("/** @type {bigint} */ var x; ({[x]: 'value', 123n() {}});").run();
-  }
-
-  @Test
-  public void testBigIntAsComputedPropForClasses() {
-    newTest().addSource("/** @unrestricted */ class C { 123n() {} }").run();
-    newTest().addSource("/** @dict */ class C { 123n() {} }").run();
-  }
-
-  @Test
-  public void testBigIntAsComputedPropForStructClasses() {
+  public void testStrictNumericOperators10() {
     newTest()
-        .addSource("class C { 123n() {} }")
-        .addDiagnostic("Cannot do '[]' access on a struct")
+        .addSource("var x = 1 >>> 'asdf';")
+        .addDiagnostic(
+            lines(
+                "operator >>>", //
+                "found   : string",
+                "required: number"))
         .run();
   }
 
@@ -24215,14 +21126,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
   }
 
   @Test
-  public void testBigIntLiteralProperty() {
-    newTest()
-        .addExterns(new TestExternsBuilder().addBigInt().build())
-        .addSource("(1n).toString()")
-        .run();
-  }
-
-  @Test
   public void testStrictComparison1() {
     newTest()
         .addSource("var x = true < 'asdf';")
@@ -24642,151 +21545,6 @@ public final class TypeCheckTest extends TypeCheckTestCase {
         .run();
   }
 
-  @Test
-  public void testCovariantIThenable1() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string|number>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable2() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !IThenable<string|number> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment",
-                "found   : IThenable<(number|string)>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable3() {
-    newTest()
-        .addSource(
-            "/** @type {!Promise<string|number>} */ var x;",
-            "function fn(/** !Promise<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenable4() {
-    newTest()
-        .addSource(
-            "/** @type {!Promise<string>} */ var x;",
-            "function fn(/** !Promise<string|number> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : Promise<(number|string)>",
-                "required: Promise<string>"))
-        .includeDefaultExterns()
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable1() {
-    newTest()
-        .addSource(
-            "/** @type {!Array<string>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : IThenable<string>",
-                "required: Array<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable2() {
-    newTest()
-        .addSource(
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !Array<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : Array<string>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable3() {
-    newTest()
-        .addSource(
-            "/** ",
-            "  @constructor",
-            "  @template T",
-            " */",
-            "function C() {}",
-            "/** @type {!C<string>} */ var x;",
-            "function fn(/** !IThenable<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : IThenable<string>",
-                "required: C<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonThenable4() {
-    newTest()
-        .addSource(
-            "/** ",
-            "  @constructor",
-            "  @template T",
-            " */",
-            "function C() {}",
-            "/** @type {!IThenable<string>} */ var x;",
-            "function fn(/** !C<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .addDiagnostic(
-            lines(
-                "assignment", //
-                "found   : C<string>",
-                "required: IThenable<string>"))
-        .run();
-  }
-
-  @Test
-  public void testCovariantIThenableNonNativeSubclass() {
-    newTest()
-        .addSource(
-            "/**",
-            " * @implements {IThenable<T>}",
-            " * @template T",
-            " */",
-            "class CustomPromise {}",
-            "/** @type {!CustomPromise<(number|string)>} */ var x;",
-            "function fn(/** !CustomPromise<string> */ a ) {",
-            "  x = a;",
-            "}")
-        .run();
-  }
 
   @Test
   public void testPropertyReferenceOnShadowingParameter() {
@@ -26493,12 +23251,12 @@ public final class TypeCheckTest extends TypeCheckTestCase {
         .run();
   }
 
-  private void testClosureTypes(String js, String description) {
+  private void testClosureTypes(String js, @Nullable String description) {
     testClosureTypesMultipleWarnings(
         js, description == null ? null : ImmutableList.of(description));
   }
 
-  private void testClosureTypesMultipleWarnings(String js, List<String> descriptions) {
+  private void testClosureTypesMultipleWarnings(String js, @Nullable List<String> descriptions) {
     compiler.initOptions(compiler.getOptions());
     Node jsRoot = IR.root(compiler.parseTestCode(js));
     Node externs =
diff --git a/test/com/google/javascript/jscomp/TypeInferenceTest.java b/test/com/google/javascript/jscomp/TypeInferenceTest.java
index ef06f3b..4ba92bb 100644
--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java
+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java
@@ -79,6 +79,7 @@ import com.google.javascript.rhino.testing.TypeSubject;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -93,7 +94,7 @@ public final class TypeInferenceTest {
   private JSTypeResolver.Closer closer;
   private Map<String, JSType> assumptions;
   private JSType assumedThisType;
-  private FlowScope returnScope;
+  private @Nullable FlowScope returnScope;
   private static final AssertionFunctionLookup ASSERTION_FUNCTION_MAP =
       AssertionFunctionLookup.of(new ClosureCodingConvention().getAssertionFunctions());
 
@@ -383,7 +384,7 @@ public final class TypeInferenceTest {
 
   /** Returns a record type with a field `fieldName` and JSType specified by `fieldType`. */
   private JSType createRecordType(String fieldName, JSType fieldType) {
-    Map<String, JSType> property = ImmutableMap.of(fieldName, fieldType);
+    ImmutableMap<String, JSType> property = ImmutableMap.of(fieldName, fieldType);
     return registry.createRecordType(property);
   }
 
@@ -2579,7 +2580,7 @@ public final class TypeInferenceTest {
   }
 
   @Test
-  public void testClassFieldsInControlFlow() {
+  public void testComputedClassFieldsInControlFlow() {
     // Based on the class semantics, the static RHS expressions only execute after all of the
     // computed properties, so `y` will get the string value rather than the boolean here.
     inFunction(
@@ -2593,6 +2594,32 @@ public final class TypeInferenceTest {
   }
 
   @Test
+  public void testClassFieldsInControlFlow() {
+    inFunction(
+        lines(
+            "let y;", //
+            "class Foo {",
+            "  static y = (y = '');",
+            "  z = [y = null];",
+            "}"));
+    verify("y", STRING_TYPE);
+  }
+
+  @Test
+  public void testThisTypeAfterMemberField() {
+    JSType thisType = createRecordType("x", STRING_TYPE);
+    assumingThisType(thisType);
+    inFunction(
+        lines(
+            "let thisDotX;", //
+            "(class C {",
+            "  /** @type {number} */",
+            "  static x = 0;",
+            "}, thisDotX = this.x);"));
+    verify("thisDotX", STRING_TYPE);
+  }
+
+  @Test
   public void testFunction() {
     // should verify y as string, but due to function-rooted CFG
     // being detached from larger, root CFG, verifies y as void
@@ -2635,7 +2662,7 @@ public final class TypeInferenceTest {
             "  }",
             "}",
             "let x = Bar.str;"));
-    verify("x", UNKNOWN_TYPE);
+    verify("x", ALL_TYPE);
   }
 
   @Test
diff --git a/test/com/google/javascript/jscomp/TypeTransformationTest.java b/test/com/google/javascript/jscomp/TypeTransformationTest.java
index 5837d63..d0a83ba 100644
--- a/test/com/google/javascript/jscomp/TypeTransformationTest.java
+++ b/test/com/google/javascript/jscomp/TypeTransformationTest.java
@@ -38,7 +38,9 @@ public final class TypeTransformationTest extends CompilerTypeTestCase {
 
   private ImmutableMap<String, JSType> typeVars;
   private ImmutableMap<String, String> nameVars;
-  private static JSType recordTypeTest, nestedRecordTypeTest, asynchRecord;
+  private static JSType recordTypeTest;
+  private static JSType nestedRecordTypeTest;
+  private static JSType asynchRecord;
 
   static final String EXTRA_TYPE_DEFS =
       lines(
@@ -1090,7 +1092,7 @@ public final class TypeTransformationTest extends CompilerTypeTestCase {
   public void testTransformationInstanceObjectToRecord2() {
     // TODO(bradfordcsmith): Define Array.prototype.length using externs instead.
     getNativeArrayType()
-        .defineDeclaredProperty("length", getNativeNumberType(), /* propertyNode */ null);
+        .defineDeclaredProperty("length", getNativeNumberType(), /* propertyNode= */ null);
     testTTL(record("length", getNativeNumberType()), "record(type(ARR, N))");
   }
 
diff --git a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
index 8aa7a64..b85e4b1 100644
--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java
@@ -35,6 +35,7 @@ import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
 import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
 import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;
 import com.google.javascript.jscomp.deps.JsFileLineParser;
@@ -58,8 +59,8 @@ import com.google.javascript.rhino.jstype.ObjectType;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -77,7 +78,6 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   private TypedScope globalScope;
   private TypedScope lastLocalScope;
   private TypedScope lastFunctionScope;
-  private final ResolutionMode moduleResolutionMode = ResolutionMode.BROWSER;
   private boolean processClosurePrimitives = false;
 
   /**
@@ -149,7 +149,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     // Create a fresh statement map for each test case.
     labeledStatementMap = new HashMap<>();
     return (Node externs, Node root) -> {
-      new GatherModuleMetadata(compiler, false, moduleResolutionMode).process(externs, root);
+      new GatherModuleMetadata(compiler, false, ResolutionMode.BROWSER).process(externs, root);
       new ModuleMapCreator(compiler, compiler.getModuleMetadataMap()).process(externs, root);
       new InferConsts(compiler).process(externs, root);
 
@@ -2622,7 +2622,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
 
     FunctionType fooClass = (FunctionType) findNameType("Foo", globalScope);
     ObjectType fooProto = fooClass.getPrototype();
-    List<FunctionType.Parameter> params = fooClass.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooClass.getParameters();
     Node ctorDef = getLabeledStatement("CTOR_BODY").statementNode.getAncestor(3);
 
     // Test class typing.
@@ -2896,7 +2896,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
 
     FunctionType fooClass = (FunctionType) findNameType("Foo", globalScope);
     ObjectType fooProto = fooClass.getPrototype();
-    List<FunctionType.Parameter> params = fooClass.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooClass.getParameters();
 
     // Test class typing.
     assertThat(fooClass.isConstructor()).isTrue();
@@ -2938,7 +2938,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooCtor).withTypeOfProp("method").isNotUnknown();
     assertType(fooCtor).withTypeOfProp("method").isNotEmpty();
 
-    List<FunctionType.Parameter> params = fooCtor.getParameters();
+    ImmutableList<FunctionType.Parameter> params = fooCtor.getParameters();
     assertThat(params).hasSize(1);
     assertType(params.get(0).getJSType()).isNumber();
     assertType(barConstructorProperty).toStringIsEqualTo("(typeof Bar)");
@@ -2964,7 +2964,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
             "}",
             "class Foo extends class extends class extends Bar {} {} {}"));
     FunctionType foo = (FunctionType) (findNameType("Foo", globalScope));
-    List<FunctionType.Parameter> params = foo.getParameters();
+    ImmutableList<FunctionType.Parameter> params = foo.getParameters();
     assertThat(params).hasSize(1);
     assertType(params.get(0).getJSType()).isString();
   }
@@ -3260,10 +3260,10 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooInstance.getPropertyType("b")).toStringIsEqualTo("(symbol|undefined)");
 
     assertThat(fooInstance.hasOwnDeclaredProperty("c")).isTrue();
-    assertType(fooInstance.getPropertyType("c")).isUnknown();
+    assertType(fooInstance.getPropertyType("c")).isNumber();
 
     assertThat(fooInstance.hasOwnDeclaredProperty("d")).isTrue();
-    assertType(fooInstance.getPropertyType("d")).isUnknown();
+    assertType(fooInstance.getPropertyType("d")).toStringIsEqualTo("*");
 
     assertThat(fooInstance.hasOwnDeclaredProperty("e")).isTrue();
     assertType(fooInstance.getPropertyType("e")).toStringIsEqualTo("(null|string)");
@@ -3326,10 +3326,10 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertType(fooCtor.getPropertyType("b")).toStringIsEqualTo("(symbol|undefined)");
 
     assertThat(fooCtor.hasOwnDeclaredProperty("c")).isTrue();
-    assertType(fooCtor.getPropertyType("c")).isUnknown();
+    assertType(fooCtor.getPropertyType("c")).isNumber();
 
     assertThat(fooCtor.hasOwnDeclaredProperty("d")).isTrue();
-    assertType(fooCtor.getPropertyType("d")).isUnknown();
+    assertType(fooCtor.getPropertyType("d")).toStringIsEqualTo("*");
 
     assertThat(fooCtor.hasOwnDeclaredProperty("e")).isTrue();
     assertType(fooCtor.getPropertyType("e")).toStringIsEqualTo("(null|string)");
@@ -4383,7 +4383,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
-  public void testClassTemplateType4() {
+  public void testClassTemplateType4_instanceProperty() {
     // Verify that template types used for instance properties are recognized.
     testSame(
         "/** @const */ var ns = {};"
@@ -4402,6 +4402,34 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testClassTemplateType4_instancePropertyWithInheritance() {
+    // Verify that template types used for instance properties are recognized
+    // when shadowing a template type on the superclass with the same name.
+    testSame(
+        lines(
+            "/**",
+            " * @template T",
+            " */",
+            "class Parent {}",
+            "",
+            "/**",
+            " * @template T",
+            " * @extends {Parent<number>}",
+            " */",
+            "class Child extends Parent {",
+            "  constructor() {",
+            "    super();",
+            "    /** @type {T} */",
+            "    this.foo;",
+            "  }",
+            "};",
+            "",
+            "/** @type {!Child<string>} */ var x = new Child();",
+            "var result = x.foo;"));
+    assertThat(findNameType("result", globalScope).toString()).isEqualTo("string");
+  }
+
+  @Test
   public void testClassTemplateType5() {
     // Verify that template types used for prototype properties in stub
     // declarations are recognized.
@@ -5279,6 +5307,23 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   }
 
   @Test
+  public void testGoogModule_moduleBodyScopeIsStoredOnTheInput() {
+    testSame("goog.module('a'); EXPORTS: exports;");
+
+    final TypedScope moduleScope = getLabeledStatement("EXPORTS").enclosingScope;
+    final Node moduleBodyNode = moduleScope.getRootNode();
+    assertNode(moduleBodyNode).hasToken(Token.MODULE_BODY);
+    final Compiler lastCompiler = getLastCompiler();
+    final InputId inputId = NodeUtil.getInputId(moduleBodyNode);
+    assertThat(inputId).isNotNull();
+    final CompilerInput compilerInput = lastCompiler.getInput(inputId);
+    assertThat(compilerInput).isNotNull();
+    final TypedScope typedScopeStoredOnTheCompilerInput = compilerInput.getTypedScope();
+    assertThat(typedScopeStoredOnTheCompilerInput).isNotNull();
+    assertThat(typedScopeStoredOnTheCompilerInput).isSameInstanceAs(moduleScope);
+  }
+
+  @Test
   public void testGoogModule_declaresExportsVariableImplicitly() {
     testSame("goog.module('a'); EXPORTS: exports;");
 
@@ -6327,9 +6372,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   @Test
   public void testLegacyGoogModule_declaresParentNamespacesGlobally() {
     processClosurePrimitives = true;
-    testSame(
-        srcs(
-            "goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
+    testSame(srcs("goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
 
     assertScope(globalScope).declares("a").directly();
     assertScope(globalScope).declares("a.b").directly();
@@ -6340,9 +6383,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
   @Test
   public void testLegacyGoogModule_isDeclaredPropertyOnParentNamespace() {
     processClosurePrimitives = true;
-    testSame(
-        srcs(
-            "goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
+    testSame(srcs("goog.module('a.b.c'); goog.module.declareLegacyNamespace(); MOD: 0;"));
 
     assertThat(globalScope.getVar("a.b")).hasJSTypeThat().hasDeclaredProperty("c");
   }
@@ -7841,7 +7882,7 @@ public final class TypedScopeCreatorTest extends CompilerTestCase {
     assertAttachedGoogModuleId("SCOPED_CAST", null);
   }
 
-  private void assertAttachedGoogModuleId(String label, String expectedId) {
+  private void assertAttachedGoogModuleId(String label, @Nullable String expectedId) {
     JSType type = this.getLabeledStatement(label).statementNode.getOnlyChild().getJSType();
 
     final String actualId;
diff --git a/test/com/google/javascript/jscomp/ValidityCheckTest.java b/test/com/google/javascript/jscomp/ValidityCheckTest.java
index 84ec5d1..1657bac 100644
--- a/test/com/google/javascript/jscomp/ValidityCheckTest.java
+++ b/test/com/google/javascript/jscomp/ValidityCheckTest.java
@@ -22,6 +22,7 @@ import static com.google.common.truth.Truth.assertWithMessage;
 import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.Token;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -31,7 +32,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class ValidityCheckTest extends CompilerTestCase {
 
-  private CompilerPass otherPass = null;
+  private @Nullable CompilerPass otherPass = null;
 
   @Before
   @Override
diff --git a/test/com/google/javascript/jscomp/VarCheckTest.java b/test/com/google/javascript/jscomp/VarCheckTest.java
index 831e2c2..b87889a 100644
--- a/test/com/google/javascript/jscomp/VarCheckTest.java
+++ b/test/com/google/javascript/jscomp/VarCheckTest.java
@@ -30,6 +30,7 @@ import com.google.javascript.jscomp.testing.JSChunkGraphBuilder;
 import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.StaticSourceFile.SourceKind;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -42,7 +43,7 @@ public final class VarCheckTest extends CompilerTestCase {
   private CheckLevel strictModuleDepErrorLevel;
   private boolean validityCheck = false;
 
-  private CheckLevel externValidationErrorLevel;
+  private @Nullable CheckLevel externValidationErrorLevel;
 
   private boolean declarationCheck;
 
@@ -636,17 +637,20 @@ public final class VarCheckTest extends CompilerTestCase {
     testDependentModules("var x = 10; function a() {y++;} a();", "var y = 11;", null);
   }
 
-  private void testDependentModules(String code1, String code2, DiagnosticType error) {
+  private void testDependentModules(String code1, String code2, @Nullable DiagnosticType error) {
     testDependentModules(code1, code2, error, null);
   }
 
   private void testDependentModules(
-      String code1, String code2, DiagnosticType error, DiagnosticType warning) {
+      String code1, String code2, DiagnosticType error, @Nullable DiagnosticType warning) {
     testTwoModules(code1, code2, true, error, warning);
   }
 
   private void testIndependentModules(
-      String code1, String code2, DiagnosticType error, DiagnosticType warning) {
+      String code1,
+      String code2,
+      @Nullable DiagnosticType error,
+      @Nullable DiagnosticType warning) {
     testTwoModules(code1, code2, false, error, warning);
   }
 
diff --git a/test/com/google/javascript/jscomp/WarningsGuardTest.java b/test/com/google/javascript/jscomp/WarningsGuardTest.java
index 2b0f313..b9f27f9 100644
--- a/test/com/google/javascript/jscomp/WarningsGuardTest.java
+++ b/test/com/google/javascript/jscomp/WarningsGuardTest.java
@@ -33,6 +33,7 @@ import com.google.javascript.rhino.Token;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.SortedSet;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -479,7 +480,7 @@ public final class WarningsGuardTest {
     return null;
   }
 
-  private static JSError makeError(String sourcePath) {
+  private static JSError makeError(@Nullable String sourcePath) {
     Node n = new Node(Token.EMPTY);
     n.setSourceFileForTesting(sourcePath);
     return JSError.make(n, BAR_WARNING);
@@ -491,7 +492,7 @@ public final class WarningsGuardTest {
     return JSError.make(n, type);
   }
 
-  private static JSError makeError(String sourcePath, CheckLevel level) {
+  private static JSError makeError(@Nullable String sourcePath, CheckLevel level) {
     Node n = new Node(Token.EMPTY);
     n.setSourceFileForTesting(sourcePath);
     return JSError.make(n, DiagnosticType.make("FOO", level, "Foo description"));
diff --git a/test/com/google/javascript/jscomp/XtbMessageBundleTest.java b/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
index f7146e5..b08fc22 100644
--- a/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
+++ b/test/com/google/javascript/jscomp/XtbMessageBundleTest.java
@@ -19,6 +19,8 @@ package com.google.javascript.jscomp;
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 
+import com.google.common.collect.ImmutableList;
+import com.google.javascript.jscomp.JsMessage.Part;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -55,21 +57,21 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     JsMessage message = bundle.getMessage("7639678437384034548");
-    assertThat(message.toString()).isEqualTo("descargar");
+    assertThat(message.asJsMessageString()).isEqualTo("descargar");
 
     message = bundle.getMessage("2398375912250604550");
-    assertThat(message.toString()).isEqualTo("Se han\nignorado {$num} conversaciones.");
+    assertThat(message.asJsMessageString()).isEqualTo("Se han\nignorado {$num} conversaciones.");
 
     message = bundle.getMessage("6323937743550839320");
-    assertThat(message.toString())
+    assertThat(message.asJsMessageString())
         .isEqualTo(
             "{$pStart}Si, puede {$linkStart_1_3}hacer "
                 + "clic{$linkEnd_1_3} para utilizar.{$pEnd}{$pStart}Esperamos "
                 + "poder ampliar.{$pEnd}");
 
     message = bundle.getMessage("3945720239421293834");
-    assertThat(message.toString()).isEmpty();
-    assertThat(message.parts()).isNotEmpty();
+    assertThat(message.asJsMessageString()).isEmpty();
+    assertThat(message.getParts()).isNotEmpty();
   }
 
   /**
@@ -100,16 +102,38 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     assertThat(bundle.getAllMessages()).hasSize(2);
-    assertThat(bundle.getMessage("123456").toString())
+    final JsMessage icuMsg = bundle.getMessage("123456");
+    assertThat(icuMsg.asIcuMessageString())
         .isEqualTo(
             "{USER_GENDER,select,"
                 + "female{Hello {USER_IDENTIFIER}.}"
                 + "male{Hello {USER_IDENTIFIER}.}"
                 + "other{Hello {USER_IDENTIFIER}.}}");
+    // For an ICU selector formatted message, XtbMessageBundle automatically converts all the
+    // placeholders into normal strings.
+    final ImmutableList<Part> icuMsgParts = icuMsg.getParts();
+    assertThat(icuMsgParts).hasSize(7);
+    assertThat(icuMsgParts.get(0).getString()).isEqualTo("{USER_GENDER,select,female{Hello ");
+    assertThat(icuMsgParts.get(1).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(2).getString()).isEqualTo(".}male{Hello ");
+    assertThat(icuMsgParts.get(3).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(4).getString()).isEqualTo(".}other{Hello ");
+    assertThat(icuMsgParts.get(5).getCanonicalPlaceholderName()).isEqualTo("USER_IDENTIFIER");
+    assertThat(icuMsgParts.get(6).getString()).isEqualTo(".}}");
 
     // Previous ICU message should not to affect next message
-    assertThat(bundle.getMessage("123457").toString())
+    final JsMessage normalMsg = bundle.getMessage("123457");
+    assertThat(normalMsg.asJsMessageString())
         .isEqualTo("{$startParagraph}p1{$endParagraph}{$startParagraph}p1{$endParagraph}");
+    final ImmutableList<Part> normalMsgParts = normalMsg.getParts();
+    // For a normal message the placeholders are not turned into strings
+    assertThat(normalMsgParts).hasSize(6);
+    assertThat(normalMsgParts.get(0).getJsPlaceholderName()).isEqualTo("startParagraph");
+    assertThat(normalMsgParts.get(1).getString()).isEqualTo("p1");
+    assertThat(normalMsgParts.get(2).getJsPlaceholderName()).isEqualTo("endParagraph");
+    assertThat(normalMsgParts.get(3).getJsPlaceholderName()).isEqualTo("startParagraph");
+    assertThat(normalMsgParts.get(4).getString()).isEqualTo("p1");
+    assertThat(normalMsgParts.get(5).getJsPlaceholderName()).isEqualTo("endParagraph");
   }
 
   /**
@@ -146,7 +170,7 @@ public final class XtbMessageBundleTest {
     XtbMessageBundle bundle = new XtbMessageBundle(stream, PROJECT_ID);
 
     assertThat(bundle.getAllMessages()).hasSize(2);
-    assertThat(bundle.getMessage("123456").toString())
+    assertThat(bundle.getMessage("123456").asIcuMessageString())
         .isEqualTo(
             "{NUM,plural, "
                 + "=1{Setting: {START_STRONG}{UDC_SETTING}{END_STRONG}"
@@ -154,7 +178,7 @@ public final class XtbMessageBundleTest {
                 + "other{Settings: {START_STRONG}{UDC_SETTING_LIST}{END_STRONG}"
                 + " Products: {START_STRONG}{PRODUCT_LIST}{END_STRONG}.}}");
     // Both translation entries should result into the same message in JavaScript.
-    assertThat(bundle.getMessage("987654").toString())
-        .isEqualTo(bundle.getMessage("123456").toString());
+    assertThat(bundle.getMessage("987654").asIcuMessageString())
+        .isEqualTo(bundle.getMessage("123456").asIcuMessageString());
   }
 }
diff --git a/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java b/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
index 4abe9c5..506e5e3 100644
--- a/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
+++ b/test/com/google/javascript/jscomp/deps/DependencyResolverTest.java
@@ -147,8 +147,7 @@ public final class DependencyResolverTest {
     Set<String> seen = new HashSet<>();
     resolver = new DefaultDependencyResolver(ImmutableList.of(fakeDeps1), true);
     try {
-      Collection<String> deps = resolver.getDependencies(
-          "goog.require('foo');goog.require('a');", seen, false);
+      resolver.getDependencies("goog.require('foo');goog.require('a');", seen, false);
       assertWithMessage("Service exception should be thrown").fail();
     } catch (ServiceException expected) {
     }
diff --git a/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java b/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
index 61c91cd..a581193 100644
--- a/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
+++ b/test/com/google/javascript/jscomp/deps/DepsGeneratorTest.java
@@ -516,7 +516,10 @@ public final class DepsGeneratorTest {
     SourceFile src1 = SourceFile.fromCode("src1.js",
         "goog.provide('a');\n");
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), true /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ true,
         "Namespace \"a\" is already provided in other file dep1.js");
   }
 
@@ -536,8 +539,10 @@ public final class DepsGeneratorTest {
     // doErrorMessagesRun uses closure_path //javascript/closure and therefore
     // fails to recognize and de-dupe the stub Closure Library at
     // //path/to/closure.
-    doErrorMessagesRun(ImmutableList.of(fauxClosureDeps),
-        ImmutableList.of(fauxClosureSrc, userSrc), true /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(fauxClosureDeps),
+        ImmutableList.of(fauxClosureSrc, userSrc),
+        /* fatal= */ true,
         "Namespace \"a\" is already provided in other file dep1.js");
   }
 
@@ -582,7 +587,10 @@ public final class DepsGeneratorTest {
         SourceFile.fromCode(
             "src1.js", LINE_JOINER.join("goog.provide('b');", "goog.provide('b');\n"));
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ false,
         "Multiple calls to goog.provide(\"b\")");
   }
 
@@ -594,7 +602,10 @@ public final class DepsGeneratorTest {
         SourceFile.fromCode(
             "src1.js", LINE_JOINER.join("goog.provide('b');", "goog.require('b');", ""));
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.of(src1), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.of(src1),
+        /* fatal= */ false,
         "Namespace \"b\" is both required and provided in the same file.");
   }
 
@@ -608,7 +619,7 @@ public final class DepsGeneratorTest {
     doErrorMessagesRun(
         ImmutableList.of(dep1),
         ImmutableList.of(src1),
-        true /* fatal */,
+        /* fatal= */ true,
         "Namespace \"b\" is required but never provided.\n"
             + "You need to pass a library that has it in srcs or exports to your target's deps.");
   }
@@ -617,7 +628,10 @@ public final class DepsGeneratorTest {
   public void testNoDepsInDepsFile() throws Exception {
     SourceFile dep1 = SourceFile.fromCode("dep1.js", "");
 
-    doErrorMessagesRun(ImmutableList.of(dep1), ImmutableList.<SourceFile>of(), false /* fatal */,
+    doErrorMessagesRun(
+        ImmutableList.of(dep1),
+        ImmutableList.<SourceFile>of(),
+        /* fatal= */ false,
         "No dependencies found in file");
   }
 
@@ -628,7 +642,7 @@ public final class DepsGeneratorTest {
     doErrorMessagesRun(
         ImmutableList.of(),
         ImmutableList.of(src1),
-        true /* fatal */,
+        /* fatal= */ true,
         "Could not find file \"./missing.js\".");
   }
 
diff --git a/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java b/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
index 967dbff..15f27d0 100644
--- a/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
+++ b/test/com/google/javascript/jscomp/deps/ModuleLoaderTest.java
@@ -32,7 +32,7 @@ import com.google.javascript.jscomp.deps.ModuleLoader.PathEscaper;
 import com.google.javascript.jscomp.deps.ModuleLoader.PathResolver;
 import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -64,7 +64,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("js/a.js", "js/b.js"))
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
     assertUri("js/a.js", loader.resolve("js/a.js"));
     assertUri("js/b.js", resolveJsModule(loader.resolve("js/a.js"), "./b"));
@@ -78,7 +78,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("A/index.js", "B/index.js", "app.js"))
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     input("A/index.js");
@@ -113,7 +113,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/A/index.js", resolveJsModule(loader.resolve(" /foo.js"), "/A"));
@@ -321,7 +321,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(PACKAGE_JSON_MAIN_ENTRIES))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/A/index.js", resolveJsModule(loader.resolve(" /foo.js"), "/A"));
@@ -378,7 +378,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of())
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(packageJsonMainEntries))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri(
@@ -420,7 +420,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("generated_files/"))
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(ImmutableMap.of()))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     assertUri("/node_modules/second.js", resolveJsModule(loader.resolve("/foo.js"), "second"));
@@ -451,7 +451,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("generated_files/"))
             .setInputs(compilerInputs)
             .setFactory(new NodeModuleResolver.Factory(ImmutableMap.of()))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     // 'first' and 'second' should resolve from foo.js
@@ -475,7 +475,7 @@ public final class ModuleLoaderTest {
             .setModuleRoots(ImmutableList.of("."))
             .setInputs(inputs("A/index.js", "B/index.js", "app.js"))
             .setFactory(new WebpackModuleResolver.Factory(webpackModulesById))
-            .setPathResolver(ModuleLoader.PathResolver.RELATIVE)
+            .setPathResolver(PathResolver.RELATIVE)
             .build();
 
     input("A/index.js");
@@ -603,9 +603,8 @@ public final class ModuleLoaderTest {
                     ErrorHandler errorHandler,
                     PathEscaper pathEscaper) ->
                     new ModuleResolver(modulePaths, moduleRootPaths, errorHandler, pathEscaper) {
-                      @Nullable
                       @Override
-                      public String resolveJsModule(
+                      public @Nullable String resolveJsModule(
                           String scriptAddress,
                           String moduleAddress,
                           String sourcename,
diff --git a/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java b/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
index 8002f2b..5cab248 100644
--- a/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/ColorFindPropertyReferencesTest.java
@@ -55,7 +55,7 @@ import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -67,7 +67,7 @@ public final class ColorFindPropertyReferencesTest extends CompilerTestCase {
 
   private final Compiler compiler = new Compiler();
 
-  private CompilerPass processor;
+  private @Nullable CompilerPass processor;
   private ImmutableSet<String> expectedOriginalNameTypes = ImmutableSet.of();
 
   /**
diff --git a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
index c4b1a90..429cbb1 100644
--- a/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
+++ b/test/com/google/javascript/jscomp/disambiguate/ColorGraphBuilderTest.java
@@ -48,7 +48,7 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -72,7 +72,7 @@ public final class ColorGraphBuilderTest extends CompilerTestCase {
       ColorGraphNodeFactory.createFactory(
           ColorRegistry.builder().setDefaultNativeColorsForTesting().build());
 
-  private CompilerPass processor;
+  private @Nullable CompilerPass processor;
   private DiGraph<ColorGraphNode, Object> result;
   private LinkedHashMap<String, ColorId> labelToId;
 
diff --git a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
index 06a5bf5..61b3ff9 100644
--- a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
+++ b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java
@@ -18,6 +18,7 @@ package com.google.javascript.jscomp.graph;
 
 import static com.google.common.truth.Truth.assertWithMessage;
 
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -28,8 +29,8 @@ import org.junit.runners.JUnit4;
  */
 @RunWith(JUnit4.class)
 public final class GraphReachabilityTest {
-  GraphReachability<String, String> reachability = null;
-  DiGraph<String, String> graph = null;
+  @Nullable GraphReachability<String, String> reachability = null;
+  @Nullable DiGraph<String, String> graph = null;
 
   @Test
   public void testSimple() {
diff --git a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
index cee02c0..9203cc9 100644
--- a/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
+++ b/test/com/google/javascript/jscomp/ijs/ConvertToTypedInterfaceTest.java
@@ -1420,6 +1420,10 @@ public final class ConvertToTypedInterfaceTest extends CompilerTestCase {
     test("while (i++ < 10) { var /** number */ field = i; }", "/** @type {number} */ var field;");
 
     test(
+        "label: while (i++ < 10) { var /** number */ field = i; }",
+        "/** @type {number} */ var field;");
+
+    test(
         "do { var /** number */ field = i; } while (i++ < 10);",
         "/** @type {number} */ var field;");
 
diff --git a/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java b/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
index cbd0481..7a5b8d7 100644
--- a/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
+++ b/test/com/google/javascript/jscomp/instrumentation/GoldenFileComparer.java
@@ -31,10 +31,10 @@ import java.util.ArrayList;
 import java.util.List;
 
 /**
- * Test compiler by comparing output to data files aka golden files.
- * Always start with the options object from this class.
+ * Test compiler by comparing output to data files aka golden files. Always start with the options
+ * object from this class.
  */
-public class GoldenFileComparer {
+public final class GoldenFileComparer {
 
   private static final String DATA_DIR =
       "test/"
@@ -115,8 +115,8 @@ public class GoldenFileComparer {
    */
   public static void compileAndCompareSubsetOfActualToExpected(
       String goldenFileName, CompilerOptions options, String sourceFileName) throws Exception {
-    List<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
-    List<SourceFile> externsFiles = ImmutableList.of();
+    ImmutableList<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
+    ImmutableList<SourceFile> externsFiles = ImmutableList.of();
     String compiledSource = compile(externsFiles, sourceFiles, options);
     String goldenSource = readFile(toFullPath(goldenFileName));
 
@@ -144,8 +144,8 @@ public class GoldenFileComparer {
    */
   public static void compileAndCompare(
       String goldenFileName, CompilerOptions options, String sourceFileName) throws Exception {
-    List<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
-    List<SourceFile> externsFiles = ImmutableList.of();
+    ImmutableList<SourceFile> sourceFiles = ImmutableList.of(readSource(sourceFileName));
+    ImmutableList<SourceFile> externsFiles = ImmutableList.of();
     compileAndCompare(goldenFileName, options, sourceFiles, externsFiles);
   }
 
@@ -161,10 +161,10 @@ public class GoldenFileComparer {
       String externsFileName)
       throws Exception {
     // Prepare sources
-    List<SourceFile> sourceFiles =
+    ImmutableList<SourceFile> sourceFiles =
         ImmutableList.of(readSource(sourceFileName1), readSource(sourceFileName2));
 
-    List<SourceFile> externsFiles =
+    ImmutableList<SourceFile> externsFiles =
         ImmutableList.of(SourceFile.fromFile(toFullPath(externsFileName)));
 
     compileAndCompare(goldenFileName, options, sourceFiles, externsFiles);
@@ -178,4 +178,6 @@ public class GoldenFileComparer {
     options.setPrettyPrint(true);
     return options;
   }
+
+  private GoldenFileComparer() {}
 }
diff --git a/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java b/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
index 7c76466..8aeb7fa 100644
--- a/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ES2021IntegrationTest.java
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
 public final class ES2021IntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setDevMode(DevMode.EVERY_PASS);
diff --git a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
index a74e3e9..816f990 100644
--- a/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/ES2022IntegrationTest.java
@@ -37,7 +37,7 @@ import org.junit.runners.JUnit4;
 public final class ES2022IntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguage(LanguageMode.UNSUPPORTED);
     options.setDevMode(DevMode.EVERY_PASS);
diff --git a/test/com/google/javascript/jscomp/integration/IntegrationTest.java b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
index b675568..af3bf08 100644
--- a/test/com/google/javascript/jscomp/integration/IntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/IntegrationTest.java
@@ -4204,12 +4204,13 @@ public final class IntegrationTest extends IntegrationTestCase {
   @Test
   @GwtIncompatible("AbstractCommandLineRunner.getBuiltinExterns()")
   public void testEs6ModuleEntryPoint() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index.js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index"));
 
     CompilerOptions options = new CompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
@@ -4229,12 +4230,13 @@ public final class IntegrationTest extends IntegrationTestCase {
   @Test
   @GwtIncompatible("AbstractCommandLineRunner.getBuiltinExterns()")
   public void testEs6ModuleEntryPointWithSquareBracketsInFilename() throws Exception {
-    List<SourceFile> inputs =
+    ImmutableList<SourceFile> inputs =
         ImmutableList.of(
             SourceFile.fromCode("/index[0].js", "import foo from './foo.js'; foo('hello');"),
             SourceFile.fromCode("/foo.js", "export default (foo) => { alert(foo); }"));
 
-    List<ModuleIdentifier> entryPoints = ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
+    ImmutableList<ModuleIdentifier> entryPoints =
+        ImmutableList.of(ModuleIdentifier.forFile("/index[0].js"));
 
     CompilerOptions options = new CompilerOptions();
     CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
@@ -4511,4 +4513,53 @@ public final class IntegrationTest extends IntegrationTestCase {
             "})"),
         DiagnosticGroups.CHECK_TYPES);
   }
+
+  @Test
+  public void forceClassTranspilationKeepAsync_withNoTranspile() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.NO_TRANSPILE);
+    options.setForceClassTranspilation(true);
+
+    // test transpiling classes but leave async functions untranspiled
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { async f(p) { await p; return 0; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = async function(p) { await p; return 0 };",
+            "window['C'] = i0$classdecl$var0"));
+  }
+
+  @Test
+  public void forceClassTranspilationKeepAsyncFunctions_withEs2021Out() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2021);
+    options.setForceClassTranspilation(true);
+
+    // test transpiling classes but leave async functions untranspiled
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { async f(p) { await p; return 0; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = async function(p) { await p; return 0 };",
+            "window['C'] = i0$classdecl$var0"));
+  }
+
+  @Test
+  public void forceClassTranspilationKeepDestructuring_withEs2015Out() {
+    CompilerOptions options = new CompilerOptions();
+    options.setLanguageOut(LanguageMode.ECMASCRIPT_2015);
+    options.setForceClassTranspilation(true);
+
+    // check that we can transpile the ES2016 `**` + classes, but leave the ES2015 destructuring
+    // parameter behind.
+    test(
+        options,
+        "window['C'] = /** @dict */ class C { f({num}) { return num ** 3; } }",
+        lines(
+            "const i0$classdecl$var0 = function() {};",
+            "i0$classdecl$var0.prototype.f = function({num}) { return Math.pow(num, 3); };",
+            "window['C'] = i0$classdecl$var0"));
+  }
 }
diff --git a/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java b/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
index cd6b7ce..fb39d50 100644
--- a/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
+++ b/test/com/google/javascript/jscomp/integration/IntegrationTestCase.java
@@ -40,6 +40,7 @@ import com.google.javascript.jscomp.testing.TestExternsBuilder;
 import com.google.javascript.rhino.Node;
 import java.util.ArrayList;
 import java.util.List;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 
 /** Framework for end-to-end test cases. */
@@ -140,7 +141,7 @@ abstract class IntegrationTestCase {
   protected List<SourceFile> externs = DEFAULT_EXTERNS;
 
   // The most recently used compiler.
-  protected Compiler lastCompiler;
+  protected @Nullable Compiler lastCompiler;
 
   protected boolean useNoninjectingCompiler = false;
 
@@ -239,7 +240,10 @@ abstract class IntegrationTestCase {
 
   /** Asserts that when compiling with the given compiler options, there is an error or warning. */
   protected void test(
-      CompilerOptions options, String[] original, String[] compiled, DiagnosticGroup warnings) {
+      CompilerOptions options,
+      String[] original,
+      String @Nullable [] compiled,
+      DiagnosticGroup warnings) {
     Compiler compiler = compile(options, original);
     checkUnexpectedErrorsOrWarnings(compiler, 1);
 
@@ -269,11 +273,9 @@ abstract class IntegrationTestCase {
     testParseError(options, original, null);
   }
 
-  /**
-   * Asserts that there is at least one parse error.
-   */
-  protected void testParseError(CompilerOptions options,
-      String original, String compiled) {
+  /** Asserts that there is at least one parse error. */
+  protected void testParseError(
+      CompilerOptions options, String original, @Nullable String compiled) {
     Compiler compiler = compile(options, original);
     for (JSError error : compiler.getErrors()) {
       if (!DiagnosticGroups.PARSING.matches(error)) {
diff --git a/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java b/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
index bb0c46b..760d68d 100644
--- a/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/OptionalChainingIntegrationTest.java
@@ -35,7 +35,7 @@ import org.junit.runners.JUnit4;
 public final class OptionalChainingIntegrationTest extends IntegrationTestCase {
 
   /** Creates a CompilerOptions object with google coding conventions. */
-  protected CompilerOptions createCompilerOptions() {
+  CompilerOptions createCompilerOptions() {
     CompilerOptions options = new CompilerOptions();
     options.setLanguageIn(LanguageMode.ECMASCRIPT_NEXT);
     options.setLanguageOut(LanguageMode.NO_TRANSPILE);
diff --git a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
index 931be83..75c4f99 100644
--- a/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
+++ b/test/com/google/javascript/jscomp/integration/TypedAstIntegrationTest.java
@@ -27,7 +27,9 @@ import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
 import com.google.javascript.jscomp.CompilerOptions.IncrementalCheckMode;
 import com.google.javascript.jscomp.CompilerOptions.LanguageMode;
+import com.google.javascript.jscomp.CrossChunkMethodMotion;
 import com.google.javascript.jscomp.DiagnosticGroups;
+import com.google.javascript.jscomp.JSChunk;
 import com.google.javascript.jscomp.SourceFile;
 import com.google.javascript.jscomp.VariableRenamingPolicy;
 import com.google.javascript.jscomp.WarningLevel;
@@ -406,6 +408,57 @@ public final class TypedAstIntegrationTest extends IntegrationTestCase {
         .isEqualTo(expectedRoot);
   }
 
+  @Test
+  public void testCrossChunkMethodMotion() throws IOException {
+    // run checks & serialize .typedasts
+    SourceFile f1 =
+        SourceFile.fromCode(
+            "f1.js",
+            lines(
+                "/** @constructor */",
+                "var Foo = function() {};",
+                "Foo.prototype.bar = function() {};",
+                "/** @type {!Foo} */",
+                "var x = new Foo();"));
+    SourceFile f2 = SourceFile.fromCode("f2.js", "x.bar();");
+    precompileLibrary(f1);
+    precompileLibrary(typeSummary(f1), f2);
+
+    Compiler compiler = new Compiler();
+    // create two chunks, where chunk 2 depends on chunk 1, and they contain f1 and f2
+    CompilerOptions options = new CompilerOptions();
+    options.setCrossChunkMethodMotion(true);
+    JSChunk chunk1 = new JSChunk("chunk1");
+    chunk1.add(f1);
+    JSChunk chunk2 = new JSChunk("chunk2");
+    chunk2.add(f2);
+    chunk2.addDependency(chunk1);
+
+    // run compilation
+    try (InputStream inputStream = toInputStream(this.shards)) {
+      compiler.initModulesWithTypedAstFilesystem(
+          ImmutableList.copyOf(this.externFiles),
+          ImmutableList.of(chunk1, chunk2),
+          options,
+          inputStream);
+    }
+    compiler.parse();
+    compiler.stage2Passes();
+    compiler.stage3Passes();
+
+    String[] expected =
+        new String[] {
+          CrossChunkMethodMotion.STUB_DECLARATIONS
+              + "var Foo = function() {};"
+              + "Foo.prototype.bar=JSCompiler_stubMethod(0); var x=new Foo;",
+          "Foo.prototype.bar=JSCompiler_unstubMethod(0,function(){}); x.bar()",
+        };
+    Node expectedRoot = parseExpectedCode(expected);
+    assertNode(compiler.getRoot().getSecondChild())
+        .usingSerializer(compiler::toSource)
+        .isEqualTo(expectedRoot);
+  }
+
   // use over 'compileTypedAstShards' if you want to validate reported errors or warnings in your
   // @Test case.
   private Compiler compileTypedAstShardsWithoutErrorChecks(CompilerOptions options)
diff --git a/test/com/google/javascript/jscomp/lint/CheckVarTest.java b/test/com/google/javascript/jscomp/lint/CheckVarTest.java
index f239187..516086f 100644
--- a/test/com/google/javascript/jscomp/lint/CheckVarTest.java
+++ b/test/com/google/javascript/jscomp/lint/CheckVarTest.java
@@ -53,6 +53,20 @@ public class CheckVarTest extends CompilerTestCase {
   }
 
   @Test
+  public void testSuppressWarning() {
+    testSame(
+        lines(
+            "/**",
+            " * @fileoverview",
+            " * @suppress {lintVarDeclarations}",
+            " */",
+            "var x;",
+            "var x12 = 12;",
+            "export var x;",
+            "function f() { var x = 12; return x; }"));
+  }
+
+  @Test
   public void testNoWarning() {
     testSame("function f() { return 'var'; }");
     testSame("let x;");
diff --git a/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java b/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
index 2de289a..bc2730d 100644
--- a/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
+++ b/test/com/google/javascript/jscomp/parsing/AttachJsdocsTest.java
@@ -37,7 +37,7 @@ import org.junit.runners.JUnit4;
 /** Ported from rhino/testsrc/org/mozilla/javascript/tests/AttachJsDocsTest.java */
 @RunWith(JUnit4.class)
 public final class AttachJsdocsTest extends BaseJSTypeTestCase {
-  private Config.LanguageMode mode;
+  private LanguageMode mode;
 
   @Before
   public void setUp() throws Exception {
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
index 51cce25..d161b9b 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java
@@ -2874,7 +2874,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             "@suppress {x,y} Some description.",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
     assertThat(info.getSuppressionsAndTheirDescription())
         .containsEntry(ImmutableSet.of("x", "y"), "Some description.");
@@ -2889,7 +2889,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             " * Spans across lines.",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
     assertThat(info.getSuppressionsAndTheirDescription())
         .containsEntry(ImmutableSet.of("x", "y"), "Some description. Spans across lines.");
@@ -2906,7 +2906,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             " * @override",
             " * @suppress {z}", // no description
             "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getAuthors()).contains("XYZ");
     assertThat(info.isOverride()).isTrue();
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y", "z"));
@@ -2921,7 +2921,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   public void testSuppressWithDescription_repeatedWarnings1() {
     String jsDocComment =
         lines("@suppress {x} Some description.", " * @suppress {x} Another description.", "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x"));
     assertThat(info.getSuppressionsAndTheirDescription()).hasSize(1);
     assertThat(info.getSuppressionsAndTheirDescription())
@@ -2933,7 +2933,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
   public void testSuppressWithDescription_repeatedWarnings2() {
     String jsDocComment =
         lines("@suppress {x} Some description.", " * @suppress {x, y} Another description.", "*/");
-    JSDocInfo info = parse(jsDocComment, true /* parseDocumentation */);
+    JSDocInfo info = parse(jsDocComment, /* parseDocumentation= */ true);
     assertThat(info.getSuppressions()).isEqualTo(ImmutableSet.of("x", "y"));
     assertThat(info.getSuppressionsAndTheirDescription()).hasSize(2);
     assertThat(info.getSuppressionsAndTheirDescription())
@@ -3258,7 +3258,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     JSDocInfo jsdoc =
         parse("@return {Foo} some long \n * multiline" + " \n * description */", true);
 
-    JSDocInfo.Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0);
+    Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0);
     assertDocumentationInMarker(returnDoc, "some long multiline description", 14, 2, 15);
     assertThat(returnDoc.getType().getPositionOnStartLine()).isEqualTo(8);
     assertThat(returnDoc.getType().getPositionOnEndLine()).isEqualTo(12);
@@ -5185,7 +5185,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     String comment = "* @desc This is a comment */";
     JSDocInfo info = parse(comment);
     assertThat(info.getOriginalCommentString()).isNull();
-    info = parse(comment, true /* parseDocumentation */);
+    info = parse(comment, /* parseDocumentation= */ true);
     assertThat(info.getOriginalCommentString()).isEqualTo(comment);
   }
 
@@ -5671,8 +5671,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param endCharno The ending character of the text.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertDocumentationInMarker(
-      JSDocInfo.Marker marker, String description, int startCharno, int endLineno, int endCharno) {
+  private static Marker assertDocumentationInMarker(
+      Marker marker, String description, int startCharno, int endLineno, int endCharno) {
     assertThat(marker.getDescription()).isNotNull();
     assertThat(marker.getDescription().getItem()).isEqualTo(description);
 
@@ -5694,8 +5694,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param hasBrackets Whether the type in the type field is expected to have brackets.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertTypeInMarker(
-      JSDocInfo.Marker marker,
+  private static Marker assertTypeInMarker(
+      Marker marker,
       String typeName,
       int startLineno,
       int startCharno,
@@ -5727,8 +5727,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param startCharno The starting character of the text.
    * @return The marker, for chaining purposes.
    */
-  private static JSDocInfo.Marker assertNameInMarker(
-      JSDocInfo.Marker marker, String name, int startLine, int startCharno) {
+  private static Marker assertNameInMarker(
+      Marker marker, String name, int startLine, int startCharno) {
     assertThat(marker.getNameNode()).isNotNull();
     assertThat(marker.getNameNode().getItem().getString()).isEqualTo(name);
 
@@ -5751,7 +5751,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param startCharno The expected character on the starting line.
    * @return The marker found, for further testing.
    */
-  private static JSDocInfo.Marker assertAnnotationMarker(
+  private static Marker assertAnnotationMarker(
       JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno) {
     return assertAnnotationMarker(jsdoc, annotationName, startLineno, startCharno, 0);
   }
@@ -5768,16 +5768,16 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
    * @param index The index of the marker.
    * @return The marker found, for further testing.
    */
-  private static JSDocInfo.Marker assertAnnotationMarker(
+  private static Marker assertAnnotationMarker(
       JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno, int index) {
 
-    Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers();
+    Collection<Marker> markers = jsdoc.getMarkers();
 
     assertThat(markers).isNotEmpty();
 
     int counter = 0;
 
-    for (JSDocInfo.Marker marker : markers) {
+    for (Marker marker : markers) {
       if (marker.getAnnotation() != null) {
         if (annotationName.equals(marker.getAnnotation().getItem())) {
 
@@ -5842,8 +5842,8 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
     return parse(
         comment,
         parseDocumentation
-            ? Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE
-            : Config.JsDocParsing.TYPES_ONLY,
+            ? JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE
+            : JsDocParsing.TYPES_ONLY,
         warnings);
   }
 
@@ -5866,7 +5866,7 @@ public final class JsDocInfoParserTest extends BaseJSTypeTestCase {
             .setClosurePrimitiveNames(extraPrimitives)
             .setLanguageMode(LanguageMode.ECMASCRIPT3)
             .setParseInlineSourceMaps(true)
-            .setStrictMode(Config.StrictMode.SLOPPY)
+            .setStrictMode(StrictMode.SLOPPY)
             .build();
 
     StaticSourceFile file = new SimpleSourceFile("testcode", SourceKind.STRONG);
diff --git a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
index d5a333d..d8af5b9 100644
--- a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
+++ b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java
@@ -51,9 +51,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization1() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, LEFT_CURLY, STRING, RIGHT_CURLY, EOL, STAR, ANNOTATION);
-    List<String> strings = ImmutableList.of("type", "string", "private");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STAR, ANNOTATION, LEFT_CURLY, STRING, RIGHT_CURLY, EOL, STAR, ANNOTATION);
+    ImmutableList<String> strings = ImmutableList.of("type", "string", "private");
     testJSDocTokenStream(" * @type {string}\n * @private", tokens, strings);
     testJSDocTokenStream(" *    @type { string } \n * @private",
         tokens, strings);
@@ -65,9 +65,18 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization2() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, LEFT_ANGLE, STRING, PIPE, STRING, RIGHT_ANGLE, RIGHT_CURLY);
-    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            ANNOTATION,
+            LEFT_CURLY,
+            STRING,
+            LEFT_ANGLE,
+            STRING,
+            PIPE,
+            STRING,
+            RIGHT_ANGLE,
+            RIGHT_CURLY);
+    ImmutableList<String> strings = ImmutableList.of("param", "Array", "string", "null");
     testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
     testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings);
     testJSDocTokenStream("@param {Array.<string |null>}", tokens, strings);
@@ -84,10 +93,21 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization4() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, LEFT_ANGLE, LEFT_PAREN, STRING, COMMA,
-        STRING, RIGHT_PAREN, RIGHT_ANGLE, RIGHT_CURLY, EOF);
-    List<String> strings = ImmutableList.of("param", "Array", "string", "null");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            ANNOTATION,
+            LEFT_CURLY,
+            STRING,
+            LEFT_ANGLE,
+            LEFT_PAREN,
+            STRING,
+            COMMA,
+            STRING,
+            RIGHT_PAREN,
+            RIGHT_ANGLE,
+            RIGHT_CURLY,
+            EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Array", "string", "null");
     testJSDocTokenStream("@param {Array.<(string,null)>}", tokens, strings);
     testJSDocTokenStream("@param {Array  .<(string,null)> } ", tokens, strings);
     testJSDocTokenStream(" @param {Array.<  (  string,null)>}",
@@ -101,8 +121,8 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization5() {
-    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "foo.Bar");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "foo.Bar");
     testJSDocTokenStream("@param foo.Bar*/", tokens, strings);
     testJSDocTokenStream(" @param   foo.Bar*/", tokens, strings);
     testJSDocTokenStream(" @param foo.Bar   */", tokens, strings);
@@ -110,9 +130,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization6() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);
-    List<String> strings = ImmutableList.of("hidden", "static", "desc");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC);
+    ImmutableList<String> strings = ImmutableList.of("hidden", "static", "desc");
     testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings);
     testJSDocTokenStream("@hidden\n @static\n@desc*/", tokens, strings);
     testJSDocTokenStream("@hidden\n@static\n @desc*/", tokens, strings);
@@ -125,9 +145,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization7() {
-    List<JsDocToken> tokens =
+    ImmutableList<JsDocToken> tokens =
         ImmutableList.of(ITER_REST, ITER_REST, ITER_REST, ITER_REST, ITER_REST, LEFT_ANGLE, EOC);
-    List<String> strings = ImmutableList.of();
+    ImmutableList<String> strings = ImmutableList.of();
 
     testJSDocTokenStream("................<*/", tokens, strings);
     testJSDocTokenStream("............... .<*/", tokens, strings);
@@ -139,11 +159,11 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization8() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING,
-        STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(
-        "param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING, STRING, EOL, EOC);
+    ImmutableList<String> strings =
+        ImmutableList.of("param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name");
     testJSDocTokenStream(
         " * @param foo.Bar opt_name this parameter is a name\n" +
         " */", tokens, strings);
@@ -154,12 +174,12 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization9() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION,
-        STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(
-        "param", "foo.Bar", "opt_name", "this", "parameter", "does",
-        "media", "blah");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(
+            STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION, STRING, EOL, EOC);
+    ImmutableList<String> strings =
+        ImmutableList.of(
+            "param", "foo.Bar", "opt_name", "this", "parameter", "does", "media", "blah");
     testJSDocTokenStream(
         " * @param foo.Bar opt_name this parameter does @media blah\n" +
         " */", tokens, strings);
@@ -167,16 +187,17 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization10() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_ANGLE, STRING, RIGHT_ANGLE, EOC);
-    List<String> strings = ImmutableList.of("Array", "String");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STRING, LEFT_ANGLE, STRING, RIGHT_ANGLE, EOC);
+    ImmutableList<String> strings = ImmutableList.of("Array", "String");
     testJSDocTokenStream("Array<String>*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization11() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, QMARK, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "string");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STRING, QMARK, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "string");
     testJSDocTokenStream("@param {string?}*/", tokens, strings);
     testJSDocTokenStream(" @param {string?}*/", tokens, strings);
     testJSDocTokenStream("@param { string?}*/", tokens, strings);
@@ -188,16 +209,17 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization12() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, ITER_REST, EOC);
-    List<String> strings = ImmutableList.of("function");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, ITER_REST, EOC);
+    ImmutableList<String> strings = ImmutableList.of("function");
 
     testJSDocTokenStream("function ...*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization13() {
-    List<JsDocToken> tokens = ImmutableList.of(ITER_REST, LEFT_SQUARE, STRING, RIGHT_SQUARE, EOC);
-    List<String> strings = ImmutableList.of("number");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ITER_REST, LEFT_SQUARE, STRING, RIGHT_SQUARE, EOC);
+    ImmutableList<String> strings = ImmutableList.of("number");
 
     testJSDocTokenStream("...[number]*/", tokens, strings);
   }
@@ -208,16 +230,17 @@ public final class JsDocTokenStreamTest {
     // followed by a comma (,) we are allowing this case to parse this way.
     // This is a simplification of the tokenizer, but the extra complexity is
     // never used.
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar...");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, EOC);
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar...");
 
     testJSDocTokenStream("foo[ bar...*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization15() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, LEFT_SQUARE, STRING, COMMA, ITER_REST, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(STRING, LEFT_SQUARE, STRING, COMMA, ITER_REST, EOC);
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar");
 
     testJSDocTokenStream("foo[ bar,...*/", tokens, strings);
     testJSDocTokenStream("foo[ bar ,...*/", tokens, strings);
@@ -228,42 +251,43 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization16() {
-    List<JsDocToken> tokens =
+    ImmutableList<JsDocToken> tokens =
         ImmutableList.of(STRING, COLON, COLON, COLON, ITER_REST, STRING, COLON, STRING, EOC);
-    List<String> strings = ImmutableList.of("foo", "bar", "bar2");
+    ImmutableList<String> strings = ImmutableList.of("foo", "bar", "bar2");
 
     testJSDocTokenStream("foo:::...bar:bar2*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization17() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of("..");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    ImmutableList<String> strings = ImmutableList.of("..");
 
     testJSDocTokenStream("..\n*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization18() {
-    List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
-    List<String> strings = ImmutableList.of(".");
+    ImmutableList<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC);
+    ImmutableList<String> strings = ImmutableList.of(".");
 
     testJSDocTokenStream(".\n*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization19() {
-    List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, LEFT_CURLY, STAR, RIGHT_CURLY, EOC);
-    List<String> strings = ImmutableList.of("type", "*");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STAR, RIGHT_CURLY, EOC);
+    ImmutableList<String> strings = ImmutableList.of("type", "*");
 
     testJSDocTokenStream("@type {*}*/", tokens, strings);
   }
 
   @Test
   public void testJsDocTokenization20() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, BANG, STRING, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "Object");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, BANG, STRING, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Object");
     testJSDocTokenStream("@param {!Object}*/", tokens, strings);
     testJSDocTokenStream(" @param {!Object}*/", tokens, strings);
     testJSDocTokenStream("@param {! Object}*/", tokens, strings);
@@ -275,9 +299,9 @@ public final class JsDocTokenStreamTest {
 
   @Test
   public void testJsDocTokenization21() {
-    List<JsDocToken> tokens = ImmutableList.of(
-        ANNOTATION, LEFT_CURLY, STRING, EQUALS, RIGHT_CURLY, EOC, EOF);
-    List<String> strings = ImmutableList.of("param", "Object");
+    ImmutableList<JsDocToken> tokens =
+        ImmutableList.of(ANNOTATION, LEFT_CURLY, STRING, EQUALS, RIGHT_CURLY, EOC, EOF);
+    ImmutableList<String> strings = ImmutableList.of("param", "Object");
     testJSDocTokenStream("@param {Object=}*/", tokens, strings);
     testJSDocTokenStream(" @param {Object=}*/", tokens, strings);
     testJSDocTokenStream("@param { Object =}*/", tokens, strings);
diff --git a/test/com/google/javascript/jscomp/parsing/ParserTest.java b/test/com/google/javascript/jscomp/parsing/ParserTest.java
index 8f62ad5..f5b1f0b 100644
--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java
+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java
@@ -92,8 +92,8 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   private static final String SEMICOLON_EXPECTED = "Semi-colon expected";
 
-  private Config.LanguageMode mode;
-  private Config.JsDocParsing parsingMode;
+  private LanguageMode mode;
+  private JsDocParsing parsingMode;
   private Config.StrictMode strictMode;
   private boolean isIdeMode = false;
   private FeatureSet expectedFeatures;
@@ -1608,7 +1608,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertNode(exprResultA).hasType(Token.EXPR_RESULT);
     assertThat(exprResultA.getNonJSDocCommentString()).isEqualTo("// comment before GETPROP");
 
-    Node nodeB = exprResultA.getFirstChild().getFirstChild();
+    Node nodeB = exprResultA.getFirstFirstChild();
     assertNode(nodeB).hasType(Token.GETPROP);
     assertThat(nodeB.getNonJSDocCommentString()).isEqualTo("// comment on GETPROP");
 
@@ -1995,6 +1995,165 @@ public final class ParserTest extends BaseJSTypeTestCase {
     assertThat(yNode.getNonJSDocComment()).isNull();
   }
 
+  @Test
+  public void testNonJSDocTrailingCommentOnConstant() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1; // comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantNoWhitespace() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1;// comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantWithMoreWhitespace() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse("const A = 1;   // comment").getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentOnConstantFollowedByConstant() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node cnst = parse(lines("const A = 1; // comment", "", "const B = 2;")).getFirstChild();
+    assertNode(cnst).hasType(Token.CONST);
+
+    assertThat(cnst.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testMultipleNonJSDocTrailingComments() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("const A = 1; /* A1 */ /* A2 */ // A3", "", "const B = 2;"));
+    Node a = n.getFirstChild();
+    assertNode(a).hasType(Token.CONST);
+    Node b = n.getLastChild();
+    assertNode(a).hasType(Token.CONST);
+    assertThat(b.getNonJSDocCommentString()).isEqualTo("/* A2 */// A3");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunction() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse("function foo(){} // comment").getFirstChild();
+    assertNode(n).hasType(Token.FUNCTION);
+
+    assertThat(n.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunctionCall() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("function g(){ f(); // comment", "f();}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("// comment");
+  }
+
+  @Test
+  public void testNonJSDocTrailingCommentAfterFunctionCallInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n =
+        parse(
+            lines(
+                "if (true) {",
+                "  f1(); // comment1 on f1()",
+                "  // comment2",
+                "  // comment3",
+                "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString())
+        .isEqualTo("// comment1 on f1()\n// comment2\n// comment3");
+  }
+
+  @Test
+  public void testLastNonJSDocCommentInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f();", "  /* comment */", "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testLastNonJSDocCommentInBlockWithBlankLines() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f();", "", "", "  /* comment */", "}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+
+    // TODO(b/242294987): This should keep the blank lines.
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testInlineCommentInFunctionCallInBlock() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("if (true) {", "  f(0, 1 /* comment */);}"));
+    Node exprRes = n.getFirstChild().getLastChild().getFirstChild();
+    assertNode(exprRes).hasType(Token.EXPR_RESULT);
+    // TODO(b/242294987): This should not be an "end of block" comment (which we treat as trailing
+    // comment on the last child), but a comment on the argument.
+    assertThat(exprRes.getTrailingNonJSDocCommentString()).isEqualTo("\n/* comment */");
+  }
+
+  @Test
+  public void testNonJSDocBigCommentInbetween() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse(lines("let x = 0; // comment on x", "//", "// more comment", "let y = 1;"));
+
+    Node fstLetDecl = n.getFirstChild();
+    Node sndLetDecl = n.getLastChild();
+
+    assertNode(fstLetDecl).hasType(Token.LET);
+    assertThat(fstLetDecl.getTrailingNonJSDocCommentString()).isEqualTo("// comment on x");
+    assertNode(sndLetDecl).hasType(Token.LET);
+    assertThat(sndLetDecl.getNonJSDocCommentString()).isEqualTo("//\n// more comment");
+  }
+
+  @Test
+  public void testInlineNonJSDocCommentsOnSeparateLetDeclarations() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+
+    Node n = parse("let a /* leading a */ = {c} /* trailing */; let /* leading b */ b  = {d};");
+    Node letADecl = n.getFirstChild();
+    Node letBDecl = n.getLastChild();
+
+    assertNode(letADecl).hasType(Token.LET);
+    assertNode(letBDecl).hasType(Token.LET);
+    assertThat(letADecl.getFirstFirstChild().getNonJSDocCommentString())
+        .contains("/* leading a */");
+    assertThat(letADecl.getTrailingNonJSDocCommentString()).contains("/* trailing */");
+    assertThat(letBDecl.getFirstChild().getNonJSDocCommentString()).contains("/* leading b */");
+  }
+
   // function f( // blah1
   //              x,
   //             // blah2
@@ -2507,7 +2666,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
     strictMode = SLOPPY;
     Node a = Node.newString(Token.NAME, "a");
     a.addChildToFront(Node.newString(Token.NAME, "b"));
-    List<ParserResult> testCases =
+    ImmutableList<ParserResult> testCases =
         ImmutableList.of(
             new ParserResult("3;", createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))),
             new ParserResult("var a = b;", createScript(new Node(Token.VAR, a))));
@@ -3656,6 +3815,20 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testIndividualCommentsAroundClasses() {
+    isIdeMode = true;
+    parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
+    Node n = parse("// comment A \n class A{} // trailing a \n // comment B \n  class Bar{}");
+    Node classA = n.getFirstChild();
+    Node classB = n.getSecondChild();
+    assertNode(classA).hasType(Token.CLASS);
+    assertThat(classA.getNonJSDocCommentString()).isEqualTo("// comment A");
+    assertThat(classA.getTrailingNonJSDocCommentString()).isEqualTo("// trailing a");
+    assertNode(classB).hasType(Token.CLASS);
+    assertThat(classB.getNonJSDocCommentString()).isEqualTo("// comment B");
+  }
+
+  @Test
   public void testMultipleLinedCommentsAttachedToSameNode() {
     isIdeMode = true;
     parsingMode = JsDocParsing.INCLUDE_ALL_COMMENTS;
@@ -6206,6 +6379,12 @@ public final class ParserTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testInvalidAwaitInsideNestedFunction() {
+    parse("async function f() { async function f2() { return await 5; } }");
+    parseError("async function f() { function f2() { return await 5; } }", UNEXPECTED_AWAIT);
+  }
+
+  @Test
   public void testAsyncFunction() {
     String asyncFunctionExpressionSource = "f = async function() {};";
     String asyncFunctionDeclarationSource = "async function f() {}";
@@ -6918,7 +7097,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   @Test
   public void testDynamicImport() {
-    List<String> dynamicImportUses =
+    ImmutableList<String> dynamicImportUses =
         ImmutableList.of(
             "import('foo')",
             "import('foo').then(function(a) { return a; })",
@@ -6947,7 +7126,7 @@ public final class ParserTest extends BaseJSTypeTestCase {
 
   @Test
   public void testAwaitDynamicImport() {
-    List<String> awaitDynamicImportUses =
+    ImmutableList<String> awaitDynamicImportUses =
         ImmutableList.of(
             "(async function() { return await import('foo'); })()",
             "(async function() { await import('foo').then(function(a) { return a; }); })()",
@@ -7290,11 +7469,10 @@ public final class ParserTest extends BaseJSTypeTestCase {
     return doParse(string, warnings).ast;
   }
 
-  private ParserRunner.ParseResult doParse(String string, String... warnings) {
+  private ParseResult doParse(String string, String... warnings) {
     TestErrorReporter testErrorReporter = new TestErrorReporter().expectAllWarnings(warnings);
     StaticSourceFile file = new SimpleSourceFile("input", SourceKind.STRONG);
-    ParserRunner.ParseResult result =
-        ParserRunner.parse(file, string, createConfig(), testErrorReporter);
+    ParseResult result = ParserRunner.parse(file, string, createConfig(), testErrorReporter);
 
     // check expected features if specified
     assertFS(result.features).contains(expectedFeatures);
diff --git a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
index 77561ab..2f6391d 100644
--- a/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/ColorSerializerTest.java
@@ -37,7 +37,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -649,8 +649,7 @@ public class ColorSerializerTest {
      * `TypeProto`. Generally test code should call `getExpectedTypeProto()` instead in order to get
      * an exception if an attempt is made to serialize an axiomatic color.
      */
-    @Nullable
-    public abstract TypeProto getNullableExpectedTypeProto();
+    public abstract @Nullable TypeProto getNullableExpectedTypeProto();
 
     // The Integer we expect ColorSerializer to create for this Color.
     public abstract Integer getExpectedTypePointer();
@@ -660,7 +659,7 @@ public class ColorSerializerTest {
     }
 
     static TestColor create(
-        Color color, TypeProto expectedTypeProto, Integer nullableExpectedTypePointer) {
+        Color color, @Nullable TypeProto expectedTypeProto, Integer nullableExpectedTypePointer) {
       return new AutoValue_ColorSerializerTest_TestColor(
           color, expectedTypeProto, nullableExpectedTypePointer);
     }
diff --git a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
index 6eec6a6..8b8d191 100644
--- a/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/JSTypeReconserializerTest.java
@@ -39,6 +39,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.function.Predicate;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -48,7 +49,7 @@ import org.junit.runners.JUnit4;
 public final class JSTypeReconserializerTest extends CompilerTestCase {
 
   // individual test cases may override this
-  private ImmutableSet<String> typesToForwardDeclare = null;
+  private @Nullable ImmutableSet<String> typesToForwardDeclare = null;
   private Predicate<String> shouldSerializeProperty;
 
   private TypePool typePool;
@@ -295,7 +296,7 @@ public final class JSTypeReconserializerTest extends CompilerTestCase {
                 "",
                 "let /** symbol|!Bar|string */ x;"));
 
-    List<UnionTypeProto> unionsContainingUnions =
+    ImmutableList<UnionTypeProto> unionsContainingUnions =
         typePool.stream()
             .filter(TypeProto::hasUnion)
             .map(TypeProto::getUnion)
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java b/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
index 1fc3a96..075085e 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeAndDeserializeAstTest.java
@@ -47,6 +47,7 @@ import java.time.Instant;
 import java.util.function.Consumer;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -64,7 +65,7 @@ import org.junit.runners.JUnit4;
 @RunWith(JUnit4.class)
 public final class SerializeAndDeserializeAstTest extends CompilerTestCase {
 
-  private Consumer<TypedAst> consumer = null;
+  private @Nullable Consumer<TypedAst> consumer = null;
   private boolean includeTypes;
 
   @Override
diff --git a/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java b/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
index 2317a25..2b05fae 100644
--- a/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
+++ b/test/com/google/javascript/jscomp/serialization/SerializeTypedAstPassTest.java
@@ -43,6 +43,7 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -53,7 +54,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
 
   private Consumer<TypedAst> astConsumer;
   // individual test cases may override this
-  private ImmutableSet<String> typesToForwardDeclare = null;
+  private @Nullable ImmutableSet<String> typesToForwardDeclare = null;
 
   // Proto fields commonly ignored in tests because hardcoding their values is brittle
   private static final ImmutableList<FieldDescriptor> BRITTLE_TYPE_FIELDS =
@@ -209,7 +210,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.TAGGED_TEMPLATELIT)
-                                .addBooleanProperty(NodeProperty.FREE_CALL)
+                                .setBooleanProperties(1L << NodeProperty.FREE_CALL.getNumber())
                                 .addChild(
                                     AstNode.newBuilder()
                                         .setKind(NodeKind.IDENTIFIER)
@@ -253,8 +254,9 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.NUMBER_LITERAL)
-                                .addBooleanProperty(NodeProperty.IS_PARENTHESIZED)
-                                .addBooleanProperty(NodeProperty.COLOR_FROM_CAST)
+                                .setBooleanProperties(
+                                    (1L << NodeProperty.IS_PARENTHESIZED.getNumber())
+                                        | (1L << NodeProperty.COLOR_FROM_CAST.getNumber()))
                                 .setDoubleValue(1)
                                 .setType(unknownType)
                                 .build())
@@ -280,7 +282,7 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
                         .addChild(
                             AstNode.newBuilder()
                                 .setKind(NodeKind.FUNCTION_LITERAL)
-                                .addBooleanProperty(NodeProperty.ARROW_FN)
+                                .setBooleanProperties(1L << NodeProperty.ARROW_FN.getNumber())
                                 .addChild(
                                     AstNode.newBuilder()
                                         .setKind(NodeKind.IDENTIFIER)
@@ -313,12 +315,12 @@ public final class SerializeTypedAstPassTest extends CompilerTestCase {
         .isEqualTo(
             AstNode.newBuilder()
                 .setKind(NodeKind.SOURCE_FILE)
-                .addBooleanProperty(NodeProperty.GOOG_MODULE)
+                .setBooleanProperties(1L << NodeProperty.GOOG_MODULE.getNumber())
                 // `/** @const */ var module$exports$a$b$c = {};`
                 .addChild(
                     AstNode.newBuilder()
                         .setKind(NodeKind.VAR_DECLARATION)
-                        .addBooleanProperty(NodeProperty.IS_NAMESPACE)
+                        .setBooleanProperties(1L << NodeProperty.IS_NAMESPACE.getNumber())
                         .setJsdoc(OptimizationJsdoc.newBuilder().addKind(JsdocTag.JSDOC_CONST))
                         .addChild(
                             AstNode.newBuilder()
diff --git a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
index 629865f..a1a4bd4 100644
--- a/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
+++ b/test/com/google/javascript/jscomp/serialization/TypedAstSerializerTest.java
@@ -30,6 +30,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -84,7 +85,7 @@ public class TypedAstSerializerTest extends CompilerTestCase {
       ImmutableList.of(OBJECT_UUID);
 
   /** Holds the serialized AST created by the last executed test method. */
-  private TypedAst testResult = null;
+  private @Nullable TypedAst testResult = null;
 
   @Override
   @Before
diff --git a/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java b/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
index 04f9fa7..457c2bd 100644
--- a/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
+++ b/test/com/google/javascript/refactoring/ApplySuggestedFixesTest.java
@@ -27,8 +27,6 @@ import com.google.javascript.jscomp.Compiler;
 import com.google.javascript.jscomp.CompilerOptions;
 import com.google.javascript.jscomp.SourceFile;
 import com.google.javascript.rhino.Node;
-import java.util.List;
-import java.util.Map;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -41,7 +39,7 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_overlapsAreErrors() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 10, ""), CodeReplacement.create(5, 3, ""));
     try {
       ApplySuggestedFixes.applyCodeReplacements(replacements, "");
@@ -51,21 +49,21 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_overlapsAreErrors_unlessEqual() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 3, "A"), CodeReplacement.create(0, 3, "A"));
     ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
   }
 
   @Test
   public void testApplyCodeReplacements_noOverlapsSucceed() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 3, ""), CodeReplacement.create(5, 3, ""));
     ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
   }
 
   @Test
   public void testApplyCodeReplacements() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(CodeReplacement.create(0, 1, "z"), CodeReplacement.create(3, 2, "qq"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("zbcqqf", newCode);
@@ -73,28 +71,31 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplyCodeReplacements_insertion() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(0, 0, "z"));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(0, 0, "z"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("zabcdef", newCode);
   }
 
   @Test
   public void testApplyCodeReplacements_deletion() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(0, 6, ""));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(0, 6, ""));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertThat(newCode).isEmpty();
   }
 
   @Test
   public void testApplyCodeReplacements_boundaryCases() throws Exception {
-    List<CodeReplacement> replacements = ImmutableList.of(CodeReplacement.create(5, 1, "z"));
+    ImmutableList<CodeReplacement> replacements =
+        ImmutableList.of(CodeReplacement.create(5, 1, "z"));
     String newCode = ApplySuggestedFixes.applyCodeReplacements(replacements, "abcdef");
     assertEquals("abcdez", newCode);
   }
 
   @Test
   public void testApplyCodeReplacements_multipleReplacements() throws Exception {
-    List<CodeReplacement> replacements =
+    ImmutableList<CodeReplacement> replacements =
         ImmutableList.of(
             CodeReplacement.create(0, 2, "z"),
             CodeReplacement.create(2, 1, "y"),
@@ -108,10 +109,11 @@ public class ApplySuggestedFixesTest {
     String code = "var someNode;";
     Compiler compiler = getCompiler(code);
     Node root = compileToScriptRoot(compiler);
-    List<SuggestedFix> fixes = ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes =
+        ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap).containsEntry("test", "");
   }
@@ -127,10 +129,10 @@ public class ApplySuggestedFixesTest {
     SuggestedFix fix = new SuggestedFix.Builder()
         .insertBefore(jsdocRoot, "!")
         .build();
-    List<SuggestedFix> fixes = ImmutableList.of(fix);
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of(fix);
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap).containsEntry("test", "/** @type {!Foo} */\nvar foo = new Foo()");
   }
@@ -150,10 +152,10 @@ public class ApplySuggestedFixesTest {
     SuggestedFix fix2 = new SuggestedFix.Builder()
         .insertBefore(foo, "!")
         .build();
-    List<SuggestedFix> fixes = ImmutableList.of(fix1, fix2);
-    Map<String, String> codeMap = ImmutableMap.of("test", code);
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of(fix1, fix2);
+    ImmutableMap<String, String> codeMap = ImmutableMap.of("test", code);
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertThat(newCodeMap).hasSize(1);
     assertThat(newCodeMap)
         .containsEntry("test", "/** @type {!Array<!Foo>} */\nvar arr = [new Foo()];");
@@ -161,23 +163,25 @@ public class ApplySuggestedFixesTest {
 
   @Test
   public void testApplySuggestedFixes_noFixes() throws Exception {
-    Map<String, String> codeMap = ImmutableMap.of(
-        "file1", "abcdef",
-        "file2", "abcdef");
-    Map<String, String> expectedNewCodeMap = ImmutableMap.of();
-    List<SuggestedFix> fixes = ImmutableList.of();
-    Map<String, String> newCodeMap = ApplySuggestedFixes.applySuggestedFixesToCode(
-        fixes, codeMap);
+    ImmutableMap<String, String> codeMap =
+        ImmutableMap.of(
+            "file1", "abcdef",
+            "file2", "abcdef");
+    ImmutableMap<String, String> expectedNewCodeMap = ImmutableMap.of();
+    ImmutableList<SuggestedFix> fixes = ImmutableList.of();
+    ImmutableMap<String, String> newCodeMap =
+        ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
     assertEquals(expectedNewCodeMap, newCodeMap);
   }
 
   @Test
   public void testApplySuggestedFixes_missingCodeForFile() throws Exception {
-    Map<String, String> codeMap = ImmutableMap.of();
+    ImmutableMap<String, String> codeMap = ImmutableMap.of();
     String code = "var someNode;";
     Compiler compiler = getCompiler(code);
     Node root = compileToScriptRoot(compiler);
-    List<SuggestedFix> fixes = ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
+    ImmutableList<SuggestedFix> fixes =
+        ImmutableList.of(new SuggestedFix.Builder().delete(root).build());
     try {
       ApplySuggestedFixes.applySuggestedFixesToCode(fixes, codeMap);
       fail("applySuggestedFixesToCode should have failed since file is missing from code map.");
@@ -192,7 +196,7 @@ public class ApplySuggestedFixesTest {
     System.out.println(root.toStringTree());
     Node var = root.getFirstChild();
 
-    List<SuggestedFix> fixes =
+    ImmutableList<SuggestedFix> fixes =
         ImmutableList.of(
             new SuggestedFix.Builder()
                 .rename(var.getLastChild(), "newShared")
@@ -203,7 +207,7 @@ public class ApplySuggestedFixesTest {
                 .rename(var.getSecondChild(), "newSecond")
                 .build());
 
-    Map<String, String> newCodeMap =
+    ImmutableMap<String, String> newCodeMap =
         ApplySuggestedFixes.applySuggestedFixesToCode(fixes, ImmutableMap.of("test", code));
     assertThat(newCodeMap).containsExactly("test", "var newFirst, newSecond, newShared;");
   }
diff --git a/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java b/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
index 175da72..14701e2 100644
--- a/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
+++ b/test/com/google/javascript/refactoring/ErrorToFixMapperTest.java
@@ -34,7 +34,7 @@ import com.google.javascript.jscomp.GoogleCodingConvention;
 import com.google.javascript.jscomp.JSError;
 import com.google.javascript.jscomp.SourceFile;
 import java.util.Collection;
-import javax.annotation.Nullable;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -75,8 +75,7 @@ public class ErrorToFixMapperTest {
   @AutoValue
   abstract static class ExpectedFix {
     /** Optional string describing the fix. */
-    @Nullable
-    abstract String description();
+    abstract @Nullable String description();
     /** What the code should look like after applying the fix. */
     abstract String fixedCode();
 
diff --git a/test/com/google/javascript/refactoring/SuggestedFixTest.java b/test/com/google/javascript/refactoring/SuggestedFixTest.java
index 960ab3d..a71adae 100644
--- a/test/com/google/javascript/refactoring/SuggestedFixTest.java
+++ b/test/com/google/javascript/refactoring/SuggestedFixTest.java
@@ -60,7 +60,7 @@ public class SuggestedFixTest {
 
   @Test
   public void testInsertBeforeWithNonJSDocBlockComment() {
-    String before = "var someRandomCode = {};";
+    String before = "var someRandomCode = {};\n";
     String after = "/* some comment */\ngoog.foo();";
     Compiler compiler = getCompiler(before + after);
     Node root = compileToScriptRoot(compiler);
@@ -75,7 +75,7 @@ public class SuggestedFixTest {
 
   @Test
   public void testInsertBeforeWithNonJSDocLineComment() {
-    String before = "var someRandomCode = {};";
+    String before = "var someRandomCode = {};\n";
     String after = "// some comment \ngoog.foo();";
     Compiler compiler = getCompiler(before + after);
     Node root = compileToScriptRoot(compiler);
diff --git a/test/com/google/javascript/rhino/HamtPMapTest.java b/test/com/google/javascript/rhino/HamtPMapTest.java
index 759f7f6..63fd562 100644
--- a/test/com/google/javascript/rhino/HamtPMapTest.java
+++ b/test/com/google/javascript/rhino/HamtPMapTest.java
@@ -194,6 +194,7 @@ public class HamtPMapTest {
   }
 
   @Test
+  @SuppressWarnings("CheckReturnValue")
   public void testReconcile_rejectsNullResult() {
     PMap<Integer, Integer> left = build(1, 3, 5, 7);
     PMap<Integer, Integer> right = build(2, 4, 6, 8);
diff --git a/test/com/google/javascript/rhino/JSDocInfoTest.java b/test/com/google/javascript/rhino/JSDocInfoTest.java
index ca0ba6a..e33c572 100644
--- a/test/com/google/javascript/rhino/JSDocInfoTest.java
+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java
@@ -155,7 +155,7 @@ public class JSDocInfoTest {
     mockedModuleLocals.add("AnotherItem");
 
     JSTypeExpression newExpr = jsTypeExpression.replaceNamesWithUnknownType(mockedModuleLocals);
-    Set<String> replacedNames = newExpr.getAllTypeNames();
+    ImmutableSet<String> replacedNames = newExpr.getAllTypeNames();
     assertThat(replacedNames).doesNotContain("Item");
     assertThat(replacedNames).contains("string");
     assertThat(replacedNames).contains("boolean");
@@ -742,7 +742,7 @@ public class JSDocInfoTest {
     JSDocInfo info = builder.build();
 
     // Then
-    Collection<Node> upperBoundRoots =
+    ImmutableList<Node> upperBoundRoots =
         info.getTemplateTypes().values().stream()
             .map(JSTypeExpression::getRoot)
             .collect(toImmutableList());
diff --git a/test/com/google/javascript/rhino/NodeTest.java b/test/com/google/javascript/rhino/NodeTest.java
index 65c6014..a39d1e7 100644
--- a/test/com/google/javascript/rhino/NodeTest.java
+++ b/test/com/google/javascript/rhino/NodeTest.java
@@ -43,13 +43,14 @@ import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.NodeSubject.assertNode;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.javascript.jscomp.colors.StandardColors;
 import com.google.javascript.jscomp.serialization.NodeProperty;
+import com.google.javascript.rhino.Node.SideEffectFlags;
 import com.google.javascript.rhino.jstype.JSTypeNative;
 import com.google.javascript.rhino.jstype.JSTypeRegistry;
 import com.google.javascript.rhino.testing.TestErrorReporter;
 import java.math.BigInteger;
-import java.util.EnumSet;
 import java.util.function.Consumer;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -76,6 +77,34 @@ public class NodeTest {
   }
 
   @Test
+  public void testSideEffectFlagsSerialization() {
+    // Test each individual flag
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_GLOBAL_STATE);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_THIS);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.MUTATES_ARGUMENTS);
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.THROWS);
+    // Test an arbitrary combination of 2 flags
+    checkSideEffectFlagsRoundTrip(SideEffectFlags.THROWS | SideEffectFlags.MUTATES_THIS);
+  }
+
+  public void checkSideEffectFlagsRoundTrip(int testFlags) {
+    final Node original = IR.call(IR.name("f"));
+    // serialization only works for nodes that actually have a source file,
+    // because in actual execution they always must have that.
+    original.setSourceFileForTesting("sourcefile");
+
+    // Simulate the situation where we've deserialized the node itself, but not its non-source-file
+    // properties yet, by cloning the orignal node before adding the side effect flags to it.
+    final Node restored = original.cloneNode();
+
+    original.setSideEffectFlags(testFlags);
+    final long serializedProperties = original.serializeProperties();
+
+    restored.deserializeProperties(serializedProperties);
+    assertThat(restored.getSideEffectFlags()).isEqualTo(testFlags);
+  }
+
+  @Test
   public void testValidatePropertiesForIsParenthesized() {
     Node n = IR.string("");
     n.setSourceFileForTesting("file.js"); // avoid error about missing source file
@@ -684,39 +713,53 @@ public class NodeTest {
     assertThat(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME)).isTrue();
   }
 
+  private long bitsetFromNodeProperties(ImmutableSet<NodeProperty> props) {
+    long bitset = 0;
+    for (NodeProperty prop : props) {
+      bitset = Node.setNodePropertyBit(bitset, prop);
+    }
+    return bitset;
+  }
+
   @Test
   public void testSerializeProperties() {
     Node node = IR.function(IR.name(""), IR.paramList(), IR.block());
     node.setIsAsyncFunction(true);
     node.setIsGeneratorFunction(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.GENERATOR_FN, NodeProperty.ASYNC_FN);
+    long result = node.serializeProperties();
+
+    assertThat(result)
+        .isEqualTo(
+            bitsetFromNodeProperties(
+                ImmutableSet.of(NodeProperty.GENERATOR_FN, NodeProperty.ASYNC_FN)));
   }
 
   @Test
   public void testSerializeProperties_isDeclaredConstant() {
     Node node = new Node(Token.NAME);
     node.setDeclaredConstantVar(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.IS_DECLARED_CONSTANT);
+    long result = node.serializeProperties();
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.IS_DECLARED_CONSTANT)));
   }
 
   @Test
   public void testSerializeProperties_isInferredConstant() {
     Node node = new Node(Token.NAME);
     node.setInferredConstantVar(true);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    assertThat(result).containsExactly(NodeProperty.IS_INFERRED_CONSTANT);
+    long result = node.serializeProperties();
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.IS_INFERRED_CONSTANT)));
   }
 
   @Test
   public void testSerializeProperties_untranslatableRhinoProp() {
     Node node = getCall("A");
-    node.setSideEffectFlags(2);
-    EnumSet<NodeProperty> result = node.serializeProperties();
-    // Rhino node prop SIDE_EFFECT_FLAGS does not have a corresponding NodeProperty
-    assertThat(node.getSideEffectFlags()).isEqualTo(2);
-    assertThat(result).isEmpty();
+    node.setUseStrict(true);
+    long result = node.serializeProperties();
+    // Rhino node prop USE_STRICT does not have a corresponding NodeProperty
+    assertThat(node.isUseStrict()).isTrue();
+    assertThat(result).isEqualTo(0);
   }
 
   @Test
@@ -725,9 +768,10 @@ public class NodeTest {
     JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter);
     Node node = Node.newString(Token.NAME, "f");
     node.setJSTypeBeforeCast(registry.getNativeType(JSTypeNative.NUMBER_TYPE));
-    EnumSet<NodeProperty> result = node.serializeProperties();
+    long result = node.serializeProperties();
     // Special case: Rhino node prop TYPE_BEFORE_CAST is converted to NodeProperty.COLOR_FROM_CAST
-    assertThat(result).containsExactly(NodeProperty.COLOR_FROM_CAST);
+    assertThat(result)
+        .isEqualTo(bitsetFromNodeProperties(ImmutableSet.of(NodeProperty.COLOR_FROM_CAST)));
   }
 
   @Test
diff --git a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
index 328e145..cb587d4 100644
--- a/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
+++ b/test/com/google/javascript/rhino/jstype/FunctionParamBuilderTest.java
@@ -40,9 +40,9 @@ package com.google.javascript.rhino.jstype;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.common.collect.ImmutableList;
 import com.google.javascript.rhino.jstype.FunctionType.Parameter;
 import com.google.javascript.rhino.testing.BaseJSTypeTestCase;
-import java.util.List;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -62,7 +62,7 @@ public class FunctionParamBuilderTest extends BaseJSTypeTestCase {
     assertThat(builder.addOptionalParams(BOOLEAN_TYPE)).isTrue();
     assertThat(builder.addVarArgs(STRING_TYPE)).isTrue();
 
-    List<Parameter> params = builder.build();
+    ImmutableList<Parameter> params = builder.build();
     assertTypeEquals(NUMBER_TYPE, params.get(0).getJSType());
     assertTypeEquals(registry.createOptionalType(BOOLEAN_TYPE), params.get(1).getJSType());
     assertTypeEquals(STRING_TYPE, params.get(2).getJSType());
diff --git a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
index a2b0386..1dbd293 100644
--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java
@@ -56,6 +56,7 @@ import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;
 import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;
 import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.javascript.rhino.IR;
@@ -66,9 +67,9 @@ import com.google.javascript.rhino.testing.AbstractStaticScope;
 import com.google.javascript.rhino.testing.MapBasedScope;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import org.jspecify.nullness.Nullable;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -84,12 +85,11 @@ public class JSTypeRegistryTest {
   // now much larger
 
   private final JSTypeRegistry registry = new JSTypeRegistry(null, null);
-  private JSTypeResolver.Closer closer;
 
   @Before
   @SuppressWarnings({"MustBeClosedChecker"})
   public void setUp() throws Exception {
-    this.closer = registry.getResolver().openForDefinition();
+    JSTypeResolver.Closer unused = registry.getResolver().openForDefinition();
   }
 
   @Test
@@ -154,7 +154,7 @@ public class JSTypeRegistryTest {
     // Test that it takes one parameter of type
     // function(function((IThenable<TYPE>|TYPE|null|{then: ?})=): ?, function(*=): ?): ?
     FunctionType promiseCtor = promiseType.getConstructor();
-    List<FunctionType.Parameter> paramList = promiseCtor.getParameters();
+    ImmutableList<FunctionType.Parameter> paramList = promiseCtor.getParameters();
     assertThat(paramList).hasSize(1);
     FunctionType.Parameter firstParameter = paramList.get(0);
     FunctionType paramType = firstParameter.getJSType().toMaybeFunctionType();
@@ -315,7 +315,7 @@ public class JSTypeRegistryTest {
   /** Returns a scope that overrides a few methods from {@link AbstractStaticScope} */
   private StaticTypedScope createStaticTypedScope(
       Node root,
-      StaticTypedScope parentScope,
+      @Nullable StaticTypedScope parentScope,
       Map<String, StaticTypedSlot> slots,
       Set<String> reservedNames) {
     return new AbstractStaticScope() {
diff --git a/test/com/google/javascript/rhino/jstype/JSTypeTest.java b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
index 04da8ad..98fedee 100644
--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java
+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java
@@ -92,11 +92,10 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   private static final StaticTypedScope EMPTY_SCOPE = MapBasedScope.emptyScope();
 
   /**
-   * A non exhaustive list of representative types used to test simple
-   * properties that should hold for all types (such as the reflexivity
-   * of subtyping).
+   * A non exhaustive list of representative types used to test simple properties that should hold
+   * for all types (such as the reflexivity of subtyping).
    */
-  private List<JSType> types;
+  private ImmutableList<JSType> types;
 
   @Before
   @SuppressWarnings({"MustBeClosedChecker"})
@@ -2506,7 +2505,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   private void assertReturnTypeEquals(JSType expectedReturnType,
       JSType function) {
-    assertThat(function instanceof FunctionType).isTrue();
+    assertThat(function).isInstanceOf(FunctionType.class);
     assertTypeEquals(expectedReturnType,
         ((FunctionType) function).getReturnType());
   }
@@ -3076,7 +3075,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertTypeEquals("apply should have the same return type as its function",
         NUMBER_TYPE, applyFn.getReturnType());
 
-    List<FunctionType.Parameter> params = applyFn.getParameters();
+    ImmutableList<FunctionType.Parameter> params = applyFn.getParameters();
     assertWithMessage("apply takes two args").that(params).hasSize(2);
     assertTypeEquals(
         "apply's first arg is the @this type",
@@ -3100,7 +3099,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertTypeEquals("call should have the same return type as its function",
         NUMBER_TYPE, callFn.getReturnType());
 
-    List<FunctionType.Parameter> params = callFn.getParameters();
+    ImmutableList<FunctionType.Parameter> params = callFn.getParameters();
     assertWithMessage("call takes one argument in this case").that(params).hasSize(1);
     assertTypeEquals(
         "call's first arg is the @this type",
@@ -3183,9 +3182,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(stringMethodEmpty.isSubtype(dateMethodEmpty)).isFalse();
 
     // Systemic tests.
-    List<FunctionType> allFunctions = ImmutableList.of(
-        dateMethodEmpty, dateMethodWithParam, dateMethodWithReturn,
-        stringMethodEmpty, stringMethodWithParam, stringMethodWithReturn);
+    ImmutableList<FunctionType> allFunctions =
+        ImmutableList.of(
+            dateMethodEmpty,
+            dateMethodWithParam,
+            dateMethodWithReturn,
+            stringMethodEmpty,
+            stringMethodWithParam,
+            stringMethodWithReturn);
     for (int i = 0; i < allFunctions.size(); i++) {
       for (int j = 0; j < allFunctions.size(); j++) {
         FunctionType typeA = allFunctions.get(i);
@@ -3263,9 +3267,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(googBarMethod.isSubtype(googSubBarMethod)).isTrue();
     assertThat(googBarReturnFn.isSubtype(googSubBarReturnFn)).isTrue();
 
-    List<FunctionType> allFunctions = ImmutableList.of(
-        googBarMethod, googBarParamFn, googBarReturnFn,
-        googSubBarMethod, googSubBarParamFn, googSubBarReturnFn);
+    ImmutableList<FunctionType> allFunctions =
+        ImmutableList.of(
+            googBarMethod,
+            googBarParamFn,
+            googBarReturnFn,
+            googSubBarMethod,
+            googSubBarParamFn,
+            googSubBarReturnFn);
     for (int i = 0; i < allFunctions.size(); i++) {
       for (int j = 0; j < allFunctions.size(); j++) {
         FunctionType typeA = allFunctions.get(i);
@@ -3347,11 +3356,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     assertThat(subclassCtor.getOwnPropertyJSDocInfo("prototype")).isNull();
   }
 
-  /**
-   * Tests operation of {@code isVoidable}.
-   *
-   * @throws Exception
-   */
+  /** Tests operation of {@code isVoidable}. */
   @Test
   public void testIsVoidable() {
     assertThat(VOID_TYPE.isVoidable()).isTrue();
@@ -4528,8 +4533,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testSymmetryOfTestForEquality() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         Tri aOnB = typeA.testForEquality(typeB);
@@ -4553,8 +4558,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getLeastSupertype is a symmetric relation. */
   @Test
   public void testSymmetryOfLeastSupertype() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         JSType aOnB = typeA.getLeastSupertype(typeB);
@@ -4589,8 +4594,8 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getGreatestSubtype is a symmetric relation. */
   @Test
   public void testSymmetryOfGreatestSubtype() {
-    List<JSType> listA = getTypesToTestForSymmetry();
-    List<JSType> listB = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listA = getTypesToTestForSymmetry();
+    ImmutableList<JSType> listB = getTypesToTestForSymmetry();
     for (JSType typeA : listA) {
       for (JSType typeB : listB) {
         JSType aOnB = typeA.getGreatestSubtype(typeB);
@@ -4618,7 +4623,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getLeastSupertype is a reflexive relation. */
   @Test
   public void testReflexivityOfLeastSupertype() {
-    List<JSType> list = getTypesToTestForSymmetry();
+    ImmutableList<JSType> list = getTypesToTestForSymmetry();
     for (JSType type : list) {
       assertTypeEquals("getLeastSupertype not reflexive",
           type, type.getLeastSupertype(type));
@@ -4628,7 +4633,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   /** Tests that getGreatestSubtype is a reflexive relation. */
   @Test
   public void testReflexivityOfGreatestSubtype() {
-    List<JSType> list = getTypesToTestForSymmetry();
+    ImmutableList<JSType> list = getTypesToTestForSymmetry();
     for (JSType type : list) {
       assertTypeEquals("getGreatestSubtype not reflexive",
           type, type.getGreatestSubtype(type));
@@ -4888,18 +4893,19 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testNamedSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        googBar.getPrototype(),
-        googBar.getInstanceType(),
-        googSubBar.getPrototype(),
-        googSubBar.getInstanceType(),
-        googSubSubBar.getPrototype(),
-        googSubSubBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            googBar.getPrototype(),
+            googBar.getInstanceType(),
+            googSubBar.getPrototype(),
+            googSubBar.getInstanceType(),
+            googSubSubBar.getPrototype(),
+            googSubSubBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4926,16 +4932,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("c", NUMBER_TYPE, null);
     JSType abcType = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        aType,
-        abOrAcType,
-        abType,
-        abcType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            aType,
+            abOrAcType,
+            abType,
+            abcType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4945,12 +4952,13 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("date", DATE_TYPE, null);
     JSType hasDateProperty = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        hasDateProperty,
-        googBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            hasDateProperty,
+            googBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -4960,89 +4968,84 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     builder.addProperty("date", UNKNOWN_TYPE, null);
     JSType hasUnknownDateProperty = builder.build();
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        hasUnknownDateProperty,
-        googBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            hasUnknownDateProperty,
+            googBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testNullableNamedTypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.ALL_TYPE)),
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)),
-        registry.createOptionalNullableType(
-            registry.getNativeType(JSTypeNative.OBJECT_TYPE)),
-        registry.createOptionalNullableType(googBar.getPrototype()),
-        registry.createOptionalNullableType(googBar.getInstanceType()),
-        registry.createNullableType(googSubBar.getPrototype()),
-        registry.createNullableType(googSubBar.getInstanceType()),
-        googSubSubBar.getPrototype(),
-        googSubSubBar.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.ALL_TYPE)),
+            registry.createOptionalNullableType(
+                registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)),
+            registry.createOptionalNullableType(registry.getNativeType(JSTypeNative.OBJECT_TYPE)),
+            registry.createOptionalNullableType(googBar.getPrototype()),
+            registry.createOptionalNullableType(googBar.getInstanceType()),
+            registry.createNullableType(googSubBar.getPrototype()),
+            registry.createNullableType(googSubBar.getInstanceType()),
+            googSubSubBar.getPrototype(),
+            googSubSubBar.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testEnumTypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        enumType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            enumType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testFunctionSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),
-        registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE),
-        dateMethod,
-        registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),
+            registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE),
+            dateMethod,
+            registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testFunctionUnionSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        createUnionType(
-            OBJECT_TYPE,
-            STRING_TYPE),
-        createUnionType(
-            GREATEST_FUNCTION_TYPE,
-            googBarInst,
-            STRING_TYPE),
-        createUnionType(
-            STRING_TYPE,
-            registry.createFunctionType(
-                createUnionType(STRING_TYPE, NUMBER_TYPE)),
-            googBarInst),
-        createUnionType(
-            registry.createFunctionType(NUMBER_TYPE),
-            googSubBarInst),
-        LEAST_FUNCTION_TYPE,
-        NO_OBJECT_TYPE,
-        NO_TYPE);
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            createUnionType(OBJECT_TYPE, STRING_TYPE),
+            createUnionType(GREATEST_FUNCTION_TYPE, googBarInst, STRING_TYPE),
+            createUnionType(
+                STRING_TYPE,
+                registry.createFunctionType(createUnionType(STRING_TYPE, NUMBER_TYPE)),
+                googBarInst),
+            createUnionType(registry.createFunctionType(NUMBER_TYPE), googSubBarInst),
+            LEAST_FUNCTION_TYPE,
+            NO_OBJECT_TYPE,
+            NO_TYPE);
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testConstructorSubtypeChain() throws Exception {
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.ALL_TYPE),
             registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),
@@ -5056,7 +5059,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testGoogBarSubtypeChain() throws Exception {
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.FUNCTION_TYPE),
             googBar,
@@ -5090,7 +5093,7 @@ public class JSTypeTest extends BaseJSTypeTestCase {
                     null,
                     /* isAbstract= */ false));
 
-    List<JSType> typeChain =
+    ImmutableList<JSType> typeChain =
         ImmutableList.of(
             registry.getNativeType(JSTypeNative.FUNCTION_TYPE),
             googBarArgConstructor,
@@ -5101,16 +5104,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
 
   @Test
   public void testInterfaceInstanceSubtypeChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        OBJECT_TYPE,
-        interfaceInstType,
-        googBar.getPrototype(),
-        googBarInst,
-        googSubBar.getPrototype(),
-        googSubBarInst,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            OBJECT_TYPE,
+            interfaceInstType,
+            googBar.getPrototype(),
+            googBarInst,
+            googSubBar.getPrototype(),
+            googSubBarInst,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5128,27 +5132,29 @@ public class JSTypeTest extends BaseJSTypeTestCase {
                     /* isAbstract= */ false));
     tempType.setImplementedInterfaces(
         Lists.<ObjectType>newArrayList(subInterfaceInstType));
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        OBJECT_TYPE,
-        interfaceInstType,
-        subInterfaceInstType,
-        tempType.getPrototype(),
-        tempType.getInstanceType(),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            OBJECT_TYPE,
+            interfaceInstType,
+            subInterfaceInstType,
+            tempType.getPrototype(),
+            tempType.getInstanceType(),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
   @Test
   public void testAnonymousObjectChain() throws Exception {
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        createNullableType(OBJECT_TYPE),
-        OBJECT_TYPE,
-        registry.createAnonymousObjectType(null),
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            createNullableType(OBJECT_TYPE),
+            OBJECT_TYPE,
+            registry.createAnonymousObjectType(null),
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5160,13 +5166,14 @@ public class JSTypeTest extends BaseJSTypeTestCase {
             .setElementType(registry.createAnonymousObjectType(null))
             .build()
             .getElementsType();
-    List<JSType> typeChain = ImmutableList.of(
-        ALL_TYPE,
-        createNullableType(OBJECT_TYPE),
-        OBJECT_TYPE,
-        enumElemType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            ALL_TYPE,
+            createNullableType(OBJECT_TYPE),
+            OBJECT_TYPE,
+            enumElemType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain);
   }
 
@@ -5181,15 +5188,16 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType arrayOfAllType = createTemplatizedType(
         ARRAY_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        arrayOfAllType,
-        arrayOfStringOrNumber,
-        arrayOfString,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            arrayOfAllType,
+            arrayOfStringOrNumber,
+            arrayOfString,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5206,16 +5214,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType arrayOfAllType = createTemplatizedType(
         ARRAY_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        arrayOfAllType,
-        arrayOfObject,
-        arrayOfArray,
-        arrayOfNoObjectType,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            arrayOfAllType,
+            arrayOfObject,
+            arrayOfArray,
+            arrayOfNoObjectType,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5230,15 +5239,16 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType objectOfAllType = createTemplatizedType(
         OBJECT_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        objectOfAllType,
-        objectOfStringOrNumber,
-        objectOfString,
-        objectOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            objectOfAllType,
+            objectOfStringOrNumber,
+            objectOfString,
+            objectOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5255,16 +5265,17 @@ public class JSTypeTest extends BaseJSTypeTestCase {
     JSType objectOfAllType = createTemplatizedType(
         OBJECT_TYPE, ALL_TYPE);
 
-    List<JSType> typeChain = ImmutableList.of(
-        registry.getNativeType(JSTypeNative.ALL_TYPE),
-        registry.getNativeType(JSTypeNative.OBJECT_TYPE),
-        objectOfAllType,
-        objectOfStringOrNumber,
-        objectOfString,
-        arrayOfString,
-        arrayOfNoType,
-        registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
-        registry.getNativeType(JSTypeNative.NO_TYPE));
+    ImmutableList<JSType> typeChain =
+        ImmutableList.of(
+            registry.getNativeType(JSTypeNative.ALL_TYPE),
+            registry.getNativeType(JSTypeNative.OBJECT_TYPE),
+            objectOfAllType,
+            objectOfStringOrNumber,
+            objectOfString,
+            arrayOfString,
+            arrayOfNoType,
+            registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),
+            registry.getNativeType(JSTypeNative.NO_TYPE));
     verifySubtypeChain(typeChain, false);
   }
 
@@ -5394,11 +5405,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6220,11 +6231,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE, STRING_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6259,11 +6270,11 @@ public class JSTypeTest extends BaseJSTypeTestCase {
         ImmutableList.of(NUMBER_TYPE));
 
     TemplateTypeMap ctrTypeMap = templatizedCtor.getTemplateTypeMap();
-    TemplateType keyA = ctrTypeMap.getTemplateTypeKeyByName("A");
+    TemplateType keyA = ctrTypeMap.getLastTemplateTypeKeyByName("A");
     assertThat(keyA).isNotNull();
-    TemplateType keyB = ctrTypeMap.getTemplateTypeKeyByName("B");
+    TemplateType keyB = ctrTypeMap.getLastTemplateTypeKeyByName("B");
     assertThat(keyB).isNotNull();
-    TemplateType keyC = ctrTypeMap.getTemplateTypeKeyByName("C");
+    TemplateType keyC = ctrTypeMap.getLastTemplateTypeKeyByName("C");
     assertThat(keyC).isNull();
     TemplateType unknownKey = registry.createTemplateType("C");
 
@@ -6280,6 +6291,57 @@ public class JSTypeTest extends BaseJSTypeTestCase {
   }
 
   @Test
+  public void testTemplatizedTypeWithSubclass() {
+    TemplateType parentKeyA = registry.createTemplateType("A");
+    TemplateType childKeyA = registry.createTemplateType("A");
+    TemplateType childKeyB = registry.createTemplateType("B");
+
+    FunctionType templatizedCtor =
+        withOpenRegistry(
+            () -> {
+              FunctionType parent =
+                  FunctionType.builder(registry)
+                      .withName("ParentType")
+                      .forConstructor()
+                      .withTemplateKeys(ImmutableList.of(parentKeyA))
+                      .build();
+              ObjectType baseType =
+                  registry.createTemplatizedType(
+                      parent.getInstanceType(), ImmutableList.of(NULL_TYPE));
+              // create a subclass that `@extends {ParentType<null>}`
+              // and has a template key with the same name 'A' as the parent.
+              FunctionType child =
+                  FunctionType.builder(registry)
+                      .withPrototypeBasedOn(baseType)
+                      .withName("TestingType")
+                      .forConstructor()
+                      .withTemplateKeys(ImmutableList.of(childKeyA, childKeyB))
+                      .build();
+              child.getInstanceType().mergeSupertypeTemplateTypes(baseType);
+              return child;
+            });
+
+    JSType templatizedInstance =
+        registry.createTemplatizedType(
+            templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE));
+
+    TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();
+
+    assertThat(templateTypeMap.getLastTemplateTypeKeyByName("A")).isEqualTo(childKeyA);
+    assertThat(templateTypeMap.getLastTemplateTypeKeyByName("B")).isEqualTo(childKeyB);
+
+    assertThat(templateTypeMap.hasTemplateKey(parentKeyA)).isTrue();
+    assertThat(templateTypeMap.hasTemplateKey(childKeyA)).isTrue();
+    assertThat(templateTypeMap.hasTemplateKey(childKeyB)).isTrue();
+
+    assertThat(templateTypeMap.getResolvedTemplateType(parentKeyA)).isEqualTo(NULL_TYPE);
+    assertThat(templateTypeMap.getResolvedTemplateType(childKeyA)).isEqualTo(NUMBER_TYPE);
+    assertThat(templateTypeMap.getResolvedTemplateType(childKeyB)).isEqualTo(STRING_TYPE);
+
+    assertThat(templatizedInstance.toString()).isEqualTo("TestingType<number,string>");
+  }
+
+  @Test
   public void testTemplateTypeValidator() {
     // The template type setValidator() will see the TemplateType, not the referenced unknown type
     // like other ProxyObjectTypes do.
diff --git a/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java b/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
index 1a2a71c..5e6e306 100644
--- a/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
+++ b/test/com/google/javascript/rhino/jstype/TemplateTypeMapTest.java
@@ -40,6 +40,7 @@ package com.google.javascript.rhino.jstype;
 
 import static com.google.javascript.rhino.testing.Asserts.assertThrows;
 import static com.google.javascript.rhino.testing.TemplateTypeMapSubject.assertThat;
+import static com.google.javascript.rhino.testing.TypeSubject.assertType;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -241,6 +242,18 @@ public final class TemplateTypeMapTest extends BaseJSTypeTestCase {
     assertThat(result).isSameInstanceAs(existing);
   }
 
+  @Test
+  public void testGetLastTemplateTypeKeyByName_returnsLastKeyIfDuplicates() {
+    TemplateType key1 = key("A");
+    TemplateType key2 = key("A");
+
+    TemplateTypeMap map = createMap(ImmutableList.of(key1, key2), ImmutableList.of(NUMBER_TYPE));
+
+    TemplateType result = map.getLastTemplateTypeKeyByName("A");
+
+    assertType(result).isSameInstanceAs(key2);
+  }
+
   private TemplateTypeMap createMap(
       ImmutableList<TemplateType> keys, ImmutableList<JSType> values) {
     return emptyMap.copyWithExtension(keys, values);

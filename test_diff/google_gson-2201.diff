diff --git a/gson/src/test/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactoryTest.java b/gson/src/test/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactoryTest.java
new file mode 100644
index 0000000..08c92f8
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactoryTest.java
@@ -0,0 +1,83 @@
+package com.google.gson.internal.bind;
+
+import static org.junit.Assert.*;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.TypeAdapter;
+import com.google.gson.internal.reflect.ReflectionHelperTest;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import java.io.IOException;
+import java.nio.file.attribute.GroupPrincipal;
+import java.nio.file.attribute.UserPrincipal;
+import java.security.Principal;
+import org.junit.AssumptionViolatedException;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ReflectiveTypeAdapterFactoryTest {
+
+  // The class jdk.net.UnixDomainPrincipal is one of the few Record types that are included in the
+  // JDK.
+  // We use this to test serialization and deserialization of Record classes, so we do not need to
+  // have
+  // record support at the language level for these tests. This class was added in JDK 16.
+  Class<?> unixDomainPrincipalClass;
+
+  @Before
+  public void setUp() throws Exception {
+    try {
+      Class.forName("java.lang.Record");
+      unixDomainPrincipalClass = Class.forName("jdk.net.UnixDomainPrincipal");
+    } catch (ClassNotFoundException e) {
+      // Records not supported, ignore
+      throw new AssumptionViolatedException("java.lang.Record not supported");
+    }
+  }
+
+  @Test
+  public void testCustomAdapterForRecords() {
+    Gson gson = new Gson();
+    TypeAdapter<?> recordAdapter = gson.getAdapter(unixDomainPrincipalClass);
+    TypeAdapter<?> defaultReflectionAdapter = gson.getAdapter(UserPrincipal.class);
+    assertNotEquals(recordAdapter.getClass(), defaultReflectionAdapter.getClass());
+  }
+
+  @Test
+  public void testSerializeRecords() throws ReflectiveOperationException {
+    Gson gson =
+        new GsonBuilder()
+            .registerTypeAdapter(UserPrincipal.class, new PrincipalTypeAdapter<>())
+            .registerTypeAdapter(GroupPrincipal.class, new PrincipalTypeAdapter<>())
+            .create();
+
+    UserPrincipal userPrincipal = gson.fromJson("\"user\"", UserPrincipal.class);
+    GroupPrincipal groupPrincipal = gson.fromJson("\"group\"", GroupPrincipal.class);
+    Object recordInstance =
+        unixDomainPrincipalClass
+            .getDeclaredConstructor(UserPrincipal.class, GroupPrincipal.class)
+            .newInstance(userPrincipal, groupPrincipal);
+    String serialized = gson.toJson(recordInstance);
+    Object deserializedRecordInstance = gson.fromJson(serialized, unixDomainPrincipalClass);
+
+    assertEquals(recordInstance, deserializedRecordInstance);
+    assertEquals("{\"user\":\"user\",\"group\":\"group\"}", serialized);
+  }
+
+  private static class PrincipalTypeAdapter<T extends Principal> extends TypeAdapter<T> {
+    @Override
+    public void write(JsonWriter out, T principal) throws IOException {
+      out.value(principal.getName());
+    }
+
+    @Override
+    public T read(JsonReader in) throws IOException {
+      final String name = in.nextString();
+      // This type adapter is only used for Group and User Principal, both of which are implemented by PrincipalImpl.
+      @SuppressWarnings("unchecked")
+      T principal = (T) new ReflectionHelperTest.PrincipalImpl(name);
+      return principal;
+    }
+  }
+}
diff --git a/gson/src/test/java/com/google/gson/internal/reflect/ReflectionHelperTest.java b/gson/src/test/java/com/google/gson/internal/reflect/ReflectionHelperTest.java
new file mode 100644
index 0000000..7d0c983
--- /dev/null
+++ b/gson/src/test/java/com/google/gson/internal/reflect/ReflectionHelperTest.java
@@ -0,0 +1,90 @@
+package com.google.gson.internal.reflect;
+
+import static org.junit.Assert.*;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.nio.file.attribute.GroupPrincipal;
+import java.nio.file.attribute.UserPrincipal;
+import java.util.Objects;
+import org.junit.AssumptionViolatedException;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ReflectionHelperTest {
+
+  @Before
+  public void setUp() throws Exception {
+    try {
+      Class.forName("java.lang.Record");
+    } catch (ClassNotFoundException e) {
+      // Records not supported, ignore
+      throw new AssumptionViolatedException("java.lang.Record not supported");
+    }
+  }
+
+  @Test
+  public void testJava17Record() throws ClassNotFoundException {
+    Class<?> unixDomainPrincipalClass = Class.forName("jdk.net.UnixDomainPrincipal");
+    // UnixDomainPrincipal is a record
+    assertTrue(ReflectionHelper.isRecord(unixDomainPrincipalClass));
+    // with 2 components
+    assertArrayEquals(
+        new String[] {"user", "group"},
+        ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass));
+    // Check canonical constructor
+    Constructor<?> constructor =
+        ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass);
+    assertNotNull(constructor);
+    assertArrayEquals(
+        new Class<?>[] {UserPrincipal.class, GroupPrincipal.class},
+        constructor.getParameterTypes());
+  }
+
+  @Test
+  public void testJava17RecordAccessors() throws ReflectiveOperationException {
+    // Create an instance of UnixDomainPrincipal, using our custom implementation of UserPrincipal,
+    // and GroupPrincipal. Then attempt to access each component of the record using our accessor
+    // methods.
+    Class<?> unixDomainPrincipalClass = Class.forName("jdk.net.UnixDomainPrincipal");
+    Object unixDomainPrincipal =
+        ReflectionHelper.getCanonicalRecordConstructor(unixDomainPrincipalClass)
+            .newInstance(new PrincipalImpl("user"), new PrincipalImpl("group"));
+    for (String componentName :
+        ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass)) {
+      Field componentField = unixDomainPrincipalClass.getDeclaredField(componentName);
+      Method accessor = ReflectionHelper.getAccessor(unixDomainPrincipalClass, componentField);
+      Object principal = accessor.invoke(unixDomainPrincipal);
+
+      assertEquals(new PrincipalImpl(componentName), principal);
+    }
+  }
+
+  /** Implementation of {@link UserPrincipal} and {@link GroupPrincipal} just for record tests. */
+  public static class PrincipalImpl implements UserPrincipal, GroupPrincipal {
+    private final String name;
+
+    public PrincipalImpl(String name) {
+      this.name = name;
+    }
+
+    @Override
+    public String getName() {
+      return name;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      PrincipalImpl principal = (PrincipalImpl) o;
+      return Objects.equals(name, principal.name);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(name);
+    }
+  }
+}

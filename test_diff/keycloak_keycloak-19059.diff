diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/KeycloakModelTest.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/KeycloakModelTest.java
index 1efab6b..a8b278a 100644
--- a/testsuite/model/src/test/java/org/keycloak/testsuite/model/KeycloakModelTest.java
+++ b/testsuite/model/src/test/java/org/keycloak/testsuite/model/KeycloakModelTest.java
@@ -30,8 +30,6 @@ import org.keycloak.common.profile.PropertiesProfileConfigResolver;
 import org.keycloak.common.util.Time;
 import org.keycloak.component.ComponentFactoryProviderFactory;
 import org.keycloak.component.ComponentFactorySpi;
-import org.keycloak.device.DeviceRepresentationProviderFactoryImpl;
-import org.keycloak.device.DeviceRepresentationSpi;
 import org.keycloak.events.EventStoreSpi;
 import org.keycloak.executors.DefaultExecutorsProviderFactory;
 import org.keycloak.executors.ExecutorsSpi;
@@ -279,9 +277,9 @@ public abstract class KeycloakModelTest {
           Stream.of(basicParameters),
           Stream.of(System.getProperty("keycloak.model.parameters", "").split("\\s*,\\s*"))
             .filter(s -> s != null && ! s.trim().isEmpty())
-            .map(cn -> { try { return Class.forName(cn.indexOf('.') >= 0 ? cn : ("org.keycloak.testsuite.model.parameters." + cn)); } catch (Exception e) { LOG.error("Cannot find " + cn); return null; }})
+            .map(cn -> { try { return Class.forName(cn.indexOf('.') >= 0 ? cn : ("org.keycloak.testsuite.model.parameters." + cn)); } catch (Exception e) { throw new RuntimeException("Cannot find class " + cn, e); }})
             .filter(Objects::nonNull)
-            .map(c -> { try { return c.getDeclaredConstructor().newInstance(); } catch (Exception e) { LOG.error("Cannot instantiate " + c); return null; }} )
+            .map(c -> { try { return c.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new RuntimeException("Cannot instantiate class " + c, e); }} )
             .filter(KeycloakModelParameters.class::isInstance)
             .map(KeycloakModelParameters.class::cast)
           )
diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/export/ExportModelTest.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/export/ExportModelTest.java
deleted file mode 100644
index 44e99ec..0000000
--- a/testsuite/model/src/test/java/org/keycloak/testsuite/model/export/ExportModelTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright 2022 Red Hat, Inc. and/or its affiliates
- * and other contributors as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.keycloak.testsuite.model.export;
-
-import org.apache.commons.io.FileUtils;
-import org.junit.Assert;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestName;
-import org.keycloak.common.enums.SslRequired;
-import org.keycloak.exportimport.ExportImportConfig;
-import org.keycloak.exportimport.ExportImportManager;
-import org.keycloak.exportimport.ExportProvider;
-import org.keycloak.exportimport.dir.DirExportProviderFactory;
-import org.keycloak.exportimport.singlefile.SingleFileExportProviderFactory;
-import org.keycloak.models.KeycloakSession;
-import org.keycloak.models.RealmModel;
-import org.keycloak.models.RoleModel;
-import org.keycloak.testsuite.model.KeycloakModelTest;
-import org.keycloak.testsuite.model.RequireProvider;
-
-import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-
-@RequireProvider(value = ExportProvider.class)
-public class ExportModelTest extends KeycloakModelTest {
-
-    public static final String REALM_NAME = "realm";
-    private String realmId;
-
-    @Override
-    public void createEnvironment(KeycloakSession s) {
-        // initialize a minimal realm with necessary entries to avoid any NPEs
-        RealmModel realm = createRealm(s, REALM_NAME);
-        realm.setSslRequired(SslRequired.NONE);
-        RoleModel role = s.roles().addRealmRole(realm, "default");
-        realm.setDefaultRole(role);
-        this.realmId = realm.getId();
-    }
-
-    @Override
-    public void cleanEnvironment(KeycloakSession s) {
-        s.realms().removeRealm(realmId);
-    }
-
-    @Test
-    @RequireProvider(value = ExportProvider.class, only = SingleFileExportProviderFactory.PROVIDER_ID)
-    public void testExportSingleFile() throws IOException {
-        try {
-            Path exportFolder = prepareTestFolder();
-            Path singleFileExport = exportFolder.resolve("singleFileExport.json");
-
-            CONFIG.spi("export")
-                    .config("exporter", SingleFileExportProviderFactory.PROVIDER_ID);
-            CONFIG.spi("export")
-                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
-                    .config(SingleFileExportProviderFactory.FILE, singleFileExport.toAbsolutePath().toString());
-            CONFIG.spi("export")
-                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
-                    .config(SingleFileExportProviderFactory.REALM_NAME, REALM_NAME);
-
-            withRealm(realmId, (session, realm) -> {
-                ExportImportConfig.setAction(ExportImportConfig.ACTION_EXPORT);
-                ExportImportManager exportImportManager = new ExportImportManager(session);
-                exportImportManager.runExport();
-                return null;
-            });
-
-            // file will exist if export was successful
-            Assert.assertTrue(Files.exists(singleFileExport));
-        } finally {
-            CONFIG.spi("export")
-                    .config("exporter", null);
-            CONFIG.spi("export")
-                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
-                    .config(SingleFileExportProviderFactory.FILE, null);
-            CONFIG.spi("export")
-                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
-                    .config(SingleFileExportProviderFactory.REALM_NAME, null);
-        }
-    }
-
-    @Test
-    @RequireProvider(value = ExportProvider.class, only = DirExportProviderFactory.PROVIDER_ID)
-    public void testExportDirectory() throws IOException {
-        try {
-            Path exportFolder = prepareTestFolder();
-
-            CONFIG.spi("export")
-                    .config("exporter", DirExportProviderFactory.PROVIDER_ID);
-            CONFIG.spi("export")
-                    .provider(DirExportProviderFactory.PROVIDER_ID)
-                    .config(DirExportProviderFactory.DIR, exportFolder.toAbsolutePath().toString());
-            CONFIG.spi("export")
-                    .provider(DirExportProviderFactory.PROVIDER_ID)
-                    .config(DirExportProviderFactory.REALM_NAME, REALM_NAME);
-
-            withRealm(realmId, (session, realm) -> {
-                ExportImportConfig.setAction(ExportImportConfig.ACTION_EXPORT);
-                ExportImportManager exportImportManager = new ExportImportManager(session);
-                exportImportManager.runExport();
-                return null;
-            });
-
-            // file will exist if export was successful
-            Assert.assertTrue(Files.exists(exportFolder.resolve(REALM_NAME + "-realm.json")));
-        } finally {
-            CONFIG.spi("export")
-                    .config("exporter", null);
-            CONFIG.spi("export")
-                    .provider(DirExportProviderFactory.PROVIDER_ID)
-                    .config(DirExportProviderFactory.DIR, null);
-            CONFIG.spi("export")
-                    .provider(DirExportProviderFactory.PROVIDER_ID)
-                    .config(DirExportProviderFactory.REALM_NAME, null);
-        }
-    }
-
-    @Rule
-    public TestName name = new TestName();
-
-    private Path prepareTestFolder() throws IOException {
-        Path singleFileExportFolder = Paths.get("target", "test", this.getClass().getName(), name.getMethodName());
-        if (singleFileExportFolder.toFile().exists()) {
-            FileUtils.deleteDirectory(singleFileExportFolder.toFile());
-        }
-        Assert.assertTrue(singleFileExportFolder.toFile().mkdirs());
-        return singleFileExportFolder;
-    }
-
-}
diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ExportModelTest.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ExportModelTest.java
new file mode 100644
index 0000000..eeaf259
--- /dev/null
+++ b/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ExportModelTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2022 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.testsuite.model.exportimport;
+
+import org.apache.commons.io.FileUtils;
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+import org.keycloak.common.enums.SslRequired;
+import org.keycloak.exportimport.ExportImportConfig;
+import org.keycloak.exportimport.ExportImportManager;
+import org.keycloak.exportimport.ExportProvider;
+import org.keycloak.exportimport.dir.DirExportProviderFactory;
+import org.keycloak.exportimport.singlefile.SingleFileExportProviderFactory;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.RoleModel;
+import org.keycloak.testsuite.model.KeycloakModelTest;
+import org.keycloak.testsuite.model.RequireProvider;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+@RequireProvider(value = ExportProvider.class)
+public class ExportModelTest extends KeycloakModelTest {
+
+    public static final String REALM_NAME = "realm";
+    private String realmId;
+
+    @Override
+    public void createEnvironment(KeycloakSession s) {
+        // initialize a minimal realm with necessary entries to avoid any NPEs
+        RealmModel realm = createRealm(s, REALM_NAME);
+        realm.setSslRequired(SslRequired.NONE);
+        RoleModel role = s.roles().addRealmRole(realm, "default");
+        realm.setDefaultRole(role);
+        this.realmId = realm.getId();
+    }
+
+    @Override
+    public void cleanEnvironment(KeycloakSession s) {
+        s.realms().removeRealm(realmId);
+    }
+
+    @Test
+    @RequireProvider(value = ExportProvider.class, only = SingleFileExportProviderFactory.PROVIDER_ID)
+    public void testExportSingleFile() throws IOException {
+        try {
+            Path exportFolder = prepareTestFolder();
+            Path singleFileExport = exportFolder.resolve("singleFileExport.json");
+
+            CONFIG.spi("export")
+                    .config("exporter", SingleFileExportProviderFactory.PROVIDER_ID);
+            CONFIG.spi("export")
+                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileExportProviderFactory.FILE, singleFileExport.toAbsolutePath().toString());
+            CONFIG.spi("export")
+                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileExportProviderFactory.REALM_NAME, REALM_NAME);
+
+            inComittedTransaction(session -> {
+                ExportImportConfig.setAction(ExportImportConfig.ACTION_EXPORT);
+                ExportImportManager exportImportManager = new ExportImportManager(session);
+                exportImportManager.runExport();
+            });
+
+            // file will exist if export was successful
+            Assert.assertTrue(Files.exists(singleFileExport));
+        } finally {
+            CONFIG.spi("export")
+                    .config("exporter", null);
+            CONFIG.spi("export")
+                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileExportProviderFactory.FILE, null);
+            CONFIG.spi("export")
+                    .provider(SingleFileExportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileExportProviderFactory.REALM_NAME, null);
+        }
+    }
+
+    @Test
+    @RequireProvider(value = ExportProvider.class, only = DirExportProviderFactory.PROVIDER_ID)
+    public void testExportDirectory() throws IOException {
+        try {
+            Path exportFolder = prepareTestFolder();
+
+            CONFIG.spi("export")
+                    .config("exporter", DirExportProviderFactory.PROVIDER_ID);
+            CONFIG.spi("export")
+                    .provider(DirExportProviderFactory.PROVIDER_ID)
+                    .config(DirExportProviderFactory.DIR, exportFolder.toAbsolutePath().toString());
+            CONFIG.spi("export")
+                    .provider(DirExportProviderFactory.PROVIDER_ID)
+                    .config(DirExportProviderFactory.REALM_NAME, REALM_NAME);
+
+            inComittedTransaction(session -> {
+                ExportImportConfig.setAction(ExportImportConfig.ACTION_EXPORT);
+                ExportImportManager exportImportManager = new ExportImportManager(session);
+                exportImportManager.runExport();
+            });
+
+            // file will exist if export was successful
+            Assert.assertTrue(Files.exists(exportFolder.resolve(REALM_NAME + "-realm.json")));
+        } finally {
+            CONFIG.spi("export")
+                    .config("exporter", null);
+            CONFIG.spi("export")
+                    .provider(DirExportProviderFactory.PROVIDER_ID)
+                    .config(DirExportProviderFactory.DIR, null);
+            CONFIG.spi("export")
+                    .provider(DirExportProviderFactory.PROVIDER_ID)
+                    .config(DirExportProviderFactory.REALM_NAME, null);
+        }
+    }
+
+    @Rule
+    public TestName name = new TestName();
+
+    private Path prepareTestFolder() throws IOException {
+        Path singleFileExportFolder = Paths.get("target", "test", this.getClass().getName(), name.getMethodName());
+        if (singleFileExportFolder.toFile().exists()) {
+            FileUtils.deleteDirectory(singleFileExportFolder.toFile());
+        }
+        Assert.assertTrue(singleFileExportFolder.toFile().mkdirs());
+        return singleFileExportFolder;
+    }
+
+}
diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ImportModelTest.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ImportModelTest.java
new file mode 100644
index 0000000..c9508ff
--- /dev/null
+++ b/testsuite/model/src/test/java/org/keycloak/testsuite/model/exportimport/ImportModelTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2023 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.testsuite.model.exportimport;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.keycloak.exportimport.ExportImportConfig;
+import org.keycloak.exportimport.ExportImportManager;
+import org.keycloak.exportimport.ExportProvider;
+import org.keycloak.exportimport.ImportProvider;
+import org.keycloak.exportimport.dir.DirExportProviderFactory;
+import org.keycloak.exportimport.dir.DirImportProviderFactory;
+import org.keycloak.exportimport.singlefile.SingleFileImportProviderFactory;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.services.managers.ApplianceBootstrap;
+import org.keycloak.testsuite.model.KeycloakModelTest;
+import org.keycloak.testsuite.model.RequireProvider;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+@RequireProvider(value = ImportProvider.class)
+public class ImportModelTest extends KeycloakModelTest {
+
+    public static final String SPI_NAME = "import";
+
+    @Override
+    public void createEnvironment(KeycloakSession s) {
+        // Master realm is needed for importing a realm
+        if (s.realms().getRealmByName("master") == null) {
+            new ApplianceBootstrap(s).createMasterRealm();
+        }
+        // clean-up test realm which might be left-over from a previous run
+        RealmModel test = s.realms().getRealmByName("test");
+        if (test != null) {
+            s.realms().removeRealm(test.getId());
+        }
+    }
+
+    @Override
+    public void cleanEnvironment(KeycloakSession s) {
+        RealmModel master = s.realms().getRealmByName("master");
+        if (master != null) {
+            s.realms().removeRealm(master.getId());
+        }
+        RealmModel test = s.realms().getRealmByName("test");
+        if (test != null) {
+            s.realms().removeRealm(test.getId());
+        }
+    }
+
+    @Test
+    @RequireProvider(value = ExportProvider.class, only = SingleFileImportProviderFactory.PROVIDER_ID)
+    public void testImportSingleFile() {
+        try {
+            Path singleFileExport = Paths.get("src/test/resources/exportimport/singleFile/testrealm.json");
+
+            CONFIG.spi(SPI_NAME)
+                    .config("importer", new SingleFileImportProviderFactory().getId());
+            CONFIG.spi(SPI_NAME)
+                    .provider(SingleFileImportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileImportProviderFactory.FILE, singleFileExport.toAbsolutePath().toString());
+
+            inComittedTransaction(session -> {
+                ExportImportConfig.setAction(ExportImportConfig.ACTION_IMPORT);
+                ExportImportManager exportImportManager = new ExportImportManager(session);
+                exportImportManager.runImport();
+            });
+
+            inComittedTransaction(session -> {
+                Assert.assertNotNull(session.realms().getRealmByName("test"));
+            });
+
+        } finally {
+            CONFIG.spi(SPI_NAME)
+                    .config("importer", null);
+            CONFIG.spi(SPI_NAME)
+                    .provider(SingleFileImportProviderFactory.PROVIDER_ID)
+                    .config(SingleFileImportProviderFactory.FILE, null);
+        }
+    }
+
+    @Test
+    @RequireProvider(value = ExportProvider.class, only = DirImportProviderFactory.PROVIDER_ID)
+    public void testImportDirectory() {
+        try {
+            Path importFolder = Paths.get("src/test/resources/exportimport/dir");
+            CONFIG.spi(SPI_NAME)
+                    .config("importer", new DirImportProviderFactory().getId());
+            CONFIG.spi(SPI_NAME)
+                    .provider(DirImportProviderFactory.PROVIDER_ID)
+                    .config(DirImportProviderFactory.DIR, importFolder.toAbsolutePath().toString());
+
+            inComittedTransaction(session -> {
+                ExportImportConfig.setAction(ExportImportConfig.ACTION_IMPORT);
+                ExportImportManager exportImportManager = new ExportImportManager(session);
+                exportImportManager.runImport();
+            });
+
+            inComittedTransaction(session -> {
+                Assert.assertNotNull(session.realms().getRealmByName("test"));
+            });
+
+        } finally {
+            CONFIG.spi(SPI_NAME)
+                    .config("importer", null);
+            CONFIG.spi(SPI_NAME)
+                    .provider(DirImportProviderFactory.PROVIDER_ID)
+                    .config(DirExportProviderFactory.DIR, null);
+        }
+    }
+
+}
diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/ConcurrentHashMapStorage.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/ConcurrentHashMapStorage.java
index 08936f2..71f7ac3 100644
--- a/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/ConcurrentHashMapStorage.java
+++ b/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/ConcurrentHashMapStorage.java
@@ -16,12 +16,22 @@
  */
 package org.keycloak.testsuite.model.parameters;
 
+import org.keycloak.common.crypto.CryptoIntegration;
+import org.keycloak.common.crypto.CryptoProvider;
 import org.keycloak.exportimport.ExportSpi;
+import org.keycloak.exportimport.ImportSpi;
 import org.keycloak.exportimport.dir.DirExportProviderFactory;
+import org.keycloak.exportimport.dir.DirImportProviderFactory;
 import org.keycloak.exportimport.singlefile.SingleFileExportProviderFactory;
+import org.keycloak.exportimport.singlefile.SingleFileImportProviderFactory;
+import org.keycloak.keys.KeyProviderFactory;
+import org.keycloak.keys.KeySpi;
+import org.keycloak.models.ClientScopeSpi;
 import org.keycloak.models.map.storage.MapStorageSpi;
 import org.keycloak.services.clientpolicy.ClientPolicyManagerFactory;
 import org.keycloak.services.clientpolicy.ClientPolicyManagerSpi;
+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyFactory;
+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicySpi;
 import org.keycloak.testsuite.model.KeycloakModelParameters;
 import org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory;
 import org.keycloak.provider.ProviderFactory;
@@ -39,13 +49,30 @@ public class ConcurrentHashMapStorage extends KeycloakModelParameters {
     static final Set<Class<? extends Spi>> ALLOWED_SPIS = ImmutableSet.<Class<? extends Spi>>builder()
       .add(ExportSpi.class)
       .add(ClientPolicyManagerSpi.class)
+      .add(ImportSpi.class)
+      .add(ClientRegistrationPolicySpi.class)
+      .add(ClientScopeSpi.class)
+      .add(KeySpi.class)
       .build();
 
+    static {
+        // CryptoIntegration needed for import of realms
+        CryptoIntegration.init(CryptoProvider.class.getClassLoader());
+    }
+
     static final Set<Class<? extends ProviderFactory>> ALLOWED_FACTORIES = ImmutableSet.<Class<? extends ProviderFactory>>builder()
       .add(ConcurrentHashMapStorageProviderFactory.class)
+      // start providers needed for export
       .add(SingleFileExportProviderFactory.class)
       .add(DirExportProviderFactory.class)
       .add(ClientPolicyManagerFactory.class)
+      // end providers needed for export
+      // start providers needed for import
+      .add(SingleFileImportProviderFactory.class)
+      .add(DirImportProviderFactory.class)
+      .add(ClientRegistrationPolicyFactory.class)
+      .add(KeyProviderFactory.class)
+      // end providers needed for import
       .build();
 
     @Override
diff --git a/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/Map.java b/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/Map.java
index e55c744..0f140cd 100644
--- a/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/Map.java
+++ b/testsuite/model/src/test/java/org/keycloak/testsuite/model/parameters/Map.java
@@ -18,9 +18,6 @@ package org.keycloak.testsuite.model.parameters;
 
 import org.keycloak.authorization.store.StoreFactorySpi;
 import org.keycloak.events.EventStoreSpi;
-import org.keycloak.exportimport.ExportSpi;
-import org.keycloak.exportimport.dir.DirExportProviderFactory;
-import org.keycloak.exportimport.singlefile.SingleFileExportProviderFactory;
 import org.keycloak.keys.PublicKeyStorageSpi;
 import org.keycloak.models.DeploymentStateSpi;
 import org.keycloak.models.SingleUseObjectProviderFactory;
@@ -37,8 +34,6 @@ import org.keycloak.models.map.loginFailure.MapUserLoginFailureProviderFactory;
 import org.keycloak.models.map.singleUseObject.MapSingleUseObjectProviderFactory;
 import org.keycloak.models.map.storage.chm.ConcurrentHashMapStorageProviderFactory;
 import org.keycloak.models.map.userSession.MapUserSessionProviderFactory;
-import org.keycloak.services.clientpolicy.ClientPolicyManagerFactory;
-import org.keycloak.services.clientpolicy.ClientPolicyManagerSpi;
 import org.keycloak.sessions.AuthenticationSessionSpi;
 import org.keycloak.testsuite.model.KeycloakModelParameters;
 import org.keycloak.models.map.client.MapClientProviderFactory;

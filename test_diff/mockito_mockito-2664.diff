diff --git a/src/test/java/org/mockitousage/IMethods.java b/src/test/java/org/mockitousage/IMethods.java
index 1289742..06492f0 100644
--- a/src/test/java/org/mockitousage/IMethods.java
+++ b/src/test/java/org/mockitousage/IMethods.java
@@ -133,8 +133,26 @@ public interface IMethods {
 
     String threeArgumentMethodWithStrings(int valueOne, String valueTwo, String valueThree);
 
+    String threeArgumentVarArgsMethod(int valueOne, String valueTwo, String... valueThree);
+
     String fourArgumentMethod(int valueOne, String valueTwo, String valueThree, boolean[] array);
 
+    String fourArgumentVarArgsMethod(
+            int valueOne, String valueTwo, int valueThree, String... valueFour);
+
+    String fiveArgumentVarArgsMethod(
+            int valueOne, String valueTwo, int valueThree, String valueFour, String... valueFive);
+
+    String sixArgumentVarArgsMethod(
+            int valueOne,
+            String valueTwo,
+            int valueThree,
+            String valueFour,
+            String valueFive,
+            String... valueSix);
+
+    int arrayVarargsMethod(String[]... arrayVarArgs);
+
     void twoArgumentMethod(int one, int two);
 
     void arrayMethod(String[] strings);
@@ -235,6 +253,8 @@ public interface IMethods {
 
     Integer toIntWrapper(int i);
 
+    Integer toIntWrapperVarArgs(int i, Object... varargs);
+
     String forObject(Object object);
 
     <T> String genericToString(T arg);
diff --git a/src/test/java/org/mockitousage/MethodsImpl.java b/src/test/java/org/mockitousage/MethodsImpl.java
index bb69656..e2d53ba 100644
--- a/src/test/java/org/mockitousage/MethodsImpl.java
+++ b/src/test/java/org/mockitousage/MethodsImpl.java
@@ -254,11 +254,48 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
+    public String threeArgumentVarArgsMethod(
+            final int valueOne, final String valueTwo, final String... valueThree) {
+        return null;
+    }
+
     public String fourArgumentMethod(
             int valueOne, String valueTwo, String valueThree, boolean[] array) {
         return null;
     }
 
+    public String fourArgumentVarArgsMethod(
+            final int valueOne,
+            final String valueTwo,
+            final int valueThree,
+            final String... valueFour) {
+        return null;
+    }
+
+    public String fiveArgumentVarArgsMethod(
+            final int valueOne,
+            final String valueTwo,
+            final int valueThree,
+            final String valueFour,
+            final String... valueFive) {
+        return null;
+    }
+
+    public String sixArgumentVarArgsMethod(
+            final int valueOne,
+            final String valueTwo,
+            final int valueThree,
+            final String valueFour,
+            final String valueFive,
+            final String... valueSix) {
+        return null;
+    }
+
+    @Override
+    public int arrayVarargsMethod(final String[]... arrayVarArgs) {
+        return 0;
+    }
+
     public void twoArgumentMethod(int one, int two) {}
 
     public void arrayMethod(String[] strings) {}
@@ -435,6 +472,11 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
+    @Override
+    public Integer toIntWrapperVarArgs(final int i, final Object... varargs) {
+        return null;
+    }
+
     public String forObject(Object object) {
         return null;
     }
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
index 7dfed44..d037cfc 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
@@ -5,6 +5,7 @@
 package org.mockitousage.stubbing;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.within;
 import static org.mockito.AdditionalAnswers.answer;
 import static org.mockito.AdditionalAnswers.answerVoid;
@@ -22,11 +23,13 @@ import static org.mockito.BDDMockito.mock;
 import static org.mockito.BDDMockito.times;
 import static org.mockito.BDDMockito.verify;
 
+import java.util.Arrays;
 import java.util.Date;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.junit.MockitoJUnitRunner;
 import org.mockito.stubbing.Answer1;
 import org.mockito.stubbing.Answer2;
@@ -42,6 +45,7 @@ import org.mockito.stubbing.VoidAnswer5;
 import org.mockito.stubbing.VoidAnswer6;
 import org.mockitousage.IMethods;
 
+@SuppressWarnings({"Convert2Lambda", "Anonymous2MethodRef", "RedundantThrows"})
 @RunWith(MockitoJUnitRunner.class)
 public class StubbingWithAdditionalAnswersTest {
 
@@ -52,10 +56,42 @@ public class StubbingWithAdditionalAnswersTest {
         given(iMethods.objectArgMethod(any())).will(returnsFirstArg());
         given(iMethods.threeArgumentMethod(eq(0), any(), anyString())).will(returnsSecondArg());
         given(iMethods.threeArgumentMethod(eq(1), any(), anyString())).will(returnsLastArg());
+        given(iMethods.mixedVarargsReturningString(eq(1), any())).will(returnsArgAt(2));
 
         assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
         assertThat(iMethods.threeArgumentMethod(0, "second", "whatever")).isEqualTo("second");
         assertThat(iMethods.threeArgumentMethod(1, "whatever", "last")).isEqualTo("last");
+        assertThat(iMethods.mixedVarargsReturningString(1, "a", "b")).isEqualTo("b");
+    }
+
+    @Test
+    public void can_return_var_arguments_of_invocation() throws Exception {
+        given(iMethods.mixedVarargsReturningStringArray(eq(1), any())).will(returnsLastArg());
+        given(iMethods.mixedVarargsReturningObjectArray(eq(1), any())).will(returnsArgAt(1));
+
+        assertThat(iMethods.mixedVarargsReturningStringArray(1, "the", "var", "args"))
+                .containsExactlyInAnyOrder("the", "var", "args");
+        assertThat(iMethods.mixedVarargsReturningObjectArray(1, "the", "var", "args"))
+                .containsExactlyInAnyOrder("the", "var", "args");
+    }
+
+    @Test
+    public void returns_arg_at_throws_on_out_of_range_var_args() throws Exception {
+        given(iMethods.mixedVarargsReturningString(eq(1), any())).will(returnsArgAt(3));
+
+        assertThatThrownBy(() -> iMethods.mixedVarargsReturningString(1, "a", "b"))
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("Invalid argument index");
+    }
+
+    @Test
+    public void returns_arg_at_throws_on_out_of_range_array_var_args() throws Exception {
+        assertThatThrownBy(
+                        () ->
+                                given(iMethods.mixedVarargsReturningStringArray(eq(1), any()))
+                                        .will(returnsArgAt(3)))
+                .isInstanceOf(MockitoException.class)
+                .hasMessageContaining("The argument of type 'String' cannot be returned");
     }
 
     @Test
@@ -85,9 +121,11 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_primitives_or_wrappers() throws Exception {
         given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());
         given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());
+        given(iMethods.toIntWrapperVarArgs(anyInt(), any())).will(returnsFirstArg());
 
         assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);
         assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);
+        assertThat(iMethods.toIntWrapperVarArgs(1, 10)).isEqualTo(1);
     }
 
     @Test
@@ -347,4 +385,340 @@ public class StubbingWithAdditionalAnswersTest {
         // expect the answer to write correctly to "target"
         verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4, 5);
     }
+
+    @Test
+    public void can_return_based_on_strongly_types_one_parameter_var_args_function()
+            throws Exception {
+        given(iMethods.varargs(any()))
+                .will(
+                        answer(
+                                new Answer1<Integer, String[]>() {
+                                    public Integer answer(String[] strings) {
+                                        return strings.length;
+                                    }
+                                }));
+
+        assertThat(iMethods.varargs("some", "args")).isEqualTo(2);
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_one_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.varargs(any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer1<String[]>() {
+                                    public void answer(String[] s) {
+                                        target.varargs(s);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.varargs("some", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).varargs("some", "args");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_two_parameter_var_args_function()
+            throws Exception {
+        given(iMethods.mixedVarargsReturningString(any(), any()))
+                .will(
+                        answer(
+                                new Answer2<String, Object, String[]>() {
+                                    public String answer(Object o, String[] s) {
+                                        return String.join("-", s);
+                                    }
+                                }));
+
+        assertThat(iMethods.mixedVarargsReturningString(1, "var", "args")).isEqualTo("var-args");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_two_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.mixedVarargsReturningString(any(), any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer2<Object, String[]>() {
+                                    public void answer(Object o, String[] s) {
+                                        target.mixedVarargsReturningString(o, s);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.mixedVarargsReturningString(1, "var", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target).mixedVarargsReturningString(1, "var", "args");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_three_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any()))
+                .will(
+                        answer(
+                                new Answer3<String, Integer, String, String[]>() {
+                                    public String answer(Integer i, String s1, String[] s2) {
+                                        target.threeArgumentVarArgsMethod(i, s1, s2);
+                                        return String.join("-", s2);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        assertThat(iMethods.threeArgumentVarArgsMethod(1, "string1", "var", "args"))
+                .isEqualTo("var-args");
+
+        // expect the answer to write correctly to "target"
+        verify(target).threeArgumentVarArgsMethod(1, "string1", "var", "args");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_three_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer3<Integer, String, String[]>() {
+                                    public void answer(Integer i, String s1, String[] s2) {
+                                        target.threeArgumentVarArgsMethod(i, s1, s2);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.threeArgumentVarArgsMethod(1, "string1", "var", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).threeArgumentVarArgsMethod(1, "string1", "var", "args");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_four_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any()))
+                .will(
+                        answer(
+                                new Answer4<String, Integer, String, Integer, String[]>() {
+                                    public String answer(
+                                            Integer i1, String s2, Integer i3, String[] s4) {
+                                        target.fourArgumentVarArgsMethod(i1, s2, i3, s4);
+                                        return String.join("-", s4);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        String[] varargs = {"var", "args"};
+        assertThat(iMethods.fourArgumentVarArgsMethod(1, "string1", 3, varargs))
+                .isEqualTo("var-args");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).fourArgumentVarArgsMethod(1, "string1", 3, varargs);
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_four_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer4<Integer, String, Integer, String[]>() {
+                                    public void answer(
+                                            Integer i, String s2, Integer i3, String[] s4) {
+                                        target.fourArgumentVarArgsMethod(i, s2, i3, s4);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.fourArgumentVarArgsMethod(1, "string1", 3, "var", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).fourArgumentVarArgsMethod(1, "string1", 3, "var", "args");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_five_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.fiveArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any()))
+                .will(
+                        answer(
+                                new Answer5<String, Integer, String, Integer, String, String[]>() {
+                                    public String answer(
+                                            Integer i1,
+                                            String s2,
+                                            Integer i3,
+                                            String s4,
+                                            String[] s5) {
+                                        target.fiveArgumentVarArgsMethod(i1, s2, i3, s4, s5);
+                                        return String.join("-", s5);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        assertThat(iMethods.fiveArgumentVarArgsMethod(1, "two", 3, "four", "var", "args"))
+                .isEqualTo("var-args");
+
+        // expect the answer to write correctly to "target"
+        verify(target).fiveArgumentVarArgsMethod(1, "two", 3, "four", "var", "args");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_five_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.fiveArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer5<Integer, String, Integer, String, String[]>() {
+                                    public void answer(
+                                            Integer i1,
+                                            String s2,
+                                            Integer i3,
+                                            String s4,
+                                            String[] s5) {
+                                        target.fiveArgumentVarArgsMethod(i1, s2, i3, s4, s5);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.fiveArgumentVarArgsMethod(1, "two", 3, "four", "var", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target).fiveArgumentVarArgsMethod(1, "two", 3, "four", "var", "args");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_six_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.sixArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any(), any()))
+                .will(
+                        answer(
+                                new Answer6<
+                                        String,
+                                        Integer,
+                                        String,
+                                        Integer,
+                                        String,
+                                        String,
+                                        String[]>() {
+                                    public String answer(
+                                            Integer i1,
+                                            String s2,
+                                            Integer i3,
+                                            String s4,
+                                            String s5,
+                                            String[] s6) {
+                                        target.sixArgumentVarArgsMethod(i1, s2, i3, s4, s5, s6);
+                                        return "answered";
+                                    }
+                                }));
+
+        // invoke on iMethods
+        assertThat(iMethods.sixArgumentVarArgsMethod(1, "two", 3, "four", "five", "var", "args"))
+                .isEqualTo("answered");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1))
+                .sixArgumentVarArgsMethod(1, "two", 3, "four", "five", "var", "args");
+    }
+
+    @Test
+    public void will_execute_a_void_returning_strongly_typed_six_parameter_var_args_function()
+            throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.sixArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any(), any()))
+                .will(
+                        answerVoid(
+                                new VoidAnswer6<
+                                        Integer, String, Integer, String, String, String[]>() {
+                                    public void answer(
+                                            Integer i1,
+                                            String s2,
+                                            Integer i3,
+                                            String s4,
+                                            String s5,
+                                            String[] s6) {
+                                        target.sixArgumentVarArgsMethod(i1, s2, i3, s4, s5, s6);
+                                    }
+                                }));
+
+        // invoke on iMethods
+        iMethods.sixArgumentVarArgsMethod(1, "two", 3, "four", "five", "var", "args");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1))
+                .sixArgumentVarArgsMethod(1, "two", 3, "four", "five", "var", "args");
+    }
+
+    @Test
+    public void can_accept_array_supertype_for_strongly_typed_var_args_function() throws Exception {
+        given(iMethods.varargs(any()))
+                .will(
+                        answer(
+                                new Answer1<Integer, Object[]>() {
+                                    public Integer answer(Object[] s) {
+                                        return s.length;
+                                    }
+                                }));
+
+        assertThat(iMethods.varargs("var", "args")).isEqualTo(2);
+    }
+
+    @Test
+    public void can_accept_non_vararg_answer_on_var_args_function() throws Exception {
+        given(iMethods.varargs(any()))
+                .will(
+                        answer(
+                                new Answer2<Integer, String, String>() {
+                                    public Integer answer(String s1, String s2) {
+                                        return s1.length() + s2.length();
+                                    }
+                                }));
+
+        assertThat(iMethods.varargs("var", "args")).isEqualTo(7);
+    }
+
+    @Test
+    public void should_work_with_var_args_with_no_elements() throws Exception {
+        given(iMethods.varargs(any()))
+                .will(
+                        answer(
+                                new Answer1<Integer, String[]>() {
+                                    public Integer answer(String[] s) {
+                                        return s.length;
+                                    }
+                                }));
+
+        assertThat(iMethods.varargs()).isEqualTo(0);
+    }
+
+    @Test
+    public void should_work_with_array_var_args() throws Exception {
+        given(iMethods.arrayVarargsMethod(any()))
+                .will(
+                        answer(
+                                new Answer1<Integer, String[][]>() {
+                                    public Integer answer(String[][] s) {
+                                        return Arrays.stream(s).mapToInt(e -> e.length).sum();
+                                    }
+                                }));
+
+        String[][] varArgs = {{}, {""}, {"", ""}};
+        assertThat(iMethods.arrayVarargsMethod(varArgs)).isEqualTo(3);
+    }
 }

diff --git a/src/test/java/org/mockito/ProgrammaticMockMakerTest.java b/src/test/java/org/mockito/ProgrammaticMockMakerTest.java
new file mode 100644
index 0000000..f03555d
--- /dev/null
+++ b/src/test/java/org/mockito/ProgrammaticMockMakerTest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2022 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito;
+
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.withSettings;
+
+import org.junit.Test;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.SmartNullPointerException;
+import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+
+public final class ProgrammaticMockMakerTest {
+    @Test
+    public void test_normal_mock_uses_given_mock_maker() {
+        ClassWithFinalMethod inlineMock =
+                Mockito.mock(
+                        ClassWithFinalMethod.class, withSettings().mockMaker(MockMakers.INLINE));
+        ClassWithFinalMethod subclassMock =
+                Mockito.mock(
+                        ClassWithFinalMethod.class, withSettings().mockMaker(MockMakers.SUBCLASS));
+
+        Mockito.when(inlineMock.finalMethodCallingNonFinal()).thenReturn("MOCKED");
+        Mockito.when(subclassMock.finalMethodCallingNonFinal()).thenReturn("MOCKED");
+
+        assertEquals("MOCKED", inlineMock.finalMethodCallingNonFinal());
+        assertEquals("ORIGINAL", subclassMock.finalMethodCallingNonFinal());
+        assertEquals("MOCKED", subclassMock.nonFinal());
+    }
+
+    @Test
+    public void test_mockability_check_uses_given_mock_maker() {
+        assertNotNull(Mockito.mock(FinalClass.class, withSettings().mockMaker(MockMakers.INLINE)));
+        assertThrows(
+                MockitoException.class,
+                () ->
+                        Mockito.mock(
+                                FinalClass.class, withSettings().mockMaker(MockMakers.SUBCLASS)));
+    }
+
+    @Test
+    public void test_deep_stups_inherit_mock_maker() {
+        Container inlineMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.INLINE)
+                                .defaultAnswer(Answers.RETURNS_DEEP_STUBS));
+        Container subclassMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.SUBCLASS)
+                                .defaultAnswer(Answers.RETURNS_DEEP_STUBS));
+
+        assertNotNull(inlineMock.finalClass());
+        assertNotNull(inlineMock.subContainer().finalClass());
+        assertNull(inlineMock.finalClass().someMethod());
+        assertNull(inlineMock.subContainer().finalClass().someMethod());
+        assertNull(inlineMock.classWithFinalMethod().finalMethod());
+        assertNull(inlineMock.subContainer().classWithFinalMethod().finalMethod());
+
+        assertNull(subclassMock.finalClass());
+        assertNull(subclassMock.subContainer().finalClass());
+        assertEquals("ORIGINAL", subclassMock.classWithFinalMethod().finalMethod());
+        assertEquals("ORIGINAL", subclassMock.subContainer().classWithFinalMethod().finalMethod());
+    }
+
+    @Test
+    public void test_returned_mocks_inherit_mock_maker() {
+        Container inlineMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.INLINE)
+                                .defaultAnswer(Answers.RETURNS_MOCKS));
+        Container subclassMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.SUBCLASS)
+                                .defaultAnswer(Answers.RETURNS_MOCKS));
+
+        assertNotNull(inlineMock.finalClass());
+        assertNotNull(inlineMock.subContainer().finalClass());
+        assertEquals("", inlineMock.finalClass().someMethod());
+        assertEquals("", inlineMock.subContainer().finalClass().someMethod());
+        assertEquals("", inlineMock.classWithFinalMethod().finalMethod());
+        assertEquals("", inlineMock.subContainer().classWithFinalMethod().finalMethod());
+
+        assertNull(subclassMock.finalClass());
+        assertNull(subclassMock.subContainer().finalClass());
+        assertEquals("ORIGINAL", subclassMock.classWithFinalMethod().finalMethod());
+        assertEquals("ORIGINAL", subclassMock.subContainer().classWithFinalMethod().finalMethod());
+    }
+
+    @Test
+    public void test_smart_nulls_inherit_mock_maker() {
+        Container inlineMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.INLINE)
+                                .defaultAnswer(Answers.RETURNS_SMART_NULLS));
+        Container subclassMock =
+                Mockito.mock(
+                        Container.class,
+                        withSettings()
+                                .mockMaker(MockMakers.SUBCLASS)
+                                .defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        assertNotNull(inlineMock.finalClass());
+        assertNotNull(inlineMock.classWithFinalMethod());
+        assertThrows(SmartNullPointerException.class, () -> inlineMock.finalClass().someMethod());
+        assertThrows(
+                SmartNullPointerException.class,
+                () -> inlineMock.classWithFinalMethod().finalMethod());
+
+        assertNull(subclassMock.finalClass());
+        assertNotNull(subclassMock.classWithFinalMethod());
+        assertEquals("ORIGINAL", subclassMock.classWithFinalMethod().finalMethod());
+    }
+
+    @Test
+    public void test_custom_mock_maker() {
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.mock(
+                                    Container.class,
+                                    withSettings().mockMaker(CustomMockMaker.class.getName()));
+                        })
+                .hasMessage("CUSTOM MOCK MAKER");
+    }
+
+    @Test
+    public void test_exception_when_mock_maker_cannot_be_instantiated() {
+        class InvalidMockMaker extends SubclassByteBuddyMockMaker {
+            // Local classes have an implicit constructor parameter,
+            // which makes them an invalid mock maker.
+        }
+        assertThatThrownBy(
+                        () -> {
+                            Mockito.mock(
+                                    Container.class,
+                                    withSettings().mockMaker(InvalidMockMaker.class.getName()));
+                        })
+                .isInstanceOf(IllegalStateException.class)
+                .hasMessageContaining("Failed to construct MockMaker")
+                .hasMessageContaining(InvalidMockMaker.class.getName());
+    }
+
+    private static final class FinalClass {
+        String someMethod() {
+            return "ORIGINAL";
+        }
+    }
+
+    private static class ClassWithFinalMethod {
+        final String finalMethod() {
+            return "ORIGINAL";
+        }
+
+        final String finalMethodCallingNonFinal() {
+            nonFinal();
+            return "ORIGINAL";
+        }
+
+        String nonFinal() {
+            return "ORIGINAL";
+        }
+    }
+
+    private static class Container {
+        FinalClass finalClass() {
+            return new FinalClass();
+        }
+
+        ClassWithFinalMethod classWithFinalMethod() {
+            return new ClassWithFinalMethod();
+        }
+
+        Container subContainer() {
+            return new Container();
+        }
+    }
+
+    public static class CustomMockMaker extends SubclassByteBuddyMockMaker {
+        @Override
+        public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+            throw new RuntimeException("CUSTOM MOCK MAKER");
+        }
+    }
+}
diff --git a/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java b/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
index 44afe0b..aa18356 100644
--- a/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
+++ b/src/test/java/org/mockito/internal/configuration/plugins/DefaultMockitoPluginsTest.java
@@ -7,6 +7,7 @@ package org.mockito.internal.configuration.plugins;
 import static org.junit.Assert.*;
 import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.INLINE_ALIAS;
 import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.PROXY_ALIAS;
+import static org.mockito.internal.configuration.plugins.DefaultMockitoPlugins.SUBCLASS_ALIAS;
 
 import org.junit.Test;
 import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;
@@ -25,11 +26,14 @@ public class DefaultMockitoPluginsTest extends TestBase {
     public void provides_plugins() throws Exception {
         assertEquals(
                 "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker",
-                plugins.getDefaultPluginClass(INLINE_ALIAS));
+                DefaultMockitoPlugins.getDefaultPluginClass(INLINE_ALIAS));
         assertEquals(InlineByteBuddyMockMaker.class, plugins.getInlineMockMaker().getClass());
         assertEquals(
                 "org.mockito.internal.creation.proxy.ProxyMockMaker",
-                plugins.getDefaultPluginClass(PROXY_ALIAS));
+                DefaultMockitoPlugins.getDefaultPluginClass(PROXY_ALIAS));
+        assertEquals(
+                "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker",
+                DefaultMockitoPlugins.getDefaultPluginClass(SUBCLASS_ALIAS));
         assertEquals(
                 ByteBuddyMockMaker.class, plugins.getDefaultPlugin(MockMaker.class).getClass());
         assertNotNull(plugins.getDefaultPlugin(InstantiatorProvider2.class));
diff --git a/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java b/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
index 7efffcf..7491a3f 100644
--- a/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
+++ b/src/test/java/org/mockito/internal/util/MockCreationValidatorTest.java
@@ -66,7 +66,7 @@ public class MockCreationValidatorTest {
     @Test
     public void should_fail_when_type_not_mockable() {
         try {
-            validator.validateType(long.class);
+            validator.validateType(long.class, null);
         } catch (MockitoException ex) {
             assertThat(ex.getMessage()).contains("primitive");
         }
diff --git a/src/test/java/org/mockito/internal/util/MockUtilTest.java b/src/test/java/org/mockito/internal/util/MockUtilTest.java
index 50cadb4..834178c 100644
--- a/src/test/java/org/mockito/internal/util/MockUtilTest.java
+++ b/src/test/java/org/mockito/internal/util/MockUtilTest.java
@@ -100,12 +100,12 @@ public class MockUtilTest extends TestBase {
 
     @Test
     public void should_know_if_type_is_mockable() throws Exception {
-        Assertions.assertThat(MockUtil.typeMockabilityOf(FinalClass.class).mockable())
+        Assertions.assertThat(MockUtil.typeMockabilityOf(FinalClass.class, null).mockable())
                 .isEqualTo(Plugins.getMockMaker().isTypeMockable(FinalClass.class).mockable());
 
-        assertFalse(MockUtil.typeMockabilityOf(int.class).mockable());
+        assertFalse(MockUtil.typeMockabilityOf(int.class, null).mockable());
 
-        assertTrue(MockUtil.typeMockabilityOf(SomeClass.class).mockable());
-        assertTrue(MockUtil.typeMockabilityOf(SomeInterface.class).mockable());
+        assertTrue(MockUtil.typeMockabilityOf(SomeClass.class, null).mockable());
+        assertTrue(MockUtil.typeMockabilityOf(SomeInterface.class, null).mockable());
     }
 }
diff --git a/src/test/java/org/mockitointegration/DeferMockMakersClassLoadingTest.java b/src/test/java/org/mockitointegration/DeferMockMakersClassLoadingTest.java
new file mode 100644
index 0000000..63c0d76
--- /dev/null
+++ b/src/test/java/org/mockitointegration/DeferMockMakersClassLoadingTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2019 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitointegration;
+
+import static org.mockito.Mockito.withSettings;
+import static org.mockitoutil.ClassLoaders.coverageTool;
+
+import java.lang.reflect.Method;
+
+import org.assertj.core.api.Assertions;
+import org.hamcrest.Matcher;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;
+import org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker;
+import org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker;
+import org.mockito.internal.creation.proxy.ProxyMockMaker;
+import org.mockito.invocation.MockHandler;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.plugins.MockMaker;
+import org.mockitoutil.ClassLoaders;
+
+public class DeferMockMakersClassLoadingTest {
+    private static final Object MY_MOCK = new Object();
+
+    @Test
+    public void mockito_should_not_load_mock_makers_it_does_not_need() throws Exception {
+        ClassLoader classLoader_without_mockMakers =
+                ClassLoaders.excludingClassLoader()
+                        .withCodeSourceUrlOf(
+                                Mockito.class,
+                                Matcher.class,
+                                CustomMockMaker.class,
+                                Assertions.class)
+                        .withCodeSourceUrlOf(coverageTool())
+                        .without(
+                                ByteBuddyMockMaker.class.getName(),
+                                SubclassByteBuddyMockMaker.class.getName(),
+                                InlineByteBuddyMockMaker.class.getName(),
+                                ProxyMockMaker.class.getName())
+                        .build();
+
+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
+        Thread.currentThread().setContextClassLoader(classLoader_without_mockMakers);
+        try {
+            Class<?> self = classLoader_without_mockMakers.loadClass(getClass().getName());
+            Method createMock = self.getMethod("createMock");
+            createMock.invoke(null);
+        } finally {
+            Thread.currentThread().setContextClassLoader(contextClassLoader);
+        }
+    }
+
+    // Called by reflection from the test method
+    public static void createMock() {
+        Assertions.assertThat(
+                        Mockito.mock(
+                                Object.class,
+                                withSettings().mockMaker(CustomMockMaker.class.getName())))
+                .isSameAs(MY_MOCK);
+    }
+
+    public static class CustomMockMaker implements MockMaker {
+        @Override
+        public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+            return settings.getTypeToMock().cast(MY_MOCK);
+        }
+
+        @Override
+        public MockHandler getHandler(Object mock) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public TypeMockability isTypeMockable(Class<?> type) {
+            return new TypeMockability() {
+                @Override
+                public boolean mockable() {
+                    return type.equals(Object.class);
+                }
+
+                @Override
+                public String nonMockableReason() {
+                    return mockable() ? "" : "type != Object.class";
+                }
+            };
+        }
+    }
+}
diff --git a/src/test/java/org/mockitousage/annotation/ProgrammaticMockMakerAnnotationTest.java b/src/test/java/org/mockitousage/annotation/ProgrammaticMockMakerAnnotationTest.java
new file mode 100644
index 0000000..ad5f2a5
--- /dev/null
+++ b/src/test/java/org/mockitousage/annotation/ProgrammaticMockMakerAnnotationTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2022 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.annotation;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockMakers;
+import org.mockito.Mockito;
+import org.mockitoutil.TestBase;
+
+public class ProgrammaticMockMakerAnnotationTest extends TestBase {
+    @Mock(mockMaker = MockMakers.INLINE)
+    ClassWithFinalMethod inlineMock;
+
+    @Mock(mockMaker = MockMakers.SUBCLASS)
+    ClassWithFinalMethod subclassMock;
+
+    @Test
+    public void test_mock_uses_given_mock_maker() {
+        Mockito.when(inlineMock.finalMethodCallingNonFinal()).thenReturn("MOCKED");
+        Mockito.when(subclassMock.finalMethodCallingNonFinal()).thenReturn("MOCKED");
+
+        assertEquals("MOCKED", inlineMock.finalMethodCallingNonFinal());
+        assertEquals("ORIGINAL", subclassMock.finalMethodCallingNonFinal());
+        assertEquals("MOCKED", subclassMock.nonFinal());
+    }
+
+    private static class ClassWithFinalMethod {
+        final String finalMethodCallingNonFinal() {
+            nonFinal();
+            return "ORIGINAL";
+        }
+
+        String nonFinal() {
+            return "ORIGINAL";
+        }
+    }
+}

diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
index b96d5fd..b46bf38 100644
--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
@@ -62,7 +62,6 @@ import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
 
 public class DefaultChannelPipelineTest {
 
@@ -730,10 +729,10 @@ public class DefaultChannelPipelineTest {
         CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
         ChannelPipeline pipeline = newLocalChannel().pipeline();
         pipeline.addFirst(handler);
-        handler.addedPromise.syncUninterruptibly();
+        handler.addedFuture.syncUninterruptibly();
         pipeline.channel().register();
         pipeline.remove(handler);
-        handler.removedPromise.syncUninterruptibly();
+        handler.removedFuture.syncUninterruptibly();
 
         pipeline.channel().close().syncUninterruptibly();
     }
@@ -747,7 +746,7 @@ public class DefaultChannelPipelineTest {
         CheckEventExecutorHandler handler = new CheckEventExecutorHandler(loop);
         ChannelPipeline pipeline = newLocalChannel().pipeline();
         pipeline.addFirst(handler);
-        handler.addedPromise.syncUninterruptibly();
+        handler.addedFuture.syncUninterruptibly();
         pipeline.channel().register();
         pipeline.replace(handler, null, new ChannelHandlerAdapter() {
             @Override
@@ -755,7 +754,7 @@ public class DefaultChannelPipelineTest {
                 latch.countDown();
             }
         });
-        handler.removedPromise.syncUninterruptibly();
+        handler.removedFuture.syncUninterruptibly();
         latch.await();
 
         pipeline.channel().close().syncUninterruptibly();
@@ -878,7 +877,7 @@ public class DefaultChannelPipelineTest {
             }
 
             void validate() {
-                validationPromise.syncUninterruptibly();
+                validationPromise.asFuture().syncUninterruptibly();
                 validationPromise = ImmediateEventExecutor.INSTANCE.newPromise();
             }
         }
@@ -1029,7 +1028,7 @@ public class DefaultChannelPipelineTest {
                 // This event must be captured by the added handler.
                 pipeline.fireUserEventTriggered(event);
             });
-            assertSame(event, promise.syncUninterruptibly().getNow());
+            assertSame(event, promise.asFuture().syncUninterruptibly().getNow());
         } finally {
             pipeline1.channel().close().syncUninterruptibly();
         }
@@ -1569,13 +1568,15 @@ public class DefaultChannelPipelineTest {
     }
 
     private static final class CallbackCheckHandler extends ChannelHandlerAdapter {
-        final Promise<Boolean> addedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
-        final Promise<Boolean> removedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
+        private final Promise<Boolean> addedHandlerPromise = ImmediateEventExecutor.INSTANCE.newPromise();
+        private final Promise<Boolean> removedHandlerPromise = ImmediateEventExecutor.INSTANCE.newPromise();
+        final Future<Boolean> addedHandler = addedHandlerPromise.asFuture();
+        final Future<Boolean> removedHandler = removedHandlerPromise.asFuture();
         final AtomicReference<Throwable> error = new AtomicReference<>();
 
         @Override
         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-            if (!addedHandler.trySuccess(true)) {
+            if (!addedHandlerPromise.trySuccess(true)) {
                 error.set(new AssertionError("handlerAdded(...) called multiple times: " + ctx.name()));
             } else if (removedHandler.isDone() && removedHandler.getNow() == Boolean.TRUE) {
                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
@@ -1584,7 +1585,7 @@ public class DefaultChannelPipelineTest {
 
         @Override
         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-            if (!removedHandler.trySuccess(true)) {
+            if (!removedHandlerPromise.trySuccess(true)) {
                 error.set(new AssertionError("handlerRemoved(...) called multiple times: " + ctx.name()));
             } else if (addedHandler.isDone() && addedHandler.getNow() == Boolean.FALSE) {
                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
@@ -1594,13 +1595,17 @@ public class DefaultChannelPipelineTest {
 
     private static final class CheckEventExecutorHandler extends ChannelHandlerAdapter {
         final EventExecutor executor;
-        final Promise<Void> addedPromise;
-        final Promise<Void> removedPromise;
+        final Future<Void> addedFuture;
+        final Future<Void> removedFuture;
+        private final Promise<Void> addedPromise;
+        private final Promise<Void> removedPromise;
 
         CheckEventExecutorHandler(EventExecutor executor) {
             this.executor = executor;
             addedPromise = executor.newPromise();
+            addedFuture = addedPromise.asFuture();
             removedPromise = executor.newPromise();
+            removedFuture = removedPromise.asFuture();
         }
 
         @Override
diff --git a/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
index 43b016e..9499cca 100644
--- a/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
+++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
@@ -209,7 +209,7 @@ public class PendingWriteQueueTest {
         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
 
         Promise<Void> promise = channel.newPromise();
-        promise.addListener(future -> queue.removeAndFailAll(new IllegalStateException()));
+        promise.asFuture().addListener(future -> queue.removeAndFailAll(new IllegalStateException()));
         Promise<Void> promise2 = channel.newPromise();
 
         channel.executor().execute(() -> {
@@ -239,7 +239,7 @@ public class PendingWriteQueueTest {
 
         Promise<Void> promise = channel.newPromise();
         final Promise<Void> promise3 = channel.newPromise();
-        promise.addListener(future -> {
+        promise.asFuture().addListener(future -> {
             queue.add(3L, promise3);
         });
         Promise<Void> promise2 = channel.newPromise();
@@ -277,13 +277,13 @@ public class PendingWriteQueueTest {
 
         Promise<Void> promise = channel.newPromise();
         final Promise<Void> promise3 = channel.newPromise();
-        promise3.addListener(future -> failOrder.add(3));
-        promise.addListener(future -> {
+        promise3.asFuture().addListener(future -> failOrder.add(3));
+        promise.asFuture().addListener(future -> {
             failOrder.add(1);
             queue.add(3L, promise3);
         });
         Promise<Void> promise2 = channel.newPromise();
-        promise2.addListener(future -> failOrder.add(2));
+        promise2.asFuture().addListener(future -> failOrder.add(2));
         channel.executor().execute(() -> {
             queue.add(1L, promise);
             queue.add(2L, promise2);
@@ -308,7 +308,7 @@ public class PendingWriteQueueTest {
         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
 
         Promise<Void> promise = channel.newPromise();
-        promise.addListener(future -> queue.removeAndWriteAll());
+        promise.asFuture().addListener(future -> queue.removeAndWriteAll());
         Promise<Void> promise2 = channel.newPromise();
 
         channel.executor().execute(() -> {
@@ -365,7 +365,7 @@ public class PendingWriteQueueTest {
             assertFalse(queue.isEmpty());
             assertEquals(++expectedSize, queue.size());
             assertNotNull(queue.current());
-            return promise;
+            return promise.asFuture();
         }
 
         @Override
diff --git a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
index 369c4b7..43e23d6 100644
--- a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
@@ -343,7 +343,7 @@ public class EmbeddedChannelTest {
             public Future<Void> write(final ChannelHandlerContext ctx, final Object msg) {
                 Promise<Void> promise = ctx.newPromise();
                 ctx.executor().execute(() -> ctx.write(msg).cascadeTo(promise));
-                return promise;
+                return promise.asFuture();
             }
         });
         Object msg = new Object();
@@ -364,7 +364,7 @@ public class EmbeddedChannelTest {
                 ctx.executor().schedule(() -> {
                     ctx.writeAndFlush(msg).cascadeTo(promise);
                 }, delay, TimeUnit.MILLISECONDS);
-                return promise;
+                return promise.asFuture();
             }
         });
         Object msg = new Object();
diff --git a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
index 7cd157b..df86b27 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
@@ -809,7 +809,7 @@ public class LocalChannelTest {
             cc.connect(sc.localAddress()).sync();
             Future<Void> f = ref.get().sync();
 
-            assertPromise.syncUninterruptibly();
+            assertPromise.asFuture().syncUninterruptibly();
             assertTrue(f.isSuccess());
         } finally {
             closeChannel(cc);

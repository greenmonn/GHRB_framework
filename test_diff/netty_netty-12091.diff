diff --git a/common/src/test/java/io/netty/util/ResourceLeakDetectorTest.java b/common/src/test/java/io/netty/util/ResourceLeakDetectorTest.java
index 2a55da2..3947d60 100644
--- a/common/src/test/java/io/netty/util/ResourceLeakDetectorTest.java
+++ b/common/src/test/java/io/netty/util/ResourceLeakDetectorTest.java
@@ -20,12 +20,18 @@ import org.junit.jupiter.api.Timeout;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
+import java.util.UUID;
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public class ResourceLeakDetectorTest {
+    @SuppressWarnings("unused")
+    private static volatile int sink;
 
     @Test
     @Timeout(value = 60000, unit = TimeUnit.MILLISECONDS)
@@ -98,6 +104,34 @@ public class ResourceLeakDetectorTest {
         assertNoErrors(error);
     }
 
+    @Timeout(10)
+    @Test
+    public void testLeakSetupHints() throws Throwable {
+        DefaultResource.detectorWithSetupHint.initialise();
+        leakResource();
+
+        do {
+            // Trigger GC.
+            System.gc();
+            // Track another resource to trigger refqueue visiting.
+            Resource resource2 = new DefaultResource();
+            DefaultResource.detectorWithSetupHint.track(resource2).close(resource2);
+            // Give the GC something to work on.
+            for (int i = 0; i < 1000; i++) {
+                sink = System.identityHashCode(new byte[10000]);
+            }
+        } while (DefaultResource.detectorWithSetupHint.getLeaksFound() < 1 && !Thread.interrupted());
+
+        assertThat(DefaultResource.detectorWithSetupHint.getLeaksFound()).isOne();
+        DefaultResource.detectorWithSetupHint.assertNoErrors();
+    }
+
+    private static void leakResource() {
+        Resource resource = new DefaultResource();
+        // We'll never close this ResourceLeakTracker.
+        DefaultResource.detectorWithSetupHint.track(resource);
+    }
+
     // Mimic the way how we implement our classes that should help with leak detection
     private static final  class LeakAwareResource implements Resource {
         private final Resource resource;
@@ -123,6 +157,8 @@ public class ResourceLeakDetectorTest {
         // Sample every allocation
         static final TestResourceLeakDetector<Resource> detector = new TestResourceLeakDetector<Resource>(
                 Resource.class, 1, Integer.MAX_VALUE);
+        static final CreationRecordLeakDetector<Resource> detectorWithSetupHint =
+                new CreationRecordLeakDetector<Resource>(Resource.class, 1);
 
         @Override
         public boolean close() {
@@ -172,4 +208,56 @@ public class ResourceLeakDetectorTest {
             ResourceLeakDetectorTest.assertNoErrors(error);
         }
     }
+
+    private static final class CreationRecordLeakDetector<T> extends ResourceLeakDetector<T> {
+        private String canaryString;
+
+        private final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        private final AtomicInteger leaksFound = new AtomicInteger(0);
+
+        CreationRecordLeakDetector(Class<?> resourceType, int samplingInterval) {
+            super(resourceType, samplingInterval);
+        }
+
+        public void initialise() {
+            canaryString = "creation-canary-" + UUID.randomUUID();
+            leaksFound.set(0);
+        }
+
+        @Override
+        protected boolean needReport() {
+            return true;
+        }
+
+        @Override
+        protected void reportTracedLeak(String resourceType, String records) {
+            if (!records.contains(canaryString)) {
+                reportError(new AssertionError("Leak records did not contain canary string"));
+            }
+            leaksFound.incrementAndGet();
+        }
+
+        @Override
+        protected void reportUntracedLeak(String resourceType) {
+            reportError(new AssertionError("Got untraced leak w/o canary string"));
+            leaksFound.incrementAndGet();
+        }
+
+        private void reportError(AssertionError cause) {
+            error.compareAndSet(null, cause);
+        }
+
+        @Override
+        protected Object getInitialHint(String resourceType) {
+            return canaryString;
+        }
+
+        int getLeaksFound() {
+            return leaksFound.get();
+        }
+
+        void assertNoErrors() throws Throwable {
+            ResourceLeakDetectorTest.assertNoErrors(error);
+        }
+    }
 }

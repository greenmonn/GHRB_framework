diff --git a/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java b/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
index c1ef8e6..dd45e64 100644
--- a/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
@@ -408,6 +408,78 @@ public class FlowControlHandlerTest {
         }
     }
 
+    /**
+     * The {@link FlowControlHandler} will not pass read events onto the
+     * pipeline when the user is calling {@code read()} on their own if the
+     * queue is not empty and auto-reading is turned off for the channel.
+     */
+    @Test
+    public void testFlowAutoReadOffAndQueueNonEmpty() throws Exception {
+        final Exchanger<Channel> peerRef = new Exchanger<Channel>();
+        final CountDownLatch msgRcvLatch1 = new CountDownLatch(1);
+        final CountDownLatch msgRcvLatch2 = new CountDownLatch(2);
+        final CountDownLatch msgRcvLatch3 = new CountDownLatch(3);
+
+        ChannelInboundHandlerAdapter handler = new ChannelDuplexHandler() {
+            @Override
+            public void channelActive(ChannelHandlerContext ctx) throws Exception {
+                ctx.fireChannelActive();
+                peerRef.exchange(ctx.channel(), 1L, SECONDS);
+            }
+
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                msgRcvLatch1.countDown();
+                msgRcvLatch2.countDown();
+                msgRcvLatch3.countDown();
+            }
+        };
+
+        final FlowControlHandler flow = new FlowControlHandler();
+        Channel server = newServer(false, flow, handler);
+        Channel client = newClient(server.localAddress());
+        try {
+            // The client connection on the server side
+            Channel peer = peerRef.exchange(null, 1L, SECONDS);
+
+            // Write the first message
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // channelRead(1)
+            peer.read();
+            assertTrue(msgRcvLatch1.await(1L, SECONDS));
+            assertFalse(peer.eventLoop().submit(new Callable<Boolean>() {
+                @Override
+                public Boolean call() {
+                    return flow.isQueueEmpty();
+                }
+            }).get());
+
+            // Write the second message
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // channelRead(2)
+            peer.read();
+            assertTrue(msgRcvLatch2.await(1L, SECONDS));
+
+            // channelRead(3)
+            peer.read();
+            assertTrue(msgRcvLatch3.await(1L, SECONDS));
+
+            assertTrue(peer.eventLoop().submit(new Callable<Boolean>() {
+                @Override
+                public Boolean call() {
+                    return flow.isQueueEmpty();
+                }
+            }).get());
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
     @Test
     public void testReentranceNotCausesNPE() throws Throwable {
         final Exchanger<Channel> peerRef = new Exchanger<Channel>();

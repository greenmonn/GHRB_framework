diff --git a/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java b/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java
new file mode 100644
index 0000000..7c8d4da
--- /dev/null
+++ b/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2023 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util;
+
+import io.netty.util.concurrent.FastThreadLocalThread;
+import org.jetbrains.annotations.NotNull;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+
+@ExtendWith(RunInFastThreadLocalThreadExtension.class)
+public class RecyclerFastThreadLocalTest extends RecyclerTest {
+    @NotNull
+    @Override
+    protected Thread newThread(Runnable runnable) {
+        return new FastThreadLocalThread(runnable);
+    }
+
+    @Override
+    @Test
+    @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
+    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {
+        final Recycler<HandledObject> recycler = newRecycler(1024);
+        final AtomicBoolean collected = new AtomicBoolean();
+        final AtomicReference<HandledObject> reference = new AtomicReference<HandledObject>();
+        Thread thread = new FastThreadLocalThread(new Runnable() {
+            @Override
+            public void run() {
+                HandledObject object = recycler.get();
+                // Store a reference to the HandledObject to ensure it is not collected when the run method finish.
+                reference.set(object);
+            }
+        }) {
+            @Override
+            protected void finalize() throws Throwable {
+                super.finalize();
+                collected.set(true);
+            }
+        };
+        assertFalse(collected.get());
+        thread.start();
+        thread.join();
+
+        // Null out so it can be collected.
+        thread = null;
+
+        // Loop until the Thread was collected. If we can not collect it the Test will fail due of a timeout.
+        while (!collected.get()) {
+            System.gc();
+            System.runFinalization();
+            Thread.sleep(50);
+        }
+
+        // Now call recycle after the Thread was collected to ensure this still works...
+        reference.getAndSet(null).recycle();
+    }
+}
diff --git a/common/src/test/java/io/netty/util/RecyclerTest.java b/common/src/test/java/io/netty/util/RecyclerTest.java
index edfd797..49359ff 100644
--- a/common/src/test/java/io/netty/util/RecyclerTest.java
+++ b/common/src/test/java/io/netty/util/RecyclerTest.java
@@ -15,6 +15,7 @@
 */
 package io.netty.util;
 
+import org.jetbrains.annotations.NotNull;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.api.function.Executable;
@@ -23,6 +24,7 @@ import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -39,11 +41,11 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class RecyclerTest {
 
-    private static Recycler<HandledObject> newRecycler(int maxCapacityPerThread) {
+    protected static Recycler<HandledObject> newRecycler(int maxCapacityPerThread) {
         return newRecycler(maxCapacityPerThread, 8, maxCapacityPerThread >> 1);
     }
 
-    private static Recycler<HandledObject> newRecycler(int maxCapacityPerThread, int ratio, int chunkSize) {
+    protected static Recycler<HandledObject> newRecycler(int maxCapacityPerThread, int ratio, int chunkSize) {
         return new Recycler<HandledObject>(maxCapacityPerThread, ratio, chunkSize) {
             @Override
             protected HandledObject newObject(
@@ -53,6 +55,11 @@ public class RecyclerTest {
         };
     }
 
+    @NotNull
+    protected Thread newThread(Runnable runnable) {
+        return new Thread(runnable);
+    }
+
     @Test
     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
     public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {
@@ -114,7 +121,7 @@ public class RecyclerTest {
         Recycler<HandledObject> recycler = newRecycler(1024);
         final HandledObject object = recycler.get();
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
-        final Thread thread1 = new Thread(new Runnable() {
+        final Thread thread1 = newThread(new Runnable() {
             @Override
             public void run() {
                 object.recycle();
@@ -123,7 +130,7 @@ public class RecyclerTest {
         thread1.start();
         thread1.join();
 
-        final Thread thread2 = new Thread(new Runnable() {
+        final Thread thread2 = newThread(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -149,7 +156,7 @@ public class RecyclerTest {
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
 
         final CountDownLatch countDownLatch = new CountDownLatch(2);
-        final Thread thread1 = new Thread(new Runnable() {
+        final Thread thread1 = newThread(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -166,7 +173,7 @@ public class RecyclerTest {
         });
         thread1.start();
 
-        final Thread thread2 = new Thread(new Runnable() {
+        final Thread thread2 = newThread(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -206,7 +213,7 @@ public class RecyclerTest {
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
 
         final CountDownLatch countDownLatch = new CountDownLatch(1);
-        final Thread thread1 = new Thread(new Runnable() {
+        final Thread thread1 = newThread(new Runnable() {
             @Override
             public void run() {
                 try {
@@ -313,13 +320,13 @@ public class RecyclerTest {
         final HandledObject o = recycler.get();
         final HandledObject o2 = recycler.get();
 
-        final Thread thread = new Thread() {
+        final Thread thread = newThread(new Runnable() {
             @Override
             public void run() {
                 o.recycle();
                 o2.recycle();
             }
-        };
+        });
         thread.start();
         thread.join();
 
@@ -332,7 +339,12 @@ public class RecyclerTest {
         final Recycler<HandledObject> recycler = newRecycler(256);
         final HandledObject o = recycler.get();
 
-        ExecutorService single = Executors.newSingleThreadExecutor();
+        ExecutorService single = Executors.newSingleThreadExecutor(new ThreadFactory() {
+            @Override
+            public Thread newThread(@NotNull Runnable r) {
+                return RecyclerTest.this.newThread(r);
+            }
+        });
 
         final CountDownLatch latch1 = new CountDownLatch(1);
         single.execute(new Runnable() {
@@ -366,7 +378,7 @@ public class RecyclerTest {
 
     @Test
     public void testMaxCapacityWithRecycleAtDifferentThread() throws Exception {
-        final int maxCapacity = 4; // Choose the number smaller than WeakOrderQueue.LINK_CAPACITY
+        final int maxCapacity = 4;
         final Recycler<HandledObject> recycler = newRecycler(maxCapacity, 4, 4);
 
         // Borrow 2 * maxCapacity objects.
@@ -382,14 +394,14 @@ public class RecyclerTest {
             array[i].recycle();
         }
 
-        final Thread thread = new Thread() {
+        final Thread thread = newThread(new Runnable() {
             @Override
             public void run() {
-                for (int i = maxCapacity; i < array.length; i ++) {
-                    array[i].recycle();
+                for (int i1 = maxCapacity; i1 < array.length; i1++) {
+                    array[i1].recycle();
                 }
             }
-        };
+        });
         thread.start();
         thread.join();
 
@@ -426,14 +438,14 @@ public class RecyclerTest {
         instancesCount.set(0);
 
         // Recycle from other thread.
-        final Thread thread = new Thread() {
+        final Thread thread = newThread(new Runnable() {
             @Override
             public void run() {
                 for (HandledObject object: array) {
                     object.recycle();
                 }
             }
-        };
+        });
         thread.start();
         thread.join();
 
diff --git a/common/src/test/java/io/netty/util/RunInFastThreadLocalThreadExtension.java b/common/src/test/java/io/netty/util/RunInFastThreadLocalThreadExtension.java
new file mode 100644
index 0000000..5445b83
--- /dev/null
+++ b/common/src/test/java/io/netty/util/RunInFastThreadLocalThreadExtension.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2023 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util;
+
+import io.netty.util.concurrent.FastThreadLocalThread;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+
+import java.lang.reflect.Method;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Annotate your test class with {@code @ExtendWith(RunInFastThreadLocalThreadExtension.class)} to have all test methods
+ * run in a {@link io.netty.util.concurrent.FastThreadLocalThread}.
+ * <p>
+ * This extension implementation is modified from the JUnit 5
+ * <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-intercepting-invocations">
+ * intercepting invocations</a> example.
+ */
+public class RunInFastThreadLocalThreadExtension implements InvocationInterceptor {
+    @Override
+    public void interceptTestMethod(
+            final Invocation<Void> invocation,
+            final ReflectiveInvocationContext<Method> invocationContext,
+            final ExtensionContext extensionContext) throws Throwable {
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+        Thread thread = new FastThreadLocalThread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    invocation.proceed();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                }
+            }
+        });
+        thread.start();
+        thread.join();
+        Throwable t = throwable.get();
+        if (t != null) {
+            throw t;
+        }
+    }
+}

diff --git a/retrofit/kotlin-test/src/test/java/retrofit2/KotlinExtensionsTest.kt b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinExtensionsTest.kt
new file mode 100644
index 0000000..b8196c7
--- /dev/null
+++ b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinExtensionsTest.kt
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import okhttp3.mockwebserver.MockWebServer
+import org.junit.Assert.assertNotNull
+import org.junit.Rule
+import org.junit.Test
+
+class KotlinExtensionsTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Empty
+
+  @Test fun reifiedCreate() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .build()
+
+    assertNotNull(retrofit.create<Empty>())
+  }
+}
diff --git a/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendRawTest.java b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendRawTest.java
new file mode 100644
index 0000000..aa8cecb
--- /dev/null
+++ b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendRawTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+import kotlin.coroutines.Continuation;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+/**
+ * This code path can only be tested from Java because Kotlin does not allow you specify a raw
+ * Response type. Win! We still test this codepath for completeness.
+ */
+public final class KotlinSuspendRawTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Object body(Continuation<? super Response> response);
+  }
+
+  @Test
+  public void raw() {
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/")).build();
+    Service service = retrofit.create(Service.class);
+
+    try {
+      service.body(null);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e)
+          .hasMessage(
+              "Response must include generic type (e.g., Response<String>)\n"
+                  + "    for method Service.body");
+    }
+  }
+}
diff --git a/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendTest.kt
new file mode 100644
index 0000000..e3f6ed6
--- /dev/null
+++ b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2
+
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.async
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withContext
+import okhttp3.OkHttpClient
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST
+import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import retrofit2.helpers.ToStringConverterFactory
+import retrofit2.http.GET
+import retrofit2.http.Path
+import java.io.IOException
+import java.lang.reflect.ParameterizedType
+import java.lang.reflect.Type
+import kotlin.coroutines.CoroutineContext
+
+class KotlinSuspendTest {
+  @get:Rule val server = MockWebServer()
+
+  interface Service {
+    @GET("/") suspend fun body(): String
+    @GET("/") suspend fun bodyNullable(): String?
+    @GET("/") suspend fun response(): Response<String>
+
+    @GET("/{a}/{b}/{c}")
+    suspend fun params(
+        @Path("a") a: String,
+        @Path("b") b: String,
+        @Path("c") c: String
+    ): String
+  }
+
+  @Test fun body() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun body404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: HttpException) {
+      assertThat(e.code()).isEqualTo(404)
+    }
+  }
+
+  @Test fun bodyFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun bodyThrowsOnNull() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    try {
+      runBlocking { example.body() }
+      fail()
+    } catch (e: KotlinNullPointerException) {
+      // Coroutines wraps exceptions with a synthetic trace so fall back to cause message.
+      val message = e.message ?: (e.cause as KotlinNullPointerException).message
+      assertThat(message).isEqualTo(
+          "Response from retrofit2.KotlinSuspendTest\$Service.body was null but response body type was declared as non-null")
+    }
+  }
+
+  @Ignore("Not working yet")
+  @Test fun bodyNullable() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(204))
+
+    val body = runBlocking { example.bodyNullable() }
+    assertThat(body).isNull()
+  }
+
+  @Test fun response() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(200)
+    assertThat(response.body()).isEqualTo("Hi")
+  }
+
+  @Test fun response404() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setResponseCode(404))
+
+    val response = runBlocking { example.response() }
+    assertThat(response.code()).isEqualTo(404)
+  }
+
+  @Test fun responseFailure() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST))
+
+    try {
+      runBlocking { example.response() }
+      fail()
+    } catch (e: IOException) {
+    }
+  }
+
+  @Test fun params() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse())
+
+    runBlocking { example.params("1", "2", "3") }
+    val request = server.takeRequest()
+    assertThat(request.path).isEqualTo("/1/2/3")
+  }
+
+  @Test fun cancelationWorks() {
+    lateinit var call: okhttp3.Call
+
+    val okHttpClient = OkHttpClient()
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callFactory {
+          val newCall = okHttpClient.newCall(it)
+          call = newCall
+          newCall
+        }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    // This leaves the connection open indefinitely allowing us to cancel without racing a body.
+    server.enqueue(MockResponse().setSocketPolicy(NO_RESPONSE))
+
+    val deferred = GlobalScope.async { example.body() }
+
+    // This will block until the server has received the request ensuring it's in flight.
+    server.takeRequest()
+
+    deferred.cancel()
+    assertTrue(call.isCanceled)
+  }
+
+  @Test fun doesNotUseCallbackExecutor() {
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .callbackExecutor { fail() }
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("Hi")
+  }
+
+  @Test fun usesCallAdapterForCall() {
+    val callAdapterFactory = object : CallAdapter.Factory() {
+      override fun get(returnType: Type, annotations: Array<Annotation>,
+          retrofit: Retrofit): CallAdapter<*, *>? {
+        if (getRawType(returnType) != Call::class.java) {
+          return null
+        }
+        if (getParameterUpperBound(0, returnType as ParameterizedType) != String::class.java) {
+          return null
+        }
+        return object : CallAdapter<String, Call<String>> {
+          override fun responseType() = String::class.java
+          override fun adapt(call: Call<String>): Call<String> {
+            return object : Call<String> by call {
+              override fun enqueue(callback: Callback<String>) {
+                call.enqueue(object : Callback<String> by callback {
+                  override fun onResponse(call: Call<String>, response: Response<String>) {
+                    if (response.isSuccessful) {
+                      callback.onResponse(call, Response.success(response.body()?.repeat(5)))
+                    } else {
+                      callback.onResponse(call, response)
+                    }
+                  }
+                })
+              }
+            }
+          }
+        }
+      }
+    }
+
+    val retrofit = Retrofit.Builder()
+        .baseUrl(server.url("/"))
+        .addCallAdapterFactory(callAdapterFactory)
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.enqueue(MockResponse().setBody("Hi"))
+
+    val body = runBlocking { example.body() }
+    assertThat(body).isEqualTo("HiHiHiHiHi")
+  }
+
+  @Test fun checkedExceptionsAreNotSynchronouslyThrownForBody() = runBlocking {
+    val retrofit = Retrofit.Builder()
+        .baseUrl("https://unresolved-host.com/")
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.shutdown()
+
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.body()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
+      }
+    }
+  }
+
+  @Test fun checkedExceptionsAreNotSynchronouslyThrownForResponse() = runBlocking {
+    val retrofit = Retrofit.Builder()
+        .baseUrl("https://unresolved-host.com/")
+        .addConverterFactory(ToStringConverterFactory())
+        .build()
+    val example = retrofit.create(Service::class.java)
+
+    server.shutdown()
+
+    // Run with a dispatcher that prevents yield from actually deferring work. An old workaround
+    // for this problem relied on yield, but it is not guaranteed to prevent direct execution.
+    withContext(DirectUnconfinedDispatcher) {
+      // The problematic behavior of the UnknownHostException being synchronously thrown is
+      // probabilistic based on thread preemption. Running a thousand times will almost always
+      // trigger it, so we run an order of magnitude more to be safe.
+      repeat(10000) {
+        try {
+          example.response()
+          fail()
+        } catch (_: IOException) {
+          // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
+        }
+      }
+    }
+  }
+
+  @Suppress("EXPERIMENTAL_OVERRIDE")
+  private object DirectUnconfinedDispatcher : CoroutineDispatcher() {
+    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false
+    override fun dispatch(context: CoroutineContext, block: Runnable) = block.run()
+  }
+}
diff --git a/retrofit/kotlin-test/src/test/java/retrofit2/KotlinUnitTest.java b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinUnitTest.java
new file mode 100644
index 0000000..389441b
--- /dev/null
+++ b/retrofit/kotlin-test/src/test/java/retrofit2/KotlinUnitTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.IOException;
+import kotlin.Unit;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.junit.Rule;
+import org.junit.Test;
+import retrofit2.http.GET;
+
+public final class KotlinUnitTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  interface Service {
+    @GET("/")
+    Call<Unit> empty();
+  }
+
+  @Test
+  public void unitOnClasspath() throws IOException {
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/")).build();
+    Service example = retrofit.create(Service.class);
+
+    server.enqueue(new MockResponse().setBody("Hi"));
+
+    Response<Unit> response = example.empty().execute();
+    assertThat(response.isSuccessful()).isTrue();
+    assertThat(response.body()).isSameAs(Unit.INSTANCE);
+  }
+}
